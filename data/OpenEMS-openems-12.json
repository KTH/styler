{
    "error_id": "12",
    "information": {
        "errors": [
            {
                "line": "289",
                "column": "46",
                "severity": "warning",
                "message": "WhitespaceAround: '{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\t * @return the Channel\n\t */\n\tdefault Channel<Integer> getCurrent(){\n\t\treturn this.channel(ChannelId.CURRENT);\n\t}\n}",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/styler/12/SymmetricMeter.java\nindex 8ee97fc8ed..249f991d19 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/styler/12/SymmetricMeter.java\n@@ -203,7 +203,7 @@ public interface SymmetricMeter extends OpenemsComponent {\n \t\t\t\t.channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //\t\t\t\t\n \t\t\t\t.build();\n \t}\n-\t\n+\n \t/**\n \t * Gets the Active Power in [W]. Negative values for Consumption; positive for\n \t * Production\n@@ -280,13 +280,13 @@ public interface SymmetricMeter extends OpenemsComponent {\n \tdefault Channel<Integer> getMaxActivePower() {\n \t\treturn this.channel(ChannelId.MAX_ACTIVE_POWER);\n \t}\n-\t\n+\n \t/**\n \t * Gets the Current in [mA].\n \t * \n \t * @return the Channel\n \t */\n-\tdefault Channel<Integer> getCurrent(){\n+\tdefault Channel<Integer> getCurrent() {\n \t\treturn this.channel(ChannelId.CURRENT);\n \t}\n }\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/intellij/12/SymmetricMeter.java\nindex 8ee97fc8ed..edada02c89 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/intellij/12/SymmetricMeter.java\n@@ -15,7 +15,7 @@ import io.openems.edge.common.modbusslave.ModbusType;\n \n /**\n  * Represents a Symmetric Meter.\n- * \n+ *\n  * <p>\n  * <ul>\n  * <li>Negative ActivePower and ConsumptionActivePower represent Consumption,\n@@ -26,267 +26,267 @@ import io.openems.edge.common.modbusslave.ModbusType;\n  */\n public interface SymmetricMeter extends OpenemsComponent {\n \n-\tpublic enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n-\t\t/**\n-\t\t * Frequency.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: mHz\n-\t\t * <li>Range: only positive values\n-\t\t * </ul>\n-\t\t */\n-\t\tFREQUENCY(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.MILLIHERTZ)), //\n-\t\t/**\n-\t\t * Minimum Ever Active Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: W\n-\t\t * <li>Range: negative or '0'\n-\t\t * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n-\t\t * </ul>\n-\t\t */\n-\t\tMIN_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.WATT)), //\n-\t\t/**\n-\t\t * Maximum Ever Active Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: W\n-\t\t * <li>Range: positive or '0'\n-\t\t * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n-\t\t * </ul>\n-\t\t */\n-\t\tMAX_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.WATT)), //\n-\t\t/**\n-\t\t * Active Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: W\n-\t\t * <li>Range: negative values for Consumption (power that is 'leaving the\n-\t\t * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n-\t\t * the system')\n-\t\t * </ul>\n-\t\t */\n-\t\tACTIVE_POWER(new IntegerDoc() //\n-\t\t\t\t.unit(Unit.WATT) //\n-\t\t\t\t.text(OpenemsConstants.POWER_DOC_TEXT) //\n-\t\t\t\t.onInit(channel -> {\n-\t\t\t\t\tchannel.onSetNextValue(value -> {\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * Fill Min/Max Active Power channels\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tif (value.isDefined()) {\n-\t\t\t\t\t\t\tint newValue = value.get();\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tChannel<Integer> minActivePowerChannel = channel.getComponent()\n-\t\t\t\t\t\t\t\t\t\t.channel(ChannelId.MIN_ACTIVE_POWER);\n-\t\t\t\t\t\t\t\tint minActivePower = minActivePowerChannel.value().orElse(0);\n-\t\t\t\t\t\t\t\tint minNextActivePower = minActivePowerChannel.getNextValue().orElse(0);\n-\t\t\t\t\t\t\t\tif (newValue < Math.min(minActivePower, minNextActivePower)) {\n-\t\t\t\t\t\t\t\t\t// avoid getting called too often -> round to 100\n-\t\t\t\t\t\t\t\t\tnewValue = IntUtils.roundToPrecision(newValue, Round.TOWARDS_ZERO, 100);\n-\t\t\t\t\t\t\t\t\tminActivePowerChannel.setNextValue(newValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tChannel<Integer> maxActivePowerChannel = channel.getComponent()\n-\t\t\t\t\t\t\t\t\t\t.channel(ChannelId.MAX_ACTIVE_POWER);\n-\t\t\t\t\t\t\t\tint maxActivePower = maxActivePowerChannel.value().orElse(0);\n-\t\t\t\t\t\t\t\tint maxNextActivePower = maxActivePowerChannel.getNextValue().orElse(0);\n-\t\t\t\t\t\t\t\tif (newValue > Math.max(maxActivePower, maxNextActivePower)) {\n-\t\t\t\t\t\t\t\t\t// avoid getting called too often -> round to 100\n-\t\t\t\t\t\t\t\t\tnewValue = IntUtils.roundToPrecision(newValue, Round.AWAY_FROM_ZERO, 100);\n-\t\t\t\t\t\t\t\t\tmaxActivePowerChannel.setNextValue(newValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n-\t\t\t\t})), //\n-\t\t/**\n-\t\t * Reactive Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: var\n-\t\t * <li>Range: negative values for Consumption (power that is 'leaving the\n-\t\t * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n-\t\t * the system')\n-\t\t * </ul>\n-\t\t */\n-\t\tREACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.VOLT_AMPERE_REACTIVE) //\n-\t\t\t\t.text(OpenemsConstants.POWER_DOC_TEXT)), //\n-\t\t/**\n-\t\t * Active Production Energy.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: Wh\n-\t\t * </ul>\n-\t\t */\n-\t\tACTIVE_PRODUCTION_ENERGY(Doc.of(OpenemsType.LONG) //\n-\t\t\t\t.unit(Unit.WATT_HOURS)),\n-\t\t/**\n-\t\t * Active Consumption Energy.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: Wh\n-\t\t * </ul>\n-\t\t */\n-\t\tACTIVE_CONSUMPTION_ENERGY(Doc.of(OpenemsType.LONG) //\n-\t\t\t\t.unit(Unit.WATT_HOURS)),\n-\t\t/**\n-\t\t * Voltage.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: mV\n-\t\t * </ul>\n-\t\t */\n-\t\tVOLTAGE(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.MILLIVOLT)), //\n-\t\t/**\n-\t\t * Current.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: mA\n-\t\t * </ul>\n-\t\t */\n-\t\tCURRENT(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.MILLIAMPERE)); //\n+  public enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n+    /**\n+     * Frequency.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: mHz\n+     * <li>Range: only positive values\n+     * </ul>\n+     */\n+    FREQUENCY(Doc.of(OpenemsType.INTEGER) //\n+        .unit(Unit.MILLIHERTZ)), //\n+    /**\n+     * Minimum Ever Active Power.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: W\n+     * <li>Range: negative or '0'\n+     * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n+     * </ul>\n+     */\n+    MIN_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n+        .unit(Unit.WATT)), //\n+    /**\n+     * Maximum Ever Active Power.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: W\n+     * <li>Range: positive or '0'\n+     * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n+     * </ul>\n+     */\n+    MAX_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n+        .unit(Unit.WATT)), //\n+    /**\n+     * Active Power.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: W\n+     * <li>Range: negative values for Consumption (power that is 'leaving the\n+     * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n+     * the system')\n+     * </ul>\n+     */\n+    ACTIVE_POWER(new IntegerDoc() //\n+        .unit(Unit.WATT) //\n+        .text(OpenemsConstants.POWER_DOC_TEXT) //\n+        .onInit(channel -> {\n+          channel.onSetNextValue(value -> {\n+            /*\n+             * Fill Min/Max Active Power channels\n+             */\n+            if (value.isDefined()) {\n+              int newValue = value.get();\n+              {\n+                Channel<Integer> minActivePowerChannel = channel.getComponent()\n+                    .channel(ChannelId.MIN_ACTIVE_POWER);\n+                int minActivePower = minActivePowerChannel.value().orElse(0);\n+                int minNextActivePower = minActivePowerChannel.getNextValue().orElse(0);\n+                if (newValue < Math.min(minActivePower, minNextActivePower)) {\n+                  // avoid getting called too often -> round to 100\n+                  newValue = IntUtils.roundToPrecision(newValue, Round.TOWARDS_ZERO, 100);\n+                  minActivePowerChannel.setNextValue(newValue);\n+                }\n+              }\n+              {\n+                Channel<Integer> maxActivePowerChannel = channel.getComponent()\n+                    .channel(ChannelId.MAX_ACTIVE_POWER);\n+                int maxActivePower = maxActivePowerChannel.value().orElse(0);\n+                int maxNextActivePower = maxActivePowerChannel.getNextValue().orElse(0);\n+                if (newValue > Math.max(maxActivePower, maxNextActivePower)) {\n+                  // avoid getting called too often -> round to 100\n+                  newValue = IntUtils.roundToPrecision(newValue, Round.AWAY_FROM_ZERO, 100);\n+                  maxActivePowerChannel.setNextValue(newValue);\n+                }\n+              }\n+            }\n+          });\n+        })), //\n+    /**\n+     * Reactive Power.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: var\n+     * <li>Range: negative values for Consumption (power that is 'leaving the\n+     * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n+     * the system')\n+     * </ul>\n+     */\n+    REACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n+        .unit(Unit.VOLT_AMPERE_REACTIVE) //\n+        .text(OpenemsConstants.POWER_DOC_TEXT)), //\n+    /**\n+     * Active Production Energy.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: Wh\n+     * </ul>\n+     */\n+    ACTIVE_PRODUCTION_ENERGY(Doc.of(OpenemsType.LONG) //\n+        .unit(Unit.WATT_HOURS)),\n+    /**\n+     * Active Consumption Energy.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: Wh\n+     * </ul>\n+     */\n+    ACTIVE_CONSUMPTION_ENERGY(Doc.of(OpenemsType.LONG) //\n+        .unit(Unit.WATT_HOURS)),\n+    /**\n+     * Voltage.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: mV\n+     * </ul>\n+     */\n+    VOLTAGE(Doc.of(OpenemsType.INTEGER) //\n+        .unit(Unit.MILLIVOLT)), //\n+    /**\n+     * Current.\n+     *\n+     * <ul>\n+     * <li>Interface: Meter Symmetric\n+     * <li>Type: Integer\n+     * <li>Unit: mA\n+     * </ul>\n+     */\n+    CURRENT(Doc.of(OpenemsType.INTEGER) //\n+        .unit(Unit.MILLIAMPERE)); //\n \n-\t\tprivate final Doc doc;\n+    private final Doc doc;\n \n-\t\tprivate ChannelId(Doc doc) {\n-\t\t\tthis.doc = doc;\n-\t\t}\n+    private ChannelId(Doc doc) {\n+      this.doc = doc;\n+    }\n \n-\t\tpublic Doc doc() {\n-\t\t\treturn this.doc;\n-\t\t}\n-\t}\n+    public Doc doc() {\n+      return this.doc;\n+    }\n+  }\n \n-\t/**\n-\t * Gets the type of this Meter.\n-\t * \n-\t * @return the MeterType\n-\t */\n-\tMeterType getMeterType();\n+  /**\n+   * Gets the type of this Meter.\n+   *\n+   * @return the MeterType\n+   */\n+  MeterType getMeterType();\n \n-\tpublic static ModbusSlaveNatureTable getModbusSlaveNatureTable(AccessMode accessMode) {\n-\t\treturn ModbusSlaveNatureTable.of(SymmetricMeter.class, accessMode, 100) //\n-\t\t\t\t.channel(0, ChannelId.FREQUENCY, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(2, ChannelId.MIN_ACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(4, ChannelId.MAX_ACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(6, ChannelId.ACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(8, ChannelId.REACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(10, ChannelId.ACTIVE_PRODUCTION_ENERGY, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(12, ChannelId.ACTIVE_CONSUMPTION_ENERGY, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(14, ChannelId.VOLTAGE, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //\t\t\t\t\n-\t\t\t\t.build();\n-\t}\n-\t\n-\t/**\n-\t * Gets the Active Power in [W]. Negative values for Consumption; positive for\n-\t * Production\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getActivePower() {\n-\t\treturn this.channel(ChannelId.ACTIVE_POWER);\n-\t}\n+  public static ModbusSlaveNatureTable getModbusSlaveNatureTable(AccessMode accessMode) {\n+    return ModbusSlaveNatureTable.of(SymmetricMeter.class, accessMode, 100) //\n+        .channel(0, ChannelId.FREQUENCY, ModbusType.FLOAT32) //\n+        .channel(2, ChannelId.MIN_ACTIVE_POWER, ModbusType.FLOAT32) //\n+        .channel(4, ChannelId.MAX_ACTIVE_POWER, ModbusType.FLOAT32) //\n+        .channel(6, ChannelId.ACTIVE_POWER, ModbusType.FLOAT32) //\n+        .channel(8, ChannelId.REACTIVE_POWER, ModbusType.FLOAT32) //\n+        .channel(10, ChannelId.ACTIVE_PRODUCTION_ENERGY, ModbusType.FLOAT32) //\n+        .channel(12, ChannelId.ACTIVE_CONSUMPTION_ENERGY, ModbusType.FLOAT32) //\n+        .channel(14, ChannelId.VOLTAGE, ModbusType.FLOAT32) //\n+        .channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //\n+        .build();\n+  }\n \n-\t/**\n-\t * Gets the Reactive Power in [var]. Negative values for Consumption; positive\n-\t * for Production.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getReactivePower() {\n-\t\treturn this.channel(ChannelId.REACTIVE_POWER);\n-\t}\n+  /**\n+   * Gets the Active Power in [W]. Negative values for Consumption; positive for\n+   * Production\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Integer> getActivePower() {\n+    return this.channel(ChannelId.ACTIVE_POWER);\n+  }\n \n-\t/**\n-\t * Gets the Production Active Energy in [Wh]. This relates to positive\n-\t * ACTIVE_POWER.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Long> getActiveProductionEnergy() {\n-\t\treturn this.channel(ChannelId.ACTIVE_PRODUCTION_ENERGY);\n-\t}\n+  /**\n+   * Gets the Reactive Power in [var]. Negative values for Consumption; positive\n+   * for Production.\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Integer> getReactivePower() {\n+    return this.channel(ChannelId.REACTIVE_POWER);\n+  }\n \n-\t/**\n-\t * Gets the Frequency in [mHz]. FREQUENCY\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getFrequency() {\n-\t\treturn this.channel(ChannelId.FREQUENCY);\n-\t}\n+  /**\n+   * Gets the Production Active Energy in [Wh]. This relates to positive\n+   * ACTIVE_POWER.\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Long> getActiveProductionEnergy() {\n+    return this.channel(ChannelId.ACTIVE_PRODUCTION_ENERGY);\n+  }\n \n-\t/**\n-\t * Gets the Voltage in [mV].\n-\t * \n-\t * @return the Channel\n-\t */\n+  /**\n+   * Gets the Frequency in [mHz]. FREQUENCY\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Integer> getFrequency() {\n+    return this.channel(ChannelId.FREQUENCY);\n+  }\n \n-\tdefault Channel<Integer> getVoltage() {\n-\t\treturn this.channel(ChannelId.VOLTAGE);\n-\t}\n+  /**\n+   * Gets the Voltage in [mV].\n+   *\n+   * @return the Channel\n+   */\n \n-\t/**\n-\t * Gets the Consumption Active Energy in [Wh]. This relates to negative\n-\t * ACTIVE_POWER.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Long> getActiveConsumptionEnergy() {\n-\t\treturn this.channel(ChannelId.ACTIVE_CONSUMPTION_ENERGY);\n-\t}\n+  default Channel<Integer> getVoltage() {\n+    return this.channel(ChannelId.VOLTAGE);\n+  }\n \n-\t/**\n-\t * Gets the Minimum Ever Active Power.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getMinActivePower() {\n-\t\treturn this.channel(ChannelId.MIN_ACTIVE_POWER);\n-\t}\n+  /**\n+   * Gets the Consumption Active Energy in [Wh]. This relates to negative\n+   * ACTIVE_POWER.\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Long> getActiveConsumptionEnergy() {\n+    return this.channel(ChannelId.ACTIVE_CONSUMPTION_ENERGY);\n+  }\n \n-\t/**\n-\t * Gets the Maximum Ever Active Power.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getMaxActivePower() {\n-\t\treturn this.channel(ChannelId.MAX_ACTIVE_POWER);\n-\t}\n-\t\n-\t/**\n-\t * Gets the Current in [mA].\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getCurrent(){\n-\t\treturn this.channel(ChannelId.CURRENT);\n-\t}\n+  /**\n+   * Gets the Minimum Ever Active Power.\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Integer> getMinActivePower() {\n+    return this.channel(ChannelId.MIN_ACTIVE_POWER);\n+  }\n+\n+  /**\n+   * Gets the Maximum Ever Active Power.\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Integer> getMaxActivePower() {\n+    return this.channel(ChannelId.MAX_ACTIVE_POWER);\n+  }\n+\n+  /**\n+   * Gets the Current in [mA].\n+   *\n+   * @return the Channel\n+   */\n+  default Channel<Integer> getCurrent() {\n+    return this.channel(ChannelId.CURRENT);\n+  }\n }\n",
            "diff_size": 267
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "246",
                    "column": "9",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 1, expected is 0, indentation should be the same level as line 251.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/naturalize/12/SymmetricMeter.java\nindex 8ee97fc8ed..e201a13b0c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/naturalize/12/SymmetricMeter.java\n@@ -248,8 +248,7 @@ public interface SymmetricMeter extends OpenemsComponent {\n \t * \n \t * @return the Channel\n \t */\n-\n-\tdefault Channel<Integer> getVoltage() {\n+default Channel<Integer> getVoltage() {\n \t\treturn this.channel(ChannelId.VOLTAGE);\n \t}\n \n@@ -286,7 +285,7 @@ public interface SymmetricMeter extends OpenemsComponent {\n \t * \n \t * @return the Channel\n \t */\n-\tdefault Channel<Integer> getCurrent(){\n+\tdefault Channel<Integer> getCurrent() {\n \t\treturn this.channel(ChannelId.CURRENT);\n \t}\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/codebuff/12/SymmetricMeter.java\nindex 8ee97fc8ed..ecb5e759b9 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/codebuff/12/SymmetricMeter.java\n@@ -24,269 +24,295 @@ import io.openems.edge.common.modbusslave.ModbusType;\n  * power that is 'entering the system', e.g. buy-from-grid\n  * </ul>\n  */\n+\n+\n public interface SymmetricMeter extends OpenemsComponent {\n \n-\tpublic enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n-\t\t/**\n-\t\t * Frequency.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: mHz\n-\t\t * <li>Range: only positive values\n-\t\t * </ul>\n-\t\t */\n-\t\tFREQUENCY(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.MILLIHERTZ)), //\n-\t\t/**\n-\t\t * Minimum Ever Active Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: W\n-\t\t * <li>Range: negative or '0'\n-\t\t * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n-\t\t * </ul>\n-\t\t */\n-\t\tMIN_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.WATT)), //\n-\t\t/**\n-\t\t * Maximum Ever Active Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: W\n-\t\t * <li>Range: positive or '0'\n-\t\t * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n-\t\t * </ul>\n-\t\t */\n-\t\tMAX_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.WATT)), //\n-\t\t/**\n-\t\t * Active Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: W\n-\t\t * <li>Range: negative values for Consumption (power that is 'leaving the\n-\t\t * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n-\t\t * the system')\n-\t\t * </ul>\n-\t\t */\n-\t\tACTIVE_POWER(new IntegerDoc() //\n-\t\t\t\t.unit(Unit.WATT) //\n-\t\t\t\t.text(OpenemsConstants.POWER_DOC_TEXT) //\n-\t\t\t\t.onInit(channel -> {\n-\t\t\t\t\tchannel.onSetNextValue(value -> {\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * Fill Min/Max Active Power channels\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tif (value.isDefined()) {\n-\t\t\t\t\t\t\tint newValue = value.get();\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tChannel<Integer> minActivePowerChannel = channel.getComponent()\n-\t\t\t\t\t\t\t\t\t\t.channel(ChannelId.MIN_ACTIVE_POWER);\n-\t\t\t\t\t\t\t\tint minActivePower = minActivePowerChannel.value().orElse(0);\n-\t\t\t\t\t\t\t\tint minNextActivePower = minActivePowerChannel.getNextValue().orElse(0);\n-\t\t\t\t\t\t\t\tif (newValue < Math.min(minActivePower, minNextActivePower)) {\n-\t\t\t\t\t\t\t\t\t// avoid getting called too often -> round to 100\n-\t\t\t\t\t\t\t\t\tnewValue = IntUtils.roundToPrecision(newValue, Round.TOWARDS_ZERO, 100);\n-\t\t\t\t\t\t\t\t\tminActivePowerChannel.setNextValue(newValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tChannel<Integer> maxActivePowerChannel = channel.getComponent()\n-\t\t\t\t\t\t\t\t\t\t.channel(ChannelId.MAX_ACTIVE_POWER);\n-\t\t\t\t\t\t\t\tint maxActivePower = maxActivePowerChannel.value().orElse(0);\n-\t\t\t\t\t\t\t\tint maxNextActivePower = maxActivePowerChannel.getNextValue().orElse(0);\n-\t\t\t\t\t\t\t\tif (newValue > Math.max(maxActivePower, maxNextActivePower)) {\n-\t\t\t\t\t\t\t\t\t// avoid getting called too often -> round to 100\n-\t\t\t\t\t\t\t\t\tnewValue = IntUtils.roundToPrecision(newValue, Round.AWAY_FROM_ZERO, 100);\n-\t\t\t\t\t\t\t\t\tmaxActivePowerChannel.setNextValue(newValue);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n-\t\t\t\t})), //\n-\t\t/**\n-\t\t * Reactive Power.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: var\n-\t\t * <li>Range: negative values for Consumption (power that is 'leaving the\n-\t\t * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n-\t\t * the system')\n-\t\t * </ul>\n-\t\t */\n-\t\tREACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.VOLT_AMPERE_REACTIVE) //\n-\t\t\t\t.text(OpenemsConstants.POWER_DOC_TEXT)), //\n-\t\t/**\n-\t\t * Active Production Energy.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: Wh\n-\t\t * </ul>\n-\t\t */\n-\t\tACTIVE_PRODUCTION_ENERGY(Doc.of(OpenemsType.LONG) //\n-\t\t\t\t.unit(Unit.WATT_HOURS)),\n-\t\t/**\n-\t\t * Active Consumption Energy.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: Wh\n-\t\t * </ul>\n-\t\t */\n-\t\tACTIVE_CONSUMPTION_ENERGY(Doc.of(OpenemsType.LONG) //\n-\t\t\t\t.unit(Unit.WATT_HOURS)),\n-\t\t/**\n-\t\t * Voltage.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: mV\n-\t\t * </ul>\n-\t\t */\n-\t\tVOLTAGE(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.MILLIVOLT)), //\n-\t\t/**\n-\t\t * Current.\n-\t\t * \n-\t\t * <ul>\n-\t\t * <li>Interface: Meter Symmetric\n-\t\t * <li>Type: Integer\n-\t\t * <li>Unit: mA\n-\t\t * </ul>\n-\t\t */\n-\t\tCURRENT(Doc.of(OpenemsType.INTEGER) //\n-\t\t\t\t.unit(Unit.MILLIAMPERE)); //\n-\n-\t\tprivate final Doc doc;\n-\n-\t\tprivate ChannelId(Doc doc) {\n-\t\t\tthis.doc = doc;\n-\t\t}\n-\n-\t\tpublic Doc doc() {\n-\t\t\treturn this.doc;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Gets the type of this Meter.\n-\t * \n-\t * @return the MeterType\n-\t */\n-\tMeterType getMeterType();\n-\n-\tpublic static ModbusSlaveNatureTable getModbusSlaveNatureTable(AccessMode accessMode) {\n-\t\treturn ModbusSlaveNatureTable.of(SymmetricMeter.class, accessMode, 100) //\n-\t\t\t\t.channel(0, ChannelId.FREQUENCY, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(2, ChannelId.MIN_ACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(4, ChannelId.MAX_ACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(6, ChannelId.ACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(8, ChannelId.REACTIVE_POWER, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(10, ChannelId.ACTIVE_PRODUCTION_ENERGY, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(12, ChannelId.ACTIVE_CONSUMPTION_ENERGY, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(14, ChannelId.VOLTAGE, ModbusType.FLOAT32) //\n-\t\t\t\t.channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //\t\t\t\t\n-\t\t\t\t.build();\n-\t}\n-\t\n-\t/**\n-\t * Gets the Active Power in [W]. Negative values for Consumption; positive for\n-\t * Production\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getActivePower() {\n-\t\treturn this.channel(ChannelId.ACTIVE_POWER);\n-\t}\n-\n-\t/**\n-\t * Gets the Reactive Power in [var]. Negative values for Consumption; positive\n-\t * for Production.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getReactivePower() {\n-\t\treturn this.channel(ChannelId.REACTIVE_POWER);\n-\t}\n-\n-\t/**\n-\t * Gets the Production Active Energy in [Wh]. This relates to positive\n-\t * ACTIVE_POWER.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Long> getActiveProductionEnergy() {\n-\t\treturn this.channel(ChannelId.ACTIVE_PRODUCTION_ENERGY);\n-\t}\n-\n-\t/**\n-\t * Gets the Frequency in [mHz]. FREQUENCY\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getFrequency() {\n-\t\treturn this.channel(ChannelId.FREQUENCY);\n-\t}\n-\n-\t/**\n-\t * Gets the Voltage in [mV].\n-\t * \n-\t * @return the Channel\n-\t */\n-\n-\tdefault Channel<Integer> getVoltage() {\n-\t\treturn this.channel(ChannelId.VOLTAGE);\n-\t}\n-\n-\t/**\n-\t * Gets the Consumption Active Energy in [Wh]. This relates to negative\n-\t * ACTIVE_POWER.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Long> getActiveConsumptionEnergy() {\n-\t\treturn this.channel(ChannelId.ACTIVE_CONSUMPTION_ENERGY);\n-\t}\n-\n-\t/**\n-\t * Gets the Minimum Ever Active Power.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getMinActivePower() {\n-\t\treturn this.channel(ChannelId.MIN_ACTIVE_POWER);\n-\t}\n-\n-\t/**\n-\t * Gets the Maximum Ever Active Power.\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getMaxActivePower() {\n-\t\treturn this.channel(ChannelId.MAX_ACTIVE_POWER);\n-\t}\n-\t\n-\t/**\n-\t * Gets the Current in [mA].\n-\t * \n-\t * @return the Channel\n-\t */\n-\tdefault Channel<Integer> getCurrent(){\n-\t\treturn this.channel(ChannelId.CURRENT);\n-\t}\n-}\n+    public enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n+        /**\n+         * Frequency.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: mHz\n+         * <li>Range: only positive values\n+         * </ul>\n+         */\n+        FREQUENCY(Doc.of(OpenemsType.INTEGER) //\n+                .unit(Unit.MILLIHERTZ)), //\n+        /**\n+         * Minimum Ever Active Power.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: W\n+         * <li>Range: negative or '0'\n+         * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n+         * </ul>\n+         */\n+        MIN_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n+                .unit(Unit.WATT)), //\n+        /**\n+         * Maximum Ever Active Power.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: W\n+         * <li>Range: positive or '0'\n+         * <li>Implementation Note: value is automatically derived from ACTIVE_POWER\n+         * </ul>\n+         */\n+        MAX_ACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n+                .unit(Unit.WATT)), //\n+        /**\n+         * Active Power.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: W\n+         * <li>Range: negative values for Consumption (power that is 'leaving the\n+         * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n+         * the system')\n+         * </ul>\n+         */\n+        ACTIVE_POWER(new IntegerDoc() //\n+                .unit(Unit.WATT) //\n+                .text(OpenemsConstants.POWER_DOC_TEXT) //\n+                .onInit(channel -> {\n+                    channel.onSetNextValue(value -> {\n+                        /*\n+                         * Fill Min/Max Active Power channels\n+                         */\n+                        if (value.isDefined()) {\n+                            int newValue = value.get();\n+                            {\n+                                Channel<Integer> minActivePowerChannel = channel.getComponent()\n+.channel(ChannelId.MIN_ACTIVE_POWER);\n+                                int minActivePower = minActivePowerChannel.value()\n+.orElse(0);\n+                                int minNextActivePower = minActivePowerChannel.getNextValue()\n+.orElse(0);\n+                                if (newValue < Math.min(minActivePower, minNextActivePower)) {\n+                                    // avoid getting called too often -> round to 100\n+                                    newValue = IntUtils.roundToPrecision(newValue, Round.TOWARDS_ZERO, 100);\n+                                    minActivePowerChannel.setNextValue(newValue);\n+                                }\n+                            }\n+\n+                            {\n+                                Channel<Integer> maxActivePowerChannel = channel.getComponent()\n+.channel(ChannelId.MAX_ACTIVE_POWER);\n+                                int maxActivePower = maxActivePowerChannel.value()\n+.orElse(0);\n+                                int maxNextActivePower = maxActivePowerChannel.getNextValue()\n+.orElse(0);\n+                                if (newValue > Math.max(maxActivePower, maxNextActivePower)) {\n+                                    // avoid getting called too often -> round to 100\n+                                    newValue = IntUtils.roundToPrecision(newValue, Round.AWAY_FROM_ZERO, 100);\n+                                    maxActivePowerChannel.setNextValue(newValue);\n+                                }\n+                            }\n+                        }\n+                    });\n+                })), //\n+        /**\n+         * Reactive Power.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: var\n+         * <li>Range: negative values for Consumption (power that is 'leaving the\n+         * system', e.g. feed-to-grid); positive for Production (power that is 'entering\n+         * the system')\n+         * </ul>\n+         */\n+        REACTIVE_POWER(Doc.of(OpenemsType.INTEGER) //\n+                .unit(Unit.VOLT_AMPERE_REACTIVE) //\n+                .text(OpenemsConstants.POWER_DOC_TEXT)), //\n+        /**\n+         * Active Production Energy.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: Wh\n+         * </ul>\n+         */\n+        ACTIVE_PRODUCTION_ENERGY(Doc.of(OpenemsType.LONG) //\n+                .unit(Unit.WATT_HOURS)),\n+        /**\n+         * Active Consumption Energy.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: Wh\n+         * </ul>\n+         */\n+        ACTIVE_CONSUMPTION_ENERGY(Doc.of(OpenemsType.LONG) //\n+                .unit(Unit.WATT_HOURS)),\n+        /**\n+         * Voltage.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: mV\n+         * </ul>\n+         */\n+        VOLTAGE(Doc.of(OpenemsType.INTEGER) //\n+                .unit(Unit.MILLIVOLT)), //\n+        /**\n+         * Current.\n+         * \n+         * <ul>\n+         * <li>Interface: Meter Symmetric\n+         * <li>Type: Integer\n+         * <li>Unit: mA\n+         * </ul>\n+         */\n+        CURRENT(Doc.of(OpenemsType.INTEGER) //\n+                .unit(Unit.MILLIAMPERE)); //\n+\n+        private final Doc doc;\n+\n+        private ChannelId(Doc doc) {\n+            this.doc = doc;\n+        }\n+\n+        public Doc doc() {\n+            return this.doc;\n+        }\n+    }\n+\n+    /**\n+     * Gets the type of this Meter.\n+     * \n+     * @return the MeterType\n+     */\n+\n+    MeterType getMeterType();\n+\n+\n+    public static ModbusSlaveNatureTable getModbusSlaveNatureTable(AccessMode accessMode) {\n+        return ModbusSlaveNatureTable.of(SymmetricMeter.class, accessMode, 100) //\n+.channel(0, ChannelId.FREQUENCY, ModbusType.FLOAT32) //\n+.channel(2, ChannelId.MIN_ACTIVE_POWER, ModbusType.FLOAT32) //\n+.channel(4, ChannelId.MAX_ACTIVE_POWER, ModbusType.FLOAT32) //\n+.channel(6, ChannelId.ACTIVE_POWER, ModbusType.FLOAT32) //\n+.channel(8, ChannelId.REACTIVE_POWER, ModbusType.FLOAT32) //\n+.channel(10, ChannelId.ACTIVE_PRODUCTION_ENERGY, ModbusType.FLOAT32) //\n+.channel(12, ChannelId.ACTIVE_CONSUMPTION_ENERGY, ModbusType.FLOAT32) //\n+.channel(14, ChannelId.VOLTAGE, ModbusType.FLOAT32) //\n+.channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //              \n+.build();\n+    }\n+    \n+    /**\n+     * Gets the Active Power in [W]. Negative values for Consumption; positive for\n+     * Production\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getActivePower() {\n+        return this.channel(ChannelId.ACTIVE_POWER);\n+    }\n+\n+    /**\n+     * Gets the Reactive Power in [var]. Negative values for Consumption; positive\n+     * for Production.\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getReactivePower() {\n+        return this.channel(ChannelId.REACTIVE_POWER);\n+    }\n+\n+    /**\n+     * Gets the Production Active Energy in [Wh]. This relates to positive\n+     * ACTIVE_POWER.\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Long> getActiveProductionEnergy() {\n+        return this.channel(ChannelId.ACTIVE_PRODUCTION_ENERGY);\n+    }\n+\n+    /**\n+     * Gets the Frequency in [mHz]. FREQUENCY\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getFrequency() {\n+        return this.channel(ChannelId.FREQUENCY);\n+    }\n+\n+    /**\n+     * Gets the Voltage in [mV].\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getVoltage() {\n+        return this.channel(ChannelId.VOLTAGE);\n+    }\n+\n+    /**\n+     * Gets the Consumption Active Energy in [Wh]. This relates to negative\n+     * ACTIVE_POWER.\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Long> getActiveConsumptionEnergy() {\n+        return this.channel(ChannelId.ACTIVE_CONSUMPTION_ENERGY);\n+    }\n+\n+    /**\n+     * Gets the Minimum Ever Active Power.\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getMinActivePower() {\n+        return this.channel(ChannelId.MIN_ACTIVE_POWER);\n+    }\n+\n+    /**\n+     * Gets the Maximum Ever Active Power.\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getMaxActivePower() {\n+        return this.channel(ChannelId.MAX_ACTIVE_POWER);\n+    }\n+    \n+    /**\n+     * Gets the Current in [mA].\n+     * \n+     * @return the Channel\n+     */\n+\n+\n+    default Channel<Integer> getCurrent() {\n+        return this.channel(ChannelId.CURRENT);\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 290
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/styler_random/12/SymmetricMeter.java\nindex 8ee97fc8ed..249f991d19 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/styler_random/12/SymmetricMeter.java\n@@ -203,7 +203,7 @@ public interface SymmetricMeter extends OpenemsComponent {\n \t\t\t\t.channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //\t\t\t\t\n \t\t\t\t.build();\n \t}\n-\t\n+\n \t/**\n \t * Gets the Active Power in [W]. Negative values for Consumption; positive for\n \t * Production\n@@ -280,13 +280,13 @@ public interface SymmetricMeter extends OpenemsComponent {\n \tdefault Channel<Integer> getMaxActivePower() {\n \t\treturn this.channel(ChannelId.MAX_ACTIVE_POWER);\n \t}\n-\t\n+\n \t/**\n \t * Gets the Current in [mA].\n \t * \n \t * @return the Channel\n \t */\n-\tdefault Channel<Integer> getCurrent(){\n+\tdefault Channel<Integer> getCurrent() {\n \t\treturn this.channel(ChannelId.CURRENT);\n \t}\n }\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/styler_three_grams/12/SymmetricMeter.java\nindex 8ee97fc8ed..249f991d19 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/errored/1/12/SymmetricMeter.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/OpenEMS-openems/styler_three_grams/12/SymmetricMeter.java\n@@ -203,7 +203,7 @@ public interface SymmetricMeter extends OpenemsComponent {\n \t\t\t\t.channel(16, ChannelId.CURRENT, ModbusType.FLOAT32) //\t\t\t\t\n \t\t\t\t.build();\n \t}\n-\t\n+\n \t/**\n \t * Gets the Active Power in [W]. Negative values for Consumption; positive for\n \t * Production\n@@ -280,13 +280,13 @@ public interface SymmetricMeter extends OpenemsComponent {\n \tdefault Channel<Integer> getMaxActivePower() {\n \t\treturn this.channel(ChannelId.MAX_ACTIVE_POWER);\n \t}\n-\t\n+\n \t/**\n \t * Gets the Current in [mA].\n \t * \n \t * @return the Channel\n \t */\n-\tdefault Channel<Integer> getCurrent(){\n+\tdefault Channel<Integer> getCurrent() {\n \t\treturn this.channel(ChannelId.CURRENT);\n \t}\n }\n",
            "diff_size": 3
        }
    ]
}