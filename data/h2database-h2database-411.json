{
    "error_id": "411",
    "information": {
        "errors": [
            {
                "line": "6098",
                "column": "13",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "                        \"Internal Error - unhandled case: \" + nullConstraint.name());\n            }\n            if(hasOpeningBracket) {\n                read(\")\");\n            }\n            return command;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/411/Parser.java\nindex 76588612d8..0baf843d59 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/411/Parser.java\n@@ -6095,7 +6095,7 @@ public class Parser {\n                 throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n                         \"Internal Error - unhandled case: \" + nullConstraint.name());\n             }\n-            if(hasOpeningBracket) {\n+            if (hasOpeningBracket) {\n                 read(\")\");\n             }\n             return command;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/411/Parser.java\nindex 76588612d8..317c204798 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/411/Parser.java\n@@ -6,6 +6,7 @@\n  * Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  * Support for the operator \"&&\" as an alias for SPATIAL_INTERSECTS\n  */\n+\n package org.h2.command;\n \n import java.math.BigDecimal;\n@@ -176,6638 +177,6699 @@ import org.h2.value.ValueTimestampTimeZone;\n  */\n public class Parser {\n \n-    private static final String WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS =\n-            \"WITH statement supports only SELECT, CREATE TABLE, INSERT, UPDATE, MERGE or DELETE statements\";\n-\n-    // used during the tokenizer phase\n-    private static final int CHAR_END = 1, CHAR_VALUE = 2, CHAR_QUOTED = 3;\n-    private static final int CHAR_NAME = 4, CHAR_SPECIAL_1 = 5,\n-            CHAR_SPECIAL_2 = 6;\n-    private static final int CHAR_STRING = 7, CHAR_DOT = 8,\n-            CHAR_DOLLAR_QUOTED_STRING = 9;\n-\n-    // this are token types\n-    private static final int KEYWORD = ParserUtil.KEYWORD;\n-    private static final int IDENTIFIER = ParserUtil.IDENTIFIER;\n-    private static final int NULL = ParserUtil.NULL;\n-    private static final int TRUE = ParserUtil.TRUE;\n-    private static final int FALSE = ParserUtil.FALSE;\n-    private static final int ROWNUM = ParserUtil.ROWNUM;\n-    private static final int PARAMETER = 10, END = 11, VALUE = 12;\n-    private static final int EQUAL = 13, BIGGER_EQUAL = 14, BIGGER = 15;\n-    private static final int SMALLER = 16, SMALLER_EQUAL = 17, NOT_EQUAL = 18;\n-    private static final int AT = 19;\n-    private static final int MINUS = 20, PLUS = 21, STRING_CONCAT = 22;\n-    private static final int OPEN = 23, CLOSE = 24;\n-    private static final int SPATIAL_INTERSECTS = 25;\n-\n-    private static final Comparator<TableFilter> TABLE_FILTER_COMPARATOR =\n-            new Comparator<TableFilter>() {\n+  private static final String WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS =\n+      \"WITH statement supports only SELECT, CREATE TABLE, INSERT, UPDATE, MERGE or DELETE statements\";\n+\n+  // used during the tokenizer phase\n+  private static final int CHAR_END = 1, CHAR_VALUE = 2, CHAR_QUOTED = 3;\n+  private static final int CHAR_NAME = 4, CHAR_SPECIAL_1 = 5,\n+      CHAR_SPECIAL_2 = 6;\n+  private static final int CHAR_STRING = 7, CHAR_DOT = 8,\n+      CHAR_DOLLAR_QUOTED_STRING = 9;\n+\n+  // this are token types\n+  private static final int KEYWORD = ParserUtil.KEYWORD;\n+  private static final int IDENTIFIER = ParserUtil.IDENTIFIER;\n+  private static final int NULL = ParserUtil.NULL;\n+  private static final int TRUE = ParserUtil.TRUE;\n+  private static final int FALSE = ParserUtil.FALSE;\n+  private static final int ROWNUM = ParserUtil.ROWNUM;\n+  private static final int PARAMETER = 10, END = 11, VALUE = 12;\n+  private static final int EQUAL = 13, BIGGER_EQUAL = 14, BIGGER = 15;\n+  private static final int SMALLER = 16, SMALLER_EQUAL = 17, NOT_EQUAL = 18;\n+  private static final int AT = 19;\n+  private static final int MINUS = 20, PLUS = 21, STRING_CONCAT = 22;\n+  private static final int OPEN = 23, CLOSE = 24;\n+  private static final int SPATIAL_INTERSECTS = 25;\n+\n+  private static final Comparator<TableFilter> TABLE_FILTER_COMPARATOR =\n+      new Comparator<TableFilter>() {\n         @Override\n         public int compare(TableFilter o1, TableFilter o2) {\n-            return o1 == o2 ? 0 : compareTableFilters(o1, o2);\n-        }\n-    };\n-\n-    private final Database database;\n-    private final Session session;\n-    /**\n-     * @see org.h2.engine.DbSettings#databaseToUpper\n-     */\n-    private final boolean identifiersToUpper;\n-\n-    /** indicates character-type for each char in sqlCommand */\n-    private int[] characterTypes;\n-    private int currentTokenType;\n-    private String currentToken;\n-    private boolean currentTokenQuoted;\n-    private Value currentValue;\n-    private String originalSQL;\n-    /** copy of originalSQL, with comments blanked out */\n-    private String sqlCommand;\n-    /** cached array if chars from sqlCommand */\n-    private char[] sqlCommandChars;\n-    /** index into sqlCommand of previous token */\n-    private int lastParseIndex;\n-    /** index into sqlCommand of current token */\n-    private int parseIndex;\n-    private CreateView createView;\n-    private Prepared currentPrepared;\n-    private Select currentSelect;\n-    private ArrayList<Parameter> parameters;\n-    private String schemaName;\n-    private ArrayList<String> expectedList;\n-    private boolean rightsChecked;\n-    private boolean recompileAlways;\n-    private boolean literalsChecked;\n-    private ArrayList<Parameter> indexedParameterList;\n-    private int orderInFrom;\n-    private ArrayList<Parameter> suppliedParameterList;\n-\n-    public Parser(Session session) {\n-        this.database = session.getDatabase();\n-        this.identifiersToUpper = database.getSettings().databaseToUpper;\n-        this.session = session;\n-    }\n-\n-    /**\n-     * Parse the statement and prepare it for execution.\n-     *\n-     * @param sql the SQL statement to parse\n-     * @return the prepared object\n-     */\n-    public Prepared prepare(String sql) {\n-        Prepared p = parse(sql);\n-        p.prepare();\n-        if (currentTokenType != END) {\n+          return o1 == o2 ? 0 : compareTableFilters(o1, o2);\n+        }\n+      };\n+\n+  private final Database database;\n+  private final Session session;\n+  /**\n+   * @see org.h2.engine.DbSettings#databaseToUpper\n+   */\n+  private final boolean identifiersToUpper;\n+\n+  /**\n+   * indicates character-type for each char in sqlCommand\n+   */\n+  private int[] characterTypes;\n+  private int currentTokenType;\n+  private String currentToken;\n+  private boolean currentTokenQuoted;\n+  private Value currentValue;\n+  private String originalSQL;\n+  /**\n+   * copy of originalSQL, with comments blanked out\n+   */\n+  private String sqlCommand;\n+  /**\n+   * cached array if chars from sqlCommand\n+   */\n+  private char[] sqlCommandChars;\n+  /**\n+   * index into sqlCommand of previous token\n+   */\n+  private int lastParseIndex;\n+  /**\n+   * index into sqlCommand of current token\n+   */\n+  private int parseIndex;\n+  private CreateView createView;\n+  private Prepared currentPrepared;\n+  private Select currentSelect;\n+  private ArrayList<Parameter> parameters;\n+  private String schemaName;\n+  private ArrayList<String> expectedList;\n+  private boolean rightsChecked;\n+  private boolean recompileAlways;\n+  private boolean literalsChecked;\n+  private ArrayList<Parameter> indexedParameterList;\n+  private int orderInFrom;\n+  private ArrayList<Parameter> suppliedParameterList;\n+\n+  public Parser(Session session) {\n+    this.database = session.getDatabase();\n+    this.identifiersToUpper = database.getSettings().databaseToUpper;\n+    this.session = session;\n+  }\n+\n+  /**\n+   * Parse the statement and prepare it for execution.\n+   *\n+   * @param sql the SQL statement to parse\n+   * @return the prepared object\n+   */\n+  public Prepared prepare(String sql) {\n+    Prepared p = parse(sql);\n+    p.prepare();\n+    if (currentTokenType != END) {\n+      throw getSyntaxError();\n+    }\n+    return p;\n+  }\n+\n+  /**\n+   * Parse a statement or a list of statements, and prepare it for execution.\n+   *\n+   * @param sql the SQL statement to parse\n+   * @return the command object\n+   */\n+  public Command prepareCommand(String sql) {\n+    try {\n+      Prepared p = parse(sql);\n+      boolean hasMore = isToken(\";\");\n+      if (!hasMore && currentTokenType != END) {\n+        throw getSyntaxError();\n+      }\n+      p.prepare();\n+      Command c = new CommandContainer(this, sql, p);\n+      if (hasMore) {\n+        String remaining = originalSQL.substring(parseIndex);\n+        if (remaining.trim().length() != 0) {\n+          CommandList list = new CommandList(this, sql, c, remaining);\n+          // list.addCommand(c);\n+          // do {\n+          // c = parseCommand();\n+          // list.addCommand(c);\n+          // } while (currentToken.equals(\";\"));\n+          c = list;\n+        }\n+      }\n+      return c;\n+    } catch (DbException e) {\n+      throw e.addSQL(originalSQL);\n+    }\n+  }\n+\n+  /**\n+   * Parse the statement, but don't prepare it for execution.\n+   *\n+   * @param sql the SQL statement to parse\n+   * @return the prepared object\n+   */\n+  Prepared parse(String sql) {\n+    Prepared p;\n+    try {\n+      // first, try the fast variant\n+      p = parse(sql, false);\n+    } catch (DbException e) {\n+      if (e.getErrorCode() == ErrorCode.SYNTAX_ERROR_1) {\n+        // now, get the detailed exception\n+        p = parse(sql, true);\n+      } else {\n+        throw e.addSQL(sql);\n+      }\n+    }\n+    p.setPrepareAlways(recompileAlways);\n+    p.setParameterList(parameters);\n+    return p;\n+  }\n+\n+  private Prepared parse(String sql, boolean withExpectedList) {\n+    initialize(sql);\n+    if (withExpectedList) {\n+      expectedList = New.arrayList();\n+    } else {\n+      expectedList = null;\n+    }\n+    parameters = New.arrayList();\n+    currentSelect = null;\n+    currentPrepared = null;\n+    createView = null;\n+    recompileAlways = false;\n+    indexedParameterList = suppliedParameterList;\n+    read();\n+    return parsePrepared();\n+  }\n+\n+  private Prepared parsePrepared() {\n+    int start = lastParseIndex;\n+    Prepared c = null;\n+    String token = currentToken;\n+    if (token.length() == 0) {\n+      c = new NoOperation(session);\n+    } else {\n+      char first = token.charAt(0);\n+      switch (first) {\n+        case '?':\n+          // read the ? as a parameter\n+          readTerm();\n+          // this is an 'out' parameter - set a dummy value\n+          parameters.get(0).setValue(ValueNull.INSTANCE);\n+          read(\"=\");\n+          read(\"CALL\");\n+          c = parseCall();\n+          break;\n+        case '(':\n+          c = parseSelect();\n+          break;\n+        case 'a':\n+        case 'A':\n+          if (readIf(\"ALTER\")) {\n+            c = parseAlter();\n+          } else if (readIf(\"ANALYZE\")) {\n+            c = parseAnalyze();\n+          }\n+          break;\n+        case 'b':\n+        case 'B':\n+          if (readIf(\"BACKUP\")) {\n+            c = parseBackup();\n+          } else if (readIf(\"BEGIN\")) {\n+            c = parseBegin();\n+          }\n+          break;\n+        case 'c':\n+        case 'C':\n+          if (readIf(\"COMMIT\")) {\n+            c = parseCommit();\n+          } else if (readIf(\"CREATE\")) {\n+            c = parseCreate();\n+          } else if (readIf(\"CALL\")) {\n+            c = parseCall();\n+          } else if (readIf(\"CHECKPOINT\")) {\n+            c = parseCheckpoint();\n+          } else if (readIf(\"COMMENT\")) {\n+            c = parseComment();\n+          }\n+          break;\n+        case 'd':\n+        case 'D':\n+          if (readIf(\"DELETE\")) {\n+            c = parseDelete();\n+          } else if (readIf(\"DROP\")) {\n+            c = parseDrop();\n+          } else if (readIf(\"DECLARE\")) {\n+            // support for DECLARE GLOBAL TEMPORARY TABLE...\n+            c = parseCreate();\n+          } else if (readIf(\"DEALLOCATE\")) {\n+            c = parseDeallocate();\n+          }\n+          break;\n+        case 'e':\n+        case 'E':\n+          if (readIf(\"EXPLAIN\")) {\n+            c = parseExplain();\n+          } else if (readIf(\"EXECUTE\")) {\n+            c = parseExecute();\n+          }\n+          break;\n+        case 'f':\n+        case 'F':\n+          if (isToken(\"FROM\")) {\n+            c = parseSelect();\n+          }\n+          break;\n+        case 'g':\n+        case 'G':\n+          if (readIf(\"GRANT\")) {\n+            c = parseGrantRevoke(CommandInterface.GRANT);\n+          }\n+          break;\n+        case 'h':\n+        case 'H':\n+          if (readIf(\"HELP\")) {\n+            c = parseHelp();\n+          }\n+          break;\n+        case 'i':\n+        case 'I':\n+          if (readIf(\"INSERT\")) {\n+            c = parseInsert();\n+          }\n+          break;\n+        case 'm':\n+        case 'M':\n+          if (readIf(\"MERGE\")) {\n+            c = parseMerge();\n+          }\n+          break;\n+        case 'p':\n+        case 'P':\n+          if (readIf(\"PREPARE\")) {\n+            c = parsePrepare();\n+          }\n+          break;\n+        case 'r':\n+        case 'R':\n+          if (readIf(\"ROLLBACK\")) {\n+            c = parseRollback();\n+          } else if (readIf(\"REVOKE\")) {\n+            c = parseGrantRevoke(CommandInterface.REVOKE);\n+          } else if (readIf(\"RUNSCRIPT\")) {\n+            c = parseRunScript();\n+          } else if (readIf(\"RELEASE\")) {\n+            c = parseReleaseSavepoint();\n+          } else if (readIf(\"REPLACE\")) {\n+            c = parseReplace();\n+          }\n+          break;\n+        case 's':\n+        case 'S':\n+          if (isToken(\"SELECT\")) {\n+            c = parseSelect();\n+          } else if (readIf(\"SET\")) {\n+            c = parseSet();\n+          } else if (readIf(\"SAVEPOINT\")) {\n+            c = parseSavepoint();\n+          } else if (readIf(\"SCRIPT\")) {\n+            c = parseScript();\n+          } else if (readIf(\"SHUTDOWN\")) {\n+            c = parseShutdown();\n+          } else if (readIf(\"SHOW\")) {\n+            c = parseShow();\n+          }\n+          break;\n+        case 't':\n+        case 'T':\n+          if (readIf(\"TRUNCATE\")) {\n+            c = parseTruncate();\n+          }\n+          break;\n+        case 'u':\n+        case 'U':\n+          if (readIf(\"UPDATE\")) {\n+            c = parseUpdate();\n+          } else if (readIf(\"USE\")) {\n+            c = parseUse();\n+          }\n+          break;\n+        case 'v':\n+        case 'V':\n+          if (readIf(\"VALUES\")) {\n+            c = parseValues();\n+          }\n+          break;\n+        case 'w':\n+        case 'W':\n+          if (readIf(\"WITH\")) {\n+            c = parseWithStatementOrQuery();\n+          }\n+          break;\n+        case ';':\n+          c = new NoOperation(session);\n+          break;\n+        default:\n+          throw getSyntaxError();\n+      }\n+      if (indexedParameterList != null) {\n+        for (int i = 0, size = indexedParameterList.size();\n+             i < size; i++) {\n+          if (indexedParameterList.get(i) == null) {\n+            indexedParameterList.set(i, new Parameter(i));\n+          }\n+        }\n+        parameters = indexedParameterList;\n+      }\n+      if (readIf(\"{\")) {\n+        do {\n+          int index = (int) readLong() - 1;\n+          if (index < 0 || index >= parameters.size()) {\n             throw getSyntaxError();\n+          }\n+          Parameter p = parameters.get(index);\n+          if (p == null) {\n+            throw getSyntaxError();\n+          }\n+          read(\":\");\n+          Expression expr = readExpression();\n+          expr = expr.optimize(session);\n+          p.setValue(expr.getValue(session));\n+        } while (readIf(\",\"));\n+        read(\"}\");\n+        for (Parameter p : parameters) {\n+          p.checkSet();\n+        }\n+        parameters.clear();\n+      }\n+    }\n+    if (c == null) {\n+      throw getSyntaxError();\n+    }\n+    setSQL(c, null, start);\n+    return c;\n+  }\n+\n+  private DbException getSyntaxError() {\n+    if (expectedList == null || expectedList.isEmpty()) {\n+      return DbException.getSyntaxError(sqlCommand, parseIndex);\n+    }\n+    StatementBuilder buff = new StatementBuilder();\n+    for (String e : expectedList) {\n+      buff.appendExceptFirst(\", \");\n+      buff.append(e);\n+    }\n+    return DbException.getSyntaxError(sqlCommand, parseIndex,\n+        buff.toString());\n+  }\n+\n+  private Prepared parseBackup() {\n+    BackupCommand command = new BackupCommand(session);\n+    read(\"TO\");\n+    command.setFileName(readExpression());\n+    return command;\n+  }\n+\n+  private Prepared parseAnalyze() {\n+    Analyze command = new Analyze(session);\n+    if (readIf(\"TABLE\")) {\n+      Table table = readTableOrView();\n+      command.setTable(table);\n+    }\n+    if (readIf(\"SAMPLE_SIZE\")) {\n+      command.setTop(readPositiveInt());\n+    }\n+    return command;\n+  }\n+\n+  private TransactionCommand parseBegin() {\n+    TransactionCommand command;\n+    if (!readIf(\"WORK\")) {\n+      readIf(\"TRANSACTION\");\n+    }\n+    command = new TransactionCommand(session, CommandInterface.BEGIN);\n+    return command;\n+  }\n+\n+  private TransactionCommand parseCommit() {\n+    TransactionCommand command;\n+    if (readIf(\"TRANSACTION\")) {\n+      command = new TransactionCommand(session,\n+          CommandInterface.COMMIT_TRANSACTION);\n+      command.setTransactionName(readUniqueIdentifier());\n+      return command;\n+    }\n+    command = new TransactionCommand(session,\n+        CommandInterface.COMMIT);\n+    readIf(\"WORK\");\n+    return command;\n+  }\n+\n+  private TransactionCommand parseShutdown() {\n+    int type = CommandInterface.SHUTDOWN;\n+    if (readIf(\"IMMEDIATELY\")) {\n+      type = CommandInterface.SHUTDOWN_IMMEDIATELY;\n+    } else if (readIf(\"COMPACT\")) {\n+      type = CommandInterface.SHUTDOWN_COMPACT;\n+    } else if (readIf(\"DEFRAG\")) {\n+      type = CommandInterface.SHUTDOWN_DEFRAG;\n+    } else {\n+      readIf(\"SCRIPT\");\n+    }\n+    return new TransactionCommand(session, type);\n+  }\n+\n+  private TransactionCommand parseRollback() {\n+    TransactionCommand command;\n+    if (readIf(\"TRANSACTION\")) {\n+      command = new TransactionCommand(session,\n+          CommandInterface.ROLLBACK_TRANSACTION);\n+      command.setTransactionName(readUniqueIdentifier());\n+      return command;\n+    }\n+    if (readIf(\"TO\")) {\n+      read(\"SAVEPOINT\");\n+      command = new TransactionCommand(session,\n+          CommandInterface.ROLLBACK_TO_SAVEPOINT);\n+      command.setSavepointName(readUniqueIdentifier());\n+    } else {\n+      readIf(\"WORK\");\n+      command = new TransactionCommand(session,\n+          CommandInterface.ROLLBACK);\n+    }\n+    return command;\n+  }\n+\n+  private Prepared parsePrepare() {\n+    if (readIf(\"COMMIT\")) {\n+      TransactionCommand command = new TransactionCommand(session,\n+          CommandInterface.PREPARE_COMMIT);\n+      command.setTransactionName(readUniqueIdentifier());\n+      return command;\n+    }\n+    String procedureName = readAliasIdentifier();\n+    if (readIf(\"(\")) {\n+      ArrayList<Column> list = New.arrayList();\n+      for (int i = 0; ; i++) {\n+        Column column = parseColumnForTable(\"C\" + i, true);\n+        list.add(column);\n+        if (readIf(\")\")) {\n+          break;\n         }\n-        return p;\n-    }\n-\n-    /**\n-     * Parse a statement or a list of statements, and prepare it for execution.\n-     *\n-     * @param sql the SQL statement to parse\n-     * @return the command object\n-     */\n-    public Command prepareCommand(String sql) {\n-        try {\n-            Prepared p = parse(sql);\n-            boolean hasMore = isToken(\";\");\n-            if (!hasMore && currentTokenType != END) {\n-                throw getSyntaxError();\n-            }\n-            p.prepare();\n-            Command c = new CommandContainer(this, sql, p);\n-            if (hasMore) {\n-                String remaining = originalSQL.substring(parseIndex);\n-                if (remaining.trim().length() != 0) {\n-                    CommandList list = new CommandList(this, sql, c, remaining);\n-                    // list.addCommand(c);\n-                    // do {\n-                    // c = parseCommand();\n-                    // list.addCommand(c);\n-                    // } while (currentToken.equals(\";\"));\n-                    c = list;\n-                }\n-            }\n-            return c;\n-        } catch (DbException e) {\n-            throw e.addSQL(originalSQL);\n-        }\n-    }\n-\n-    /**\n-     * Parse the statement, but don't prepare it for execution.\n-     *\n-     * @param sql the SQL statement to parse\n-     * @return the prepared object\n-     */\n-    Prepared parse(String sql) {\n-        Prepared p;\n-        try {\n-            // first, try the fast variant\n-            p = parse(sql, false);\n-        } catch (DbException e) {\n-            if (e.getErrorCode() == ErrorCode.SYNTAX_ERROR_1) {\n-                // now, get the detailed exception\n-                p = parse(sql, true);\n-            } else {\n-                throw e.addSQL(sql);\n-            }\n-        }\n-        p.setPrepareAlways(recompileAlways);\n-        p.setParameterList(parameters);\n-        return p;\n-    }\n-\n-    private Prepared parse(String sql, boolean withExpectedList) {\n-        initialize(sql);\n-        if (withExpectedList) {\n-            expectedList = New.arrayList();\n+        read(\",\");\n+      }\n+    }\n+    read(\"AS\");\n+    Prepared prep = parsePrepared();\n+    PrepareProcedure command = new PrepareProcedure(session);\n+    command.setProcedureName(procedureName);\n+    command.setPrepared(prep);\n+    return command;\n+  }\n+\n+  private TransactionCommand parseSavepoint() {\n+    TransactionCommand command = new TransactionCommand(session,\n+        CommandInterface.SAVEPOINT);\n+    command.setSavepointName(readUniqueIdentifier());\n+    return command;\n+  }\n+\n+  private Prepared parseReleaseSavepoint() {\n+    Prepared command = new NoOperation(session);\n+    readIf(\"SAVEPOINT\");\n+    readUniqueIdentifier();\n+    return command;\n+  }\n+\n+  private Schema findSchema(String schemaName) {\n+    if (schemaName == null) {\n+      return null;\n+    }\n+    Schema schema = database.findSchema(schemaName);\n+    if (schema == null) {\n+      if (equalsToken(\"SESSION\", schemaName)) {\n+        // for local temporary tables\n+        schema = database.getSchema(session.getCurrentSchemaName());\n+      } else if (database.getMode().sysDummy1 &&\n+          \"SYSIBM\".equals(schemaName)) {\n+        // IBM DB2 and Apache Derby compatibility: SYSIBM.SYSDUMMY1\n+        schema = database.getSchema(session.getCurrentSchemaName());\n+      }\n+    }\n+    return schema;\n+  }\n+\n+  private Schema getSchema(String schemaName) {\n+    if (schemaName == null) {\n+      return null;\n+    }\n+    Schema schema = findSchema(schemaName);\n+    if (schema == null) {\n+      throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schemaName);\n+    }\n+    return schema;\n+  }\n+\n+  private Schema getSchema() {\n+    return getSchema(schemaName);\n+  }\n+\n+  /*\n+   * Gets the current schema for scenarios that need a guaranteed, non-null schema object.\n+   *\n+   * This routine is solely here\n+   * because of the function readIdentifierWithSchema(String defaultSchemaName) - which\n+   * is often called with a null parameter (defaultSchemaName) - then 6 lines into the function\n+   * that routine nullifies the state field schemaName - which I believe is a bug.\n+   *\n+   * There are about 7 places where \"readIdentifierWithSchema(null)\" is called in this file.\n+   *\n+   * In other words when is it legal to not have an active schema defined by schemaName ?\n+   * I don't think it's ever a valid case. I don't understand when that would be allowed.\n+   * I spent a long time trying to figure this out.\n+   * As another proof of this point, the command \"SET SCHEMA=NULL\" is not a valid command.\n+   *\n+   * I did try to fix this in readIdentifierWithSchema(String defaultSchemaName)\n+   * - but every fix I tried cascaded so many unit test errors - so\n+   * I gave up. I think this needs a bigger effort to fix his, as part of bigger, dedicated story.\n+   *\n+   */\n+  private Schema getSchemaWithDefault() {\n+    if (schemaName == null) {\n+      schemaName = session.getCurrentSchemaName();\n+    }\n+    return getSchema(schemaName);\n+  }\n+\n+  private Column readTableColumn(TableFilter filter) {\n+    String tableAlias = null;\n+    String columnName = readColumnIdentifier();\n+    if (readIf(\".\")) {\n+      tableAlias = columnName;\n+      columnName = readColumnIdentifier();\n+      if (readIf(\".\")) {\n+        String schema = tableAlias;\n+        tableAlias = columnName;\n+        columnName = readColumnIdentifier();\n+        if (readIf(\".\")) {\n+          String catalogName = schema;\n+          schema = tableAlias;\n+          tableAlias = columnName;\n+          columnName = readColumnIdentifier();\n+          if (!equalsToken(catalogName, database.getShortName())) {\n+            throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n+                catalogName);\n+          }\n+        }\n+        if (!equalsToken(schema, filter.getTable().getSchema()\n+            .getName())) {\n+          throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schema);\n+        }\n+      }\n+      if (!equalsToken(tableAlias, filter.getTableAlias())) {\n+        throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1,\n+            tableAlias);\n+      }\n+    }\n+    if (database.getSettings().rowId) {\n+      if (Column.ROWID.equals(columnName)) {\n+        return filter.getRowIdColumn();\n+      }\n+    }\n+    return filter.getTable().getColumn(columnName);\n+  }\n+\n+  private Update parseUpdate() {\n+    Update command = new Update(session);\n+    currentPrepared = command;\n+    int start = lastParseIndex;\n+    TableFilter filter = readSimpleTableFilter(0, null);\n+    command.setTableFilter(filter);\n+    parseUpdateSetClause(command, filter, start);\n+    return command;\n+  }\n+\n+  private void parseUpdateSetClause(Update command, TableFilter filter,\n+                                    int start) {\n+    read(\"SET\");\n+    if (readIf(\"(\")) {\n+      ArrayList<Column> columns = New.arrayList();\n+      do {\n+        Column column = readTableColumn(filter);\n+        columns.add(column);\n+      } while (readIf(\",\"));\n+      read(\")\");\n+      read(\"=\");\n+      Expression expression = readExpression();\n+      if (columns.size() == 1) {\n+        // the expression is parsed as a simple value\n+        command.setAssignment(columns.get(0), expression);\n+      } else {\n+        for (int i = 0, size = columns.size(); i < size; i++) {\n+          Column column = columns.get(i);\n+          Function f = Function.getFunction(database, \"ARRAY_GET\");\n+          f.setParameter(0, expression);\n+          f.setParameter(1, ValueExpression.get(ValueInt.get(i + 1)));\n+          f.doneWithParameters();\n+          command.setAssignment(column, f);\n+        }\n+      }\n+    } else {\n+      do {\n+        Column column = readTableColumn(filter);\n+        read(\"=\");\n+        Expression expression;\n+        if (readIf(\"DEFAULT\")) {\n+          expression = ValueExpression.getDefault();\n         } else {\n-            expectedList = null;\n-        }\n-        parameters = New.arrayList();\n-        currentSelect = null;\n-        currentPrepared = null;\n-        createView = null;\n-        recompileAlways = false;\n-        indexedParameterList = suppliedParameterList;\n-        read();\n-        return parsePrepared();\n-    }\n-\n-    private Prepared parsePrepared() {\n-        int start = lastParseIndex;\n-        Prepared c = null;\n-        String token = currentToken;\n-        if (token.length() == 0) {\n-            c = new NoOperation(session);\n+          expression = readExpression();\n+        }\n+        command.setAssignment(column, expression);\n+      } while (readIf(\",\"));\n+    }\n+    if (readIf(\"WHERE\")) {\n+      Expression condition = readExpression();\n+      command.setCondition(condition);\n+    }\n+    if (readIf(\"ORDER\")) {\n+      // for MySQL compatibility\n+      // (this syntax is supported, but ignored)\n+      read(\"BY\");\n+      parseSimpleOrderList();\n+    }\n+    if (readIf(\"LIMIT\")) {\n+      Expression limit = readTerm().optimize(session);\n+      command.setLimit(limit);\n+    }\n+    setSQL(command, \"UPDATE\", start);\n+  }\n+\n+  private TableFilter readSimpleTableFilter(int orderInFrom,\n+                                            Collection<String> excludeTokens) {\n+    Table table = readTableOrView();\n+    String alias = null;\n+    if (readIf(\"AS\")) {\n+      alias = readAliasIdentifier();\n+    } else if (currentTokenType == IDENTIFIER) {\n+      if (!equalsTokenIgnoreCase(currentToken, \"SET\")\n+          && (excludeTokens == null || !isTokenInList(excludeTokens))) {\n+        // SET is not a keyword (PostgreSQL supports it as a table name)\n+        alias = readAliasIdentifier();\n+      }\n+    }\n+    return new TableFilter(session, table, alias, rightsChecked,\n+        currentSelect, orderInFrom, null);\n+  }\n+\n+  private Delete parseDelete() {\n+    Delete command = new Delete(session);\n+    Expression limit = null;\n+    if (readIf(\"TOP\")) {\n+      limit = readTerm().optimize(session);\n+    }\n+    currentPrepared = command;\n+    int start = lastParseIndex;\n+    if (!readIf(\"FROM\") && database.getMode().getEnum() == ModeEnum.MySQL) {\n+      readIdentifierWithSchema();\n+      read(\"FROM\");\n+    }\n+    TableFilter filter = readSimpleTableFilter(0, null);\n+    command.setTableFilter(filter);\n+    parseDeleteGivenTable(command, limit, start);\n+    return command;\n+  }\n+\n+  private void parseDeleteGivenTable(Delete command, Expression limit,\n+                                     int start) {\n+    if (readIf(\"WHERE\")) {\n+      Expression condition = readExpression();\n+      command.setCondition(condition);\n+    }\n+    if (readIf(\"LIMIT\") && limit == null) {\n+      limit = readTerm().optimize(session);\n+    }\n+    command.setLimit(limit);\n+    setSQL(command, \"DELETE\", start);\n+  }\n+\n+  private IndexColumn[] parseIndexColumnList() {\n+    ArrayList<IndexColumn> columns = New.arrayList();\n+    do {\n+      IndexColumn column = new IndexColumn();\n+      column.columnName = readColumnIdentifier();\n+      columns.add(column);\n+      if (readIf(\"ASC\")) {\n+        // ignore\n+      } else if (readIf(\"DESC\")) {\n+        column.sortType = SortOrder.DESCENDING;\n+      }\n+      if (readIf(\"NULLS\")) {\n+        if (readIf(\"FIRST\")) {\n+          column.sortType |= SortOrder.NULLS_FIRST;\n         } else {\n-            char first = token.charAt(0);\n-            switch (first) {\n-            case '?':\n-                // read the ? as a parameter\n-                readTerm();\n-                // this is an 'out' parameter - set a dummy value\n-                parameters.get(0).setValue(ValueNull.INSTANCE);\n-                read(\"=\");\n-                read(\"CALL\");\n-                c = parseCall();\n-                break;\n-            case '(':\n-                c = parseSelect();\n-                break;\n-            case 'a':\n-            case 'A':\n-                if (readIf(\"ALTER\")) {\n-                    c = parseAlter();\n-                } else if (readIf(\"ANALYZE\")) {\n-                    c = parseAnalyze();\n-                }\n-                break;\n-            case 'b':\n-            case 'B':\n-                if (readIf(\"BACKUP\")) {\n-                    c = parseBackup();\n-                } else if (readIf(\"BEGIN\")) {\n-                    c = parseBegin();\n-                }\n-                break;\n-            case 'c':\n-            case 'C':\n-                if (readIf(\"COMMIT\")) {\n-                    c = parseCommit();\n-                } else if (readIf(\"CREATE\")) {\n-                    c = parseCreate();\n-                } else if (readIf(\"CALL\")) {\n-                    c = parseCall();\n-                } else if (readIf(\"CHECKPOINT\")) {\n-                    c = parseCheckpoint();\n-                } else if (readIf(\"COMMENT\")) {\n-                    c = parseComment();\n-                }\n-                break;\n-            case 'd':\n-            case 'D':\n-                if (readIf(\"DELETE\")) {\n-                    c = parseDelete();\n-                } else if (readIf(\"DROP\")) {\n-                    c = parseDrop();\n-                } else if (readIf(\"DECLARE\")) {\n-                    // support for DECLARE GLOBAL TEMPORARY TABLE...\n-                    c = parseCreate();\n-                } else if (readIf(\"DEALLOCATE\")) {\n-                    c = parseDeallocate();\n-                }\n-                break;\n-            case 'e':\n-            case 'E':\n-                if (readIf(\"EXPLAIN\")) {\n-                    c = parseExplain();\n-                } else if (readIf(\"EXECUTE\")) {\n-                    c = parseExecute();\n-                }\n-                break;\n-            case 'f':\n-            case 'F':\n-                if (isToken(\"FROM\")) {\n-                    c = parseSelect();\n-                }\n-                break;\n-            case 'g':\n-            case 'G':\n-                if (readIf(\"GRANT\")) {\n-                    c = parseGrantRevoke(CommandInterface.GRANT);\n-                }\n-                break;\n-            case 'h':\n-            case 'H':\n-                if (readIf(\"HELP\")) {\n-                    c = parseHelp();\n-                }\n-                break;\n-            case 'i':\n-            case 'I':\n-                if (readIf(\"INSERT\")) {\n-                    c = parseInsert();\n-                }\n-                break;\n-            case 'm':\n-            case 'M':\n-                if (readIf(\"MERGE\")) {\n-                    c = parseMerge();\n-                }\n-                break;\n-            case 'p':\n-            case 'P':\n-                if (readIf(\"PREPARE\")) {\n-                    c = parsePrepare();\n-                }\n-                break;\n-            case 'r':\n-            case 'R':\n-                if (readIf(\"ROLLBACK\")) {\n-                    c = parseRollback();\n-                } else if (readIf(\"REVOKE\")) {\n-                    c = parseGrantRevoke(CommandInterface.REVOKE);\n-                } else if (readIf(\"RUNSCRIPT\")) {\n-                    c = parseRunScript();\n-                } else if (readIf(\"RELEASE\")) {\n-                    c = parseReleaseSavepoint();\n-                } else if (readIf(\"REPLACE\")) {\n-                    c = parseReplace();\n-                }\n-                break;\n-            case 's':\n-            case 'S':\n-                if (isToken(\"SELECT\")) {\n-                    c = parseSelect();\n-                } else if (readIf(\"SET\")) {\n-                    c = parseSet();\n-                } else if (readIf(\"SAVEPOINT\")) {\n-                    c = parseSavepoint();\n-                } else if (readIf(\"SCRIPT\")) {\n-                    c = parseScript();\n-                } else if (readIf(\"SHUTDOWN\")) {\n-                    c = parseShutdown();\n-                } else if (readIf(\"SHOW\")) {\n-                    c = parseShow();\n-                }\n-                break;\n-            case 't':\n-            case 'T':\n-                if (readIf(\"TRUNCATE\")) {\n-                    c = parseTruncate();\n-                }\n-                break;\n-            case 'u':\n-            case 'U':\n-                if (readIf(\"UPDATE\")) {\n-                    c = parseUpdate();\n-                } else if (readIf(\"USE\")) {\n-                    c = parseUse();\n-                }\n-                break;\n-            case 'v':\n-            case 'V':\n-                if (readIf(\"VALUES\")) {\n-                    c = parseValues();\n-                }\n-                break;\n-            case 'w':\n-            case 'W':\n-                if (readIf(\"WITH\")) {\n-                    c = parseWithStatementOrQuery();\n-                }\n-                break;\n-            case ';':\n-                c = new NoOperation(session);\n-                break;\n-            default:\n-                throw getSyntaxError();\n-            }\n-            if (indexedParameterList != null) {\n-                for (int i = 0, size = indexedParameterList.size();\n-                        i < size; i++) {\n-                    if (indexedParameterList.get(i) == null) {\n-                        indexedParameterList.set(i, new Parameter(i));\n-                    }\n-                }\n-                parameters = indexedParameterList;\n-            }\n-            if (readIf(\"{\")) {\n-                do {\n-                    int index = (int) readLong() - 1;\n-                    if (index < 0 || index >= parameters.size()) {\n-                        throw getSyntaxError();\n-                    }\n-                    Parameter p = parameters.get(index);\n-                    if (p == null) {\n-                        throw getSyntaxError();\n-                    }\n-                    read(\":\");\n-                    Expression expr = readExpression();\n-                    expr = expr.optimize(session);\n-                    p.setValue(expr.getValue(session));\n-                } while (readIf(\",\"));\n-                read(\"}\");\n-                for (Parameter p : parameters) {\n-                    p.checkSet();\n-                }\n-                parameters.clear();\n+          read(\"LAST\");\n+          column.sortType |= SortOrder.NULLS_LAST;\n+        }\n+      }\n+    } while (readIf(\",\"));\n+    read(\")\");\n+    return columns.toArray(new IndexColumn[0]);\n+  }\n+\n+  private String[] parseColumnList() {\n+    ArrayList<String> columns = New.arrayList();\n+    do {\n+      String columnName = readColumnIdentifier();\n+      columns.add(columnName);\n+    } while (readIfMore());\n+    return columns.toArray(new String[0]);\n+  }\n+\n+  private Column[] parseColumnList(Table table) {\n+    ArrayList<Column> columns = New.arrayList();\n+    HashSet<Column> set = new HashSet<>();\n+    if (!readIf(\")\")) {\n+      do {\n+        Column column = parseColumn(table);\n+        if (!set.add(column)) {\n+          throw DbException.get(ErrorCode.DUPLICATE_COLUMN_NAME_1,\n+              column.getSQL());\n+        }\n+        columns.add(column);\n+      } while (readIfMore());\n+    }\n+    return columns.toArray(new Column[0]);\n+  }\n+\n+  private Column parseColumn(Table table) {\n+    String id = readColumnIdentifier();\n+    if (database.getSettings().rowId && Column.ROWID.equals(id)) {\n+      return table.getRowIdColumn();\n+    }\n+    return table.getColumn(id);\n+  }\n+\n+  private boolean readIfMore() {\n+    if (readIf(\",\")) {\n+      return !readIf(\")\");\n+    }\n+    read(\")\");\n+    return false;\n+  }\n+\n+  private Prepared parseHelp() {\n+    StringBuilder buff = new StringBuilder(\n+        \"SELECT * FROM INFORMATION_SCHEMA.HELP\");\n+    int i = 0;\n+    ArrayList<Value> paramValues = New.arrayList();\n+    while (currentTokenType != END) {\n+      String s = currentToken;\n+      read();\n+      if (i == 0) {\n+        buff.append(\" WHERE \");\n+      } else {\n+        buff.append(\" AND \");\n+      }\n+      i++;\n+      buff.append(\"UPPER(TOPIC) LIKE ?\");\n+      paramValues.add(ValueString.get(\"%\" + s + \"%\"));\n+    }\n+    return prepare(session, buff.toString(), paramValues);\n+  }\n+\n+  private Prepared parseShow() {\n+    ArrayList<Value> paramValues = New.arrayList();\n+    StringBuilder buff = new StringBuilder(\"SELECT \");\n+    if (readIf(\"CLIENT_ENCODING\")) {\n+      // for PostgreSQL compatibility\n+      buff.append(\"'UNICODE' AS CLIENT_ENCODING FROM DUAL\");\n+    } else if (readIf(\"DEFAULT_TRANSACTION_ISOLATION\")) {\n+      // for PostgreSQL compatibility\n+      buff.append(\"'read committed' AS DEFAULT_TRANSACTION_ISOLATION \" +\n+          \"FROM DUAL\");\n+    } else if (readIf(\"TRANSACTION\")) {\n+      // for PostgreSQL compatibility\n+      read(\"ISOLATION\");\n+      read(\"LEVEL\");\n+      buff.append(\"'read committed' AS TRANSACTION_ISOLATION \" +\n+          \"FROM DUAL\");\n+    } else if (readIf(\"DATESTYLE\")) {\n+      // for PostgreSQL compatibility\n+      buff.append(\"'ISO' AS DATESTYLE FROM DUAL\");\n+    } else if (readIf(\"SERVER_VERSION\")) {\n+      // for PostgreSQL compatibility\n+      buff.append(\"'8.1.4' AS SERVER_VERSION FROM DUAL\");\n+    } else if (readIf(\"SERVER_ENCODING\")) {\n+      // for PostgreSQL compatibility\n+      buff.append(\"'UTF8' AS SERVER_ENCODING FROM DUAL\");\n+    } else if (readIf(\"TABLES\")) {\n+      // for MySQL compatibility\n+      String schema = Constants.SCHEMA_MAIN;\n+      if (readIf(\"FROM\")) {\n+        schema = readUniqueIdentifier();\n+      }\n+      buff.append(\"TABLE_NAME, TABLE_SCHEMA FROM \"\n+          + \"INFORMATION_SCHEMA.TABLES \"\n+          + \"WHERE TABLE_SCHEMA=? ORDER BY TABLE_NAME\");\n+      paramValues.add(ValueString.get(schema));\n+    } else if (readIf(\"COLUMNS\")) {\n+      // for MySQL compatibility\n+      read(\"FROM\");\n+      String tableName = readIdentifierWithSchema();\n+      String schemaName = getSchema().getName();\n+      paramValues.add(ValueString.get(tableName));\n+      if (readIf(\"FROM\")) {\n+        schemaName = readUniqueIdentifier();\n+      }\n+      buff.append(\"C.COLUMN_NAME FIELD, \"\n+          + \"C.TYPE_NAME || '(' || C.NUMERIC_PRECISION || ')' TYPE, \"\n+          + \"C.IS_NULLABLE \\\"NULL\\\", \"\n+          + \"CASE (SELECT MAX(I.INDEX_TYPE_NAME) FROM \"\n+          + \"INFORMATION_SCHEMA.INDEXES I \"\n+          + \"WHERE I.TABLE_SCHEMA=C.TABLE_SCHEMA \"\n+          + \"AND I.TABLE_NAME=C.TABLE_NAME \"\n+          + \"AND I.COLUMN_NAME=C.COLUMN_NAME)\"\n+          + \"WHEN 'PRIMARY KEY' THEN 'PRI' \"\n+          + \"WHEN 'UNIQUE INDEX' THEN 'UNI' ELSE '' END KEY, \"\n+          + \"IFNULL(COLUMN_DEFAULT, 'NULL') DEFAULT \"\n+          + \"FROM INFORMATION_SCHEMA.COLUMNS C \"\n+          + \"WHERE C.TABLE_NAME=? AND C.TABLE_SCHEMA=? \"\n+          + \"ORDER BY C.ORDINAL_POSITION\");\n+      paramValues.add(ValueString.get(schemaName));\n+    } else if (readIf(\"DATABASES\") || readIf(\"SCHEMAS\")) {\n+      // for MySQL compatibility\n+      buff.append(\"SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA\");\n+    }\n+    boolean b = session.getAllowLiterals();\n+    try {\n+      // need to temporarily enable it, in case we are in\n+      // ALLOW_LITERALS_NUMBERS mode\n+      session.setAllowLiterals(true);\n+      return prepare(session, buff.toString(), paramValues);\n+    } finally {\n+      session.setAllowLiterals(b);\n+    }\n+  }\n+\n+  private static Prepared prepare(Session s, String sql,\n+                                  ArrayList<Value> paramValues) {\n+    Prepared prep = s.prepare(sql);\n+    ArrayList<Parameter> params = prep.getParameters();\n+    if (params != null) {\n+      for (int i = 0, size = params.size(); i < size; i++) {\n+        Parameter p = params.get(i);\n+        p.setValue(paramValues.get(i));\n+      }\n+    }\n+    return prep;\n+  }\n+\n+  private boolean isSelect() {\n+    int start = lastParseIndex;\n+    while (readIf(\"(\")) {\n+      // need to read ahead, it could be a nested union:\n+      // ((select 1) union (select 1))\n+    }\n+    boolean select = isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"WITH\");\n+    parseIndex = start;\n+    read();\n+    return select;\n+  }\n+\n+\n+  private Prepared parseMerge() {\n+    Merge command = new Merge(session);\n+    currentPrepared = command;\n+    int start = lastParseIndex;\n+    read(\"INTO\");\n+    List<String> excludeIdentifiers = Arrays.asList(\"USING\", \"KEY\", \"VALUES\");\n+    TableFilter targetTableFilter =\n+        readSimpleTableFilter(0, excludeIdentifiers);\n+    command.setTargetTableFilter(targetTableFilter);\n+    Table table = command.getTargetTable();\n+\n+    if (readIf(\"USING\")) {\n+      return parseMergeUsing(command, start);\n+    }\n+    if (readIf(\"(\")) {\n+      if (isSelect()) {\n+        command.setQuery(parseSelect());\n+        read(\")\");\n+        return command;\n+      }\n+      Column[] columns = parseColumnList(table);\n+      command.setColumns(columns);\n+    }\n+    if (readIf(\"KEY\")) {\n+      read(\"(\");\n+      Column[] keys = parseColumnList(table);\n+      command.setKeys(keys);\n+    }\n+    if (readIf(\"VALUES\")) {\n+      do {\n+        ArrayList<Expression> values = New.arrayList();\n+        read(\"(\");\n+        if (!readIf(\")\")) {\n+          do {\n+            if (readIf(\"DEFAULT\")) {\n+              values.add(null);\n+            } else {\n+              values.add(readExpression());\n             }\n+          } while (readIfMore());\n         }\n-        if (c == null) {\n-            throw getSyntaxError();\n-        }\n-        setSQL(c, null, start);\n-        return c;\n-    }\n-\n-    private DbException getSyntaxError() {\n-        if (expectedList == null || expectedList.isEmpty()) {\n-            return DbException.getSyntaxError(sqlCommand, parseIndex);\n-        }\n-        StatementBuilder buff = new StatementBuilder();\n-        for (String e : expectedList) {\n-            buff.appendExceptFirst(\", \");\n-            buff.append(e);\n-        }\n-        return DbException.getSyntaxError(sqlCommand, parseIndex,\n-                buff.toString());\n+        command.addRow(values.toArray(new Expression[0]));\n+      } while (readIf(\",\"));\n+    } else {\n+      command.setQuery(parseSelect());\n     }\n+    return command;\n+  }\n \n-    private Prepared parseBackup() {\n-        BackupCommand command = new BackupCommand(session);\n-        read(\"TO\");\n-        command.setFileName(readExpression());\n-        return command;\n-    }\n+  private MergeUsing parseMergeUsing(Merge oldCommand, int start) {\n+    MergeUsing command = new MergeUsing(oldCommand);\n+    currentPrepared = command;\n \n-    private Prepared parseAnalyze() {\n-        Analyze command = new Analyze(session);\n-        if (readIf(\"TABLE\")) {\n-            Table table = readTableOrView();\n-            command.setTable(table);\n-        }\n-        if (readIf(\"SAMPLE_SIZE\")) {\n-            command.setTop(readPositiveInt());\n-        }\n-        return command;\n+    if (readIf(\"(\")) {\n+      /* a select query is supplied */\n+      if (isSelect()) {\n+        command.setQuery(parseSelect());\n+        read(\")\");\n+      }\n+      command.setQueryAlias(readFromAlias(null, Arrays.asList(\"ON\")));\n+\n+      String[] querySQLOutput = new String[] {null};\n+      List<Column> columnTemplateList =\n+          TableView.createQueryColumnTemplateList(null, command.getQuery(),\n+              querySQLOutput);\n+      TableView temporarySourceTableView = createCTEView(\n+          command.getQueryAlias(), querySQLOutput[0],\n+          columnTemplateList, false/* no recursion */,\n+          false/* do not add to session */,\n+          false /* isPersistent */,\n+          session);\n+      TableFilter sourceTableFilter = new TableFilter(session,\n+          temporarySourceTableView, command.getQueryAlias(),\n+          rightsChecked, (Select) command.getQuery(), 0, null);\n+      command.setSourceTableFilter(sourceTableFilter);\n+    } else {\n+      /* Its a table name, simulate a query by building a select query for the table */\n+      List<String> excludeIdentifiers = Arrays.asList(\"ON\");\n+      TableFilter sourceTableFilter =\n+          readSimpleTableFilter(0, excludeIdentifiers);\n+      command.setSourceTableFilter(sourceTableFilter);\n+\n+      StringBuilder buff = new StringBuilder(\"SELECT * FROM \")\n+          .append(sourceTableFilter.getTable().getName());\n+      if (sourceTableFilter.getTableAlias() != null) {\n+        buff.append(\" AS \").append(sourceTableFilter.getTableAlias());\n+      }\n+      Prepared preparedQuery =\n+          prepare(session, buff.toString(), null/*paramValues*/);\n+      command.setQuery((Select) preparedQuery);\n+\n+    }\n+    read(\"ON\");\n+    read(\"(\");\n+    Expression condition = readExpression();\n+    command.setOnCondition(condition);\n+    read(\")\");\n+\n+    if (readIfAll(\"WHEN\", \"MATCHED\", \"THEN\")) {\n+      int startMatched = lastParseIndex;\n+      if (readIf(\"UPDATE\")) {\n+        Update updateCommand = new Update(session);\n+        //currentPrepared = updateCommand;\n+        TableFilter filter = command.getTargetTableFilter();\n+        updateCommand.setTableFilter(filter);\n+        parseUpdateSetClause(updateCommand, filter, startMatched);\n+        command.setUpdateCommand(updateCommand);\n+      }\n+      startMatched = lastParseIndex;\n+      if (readIf(\"DELETE\")) {\n+        Delete deleteCommand = new Delete(session);\n+        TableFilter filter = command.getTargetTableFilter();\n+        deleteCommand.setTableFilter(filter);\n+        parseDeleteGivenTable(deleteCommand, null, startMatched);\n+        command.setDeleteCommand(deleteCommand);\n+      }\n+    }\n+    if (readIfAll(\"WHEN\", \"NOT\", \"MATCHED\", \"THEN\")) {\n+      if (readIf(\"INSERT\")) {\n+        Insert insertCommand = new Insert(session);\n+        insertCommand.setTable(command.getTargetTable());\n+        parseInsertGivenTable(insertCommand, command.getTargetTable());\n+        command.setInsertCommand(insertCommand);\n+      }\n+    }\n+\n+    setSQL(command, \"MERGE\", start);\n+\n+    // build and prepare the targetMatchQuery ready to test each rows\n+    // existence in the target table (using source row to match)\n+    StringBuilder targetMatchQuerySQL = new StringBuilder(\n+        \"SELECT _ROWID_ FROM \" + command.getTargetTable().getName());\n+    if (command.getTargetTableFilter().getTableAlias() != null) {\n+      targetMatchQuerySQL.append(\n+          \" AS \" + command.getTargetTableFilter().getTableAlias());\n+    }\n+    targetMatchQuerySQL\n+        .append(\" WHERE \").append(command.getOnCondition().getSQL());\n+    command.setTargetMatchQuery(\n+        (Select) parse(targetMatchQuerySQL.toString()));\n+\n+    return command;\n+  }\n+\n+  private Insert parseInsert() {\n+    Insert command = new Insert(session);\n+    currentPrepared = command;\n+    if (database.getMode().onDuplicateKeyUpdate && readIf(\"IGNORE\")) {\n+      command.setIgnore(true);\n+    }\n+    read(\"INTO\");\n+    Table table = readTableOrView();\n+    command.setTable(table);\n+    Insert returnedCommand = parseInsertGivenTable(command, table);\n+    if (returnedCommand != null) {\n+      return returnedCommand;\n+    }\n+    if (database.getMode().onDuplicateKeyUpdate) {\n+      if (readIf(\"ON\")) {\n+        read(\"DUPLICATE\");\n+        read(\"KEY\");\n+        read(\"UPDATE\");\n+        do {\n+          Column column = parseColumn(table);\n+          read(\"=\");\n+          Expression expression;\n+          if (readIf(\"DEFAULT\")) {\n+            expression = ValueExpression.getDefault();\n+          } else {\n+            expression = readExpression();\n+          }\n+          command.addAssignmentForDuplicate(column, expression);\n+        } while (readIf(\",\"));\n+      }\n     }\n-\n-    private TransactionCommand parseBegin() {\n-        TransactionCommand command;\n-        if (!readIf(\"WORK\")) {\n-            readIf(\"TRANSACTION\");\n-        }\n-        command = new TransactionCommand(session, CommandInterface.BEGIN);\n-        return command;\n+    if (database.getMode().isolationLevelInSelectOrInsertStatement) {\n+      parseIsolationClause();\n     }\n+    return command;\n+  }\n \n-    private TransactionCommand parseCommit() {\n-        TransactionCommand command;\n-        if (readIf(\"TRANSACTION\")) {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.COMMIT_TRANSACTION);\n-            command.setTransactionName(readUniqueIdentifier());\n-            return command;\n-        }\n-        command = new TransactionCommand(session,\n-                CommandInterface.COMMIT);\n-        readIf(\"WORK\");\n+  private Insert parseInsertGivenTable(Insert command, Table table) {\n+    Column[] columns = null;\n+    if (readIf(\"(\")) {\n+      if (isSelect()) {\n+        command.setQuery(parseSelect());\n+        read(\")\");\n         return command;\n-    }\n-\n-    private TransactionCommand parseShutdown() {\n-        int type = CommandInterface.SHUTDOWN;\n-        if (readIf(\"IMMEDIATELY\")) {\n-            type = CommandInterface.SHUTDOWN_IMMEDIATELY;\n-        } else if (readIf(\"COMPACT\")) {\n-            type = CommandInterface.SHUTDOWN_COMPACT;\n-        } else if (readIf(\"DEFRAG\")) {\n-            type = CommandInterface.SHUTDOWN_DEFRAG;\n-        } else {\n-            readIf(\"SCRIPT\");\n-        }\n-        return new TransactionCommand(session, type);\n-    }\n-\n-    private TransactionCommand parseRollback() {\n-        TransactionCommand command;\n-        if (readIf(\"TRANSACTION\")) {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.ROLLBACK_TRANSACTION);\n-            command.setTransactionName(readUniqueIdentifier());\n-            return command;\n+      }\n+      columns = parseColumnList(table);\n+      command.setColumns(columns);\n+    }\n+    if (readIf(\"DIRECT\")) {\n+      command.setInsertFromSelect(true);\n+    }\n+    if (readIf(\"SORTED\")) {\n+      command.setSortedInsertMode(true);\n+    }\n+    if (readIf(\"DEFAULT\")) {\n+      read(\"VALUES\");\n+      Expression[] expr = {};\n+      command.addRow(expr);\n+    } else if (readIf(\"VALUES\")) {\n+      read(\"(\");\n+      do {\n+        ArrayList<Expression> values = New.arrayList();\n+        if (!readIf(\")\")) {\n+          do {\n+            if (readIf(\"DEFAULT\")) {\n+              values.add(null);\n+            } else {\n+              values.add(readExpression());\n+            }\n+          } while (readIfMore());\n         }\n-        if (readIf(\"TO\")) {\n-            read(\"SAVEPOINT\");\n-            command = new TransactionCommand(session,\n-                    CommandInterface.ROLLBACK_TO_SAVEPOINT);\n-            command.setSavepointName(readUniqueIdentifier());\n+        command.addRow(values.toArray(new Expression[0]));\n+        // the following condition will allow (..),; and (..);\n+      } while (readIf(\",\") && readIf(\"(\"));\n+    } else if (readIf(\"SET\")) {\n+      if (columns != null) {\n+        throw getSyntaxError();\n+      }\n+      ArrayList<Column> columnList = New.arrayList();\n+      ArrayList<Expression> values = New.arrayList();\n+      do {\n+        columnList.add(parseColumn(table));\n+        read(\"=\");\n+        Expression expression;\n+        if (readIf(\"DEFAULT\")) {\n+          expression = ValueExpression.getDefault();\n         } else {\n-            readIf(\"WORK\");\n-            command = new TransactionCommand(session,\n-                    CommandInterface.ROLLBACK);\n-        }\n+          expression = readExpression();\n+        }\n+        values.add(expression);\n+      } while (readIf(\",\"));\n+      command.setColumns(columnList.toArray(new Column[0]));\n+      command.addRow(values.toArray(new Expression[0]));\n+    } else {\n+      command.setQuery(parseSelect());\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * MySQL compatibility. REPLACE is similar to MERGE.\n+   */\n+  private Replace parseReplace() {\n+    Replace command = new Replace(session);\n+    currentPrepared = command;\n+    read(\"INTO\");\n+    Table table = readTableOrView();\n+    command.setTable(table);\n+    if (readIf(\"(\")) {\n+      if (isSelect()) {\n+        command.setQuery(parseSelect());\n+        read(\")\");\n         return command;\n+      }\n+      Column[] columns = parseColumnList(table);\n+      command.setColumns(columns);\n     }\n-\n-    private Prepared parsePrepare() {\n-        if (readIf(\"COMMIT\")) {\n-            TransactionCommand command = new TransactionCommand(session,\n-                    CommandInterface.PREPARE_COMMIT);\n-            command.setTransactionName(readUniqueIdentifier());\n-            return command;\n-        }\n-        String procedureName = readAliasIdentifier();\n-        if (readIf(\"(\")) {\n-            ArrayList<Column> list = New.arrayList();\n-            for (int i = 0;; i++) {\n-                Column column = parseColumnForTable(\"C\" + i, true);\n-                list.add(column);\n-                if (readIf(\")\")) {\n-                    break;\n-                }\n-                read(\",\");\n+    if (readIf(\"VALUES\")) {\n+      do {\n+        ArrayList<Expression> values = New.arrayList();\n+        read(\"(\");\n+        if (!readIf(\")\")) {\n+          do {\n+            if (readIf(\"DEFAULT\")) {\n+              values.add(null);\n+            } else {\n+              values.add(readExpression());\n             }\n+          } while (readIfMore());\n         }\n-        read(\"AS\");\n-        Prepared prep = parsePrepared();\n-        PrepareProcedure command = new PrepareProcedure(session);\n-        command.setProcedureName(procedureName);\n-        command.setPrepared(prep);\n-        return command;\n-    }\n-\n-    private TransactionCommand parseSavepoint() {\n-        TransactionCommand command = new TransactionCommand(session,\n-                CommandInterface.SAVEPOINT);\n-        command.setSavepointName(readUniqueIdentifier());\n-        return command;\n-    }\n-\n-    private Prepared parseReleaseSavepoint() {\n-        Prepared command = new NoOperation(session);\n-        readIf(\"SAVEPOINT\");\n-        readUniqueIdentifier();\n-        return command;\n+        command.addRow(values.toArray(new Expression[0]));\n+      } while (readIf(\",\"));\n+    } else {\n+      command.setQuery(parseSelect());\n     }\n+    return command;\n+  }\n \n-    private Schema findSchema(String schemaName) {\n-        if (schemaName == null) {\n-            return null;\n+  private TableFilter readTableFilter() {\n+    Table table;\n+    String alias = null;\n+    if (readIf(\"(\")) {\n+      if (isSelect()) {\n+        Query query = parseSelectUnion();\n+        read(\")\");\n+        query.setParameterList(new ArrayList<>(parameters));\n+        query.init();\n+        Session s;\n+        if (createView != null) {\n+          s = database.getSystemSession();\n+        } else {\n+          s = session;\n+        }\n+        alias = session.getNextSystemIdentifier(sqlCommand);\n+        table = TableView.createTempView(s, session.getUser(), alias,\n+            query, currentSelect);\n+      } else {\n+        TableFilter top;\n+        top = readTableFilter();\n+        top = readJoin(top);\n+        read(\")\");\n+        alias = readFromAlias(null);\n+        if (alias != null) {\n+          top.setAlias(alias);\n         }\n-        Schema schema = database.findSchema(schemaName);\n-        if (schema == null) {\n-            if (equalsToken(\"SESSION\", schemaName)) {\n-                // for local temporary tables\n-                schema = database.getSchema(session.getCurrentSchemaName());\n-            } else if (database.getMode().sysDummy1 &&\n-                    \"SYSIBM\".equals(schemaName)) {\n-                // IBM DB2 and Apache Derby compatibility: SYSIBM.SYSDUMMY1\n-                schema = database.getSchema(session.getCurrentSchemaName());\n-            }\n+        return top;\n+      }\n+    } else if (readIf(\"VALUES\")) {\n+      table = parseValuesTable(0).getTable();\n+    } else {\n+      String tableName = readIdentifierWithSchema(null);\n+      Schema schema = getSchema();\n+      boolean foundLeftBracket = readIf(\"(\");\n+      if (foundLeftBracket && readIf(\"INDEX\")) {\n+        // Sybase compatibility with\n+        // \"select * from test (index table1_index)\"\n+        readIdentifierWithSchema(null);\n+        read(\")\");\n+        foundLeftBracket = false;\n+      }\n+      if (foundLeftBracket) {\n+        Schema mainSchema = database.getSchema(Constants.SCHEMA_MAIN);\n+        if (equalsToken(tableName, RangeTable.NAME)\n+            || equalsToken(tableName, RangeTable.ALIAS)) {\n+          Expression min = readExpression();\n+          read(\",\");\n+          Expression max = readExpression();\n+          if (readIf(\",\")) {\n+            Expression step = readExpression();\n+            read(\")\");\n+            table = new RangeTable(mainSchema, min, max, step,\n+                false);\n+          } else {\n+            read(\")\");\n+            table = new RangeTable(mainSchema, min, max, false);\n+          }\n+        } else {\n+          Expression expr = readFunction(schema, tableName);\n+          if (!(expr instanceof FunctionCall)) {\n+            throw getSyntaxError();\n+          }\n+          FunctionCall call = (FunctionCall) expr;\n+          if (!call.isDeterministic()) {\n+            recompileAlways = true;\n+          }\n+          table = new FunctionTable(mainSchema, session, expr, call);\n+        }\n+      } else if (equalsToken(\"DUAL\", tableName)) {\n+        table = getDualTable(false);\n+      } else if (database.getMode().sysDummy1 &&\n+          equalsToken(\"SYSDUMMY1\", tableName)) {\n+        table = getDualTable(false);\n+      } else {\n+        table = readTableOrView(tableName);\n+      }\n+    }\n+    IndexHints indexHints = null;\n+    // for backward compatibility, handle case where USE is a table alias\n+    if (readIf(\"USE\")) {\n+      if (readIf(\"INDEX\")) {\n+        indexHints = parseIndexHints(table);\n+      } else {\n+        alias = \"USE\";\n+      }\n+    } else {\n+      alias = readFromAlias(alias);\n+      if (alias != null) {\n+        // if alias present, a second chance to parse index hints\n+        if (readIf(\"USE\")) {\n+          read(\"INDEX\");\n+          indexHints = parseIndexHints(table);\n         }\n-        return schema;\n+      }\n     }\n-\n-    private Schema getSchema(String schemaName) {\n-        if (schemaName == null) {\n-            return null;\n-        }\n-        Schema schema = findSchema(schemaName);\n-        if (schema == null) {\n-            throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schemaName);\n-        }\n-        return schema;\n+    // inherit alias for CTE as views from table name\n+    if (table.isView() && table.isTableExpression() && alias == null) {\n+      alias = table.getName();\n     }\n+    return new TableFilter(session, table, alias, rightsChecked,\n+        currentSelect, orderInFrom++, indexHints);\n+  }\n \n-    private Schema getSchema() {\n-        return getSchema(schemaName);\n+  private IndexHints parseIndexHints(Table table) {\n+    if (table == null) {\n+      throw getSyntaxError();\n     }\n-    /*\n-     * Gets the current schema for scenarios that need a guaranteed, non-null schema object.\n-     *\n-     * This routine is solely here\n-     * because of the function readIdentifierWithSchema(String defaultSchemaName) - which\n-     * is often called with a null parameter (defaultSchemaName) - then 6 lines into the function\n-     * that routine nullifies the state field schemaName - which I believe is a bug.\n-     *\n-     * There are about 7 places where \"readIdentifierWithSchema(null)\" is called in this file.\n-     *\n-     * In other words when is it legal to not have an active schema defined by schemaName ?\n-     * I don't think it's ever a valid case. I don't understand when that would be allowed.\n-     * I spent a long time trying to figure this out.\n-     * As another proof of this point, the command \"SET SCHEMA=NULL\" is not a valid command.\n-     *\n-     * I did try to fix this in readIdentifierWithSchema(String defaultSchemaName)\n-     * - but every fix I tried cascaded so many unit test errors - so\n-     * I gave up. I think this needs a bigger effort to fix his, as part of bigger, dedicated story.\n-     *\n-     */\n-    private Schema getSchemaWithDefault() {\n-        if (schemaName == null) {\n-            schemaName = session.getCurrentSchemaName();\n+    read(\"(\");\n+    LinkedHashSet<String> indexNames = new LinkedHashSet<>();\n+    if (!readIf(\")\")) {\n+      do {\n+        String indexName = readIdentifierWithSchema();\n+        Index index = table.getIndex(indexName);\n+        indexNames.add(index.getName());\n+      } while (readIf(\",\"));\n+      read(\")\");\n+    }\n+    return IndexHints.createUseIndexHints(indexNames);\n+  }\n+\n+  private String readFromAlias(String alias, List<String> excludeIdentifiers) {\n+    if (readIf(\"AS\")) {\n+      alias = readAliasIdentifier();\n+    } else if (currentTokenType == IDENTIFIER &&\n+        !isTokenInList(excludeIdentifiers)) {\n+      alias = readAliasIdentifier();\n+    }\n+    return alias;\n+  }\n+\n+  private String readFromAlias(String alias) {\n+    // left and right are not keywords (because they are functions as\n+    // well)\n+    List<String> excludeIdentifiers = Arrays.asList(\"LEFT\", \"RIGHT\", \"FULL\");\n+    return readFromAlias(alias, excludeIdentifiers);\n+  }\n+\n+  private Prepared parseTruncate() {\n+    read(\"TABLE\");\n+    Table table = readTableOrView();\n+    TruncateTable command = new TruncateTable(session);\n+    command.setTable(table);\n+    return command;\n+  }\n+\n+  private boolean readIfExists(boolean ifExists) {\n+    if (readIf(\"IF\")) {\n+      read(\"EXISTS\");\n+      ifExists = true;\n+    }\n+    return ifExists;\n+  }\n+\n+  private Prepared parseComment() {\n+    int type = 0;\n+    read(\"ON\");\n+    boolean column = false;\n+    if (readIf(\"TABLE\") || readIf(\"VIEW\")) {\n+      type = DbObject.TABLE_OR_VIEW;\n+    } else if (readIf(\"COLUMN\")) {\n+      column = true;\n+      type = DbObject.TABLE_OR_VIEW;\n+    } else if (readIf(\"CONSTANT\")) {\n+      type = DbObject.CONSTANT;\n+    } else if (readIf(\"CONSTRAINT\")) {\n+      type = DbObject.CONSTRAINT;\n+    } else if (readIf(\"ALIAS\")) {\n+      type = DbObject.FUNCTION_ALIAS;\n+    } else if (readIf(\"INDEX\")) {\n+      type = DbObject.INDEX;\n+    } else if (readIf(\"ROLE\")) {\n+      type = DbObject.ROLE;\n+    } else if (readIf(\"SCHEMA\")) {\n+      type = DbObject.SCHEMA;\n+    } else if (readIf(\"SEQUENCE\")) {\n+      type = DbObject.SEQUENCE;\n+    } else if (readIf(\"TRIGGER\")) {\n+      type = DbObject.TRIGGER;\n+    } else if (readIf(\"USER\")) {\n+      type = DbObject.USER;\n+    } else if (readIf(\"DOMAIN\")) {\n+      type = DbObject.USER_DATATYPE;\n+    } else {\n+      throw getSyntaxError();\n+    }\n+    SetComment command = new SetComment(session);\n+    String objectName;\n+    if (column) {\n+      // can't use readIdentifierWithSchema() because\n+      // it would not read schema.table.column correctly\n+      // if the db name is equal to the schema name\n+      ArrayList<String> list = New.arrayList();\n+      do {\n+        list.add(readUniqueIdentifier());\n+      } while (readIf(\".\"));\n+      schemaName = session.getCurrentSchemaName();\n+      if (list.size() == 4) {\n+        if (!equalsToken(database.getShortName(), list.remove(0))) {\n+          throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+              \"database name\");\n+        }\n+      }\n+      if (list.size() == 3) {\n+        schemaName = list.remove(0);\n+      }\n+      if (list.size() != 2) {\n+        throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+            \"table.column\");\n+      }\n+      objectName = list.get(0);\n+      command.setColumn(true);\n+      command.setColumnName(list.get(1));\n+    } else {\n+      objectName = readIdentifierWithSchema();\n+    }\n+    command.setSchemaName(schemaName);\n+    command.setObjectName(objectName);\n+    command.setObjectType(type);\n+    read(\"IS\");\n+    command.setCommentExpression(readExpression());\n+    return command;\n+  }\n+\n+  private Prepared parseDrop() {\n+    if (readIf(\"TABLE\")) {\n+      boolean ifExists = readIfExists(false);\n+      String tableName = readIdentifierWithSchema();\n+      DropTable command = new DropTable(session, getSchema());\n+      command.setTableName(tableName);\n+      while (readIf(\",\")) {\n+        tableName = readIdentifierWithSchema();\n+        DropTable next = new DropTable(session, getSchema());\n+        next.setTableName(tableName);\n+        command.addNextDropTable(next);\n+      }\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      if (readIf(\"CASCADE\")) {\n+        command.setDropAction(ConstraintActionType.CASCADE);\n+        readIf(\"CONSTRAINTS\");\n+      } else if (readIf(\"RESTRICT\")) {\n+        command.setDropAction(ConstraintActionType.RESTRICT);\n+      } else if (readIf(\"IGNORE\")) {\n+        command.setDropAction(ConstraintActionType.SET_DEFAULT);\n+      }\n+      return command;\n+    } else if (readIf(\"INDEX\")) {\n+      boolean ifExists = readIfExists(false);\n+      String indexName = readIdentifierWithSchema();\n+      DropIndex command = new DropIndex(session, getSchema());\n+      command.setIndexName(indexName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"USER\")) {\n+      boolean ifExists = readIfExists(false);\n+      DropUser command = new DropUser(session);\n+      command.setUserName(readUniqueIdentifier());\n+      ifExists = readIfExists(ifExists);\n+      readIf(\"CASCADE\");\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"SEQUENCE\")) {\n+      boolean ifExists = readIfExists(false);\n+      String sequenceName = readIdentifierWithSchema();\n+      DropSequence command = new DropSequence(session, getSchema());\n+      command.setSequenceName(sequenceName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"CONSTANT\")) {\n+      boolean ifExists = readIfExists(false);\n+      String constantName = readIdentifierWithSchema();\n+      DropConstant command = new DropConstant(session, getSchema());\n+      command.setConstantName(constantName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"TRIGGER\")) {\n+      boolean ifExists = readIfExists(false);\n+      String triggerName = readIdentifierWithSchema();\n+      DropTrigger command = new DropTrigger(session, getSchema());\n+      command.setTriggerName(triggerName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"VIEW\")) {\n+      boolean ifExists = readIfExists(false);\n+      String viewName = readIdentifierWithSchema();\n+      DropView command = new DropView(session, getSchema());\n+      command.setViewName(viewName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      ConstraintActionType dropAction = parseCascadeOrRestrict();\n+      if (dropAction != null) {\n+        command.setDropAction(dropAction);\n+      }\n+      return command;\n+    } else if (readIf(\"ROLE\")) {\n+      boolean ifExists = readIfExists(false);\n+      DropRole command = new DropRole(session);\n+      command.setRoleName(readUniqueIdentifier());\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"ALIAS\")) {\n+      boolean ifExists = readIfExists(false);\n+      String aliasName = readIdentifierWithSchema();\n+      DropFunctionAlias command = new DropFunctionAlias(session,\n+          getSchema());\n+      command.setAliasName(aliasName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"SCHEMA\")) {\n+      boolean ifExists = readIfExists(false);\n+      DropSchema command = new DropSchema(session);\n+      command.setSchemaName(readUniqueIdentifier());\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    } else if (readIf(\"ALL\")) {\n+      read(\"OBJECTS\");\n+      DropDatabase command = new DropDatabase(session);\n+      command.setDropAllObjects(true);\n+      if (readIf(\"DELETE\")) {\n+        read(\"FILES\");\n+        command.setDeleteFiles(true);\n+      }\n+      return command;\n+    } else if (readIf(\"DOMAIN\")) {\n+      return parseDropUserDataType();\n+    } else if (readIf(\"TYPE\")) {\n+      return parseDropUserDataType();\n+    } else if (readIf(\"DATATYPE\")) {\n+      return parseDropUserDataType();\n+    } else if (readIf(\"AGGREGATE\")) {\n+      return parseDropAggregate();\n+    } else if (readIf(\"SYNONYM\")) {\n+      boolean ifExists = readIfExists(false);\n+      String synonymName = readIdentifierWithSchema();\n+      DropSynonym command = new DropSynonym(session, getSchema());\n+      command.setSynonymName(synonymName);\n+      ifExists = readIfExists(ifExists);\n+      command.setIfExists(ifExists);\n+      return command;\n+    }\n+    throw getSyntaxError();\n+  }\n+\n+  private DropUserDataType parseDropUserDataType() {\n+    boolean ifExists = readIfExists(false);\n+    DropUserDataType command = new DropUserDataType(session);\n+    command.setTypeName(readUniqueIdentifier());\n+    ifExists = readIfExists(ifExists);\n+    command.setIfExists(ifExists);\n+    return command;\n+  }\n+\n+  private DropAggregate parseDropAggregate() {\n+    boolean ifExists = readIfExists(false);\n+    DropAggregate command = new DropAggregate(session);\n+    command.setName(readUniqueIdentifier());\n+    ifExists = readIfExists(ifExists);\n+    command.setIfExists(ifExists);\n+    return command;\n+  }\n+\n+  private TableFilter readJoin(TableFilter top) {\n+    TableFilter last = top;\n+    while (true) {\n+      TableFilter join;\n+      if (readIf(\"RIGHT\")) {\n+        readIf(\"OUTER\");\n+        read(\"JOIN\");\n+        // the right hand side is the 'inner' table usually\n+        join = readTableFilter();\n+        join = readJoin(join);\n+        Expression on = null;\n+        if (readIf(\"ON\")) {\n+          on = readExpression();\n+        }\n+        addJoin(join, top, true, on);\n+        top = join;\n+      } else if (readIf(\"LEFT\")) {\n+        readIf(\"OUTER\");\n+        read(\"JOIN\");\n+        join = readTableFilter();\n+        join = readJoin(join);\n+        Expression on = null;\n+        if (readIf(\"ON\")) {\n+          on = readExpression();\n+        }\n+        addJoin(top, join, true, on);\n+      } else if (readIf(\"FULL\")) {\n+        throw getSyntaxError();\n+      } else if (readIf(\"INNER\")) {\n+        read(\"JOIN\");\n+        join = readTableFilter();\n+        top = readJoin(top);\n+        Expression on = null;\n+        if (readIf(\"ON\")) {\n+          on = readExpression();\n         }\n-        return getSchema(schemaName);\n-    }\n-\n-    private Column readTableColumn(TableFilter filter) {\n-        String tableAlias = null;\n-        String columnName = readColumnIdentifier();\n-        if (readIf(\".\")) {\n-            tableAlias = columnName;\n-            columnName = readColumnIdentifier();\n-            if (readIf(\".\")) {\n-                String schema = tableAlias;\n-                tableAlias = columnName;\n-                columnName = readColumnIdentifier();\n-                if (readIf(\".\")) {\n-                    String catalogName = schema;\n-                    schema = tableAlias;\n-                    tableAlias = columnName;\n-                    columnName = readColumnIdentifier();\n-                    if (!equalsToken(catalogName, database.getShortName())) {\n-                        throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n-                                catalogName);\n-                    }\n-                }\n-                if (!equalsToken(schema, filter.getTable().getSchema()\n-                        .getName())) {\n-                    throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schema);\n-                }\n-            }\n-            if (!equalsToken(tableAlias, filter.getTableAlias())) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1,\n-                        tableAlias);\n-            }\n+        addJoin(top, join, false, on);\n+      } else if (readIf(\"JOIN\")) {\n+        join = readTableFilter();\n+        top = readJoin(top);\n+        Expression on = null;\n+        if (readIf(\"ON\")) {\n+          on = readExpression();\n+        }\n+        addJoin(top, join, false, on);\n+      } else if (readIf(\"CROSS\")) {\n+        read(\"JOIN\");\n+        join = readTableFilter();\n+        addJoin(top, join, false, null);\n+      } else if (readIf(\"NATURAL\")) {\n+        read(\"JOIN\");\n+        join = readTableFilter();\n+        Column[] tableCols = last.getTable().getColumns();\n+        Column[] joinCols = join.getTable().getColumns();\n+        String tableSchema = last.getTable().getSchema().getName();\n+        String joinSchema = join.getTable().getSchema().getName();\n+        Expression on = null;\n+        for (Column tc : tableCols) {\n+          String tableColumnName = tc.getName();\n+          for (Column c : joinCols) {\n+            String joinColumnName = c.getName();\n+            if (equalsToken(tableColumnName, joinColumnName)) {\n+              join.addNaturalJoinColumn(c);\n+              Expression tableExpr = new ExpressionColumn(\n+                  database, tableSchema,\n+                  last.getTableAlias(), tableColumnName);\n+              Expression joinExpr = new ExpressionColumn(\n+                  database, joinSchema, join.getTableAlias(),\n+                  joinColumnName);\n+              Expression equal = new Comparison(session,\n+                  Comparison.EQUAL, tableExpr, joinExpr);\n+              if (on == null) {\n+                on = equal;\n+              } else {\n+                on = new ConditionAndOr(ConditionAndOr.AND, on,\n+                    equal);\n+              }\n+            }\n+          }\n+        }\n+        addJoin(top, join, false, on);\n+      } else {\n+        break;\n+      }\n+      last = join;\n+    }\n+    return top;\n+  }\n+\n+  /**\n+   * Add one join to another. This method creates nested join between them if\n+   * required.\n+   *\n+   * @param top   parent join\n+   * @param join  child join\n+   * @param outer if child join is an outer join\n+   * @param on    the join condition\n+   * @see TableFilter#addJoin(TableFilter, boolean, Expression)\n+   */\n+  private void addJoin(TableFilter top, TableFilter join, boolean outer,\n+                       Expression on) {\n+    if (join.getJoin() != null) {\n+      String joinTable = Constants.PREFIX_JOIN + parseIndex;\n+      TableFilter n = new TableFilter(session, getDualTable(true),\n+          joinTable, rightsChecked, currentSelect, join.getOrderInFrom(),\n+          null);\n+      n.setNestedJoin(join);\n+      join = n;\n+    }\n+    top.addJoin(join, outer, on);\n+  }\n+\n+  private Prepared parseExecute() {\n+    ExecuteProcedure command = new ExecuteProcedure(session);\n+    String procedureName = readAliasIdentifier();\n+    Procedure p = session.getProcedure(procedureName);\n+    if (p == null) {\n+      throw DbException.get(ErrorCode.FUNCTION_ALIAS_NOT_FOUND_1,\n+          procedureName);\n+    }\n+    command.setProcedure(p);\n+    if (readIf(\"(\")) {\n+      for (int i = 0; ; i++) {\n+        command.setExpression(i, readExpression());\n+        if (readIf(\")\")) {\n+          break;\n         }\n-        if (database.getSettings().rowId) {\n-            if (Column.ROWID.equals(columnName)) {\n-                return filter.getRowIdColumn();\n-            }\n+        read(\",\");\n+      }\n+    }\n+    return command;\n+  }\n+\n+  private DeallocateProcedure parseDeallocate() {\n+    readIf(\"PLAN\");\n+    String procedureName = readAliasIdentifier();\n+    DeallocateProcedure command = new DeallocateProcedure(session);\n+    command.setProcedureName(procedureName);\n+    return command;\n+  }\n+\n+  private Explain parseExplain() {\n+    Explain command = new Explain(session);\n+    if (readIf(\"ANALYZE\")) {\n+      command.setExecuteCommand(true);\n+    } else {\n+      if (readIf(\"PLAN\")) {\n+        readIf(\"FOR\");\n+      }\n+    }\n+    if (isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"(\") ||\n+        isToken(\"WITH\")) {\n+      Query query = parseSelect();\n+      query.setNeverLazy(true);\n+      command.setCommand(query);\n+    } else if (readIf(\"DELETE\")) {\n+      command.setCommand(parseDelete());\n+    } else if (readIf(\"UPDATE\")) {\n+      command.setCommand(parseUpdate());\n+    } else if (readIf(\"INSERT\")) {\n+      command.setCommand(parseInsert());\n+    } else if (readIf(\"MERGE\")) {\n+      command.setCommand(parseMerge());\n+    } else {\n+      throw getSyntaxError();\n+    }\n+    return command;\n+  }\n+\n+  private Query parseSelect() {\n+    Query command = null;\n+    int paramIndex = parameters.size();\n+    command = parseSelectUnion();\n+    ArrayList<Parameter> params = New.arrayList();\n+    for (int i = paramIndex, size = parameters.size(); i < size; i++) {\n+      params.add(parameters.get(i));\n+    }\n+    command.setParameterList(params);\n+    command.init();\n+    return command;\n+  }\n+\n+  private Prepared parseWithStatementOrQuery() {\n+    int paramIndex = parameters.size();\n+    Prepared command = parseWith();\n+    ArrayList<Parameter> params = New.arrayList();\n+    for (int i = paramIndex, size = parameters.size(); i < size; i++) {\n+      params.add(parameters.get(i));\n+    }\n+    command.setParameterList(params);\n+    if (command instanceof Query) {\n+      Query query = (Query) command;\n+      query.init();\n+    }\n+    return command;\n+  }\n+\n+  private Query parseSelectUnion() {\n+    int start = lastParseIndex;\n+    Query command = parseSelectSub();\n+    return parseSelectUnionExtension(command, start, false);\n+  }\n+\n+  private Query parseSelectUnionExtension(Query command, int start,\n+                                          boolean unionOnly) {\n+    while (true) {\n+      if (readIf(\"UNION\")) {\n+        SelectUnion union = new SelectUnion(session, command);\n+        if (readIf(\"ALL\")) {\n+          union.setUnionType(SelectUnion.UnionType.UNION_ALL);\n+        } else {\n+          readIf(\"DISTINCT\");\n+          union.setUnionType(SelectUnion.UnionType.UNION);\n+        }\n+        union.setRight(parseSelectSub());\n+        command = union;\n+      } else if (readIf(\"MINUS\") || readIf(\"EXCEPT\")) {\n+        SelectUnion union = new SelectUnion(session, command);\n+        union.setUnionType(SelectUnion.UnionType.EXCEPT);\n+        union.setRight(parseSelectSub());\n+        command = union;\n+      } else if (readIf(\"INTERSECT\")) {\n+        SelectUnion union = new SelectUnion(session, command);\n+        union.setUnionType(SelectUnion.UnionType.INTERSECT);\n+        union.setRight(parseSelectSub());\n+        command = union;\n+      } else {\n+        break;\n+      }\n+    }\n+    if (!unionOnly) {\n+      parseEndOfQuery(command);\n+    }\n+    setSQL(command, null, start);\n+    return command;\n+  }\n+\n+  private void parseEndOfQuery(Query command) {\n+    if (readIf(\"ORDER\")) {\n+      read(\"BY\");\n+      Select oldSelect = currentSelect;\n+      if (command instanceof Select) {\n+        currentSelect = (Select) command;\n+      }\n+      ArrayList<SelectOrderBy> orderList = New.arrayList();\n+      do {\n+        boolean canBeNumber = true;\n+        if (readIf(\"=\")) {\n+          canBeNumber = false;\n+        }\n+        SelectOrderBy order = new SelectOrderBy();\n+        Expression expr = readExpression();\n+        if (canBeNumber && expr instanceof ValueExpression &&\n+            expr.getType() == Value.INT) {\n+          order.columnIndexExpr = expr;\n+        } else if (expr instanceof Parameter) {\n+          recompileAlways = true;\n+          order.columnIndexExpr = expr;\n+        } else {\n+          order.expression = expr;\n         }\n-        return filter.getTable().getColumn(columnName);\n-    }\n-\n-    private Update parseUpdate() {\n-        Update command = new Update(session);\n-        currentPrepared = command;\n-        int start = lastParseIndex;\n-        TableFilter filter = readSimpleTableFilter(0, null);\n-        command.setTableFilter(filter);\n-        parseUpdateSetClause(command, filter, start);\n-        return command;\n-    }\n-\n-    private void parseUpdateSetClause(Update command, TableFilter filter, int start) {\n-        read(\"SET\");\n-        if (readIf(\"(\")) {\n-            ArrayList<Column> columns = New.arrayList();\n+        if (readIf(\"DESC\")) {\n+          order.descending = true;\n+        } else {\n+          readIf(\"ASC\");\n+        }\n+        if (readIf(\"NULLS\")) {\n+          if (readIf(\"FIRST\")) {\n+            order.nullsFirst = true;\n+          } else {\n+            read(\"LAST\");\n+            order.nullsLast = true;\n+          }\n+        }\n+        orderList.add(order);\n+      } while (readIf(\",\"));\n+      command.setOrder(orderList);\n+      currentSelect = oldSelect;\n+    }\n+    if (database.getMode().supportOffsetFetch) {\n+      // make sure aggregate functions will not work here\n+      Select temp = currentSelect;\n+      currentSelect = null;\n+\n+      // http://sqlpro.developpez.com/SQL2008/\n+      if (readIf(\"OFFSET\")) {\n+        command.setOffset(readExpression().optimize(session));\n+        if (!readIf(\"ROW\")) {\n+          readIf(\"ROWS\");\n+        }\n+      }\n+      if (readIf(\"FETCH\")) {\n+        if (!readIf(\"FIRST\")) {\n+          read(\"NEXT\");\n+        }\n+        if (readIf(\"ROW\")) {\n+          command.setLimit(ValueExpression.get(ValueInt.get(1)));\n+        } else {\n+          Expression limit = readExpression().optimize(session);\n+          command.setLimit(limit);\n+          if (!readIf(\"ROW\")) {\n+            read(\"ROWS\");\n+          }\n+        }\n+        read(\"ONLY\");\n+      }\n+\n+      currentSelect = temp;\n+    }\n+    if (readIf(\"LIMIT\")) {\n+      Select temp = currentSelect;\n+      // make sure aggregate functions will not work here\n+      currentSelect = null;\n+      Expression limit = readExpression().optimize(session);\n+      command.setLimit(limit);\n+      if (readIf(\"OFFSET\")) {\n+        Expression offset = readExpression().optimize(session);\n+        command.setOffset(offset);\n+      } else if (readIf(\",\")) {\n+        // MySQL: [offset, ] rowcount\n+        Expression offset = limit;\n+        limit = readExpression().optimize(session);\n+        command.setOffset(offset);\n+        command.setLimit(limit);\n+      }\n+      if (readIf(\"SAMPLE_SIZE\")) {\n+        Expression sampleSize = readExpression().optimize(session);\n+        command.setSampleSize(sampleSize);\n+      }\n+      currentSelect = temp;\n+    }\n+    if (readIf(\"FOR\")) {\n+      if (readIf(\"UPDATE\")) {\n+        if (readIf(\"OF\")) {\n+          do {\n+            readIdentifierWithSchema();\n+          } while (readIf(\",\"));\n+        } else if (readIf(\"NOWAIT\")) {\n+          // TODO parser: select for update nowait: should not wait\n+        }\n+        command.setForUpdate(true);\n+      } else if (readIf(\"READ\") || readIf(\"FETCH\")) {\n+        read(\"ONLY\");\n+      }\n+    }\n+    if (database.getMode().isolationLevelInSelectOrInsertStatement) {\n+      parseIsolationClause();\n+    }\n+  }\n+\n+  /**\n+   * DB2 isolation clause\n+   */\n+  private void parseIsolationClause() {\n+    if (readIf(\"WITH\")) {\n+      if (readIf(\"RR\") || readIf(\"RS\")) {\n+        // concurrent-access-resolution clause\n+        if (readIf(\"USE\")) {\n+          read(\"AND\");\n+          read(\"KEEP\");\n+          if (readIf(\"SHARE\") || readIf(\"UPDATE\") ||\n+              readIf(\"EXCLUSIVE\")) {\n+            // ignore\n+          }\n+          read(\"LOCKS\");\n+        }\n+      } else if (readIf(\"CS\") || readIf(\"UR\")) {\n+        // ignore\n+      }\n+    }\n+  }\n+\n+  private Query parseSelectSub() {\n+    if (readIf(\"(\")) {\n+      Query command = parseSelectUnion();\n+      read(\")\");\n+      return command;\n+    }\n+    if (readIf(\"WITH\")) {\n+      Query query = null;\n+      try {\n+        query = (Query) parseWith();\n+      } catch (ClassCastException e) {\n+        throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n+            \"WITH statement supports only SELECT (query) in this context\");\n+      }\n+      // recursive can not be lazy\n+      query.setNeverLazy(true);\n+      return query;\n+    }\n+    Select select = parseSelectSimple();\n+    return select;\n+  }\n+\n+  private void parseSelectSimpleFromPart(Select command) {\n+    do {\n+      TableFilter filter = readTableFilter();\n+      parseJoinTableFilter(filter, command);\n+    } while (readIf(\",\"));\n+\n+    // Parser can reorder joined table filters, need to explicitly sort them\n+    // to get the order as it was in the original query.\n+    if (session.isForceJoinOrder()) {\n+      sortTableFilters(command.getTopFilters());\n+    }\n+  }\n+\n+  private static void sortTableFilters(ArrayList<TableFilter> filters) {\n+    if (filters.size() < 2) {\n+      return;\n+    }\n+    // Most probably we are already sorted correctly.\n+    boolean sorted = true;\n+    TableFilter prev = filters.get(0);\n+    for (int i = 1; i < filters.size(); i++) {\n+      TableFilter next = filters.get(i);\n+      if (compareTableFilters(prev, next) > 0) {\n+        sorted = false;\n+        break;\n+      }\n+      prev = next;\n+    }\n+    // If not, then sort manually.\n+    if (!sorted) {\n+      Collections.sort(filters, TABLE_FILTER_COMPARATOR);\n+    }\n+  }\n+\n+  /**\n+   * Find out which of the table filters appears first in the \"from\" clause.\n+   *\n+   * @param o1 the first table filter\n+   * @param o2 the second table filter\n+   * @return -1 if o1 appears first, and 1 if o2 appears first\n+   */\n+  static int compareTableFilters(TableFilter o1, TableFilter o2) {\n+    assert o1.getOrderInFrom() != o2.getOrderInFrom();\n+    return o1.getOrderInFrom() > o2.getOrderInFrom() ? 1 : -1;\n+  }\n+\n+  private void parseJoinTableFilter(TableFilter top, final Select command) {\n+    top = readJoin(top);\n+    command.addTableFilter(top, true);\n+    boolean isOuter = false;\n+    while (true) {\n+      TableFilter n = top.getNestedJoin();\n+      if (n != null) {\n+        n.visit(new TableFilterVisitor() {\n+          @Override\n+          public void accept(TableFilter f) {\n+            command.addTableFilter(f, false);\n+          }\n+        });\n+      }\n+      TableFilter join = top.getJoin();\n+      if (join == null) {\n+        break;\n+      }\n+      isOuter = isOuter | join.isJoinOuter();\n+      if (isOuter) {\n+        command.addTableFilter(join, false);\n+      } else {\n+        // make flat so the optimizer can work better\n+        Expression on = join.getJoinCondition();\n+        if (on != null) {\n+          command.addCondition(on);\n+        }\n+        join.removeJoinCondition();\n+        top.removeJoin();\n+        command.addTableFilter(join, true);\n+      }\n+      top = join;\n+    }\n+  }\n+\n+  private void parseSelectSimpleSelectPart(Select command) {\n+    Select temp = currentSelect;\n+    // make sure aggregate functions will not work in TOP and LIMIT\n+    currentSelect = null;\n+    if (readIf(\"TOP\")) {\n+      // can't read more complex expressions here because\n+      // SELECT TOP 1 +? A FROM TEST could mean\n+      // SELECT TOP (1+?) A FROM TEST or\n+      // SELECT TOP 1 (+?) AS A FROM TEST\n+      Expression limit = readTerm().optimize(session);\n+      command.setLimit(limit);\n+    } else if (readIf(\"LIMIT\")) {\n+      Expression offset = readTerm().optimize(session);\n+      command.setOffset(offset);\n+      Expression limit = readTerm().optimize(session);\n+      command.setLimit(limit);\n+    }\n+    currentSelect = temp;\n+    if (readIf(\"DISTINCT\")) {\n+      command.setDistinct(true);\n+    } else {\n+      readIf(\"ALL\");\n+    }\n+    ArrayList<Expression> expressions = New.arrayList();\n+    do {\n+      if (readIf(\"*\")) {\n+        expressions.add(new Wildcard(null, null));\n+      } else {\n+        Expression expr = readExpression();\n+        if (readIf(\"AS\") || currentTokenType == IDENTIFIER) {\n+          String alias = readAliasIdentifier();\n+          boolean aliasColumnName = database.getSettings().aliasColumnName;\n+          aliasColumnName |= database.getMode().aliasColumnName;\n+          expr = new Alias(expr, alias, aliasColumnName);\n+        }\n+        expressions.add(expr);\n+      }\n+    } while (readIf(\",\"));\n+    command.setExpressions(expressions);\n+  }\n+\n+  private Select parseSelectSimple() {\n+    boolean fromFirst;\n+    if (readIf(\"SELECT\")) {\n+      fromFirst = false;\n+    } else if (readIf(\"FROM\")) {\n+      fromFirst = true;\n+    } else {\n+      throw getSyntaxError();\n+    }\n+    Select command = new Select(session);\n+    int start = lastParseIndex;\n+    Select oldSelect = currentSelect;\n+    currentSelect = command;\n+    currentPrepared = command;\n+    if (fromFirst) {\n+      parseSelectSimpleFromPart(command);\n+      read(\"SELECT\");\n+      parseSelectSimpleSelectPart(command);\n+    } else {\n+      parseSelectSimpleSelectPart(command);\n+      if (!readIf(\"FROM\")) {\n+        // select without FROM: convert to SELECT ... FROM\n+        // SYSTEM_RANGE(1,1)\n+        Table dual = getDualTable(false);\n+        TableFilter filter = new TableFilter(session, dual, null,\n+            rightsChecked, currentSelect, 0,\n+            null);\n+        command.addTableFilter(filter, true);\n+      } else {\n+        parseSelectSimpleFromPart(command);\n+      }\n+    }\n+    if (readIf(\"WHERE\")) {\n+      Expression condition = readExpression();\n+      command.addCondition(condition);\n+    }\n+    // the group by is read for the outer select (or not a select)\n+    // so that columns that are not grouped can be used\n+    currentSelect = oldSelect;\n+    if (readIf(\"GROUP\")) {\n+      read(\"BY\");\n+      command.setGroupQuery();\n+      ArrayList<Expression> list = New.arrayList();\n+      do {\n+        Expression expr = readExpression();\n+        list.add(expr);\n+      } while (readIf(\",\"));\n+      command.setGroupBy(list);\n+    }\n+    currentSelect = command;\n+    if (readIf(\"HAVING\")) {\n+      command.setGroupQuery();\n+      Expression condition = readExpression();\n+      command.setHaving(condition);\n+    }\n+    command.setParameterList(parameters);\n+    currentSelect = oldSelect;\n+    setSQL(command, \"SELECT\", start);\n+    return command;\n+  }\n+\n+  private Table getDualTable(boolean noColumns) {\n+    Schema main = database.findSchema(Constants.SCHEMA_MAIN);\n+    Expression one = ValueExpression.get(ValueLong.get(1));\n+    return new RangeTable(main, one, one, noColumns);\n+  }\n+\n+  private void setSQL(Prepared command, String start, int startIndex) {\n+    String sql = originalSQL.substring(startIndex, lastParseIndex).trim();\n+    if (start != null) {\n+      sql = start + \" \" + sql;\n+    }\n+    command.setSQL(sql);\n+  }\n+\n+  private Expression readExpression() {\n+    Expression r = readAnd();\n+    while (readIf(\"OR\")) {\n+      r = new ConditionAndOr(ConditionAndOr.OR, r, readAnd());\n+    }\n+    return r;\n+  }\n+\n+  private Expression readAnd() {\n+    Expression r = readCondition();\n+    while (readIf(\"AND\")) {\n+      r = new ConditionAndOr(ConditionAndOr.AND, r, readCondition());\n+    }\n+    return r;\n+  }\n+\n+  private Expression readCondition() {\n+    if (readIf(\"NOT\")) {\n+      return new ConditionNot(readCondition());\n+    }\n+    if (readIf(\"EXISTS\")) {\n+      read(\"(\");\n+      Query query = parseSelect();\n+      // can not reduce expression because it might be a union except\n+      // query with distinct\n+      read(\")\");\n+      return new ConditionExists(query);\n+    }\n+    if (readIf(\"INTERSECTS\")) {\n+      read(\"(\");\n+      Expression r1 = readConcat();\n+      read(\",\");\n+      Expression r2 = readConcat();\n+      read(\")\");\n+      return new Comparison(session, Comparison.SPATIAL_INTERSECTS, r1,\n+          r2);\n+    }\n+    Expression r = readConcat();\n+    while (true) {\n+      // special case: NOT NULL is not part of an expression (as in CREATE\n+      // TABLE TEST(ID INT DEFAULT 0 NOT NULL))\n+      int backup = parseIndex;\n+      boolean not = false;\n+      if (readIf(\"NOT\")) {\n+        not = true;\n+        if (isToken(\"NULL\")) {\n+          // this really only works for NOT NULL!\n+          parseIndex = backup;\n+          currentToken = \"NOT\";\n+          break;\n+        }\n+      }\n+      if (readIf(\"LIKE\")) {\n+        Expression b = readConcat();\n+        Expression esc = null;\n+        if (readIf(\"ESCAPE\")) {\n+          esc = readConcat();\n+        }\n+        recompileAlways = true;\n+        r = new CompareLike(database, r, b, esc, false);\n+      } else if (readIf(\"ILIKE\")) {\n+        Function function = Function.getFunction(database, \"CAST\");\n+        function.setDataType(new Column(\"X\", Value.STRING_IGNORECASE));\n+        function.setParameter(0, r);\n+        r = function;\n+        Expression b = readConcat();\n+        Expression esc = null;\n+        if (readIf(\"ESCAPE\")) {\n+          esc = readConcat();\n+        }\n+        recompileAlways = true;\n+        r = new CompareLike(database, r, b, esc, false);\n+      } else if (readIf(\"REGEXP\")) {\n+        Expression b = readConcat();\n+        recompileAlways = true;\n+        r = new CompareLike(database, r, b, null, true);\n+      } else if (readIf(\"IS\")) {\n+        if (readIf(\"NOT\")) {\n+          if (readIf(\"NULL\")) {\n+            r = new Comparison(session, Comparison.IS_NOT_NULL, r,\n+                null);\n+          } else if (readIf(\"DISTINCT\")) {\n+            read(\"FROM\");\n+            r = new Comparison(session, Comparison.EQUAL_NULL_SAFE,\n+                r, readConcat());\n+          } else {\n+            r = new Comparison(session,\n+                Comparison.NOT_EQUAL_NULL_SAFE, r, readConcat());\n+          }\n+        } else if (readIf(\"NULL\")) {\n+          r = new Comparison(session, Comparison.IS_NULL, r, null);\n+        } else if (readIf(\"DISTINCT\")) {\n+          read(\"FROM\");\n+          r = new Comparison(session, Comparison.NOT_EQUAL_NULL_SAFE,\n+              r, readConcat());\n+        } else {\n+          r = new Comparison(session, Comparison.EQUAL_NULL_SAFE, r,\n+              readConcat());\n+        }\n+      } else if (readIf(\"IN\")) {\n+        read(\"(\");\n+        if (readIf(\")\")) {\n+          if (database.getMode().prohibitEmptyInPredicate) {\n+            throw getSyntaxError();\n+          }\n+          r = ValueExpression.get(ValueBoolean.get(false));\n+        } else {\n+          if (isSelect()) {\n+            Query query = parseSelect();\n+            // can not be lazy because we have to call\n+            // method ResultInterface.containsDistinct\n+            // which is not supported for lazy execution\n+            query.setNeverLazy(true);\n+            r = new ConditionInSelect(database, r, query, false,\n+                Comparison.EQUAL);\n+          } else {\n+            ArrayList<Expression> v = New.arrayList();\n+            Expression last;\n             do {\n-                Column column = readTableColumn(filter);\n-                columns.add(column);\n+              last = readExpression();\n+              v.add(last);\n             } while (readIf(\",\"));\n-            read(\")\");\n-            read(\"=\");\n-            Expression expression = readExpression();\n-            if (columns.size() == 1) {\n-                // the expression is parsed as a simple value\n-                command.setAssignment(columns.get(0), expression);\n+            if (v.size() == 1 && (last instanceof Subquery)) {\n+              Subquery s = (Subquery) last;\n+              Query q = s.getQuery();\n+              r = new ConditionInSelect(database, r, q, false,\n+                  Comparison.EQUAL);\n             } else {\n-                for (int i = 0, size = columns.size(); i < size; i++) {\n-                    Column column = columns.get(i);\n-                    Function f = Function.getFunction(database, \"ARRAY_GET\");\n-                    f.setParameter(0, expression);\n-                    f.setParameter(1, ValueExpression.get(ValueInt.get(i + 1)));\n-                    f.doneWithParameters();\n-                    command.setAssignment(column, f);\n-                }\n-            }\n+              r = new ConditionIn(database, r, v);\n+            }\n+          }\n+          read(\")\");\n+        }\n+      } else if (readIf(\"BETWEEN\")) {\n+        Expression low = readConcat();\n+        read(\"AND\");\n+        Expression high = readConcat();\n+        Expression condLow = new Comparison(session,\n+            Comparison.SMALLER_EQUAL, low, r);\n+        Expression condHigh = new Comparison(session,\n+            Comparison.BIGGER_EQUAL, high, r);\n+        r = new ConditionAndOr(ConditionAndOr.AND, condLow, condHigh);\n+      } else {\n+        int compareType = getCompareType(currentTokenType);\n+        if (compareType < 0) {\n+          break;\n+        }\n+        read();\n+        if (readIf(\"ALL\")) {\n+          read(\"(\");\n+          Query query = parseSelect();\n+          r = new ConditionInSelect(database, r, query, true,\n+              compareType);\n+          read(\")\");\n+        } else if (readIf(\"ANY\") || readIf(\"SOME\")) {\n+          read(\"(\");\n+          if (currentTokenType == PARAMETER && compareType == 0) {\n+            Parameter p = readParameter();\n+            r = new ConditionInParameter(database, r, p);\n+          } else {\n+            Query query = parseSelect();\n+            r = new ConditionInSelect(database, r, query, false,\n+                compareType);\n+          }\n+          read(\")\");\n         } else {\n-            do {\n-                Column column = readTableColumn(filter);\n-                read(\"=\");\n-                Expression expression;\n-                if (readIf(\"DEFAULT\")) {\n-                    expression = ValueExpression.getDefault();\n+          Expression right = readConcat();\n+          if (SysProperties.OLD_STYLE_OUTER_JOIN &&\n+              readIf(\"(\") && readIf(\"+\") && readIf(\")\")) {\n+            // support for a subset of old-fashioned Oracle outer\n+            // join with (+)\n+            if (r instanceof ExpressionColumn &&\n+                right instanceof ExpressionColumn) {\n+              ExpressionColumn leftCol = (ExpressionColumn) r;\n+              ExpressionColumn rightCol = (ExpressionColumn) right;\n+              ArrayList<TableFilter> filters = currentSelect\n+                  .getTopFilters();\n+              for (TableFilter f : filters) {\n+                while (f != null) {\n+                  leftCol.mapColumns(f, 0);\n+                  rightCol.mapColumns(f, 0);\n+                  f = f.getJoin();\n+                }\n+              }\n+              TableFilter leftFilter = leftCol.getTableFilter();\n+              TableFilter rightFilter = rightCol.getTableFilter();\n+              r = new Comparison(session, compareType, r, right);\n+              if (leftFilter != null && rightFilter != null) {\n+                int idx = filters.indexOf(rightFilter);\n+                if (idx >= 0) {\n+                  filters.remove(idx);\n+                  leftFilter.addJoin(rightFilter, true, r);\n                 } else {\n-                    expression = readExpression();\n+                  rightFilter.mapAndAddFilter(r);\n                 }\n-                command.setAssignment(column, expression);\n-            } while (readIf(\",\"));\n+                r = ValueExpression.get(ValueBoolean.get(true));\n+              }\n+            }\n+          } else {\n+            r = new Comparison(session, compareType, r, right);\n+          }\n         }\n-        if (readIf(\"WHERE\")) {\n-            Expression condition = readExpression();\n-            command.setCondition(condition);\n+      }\n+      if (not) {\n+        r = new ConditionNot(r);\n+      }\n+    }\n+    return r;\n+  }\n+\n+  private Expression readConcat() {\n+    Expression r = readSum();\n+    while (true) {\n+      if (readIf(\"||\")) {\n+        r = new Operation(OpType.CONCAT, r, readSum());\n+      } else if (readIf(\"~\")) {\n+        if (readIf(\"*\")) {\n+          Function function = Function.getFunction(database, \"CAST\");\n+          function.setDataType(new Column(\"X\",\n+              Value.STRING_IGNORECASE));\n+          function.setParameter(0, r);\n+          r = function;\n+        }\n+        r = new CompareLike(database, r, readSum(), null, true);\n+      } else if (readIf(\"!~\")) {\n+        if (readIf(\"*\")) {\n+          Function function = Function.getFunction(database, \"CAST\");\n+          function.setDataType(new Column(\"X\",\n+              Value.STRING_IGNORECASE));\n+          function.setParameter(0, r);\n+          r = function;\n+        }\n+        r = new ConditionNot(new CompareLike(database, r, readSum(),\n+            null, true));\n+      } else {\n+        return r;\n+      }\n+    }\n+  }\n+\n+  private Expression readSum() {\n+    Expression r = readFactor();\n+    while (true) {\n+      if (readIf(\"+\")) {\n+        r = new Operation(OpType.PLUS, r, readFactor());\n+      } else if (readIf(\"-\")) {\n+        r = new Operation(OpType.MINUS, r, readFactor());\n+      } else {\n+        return r;\n+      }\n+    }\n+  }\n+\n+  private Expression readFactor() {\n+    Expression r = readTerm();\n+    while (true) {\n+      if (readIf(\"*\")) {\n+        r = new Operation(OpType.MULTIPLY, r, readTerm());\n+      } else if (readIf(\"/\")) {\n+        r = new Operation(OpType.DIVIDE, r, readTerm());\n+      } else if (readIf(\"%\")) {\n+        r = new Operation(OpType.MODULUS, r, readTerm());\n+      } else {\n+        return r;\n+      }\n+    }\n+  }\n+\n+  private Expression readAggregate(AggregateType aggregateType,\n+                                   String aggregateName) {\n+    if (currentSelect == null) {\n+      throw getSyntaxError();\n+    }\n+    currentSelect.setGroupQuery();\n+    Aggregate r;\n+    if (aggregateType == AggregateType.COUNT) {\n+      if (readIf(\"*\")) {\n+        r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect,\n+            false);\n+      } else {\n+        boolean distinct = readIf(\"DISTINCT\");\n+        Expression on = readExpression();\n+        if (on instanceof Wildcard && !distinct) {\n+          // PostgreSQL compatibility: count(t.*)\n+          r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect,\n+              false);\n+        } else {\n+          r = new Aggregate(AggregateType.COUNT, on, currentSelect,\n+              distinct);\n         }\n+      }\n+    } else if (aggregateType == AggregateType.GROUP_CONCAT) {\n+      boolean distinct = readIf(\"DISTINCT\");\n+\n+      if (equalsToken(\"GROUP_CONCAT\", aggregateName)) {\n+        r = new Aggregate(AggregateType.GROUP_CONCAT,\n+            readExpression(), currentSelect, distinct);\n         if (readIf(\"ORDER\")) {\n-            // for MySQL compatibility\n-            // (this syntax is supported, but ignored)\n-            read(\"BY\");\n-            parseSimpleOrderList();\n+          read(\"BY\");\n+          r.setGroupConcatOrder(parseSimpleOrderList());\n         }\n-        if (readIf(\"LIMIT\")) {\n-            Expression limit = readTerm().optimize(session);\n-            command.setLimit(limit);\n+\n+        if (readIf(\"SEPARATOR\")) {\n+          r.setGroupConcatSeparator(readExpression());\n         }\n-        setSQL(command, \"UPDATE\", start);\n-    }\n-\n-    private TableFilter readSimpleTableFilter(int orderInFrom, Collection<String> excludeTokens) {\n-        Table table = readTableOrView();\n-        String alias = null;\n-        if (readIf(\"AS\")) {\n-            alias = readAliasIdentifier();\n-        } else if (currentTokenType == IDENTIFIER) {\n-            if (!equalsTokenIgnoreCase(currentToken, \"SET\")\n-                    && (excludeTokens == null || !isTokenInList(excludeTokens))) {\n-                // SET is not a keyword (PostgreSQL supports it as a table name)\n-                alias = readAliasIdentifier();\n-            }\n+      } else if (equalsToken(\"STRING_AGG\", aggregateName)) {\n+        // PostgreSQL compatibility: string_agg(expression, delimiter)\n+        r = new Aggregate(AggregateType.GROUP_CONCAT,\n+            readExpression(), currentSelect, distinct);\n+        read(\",\");\n+        r.setGroupConcatSeparator(readExpression());\n+        if (readIf(\"ORDER\")) {\n+          read(\"BY\");\n+          r.setGroupConcatOrder(parseSimpleOrderList());\n+        }\n+      } else {\n+        r = null;\n+      }\n+    } else {\n+      boolean distinct = readIf(\"DISTINCT\");\n+      r = new Aggregate(aggregateType, readExpression(), currentSelect,\n+          distinct);\n+    }\n+    read(\")\");\n+    if (r != null && readIf(\"FILTER\")) {\n+      read(\"(\");\n+      read(\"WHERE\");\n+      Expression condition = readExpression();\n+      read(\")\");\n+      r.setFilterCondition(condition);\n+    }\n+    return r;\n+  }\n+\n+  private ArrayList<SelectOrderBy> parseSimpleOrderList() {\n+    ArrayList<SelectOrderBy> orderList = New.arrayList();\n+    do {\n+      SelectOrderBy order = new SelectOrderBy();\n+      Expression expr = readExpression();\n+      order.expression = expr;\n+      if (readIf(\"DESC\")) {\n+        order.descending = true;\n+      } else {\n+        readIf(\"ASC\");\n+      }\n+      orderList.add(order);\n+    } while (readIf(\",\"));\n+    return orderList;\n+  }\n+\n+  private JavaFunction readJavaFunction(Schema schema, String functionName) {\n+    FunctionAlias functionAlias = null;\n+    if (schema != null) {\n+      functionAlias = schema.findFunction(functionName);\n+    } else {\n+      functionAlias = findFunctionAlias(session.getCurrentSchemaName(),\n+          functionName);\n+    }\n+    if (functionAlias == null) {\n+      throw DbException.get(ErrorCode.FUNCTION_NOT_FOUND_1, functionName);\n+    }\n+    Expression[] args;\n+    ArrayList<Expression> argList = New.arrayList();\n+    int numArgs = 0;\n+    while (!readIf(\")\")) {\n+      if (numArgs++ > 0) {\n+        read(\",\");\n+      }\n+      argList.add(readExpression());\n+    }\n+    args = argList.toArray(new Expression[0]);\n+    JavaFunction func = new JavaFunction(functionAlias, args);\n+    return func;\n+  }\n+\n+  private JavaAggregate readJavaAggregate(UserAggregate aggregate) {\n+    ArrayList<Expression> params = New.arrayList();\n+    do {\n+      params.add(readExpression());\n+    } while (readIf(\",\"));\n+    read(\")\");\n+    Expression filterCondition;\n+    if (readIf(\"FILTER\")) {\n+      read(\"(\");\n+      read(\"WHERE\");\n+      filterCondition = readExpression();\n+      read(\")\");\n+    } else {\n+      filterCondition = null;\n+    }\n+    Expression[] list = params.toArray(new Expression[0]);\n+    JavaAggregate agg =\n+        new JavaAggregate(aggregate, list, currentSelect, filterCondition);\n+    currentSelect.setGroupQuery();\n+    return agg;\n+  }\n+\n+  private AggregateType getAggregateType(String name) {\n+    if (!identifiersToUpper) {\n+      // if not yet converted to uppercase, do it now\n+      name = StringUtils.toUpperEnglish(name);\n+    }\n+    return Aggregate.getAggregateType(name);\n+  }\n+\n+  private Expression readFunction(Schema schema, String name) {\n+    if (schema != null) {\n+      return readJavaFunction(schema, name);\n+    }\n+    AggregateType agg = getAggregateType(name);\n+    if (agg != null) {\n+      return readAggregate(agg, name);\n+    }\n+    Function function = Function.getFunction(database, name);\n+    if (function == null) {\n+      UserAggregate aggregate = database.findAggregate(name);\n+      if (aggregate != null) {\n+        return readJavaAggregate(aggregate);\n+      }\n+      return readJavaFunction(null, name);\n+    }\n+    switch (function.getFunctionType()) {\n+      case Function.CAST: {\n+        function.setParameter(0, readExpression());\n+        read(\"AS\");\n+        Column type = parseColumnWithType(null);\n+        function.setDataType(type);\n+        read(\")\");\n+        break;\n+      }\n+      case Function.CONVERT: {\n+        if (database.getMode().swapConvertFunctionParameters) {\n+          Column type = parseColumnWithType(null);\n+          function.setDataType(type);\n+          read(\",\");\n+          function.setParameter(0, readExpression());\n+          read(\")\");\n+        } else {\n+          function.setParameter(0, readExpression());\n+          read(\",\");\n+          Column type = parseColumnWithType(null);\n+          function.setDataType(type);\n+          read(\")\");\n+        }\n+        break;\n+      }\n+      case Function.EXTRACT: {\n+        function.setParameter(0,\n+            ValueExpression.get(ValueString.get(currentToken)));\n+        read();\n+        read(\"FROM\");\n+        function.setParameter(1, readExpression());\n+        read(\")\");\n+        break;\n+      }\n+      case Function.DATE_ADD:\n+      case Function.DATE_DIFF: {\n+        if (Function.isDatePart(currentToken)) {\n+          function.setParameter(0,\n+              ValueExpression.get(ValueString.get(currentToken)));\n+          read();\n+        } else {\n+          function.setParameter(0, readExpression());\n         }\n-        return new TableFilter(session, table, alias, rightsChecked,\n-                currentSelect, orderInFrom, null);\n-    }\n-\n-    private Delete parseDelete() {\n-        Delete command = new Delete(session);\n-        Expression limit = null;\n-        if (readIf(\"TOP\")) {\n-            limit = readTerm().optimize(session);\n+        read(\",\");\n+        function.setParameter(1, readExpression());\n+        read(\",\");\n+        function.setParameter(2, readExpression());\n+        read(\")\");\n+        break;\n+      }\n+      case Function.SUBSTRING: {\n+        // Different variants include:\n+        // SUBSTRING(X,1)\n+        // SUBSTRING(X,1,1)\n+        // SUBSTRING(X FROM 1 FOR 1) -- Postgres\n+        // SUBSTRING(X FROM 1) -- Postgres\n+        // SUBSTRING(X FOR 1) -- Postgres\n+        function.setParameter(0, readExpression());\n+        if (readIf(\"FROM\")) {\n+          function.setParameter(1, readExpression());\n+          if (readIf(\"FOR\")) {\n+            function.setParameter(2, readExpression());\n+          }\n+        } else if (readIf(\"FOR\")) {\n+          function.setParameter(1, ValueExpression.get(ValueInt.get(0)));\n+          function.setParameter(2, readExpression());\n+        } else {\n+          read(\",\");\n+          function.setParameter(1, readExpression());\n+          if (readIf(\",\")) {\n+            function.setParameter(2, readExpression());\n+          }\n         }\n-        currentPrepared = command;\n-        int start = lastParseIndex;\n-        if (!readIf(\"FROM\") && database.getMode().getEnum() == ModeEnum.MySQL) {\n-            readIdentifierWithSchema();\n+        read(\")\");\n+        break;\n+      }\n+      case Function.POSITION: {\n+        // can't read expression because IN would be read too early\n+        function.setParameter(0, readConcat());\n+        if (!readIf(\",\")) {\n+          read(\"IN\");\n+        }\n+        function.setParameter(1, readExpression());\n+        read(\")\");\n+        break;\n+      }\n+      case Function.TRIM: {\n+        Expression space = null;\n+        if (readIf(\"LEADING\")) {\n+          function = Function.getFunction(database, \"LTRIM\");\n+          if (!readIf(\"FROM\")) {\n+            space = readExpression();\n+            read(\"FROM\");\n+          }\n+        } else if (readIf(\"TRAILING\")) {\n+          function = Function.getFunction(database, \"RTRIM\");\n+          if (!readIf(\"FROM\")) {\n+            space = readExpression();\n             read(\"FROM\");\n+          }\n+        } else if (readIf(\"BOTH\")) {\n+          if (!readIf(\"FROM\")) {\n+            space = readExpression();\n+            read(\"FROM\");\n+          }\n         }\n-        TableFilter filter = readSimpleTableFilter(0, null);\n-        command.setTableFilter(filter);\n-        parseDeleteGivenTable(command, limit, start);\n-        return command;\n-    }\n-\n-    private void parseDeleteGivenTable(Delete command, Expression limit, int start) {\n-        if (readIf(\"WHERE\")) {\n-            Expression condition = readExpression();\n-            command.setCondition(condition);\n+        Expression p0 = readExpression();\n+        if (readIf(\",\")) {\n+          space = readExpression();\n+        } else if (readIf(\"FROM\")) {\n+          space = p0;\n+          p0 = readExpression();\n         }\n-        if (readIf(\"LIMIT\") && limit == null) {\n-            limit = readTerm().optimize(session);\n+        function.setParameter(0, p0);\n+        if (space != null) {\n+          function.setParameter(1, space);\n         }\n-        command.setLimit(limit);\n-        setSQL(command, \"DELETE\", start);\n-    }\n-\n-    private IndexColumn[] parseIndexColumnList() {\n-        ArrayList<IndexColumn> columns = New.arrayList();\n+        read(\")\");\n+        break;\n+      }\n+      case Function.TABLE:\n+      case Function.TABLE_DISTINCT: {\n+        int i = 0;\n+        ArrayList<Column> columns = New.arrayList();\n         do {\n-            IndexColumn column = new IndexColumn();\n-            column.columnName = readColumnIdentifier();\n-            columns.add(column);\n-            if (readIf(\"ASC\")) {\n-                // ignore\n-            } else if (readIf(\"DESC\")) {\n-                column.sortType = SortOrder.DESCENDING;\n-            }\n-            if (readIf(\"NULLS\")) {\n-                if (readIf(\"FIRST\")) {\n-                    column.sortType |= SortOrder.NULLS_FIRST;\n-                } else {\n-                    read(\"LAST\");\n-                    column.sortType |= SortOrder.NULLS_LAST;\n-                }\n-            }\n+          String columnName = readAliasIdentifier();\n+          Column column = parseColumnWithType(columnName);\n+          columns.add(column);\n+          read(\"=\");\n+          function.setParameter(i, readExpression());\n+          i++;\n         } while (readIf(\",\"));\n         read(\")\");\n-        return columns.toArray(new IndexColumn[0]);\n-    }\n-\n-    private String[] parseColumnList() {\n-        ArrayList<String> columns = New.arrayList();\n-        do {\n-            String columnName = readColumnIdentifier();\n-            columns.add(columnName);\n-        } while (readIfMore());\n-        return columns.toArray(new String[0]);\n-    }\n-\n-    private Column[] parseColumnList(Table table) {\n-        ArrayList<Column> columns = New.arrayList();\n-        HashSet<Column> set = new HashSet<>();\n-        if (!readIf(\")\")) {\n-            do {\n-                Column column = parseColumn(table);\n-                if (!set.add(column)) {\n-                    throw DbException.get(ErrorCode.DUPLICATE_COLUMN_NAME_1,\n-                            column.getSQL());\n-                }\n-                columns.add(column);\n-            } while (readIfMore());\n-        }\n-        return columns.toArray(new Column[0]);\n-    }\n-\n-    private Column parseColumn(Table table) {\n-        String id = readColumnIdentifier();\n-        if (database.getSettings().rowId && Column.ROWID.equals(id)) {\n-            return table.getRowIdColumn();\n-        }\n-        return table.getColumn(id);\n-    }\n-\n-    private boolean readIfMore() {\n-        if (readIf(\",\")) {\n-            return !readIf(\")\");\n-        }\n+        TableFunction tf = (TableFunction) function;\n+        tf.setColumns(columns);\n+        break;\n+      }\n+      case Function.ROW_NUMBER:\n         read(\")\");\n-        return false;\n-    }\n-\n-    private Prepared parseHelp() {\n-        StringBuilder buff = new StringBuilder(\n-                \"SELECT * FROM INFORMATION_SCHEMA.HELP\");\n-        int i = 0;\n-        ArrayList<Value> paramValues = New.arrayList();\n-        while (currentTokenType != END) {\n-            String s = currentToken;\n-            read();\n-            if (i == 0) {\n-                buff.append(\" WHERE \");\n-            } else {\n-                buff.append(\" AND \");\n-            }\n-            i++;\n-            buff.append(\"UPPER(TOPIC) LIKE ?\");\n-            paramValues.add(ValueString.get(\"%\" + s + \"%\"));\n+        read(\"OVER\");\n+        read(\"(\");\n+        read(\")\");\n+        if (currentSelect == null && currentPrepared == null) {\n+          throw getSyntaxError();\n         }\n-        return prepare(session, buff.toString(), paramValues);\n-    }\n-\n-    private Prepared parseShow() {\n-        ArrayList<Value> paramValues = New.arrayList();\n-        StringBuilder buff = new StringBuilder(\"SELECT \");\n-        if (readIf(\"CLIENT_ENCODING\")) {\n-            // for PostgreSQL compatibility\n-            buff.append(\"'UNICODE' AS CLIENT_ENCODING FROM DUAL\");\n-        } else if (readIf(\"DEFAULT_TRANSACTION_ISOLATION\")) {\n-            // for PostgreSQL compatibility\n-            buff.append(\"'read committed' AS DEFAULT_TRANSACTION_ISOLATION \" +\n-                    \"FROM DUAL\");\n-        } else if (readIf(\"TRANSACTION\")) {\n-            // for PostgreSQL compatibility\n-            read(\"ISOLATION\");\n-            read(\"LEVEL\");\n-            buff.append(\"'read committed' AS TRANSACTION_ISOLATION \" +\n-                    \"FROM DUAL\");\n-        } else if (readIf(\"DATESTYLE\")) {\n-            // for PostgreSQL compatibility\n-            buff.append(\"'ISO' AS DATESTYLE FROM DUAL\");\n-        } else if (readIf(\"SERVER_VERSION\")) {\n-            // for PostgreSQL compatibility\n-            buff.append(\"'8.1.4' AS SERVER_VERSION FROM DUAL\");\n-        } else if (readIf(\"SERVER_ENCODING\")) {\n-            // for PostgreSQL compatibility\n-            buff.append(\"'UTF8' AS SERVER_ENCODING FROM DUAL\");\n-        } else if (readIf(\"TABLES\")) {\n-            // for MySQL compatibility\n-            String schema = Constants.SCHEMA_MAIN;\n-            if (readIf(\"FROM\")) {\n-                schema = readUniqueIdentifier();\n+        return new Rownum(currentSelect == null ? currentPrepared\n+            : currentSelect);\n+      default:\n+        if (!readIf(\")\")) {\n+          int i = 0;\n+          do {\n+            function.setParameter(i++, readExpression());\n+          } while (readIf(\",\"));\n+          read(\")\");\n+        }\n+    }\n+    function.doneWithParameters();\n+    return function;\n+  }\n+\n+  private Expression readFunctionWithoutParameters(String name) {\n+    if (readIf(\"(\")) {\n+      read(\")\");\n+    }\n+    if (database.isAllowBuiltinAliasOverride()) {\n+      FunctionAlias functionAlias =\n+          database.getSchema(session.getCurrentSchemaName()).findFunction(name);\n+      if (functionAlias != null) {\n+        JavaFunction func = new JavaFunction(functionAlias, new Expression[0]);\n+        return func;\n+      }\n+    }\n+    Function function = Function.getFunction(database, name);\n+    function.doneWithParameters();\n+    return function;\n+  }\n+\n+  private Expression readWildcardOrSequenceValue(String schema,\n+                                                 String objectName) {\n+    if (readIf(\"*\")) {\n+      return new Wildcard(schema, objectName);\n+    }\n+    if (schema == null) {\n+      schema = session.getCurrentSchemaName();\n+    }\n+    if (readIf(\"NEXTVAL\")) {\n+      Sequence sequence = findSequence(schema, objectName);\n+      if (sequence != null) {\n+        return new SequenceValue(sequence);\n+      }\n+    } else if (readIf(\"CURRVAL\")) {\n+      Sequence sequence = findSequence(schema, objectName);\n+      if (sequence != null) {\n+        Function function = Function.getFunction(database, \"CURRVAL\");\n+        function.setParameter(0, ValueExpression.get(ValueString\n+            .get(sequence.getSchema().getName())));\n+        function.setParameter(1, ValueExpression.get(ValueString\n+            .get(sequence.getName())));\n+        function.doneWithParameters();\n+        return function;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Expression readTermObjectDot(String objectName) {\n+    Expression expr = readWildcardOrSequenceValue(null, objectName);\n+    if (expr != null) {\n+      return expr;\n+    }\n+    String name = readColumnIdentifier();\n+    Schema s = database.findSchema(objectName);\n+    if ((!SysProperties.OLD_STYLE_OUTER_JOIN || s != null) && readIf(\"(\")) {\n+      // only if the token before the dot is a valid schema name,\n+      // otherwise the old style Oracle outer join doesn't work:\n+      // t.x = t2.x(+)\n+      // this additional check is not required\n+      // if the old style outer joins are not supported\n+      return readFunction(s, name);\n+    } else if (readIf(\".\")) {\n+      String schema = objectName;\n+      objectName = name;\n+      expr = readWildcardOrSequenceValue(schema, objectName);\n+      if (expr != null) {\n+        return expr;\n+      }\n+      name = readColumnIdentifier();\n+      if (readIf(\"(\")) {\n+        String databaseName = schema;\n+        if (!equalsToken(database.getShortName(), databaseName)) {\n+          throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n+              databaseName);\n+        }\n+        schema = objectName;\n+        return readFunction(database.getSchema(schema), name);\n+      } else if (readIf(\".\")) {\n+        String databaseName = schema;\n+        if (!equalsToken(database.getShortName(), databaseName)) {\n+          throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n+              databaseName);\n+        }\n+        schema = objectName;\n+        objectName = name;\n+        expr = readWildcardOrSequenceValue(schema, objectName);\n+        if (expr != null) {\n+          return expr;\n+        }\n+        name = readColumnIdentifier();\n+        return new ExpressionColumn(database, schema, objectName, name);\n+      }\n+      return new ExpressionColumn(database, schema, objectName, name);\n+    }\n+    return new ExpressionColumn(database, null, objectName, name);\n+  }\n+\n+  private Parameter readParameter() {\n+    // there must be no space between ? and the number\n+    boolean indexed = Character.isDigit(sqlCommandChars[parseIndex]);\n+\n+    Parameter p;\n+    if (indexed) {\n+      readParameterIndex();\n+      if (indexedParameterList == null) {\n+        if (parameters == null) {\n+          // this can occur when parsing expressions only (for\n+          // example check constraints)\n+          throw getSyntaxError();\n+        } else if (!parameters.isEmpty()) {\n+          throw DbException\n+              .get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n+        }\n+        indexedParameterList = New.arrayList();\n+      }\n+      int index = currentValue.getInt() - 1;\n+      if (index < 0 || index >= Constants.MAX_PARAMETER_INDEX) {\n+        throw DbException.getInvalidValueException(\n+            \"parameter index\", index);\n+      }\n+      if (indexedParameterList.size() <= index) {\n+        indexedParameterList.ensureCapacity(index + 1);\n+        while (indexedParameterList.size() <= index) {\n+          indexedParameterList.add(null);\n+        }\n+      }\n+      p = indexedParameterList.get(index);\n+      if (p == null) {\n+        p = new Parameter(index);\n+        indexedParameterList.set(index, p);\n+      }\n+      read();\n+    } else {\n+      read();\n+      if (indexedParameterList != null) {\n+        throw DbException\n+            .get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n+      }\n+      p = new Parameter(parameters.size());\n+    }\n+    parameters.add(p);\n+    return p;\n+  }\n+\n+  private Expression readTerm() {\n+    Expression r;\n+    switch (currentTokenType) {\n+      case AT:\n+        read();\n+        r = new Variable(session, readAliasIdentifier());\n+        if (readIf(\":=\")) {\n+          Expression value = readExpression();\n+          Function function = Function.getFunction(database, \"SET\");\n+          function.setParameter(0, r);\n+          function.setParameter(1, value);\n+          r = function;\n+        }\n+        break;\n+      case PARAMETER:\n+        r = readParameter();\n+        break;\n+      case KEYWORD:\n+        if (isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"WITH\")) {\n+          Query query = parseSelect();\n+          r = new Subquery(query);\n+        } else {\n+          throw getSyntaxError();\n+        }\n+        break;\n+      case IDENTIFIER:\n+        String name = currentToken;\n+        if (currentTokenQuoted) {\n+          read();\n+          if (readIf(\"(\")) {\n+            r = readFunction(null, name);\n+          } else if (readIf(\".\")) {\n+            r = readTermObjectDot(name);\n+          } else {\n+            r = new ExpressionColumn(database, null, null, name);\n+          }\n+        } else {\n+          read();\n+          if (readIf(\".\")) {\n+            r = readTermObjectDot(name);\n+          } else if (equalsToken(\"CASE\", name)) {\n+            // CASE must be processed before (,\n+            // otherwise CASE(3) would be a function call, which it is\n+            // not\n+            r = readCase();\n+          } else if (readIf(\"(\")) {\n+            r = readFunction(null, name);\n+          } else if (equalsToken(\"CURRENT_USER\", name)) {\n+            r = readFunctionWithoutParameters(\"USER\");\n+          } else if (equalsToken(\"CURRENT_TIMESTAMP\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+          } else if (equalsToken(\"SYSDATE\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+          } else if (equalsToken(\"SYSTIMESTAMP\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+          } else if (equalsToken(\"CURRENT_DATE\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n+          } else if (equalsToken(\"TODAY\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n+          } else if (equalsToken(\"CURRENT_TIME\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n+          } else if (equalsToken(\"SYSTIME\", name)) {\n+            r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n+          } else if (equalsToken(\"CURRENT\", name)) {\n+            if (readIf(\"TIMESTAMP\")) {\n+              r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+            } else if (readIf(\"TIME\")) {\n+              r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n+            } else if (readIf(\"DATE\")) {\n+              r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n+            } else {\n+              r = new ExpressionColumn(database, null, null, name);\n             }\n-            buff.append(\"TABLE_NAME, TABLE_SCHEMA FROM \"\n-                    + \"INFORMATION_SCHEMA.TABLES \"\n-                    + \"WHERE TABLE_SCHEMA=? ORDER BY TABLE_NAME\");\n-            paramValues.add(ValueString.get(schema));\n-        } else if (readIf(\"COLUMNS\")) {\n-            // for MySQL compatibility\n-            read(\"FROM\");\n-            String tableName = readIdentifierWithSchema();\n-            String schemaName = getSchema().getName();\n-            paramValues.add(ValueString.get(tableName));\n-            if (readIf(\"FROM\")) {\n-                schemaName = readUniqueIdentifier();\n+          } else if (equalsToken(\"NEXT\", name) && readIf(\"VALUE\")) {\n+            read(\"FOR\");\n+            Sequence sequence = readSequence();\n+            r = new SequenceValue(sequence);\n+          } else if (equalsToken(\"TIME\", name)) {\n+            boolean without = readIf(\"WITHOUT\");\n+            if (without) {\n+              read(\"TIME\");\n+              read(\"ZONE\");\n+            }\n+            if (currentTokenType != VALUE\n+                || currentValue.getType() != Value.STRING) {\n+              if (without) {\n+                throw getSyntaxError();\n+              }\n+              r = new ExpressionColumn(database, null, null, name);\n+            } else {\n+              String time = currentValue.getString();\n+              read();\n+              r = ValueExpression.get(ValueTime.parse(time));\n             }\n-            buff.append(\"C.COLUMN_NAME FIELD, \"\n-                    + \"C.TYPE_NAME || '(' || C.NUMERIC_PRECISION || ')' TYPE, \"\n-                    + \"C.IS_NULLABLE \\\"NULL\\\", \"\n-                    + \"CASE (SELECT MAX(I.INDEX_TYPE_NAME) FROM \"\n-                    + \"INFORMATION_SCHEMA.INDEXES I \"\n-                    + \"WHERE I.TABLE_SCHEMA=C.TABLE_SCHEMA \"\n-                    + \"AND I.TABLE_NAME=C.TABLE_NAME \"\n-                    + \"AND I.COLUMN_NAME=C.COLUMN_NAME)\"\n-                    + \"WHEN 'PRIMARY KEY' THEN 'PRI' \"\n-                    + \"WHEN 'UNIQUE INDEX' THEN 'UNI' ELSE '' END KEY, \"\n-                    + \"IFNULL(COLUMN_DEFAULT, 'NULL') DEFAULT \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMNS C \"\n-                    + \"WHERE C.TABLE_NAME=? AND C.TABLE_SCHEMA=? \"\n-                    + \"ORDER BY C.ORDINAL_POSITION\");\n-            paramValues.add(ValueString.get(schemaName));\n-        } else if (readIf(\"DATABASES\") || readIf(\"SCHEMAS\")) {\n-            // for MySQL compatibility\n-            buff.append(\"SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA\");\n-        }\n-        boolean b = session.getAllowLiterals();\n-        try {\n-            // need to temporarily enable it, in case we are in\n-            // ALLOW_LITERALS_NUMBERS mode\n-            session.setAllowLiterals(true);\n-            return prepare(session, buff.toString(), paramValues);\n-        } finally {\n-            session.setAllowLiterals(b);\n-        }\n-    }\n-\n-    private static Prepared prepare(Session s, String sql,\n-            ArrayList<Value> paramValues) {\n-        Prepared prep = s.prepare(sql);\n-        ArrayList<Parameter> params = prep.getParameters();\n-        if (params != null) {\n-            for (int i = 0, size = params.size(); i < size; i++) {\n-                Parameter p = params.get(i);\n-                p.setValue(paramValues.get(i));\n+          } else if (equalsToken(\"TIMESTAMP\", name)) {\n+            if (readIf(\"WITH\")) {\n+              read(\"TIME\");\n+              read(\"ZONE\");\n+              if (currentTokenType != VALUE\n+                  || currentValue.getType() != Value.STRING) {\n+                throw getSyntaxError();\n+              }\n+              String timestamp = currentValue.getString();\n+              read();\n+              r = ValueExpression.get(ValueTimestampTimeZone.parse(timestamp));\n+            } else {\n+              boolean without = readIf(\"WITHOUT\");\n+              if (without) {\n+                read(\"TIME\");\n+                read(\"ZONE\");\n+              }\n+              if (currentTokenType != VALUE\n+                  || currentValue.getType() != Value.STRING) {\n+                if (without) {\n+                  throw getSyntaxError();\n+                }\n+                r = new ExpressionColumn(database, null, null, name);\n+              } else {\n+                String timestamp = currentValue.getString();\n+                read();\n+                r = ValueExpression\n+                    .get(ValueTimestamp.parse(timestamp, database.getMode()));\n+              }\n+            }\n+          } else if (currentTokenType == VALUE &&\n+              currentValue.getType() == Value.STRING) {\n+            if (equalsToken(\"DATE\", name) ||\n+                equalsToken(\"D\", name)) {\n+              String date = currentValue.getString();\n+              read();\n+              r = ValueExpression.get(ValueDate.parse(date));\n+            } else if (equalsToken(\"T\", name)) {\n+              String time = currentValue.getString();\n+              read();\n+              r = ValueExpression.get(ValueTime.parse(time));\n+            } else if (equalsToken(\"TS\", name)) {\n+              String timestamp = currentValue.getString();\n+              read();\n+              r = ValueExpression\n+                  .get(ValueTimestamp.parse(timestamp, database.getMode()));\n+            } else if (equalsToken(\"X\", name)) {\n+              read();\n+              byte[] buffer = StringUtils\n+                  .convertHexToBytes(currentValue.getString());\n+              r = ValueExpression.get(ValueBytes.getNoCopy(buffer));\n+            } else if (equalsToken(\"E\", name)) {\n+              String text = currentValue.getString();\n+              // the PostgreSQL ODBC driver uses\n+              // LIKE E'PROJECT\\\\_DATA' instead of LIKE\n+              // 'PROJECT\\_DATA'\n+              // N: SQL-92 \"National Language\" strings\n+              text = StringUtils.replaceAll(text, \"\\\\\\\\\", \"\\\\\");\n+              read();\n+              r = ValueExpression.get(ValueString.get(text));\n+            } else if (equalsToken(\"N\", name)) {\n+              // SQL-92 \"National Language\" strings\n+              String text = currentValue.getString();\n+              read();\n+              r = ValueExpression.get(ValueString.get(text));\n+            } else {\n+              r = new ExpressionColumn(database, null, null, name);\n             }\n+          } else {\n+            r = new ExpressionColumn(database, null, null, name);\n+          }\n         }\n-        return prep;\n-    }\n-\n-    private boolean isSelect() {\n-        int start = lastParseIndex;\n-        while (readIf(\"(\")) {\n-            // need to read ahead, it could be a nested union:\n-            // ((select 1) union (select 1))\n-        }\n-        boolean select = isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"WITH\");\n-        parseIndex = start;\n+        break;\n+      case MINUS:\n         read();\n-        return select;\n-    }\n-\n-\n-    private Prepared parseMerge() {\n-        Merge command = new Merge(session);\n-        currentPrepared = command;\n-        int start = lastParseIndex;\n-        read(\"INTO\");\n-        List<String> excludeIdentifiers = Arrays.asList(\"USING\", \"KEY\", \"VALUES\");\n-        TableFilter targetTableFilter = readSimpleTableFilter(0, excludeIdentifiers);\n-        command.setTargetTableFilter(targetTableFilter);\n-        Table table = command.getTargetTable();\n-\n-        if (readIf(\"USING\")) {\n-            return parseMergeUsing(command, start);\n-        }\n-        if (readIf(\"(\")) {\n-            if (isSelect()) {\n-                command.setQuery(parseSelect());\n-                read(\")\");\n-                return command;\n-            }\n-            Column[] columns = parseColumnList(table);\n-            command.setColumns(columns);\n-        }\n-        if (readIf(\"KEY\")) {\n-            read(\"(\");\n-            Column[] keys = parseColumnList(table);\n-            command.setKeys(keys);\n-        }\n-        if (readIf(\"VALUES\")) {\n-            do {\n-                ArrayList<Expression> values = New.arrayList();\n-                read(\"(\");\n-                if (!readIf(\")\")) {\n-                    do {\n-                        if (readIf(\"DEFAULT\")) {\n-                            values.add(null);\n-                        } else {\n-                            values.add(readExpression());\n-                        }\n-                    } while (readIfMore());\n-                }\n-                command.addRow(values.toArray(new Expression[0]));\n-            } while (readIf(\",\"));\n+        if (currentTokenType == VALUE) {\n+          r = ValueExpression.get(currentValue.negate());\n+          if (r.getType() == Value.LONG &&\n+              r.getValue(session).getLong() == Integer.MIN_VALUE) {\n+            // convert Integer.MIN_VALUE to type 'int'\n+            // (Integer.MAX_VALUE+1 is of type 'long')\n+            r = ValueExpression.get(ValueInt.get(Integer.MIN_VALUE));\n+          } else if (r.getType() == Value.DECIMAL &&\n+              r.getValue(session).getBigDecimal()\n+                  .compareTo(ValueLong.MIN_BD) == 0) {\n+            // convert Long.MIN_VALUE to type 'long'\n+            // (Long.MAX_VALUE+1 is of type 'decimal')\n+            r = ValueExpression.get(ValueLong.MIN);\n+          }\n+          read();\n         } else {\n-            command.setQuery(parseSelect());\n+          r = new Operation(OpType.NEGATE, readTerm(), null);\n         }\n-        return command;\n-    }\n-\n-    private MergeUsing parseMergeUsing(Merge oldCommand, int start) {\n-        MergeUsing command = new MergeUsing(oldCommand);\n-        currentPrepared = command;\n-\n-        if (readIf(\"(\")) {\n-            /* a select query is supplied */\n-            if (isSelect()) {\n-                command.setQuery(parseSelect());\n-                read(\")\");\n-            }\n-            command.setQueryAlias(readFromAlias(null, Arrays.asList(\"ON\")));\n-\n-            String[] querySQLOutput = new String[]{null};\n-            List<Column> columnTemplateList = TableView.createQueryColumnTemplateList(null, command.getQuery(),\n-                    querySQLOutput);\n-            TableView temporarySourceTableView = createCTEView(\n-                    command.getQueryAlias(), querySQLOutput[0],\n-                    columnTemplateList, false/* no recursion */,\n-                    false/* do not add to session */,\n-                    false /* isPersistent */,\n-                    session);\n-            TableFilter sourceTableFilter = new TableFilter(session,\n-                    temporarySourceTableView, command.getQueryAlias(),\n-                    rightsChecked, (Select) command.getQuery(), 0, null);\n-            command.setSourceTableFilter(sourceTableFilter);\n+        break;\n+      case PLUS:\n+        read();\n+        r = readTerm();\n+        break;\n+      case OPEN:\n+        read();\n+        if (readIf(\")\")) {\n+          r = new ExpressionList(new Expression[0]);\n         } else {\n-            /* Its a table name, simulate a query by building a select query for the table */\n-            List<String> excludeIdentifiers = Arrays.asList(\"ON\");\n-            TableFilter sourceTableFilter = readSimpleTableFilter(0, excludeIdentifiers);\n-            command.setSourceTableFilter(sourceTableFilter);\n-\n-            StringBuilder buff = new StringBuilder(\"SELECT * FROM \")\n-                    .append(sourceTableFilter.getTable().getName());\n-            if (sourceTableFilter.getTableAlias() != null) {\n-                buff.append(\" AS \").append(sourceTableFilter.getTableAlias());\n-            }\n-            Prepared preparedQuery = prepare(session, buff.toString(), null/*paramValues*/);\n-            command.setQuery((Select) preparedQuery);\n-\n-        }\n-        read(\"ON\");\n-        read(\"(\");\n-        Expression condition = readExpression();\n-        command.setOnCondition(condition);\n-        read(\")\");\n-\n-        if (readIfAll(\"WHEN\", \"MATCHED\", \"THEN\")) {\n-            int startMatched = lastParseIndex;\n-            if (readIf(\"UPDATE\")) {\n-                Update updateCommand = new Update(session);\n-                //currentPrepared = updateCommand;\n-                TableFilter filter = command.getTargetTableFilter();\n-                updateCommand.setTableFilter(filter);\n-                parseUpdateSetClause(updateCommand, filter, startMatched);\n-                command.setUpdateCommand(updateCommand);\n-            }\n-            startMatched = lastParseIndex;\n-            if (readIf(\"DELETE\")) {\n-                Delete deleteCommand = new Delete(session);\n-                TableFilter filter = command.getTargetTableFilter();\n-                deleteCommand.setTableFilter(filter);\n-                parseDeleteGivenTable(deleteCommand, null, startMatched);\n-                command.setDeleteCommand(deleteCommand);\n+          r = readExpression();\n+          if (readIf(\",\")) {\n+            ArrayList<Expression> list = New.arrayList();\n+            list.add(r);\n+            while (!readIf(\")\")) {\n+              r = readExpression();\n+              list.add(r);\n+              if (!readIf(\",\")) {\n+                read(\")\");\n+                break;\n+              }\n             }\n+            r = new ExpressionList(list.toArray(new Expression[0]));\n+          } else {\n+            read(\")\");\n+          }\n         }\n-        if (readIfAll(\"WHEN\", \"NOT\", \"MATCHED\", \"THEN\")) {\n-            if (readIf(\"INSERT\")) {\n-                Insert insertCommand = new Insert(session);\n-                insertCommand.setTable(command.getTargetTable());\n-                parseInsertGivenTable(insertCommand, command.getTargetTable());\n-                command.setInsertCommand(insertCommand);\n-            }\n+        break;\n+      case TRUE:\n+        read();\n+        r = ValueExpression.get(ValueBoolean.get(true));\n+        break;\n+      case FALSE:\n+        read();\n+        r = ValueExpression.get(ValueBoolean.get(false));\n+        break;\n+      case ROWNUM:\n+        read();\n+        if (readIf(\"(\")) {\n+          read(\")\");\n         }\n-\n-        setSQL(command, \"MERGE\", start);\n-\n-        // build and prepare the targetMatchQuery ready to test each rows\n-        // existence in the target table (using source row to match)\n-        StringBuilder targetMatchQuerySQL = new StringBuilder(\n-                \"SELECT _ROWID_ FROM \" + command.getTargetTable().getName());\n-        if (command.getTargetTableFilter().getTableAlias() != null) {\n-            targetMatchQuerySQL.append(\n-                    \" AS \" + command.getTargetTableFilter().getTableAlias());\n+        if (currentSelect == null && currentPrepared == null) {\n+          throw getSyntaxError();\n         }\n-        targetMatchQuerySQL\n-                .append(\" WHERE \").append(command.getOnCondition().getSQL());\n-        command.setTargetMatchQuery(\n-                (Select) parse(targetMatchQuerySQL.toString()));\n-\n-        return command;\n+        r = new Rownum(currentSelect == null ? currentPrepared\n+            : currentSelect);\n+        break;\n+      case NULL:\n+        read();\n+        r = ValueExpression.getNull();\n+        break;\n+      case VALUE:\n+        r = ValueExpression.get(currentValue);\n+        read();\n+        break;\n+      default:\n+        throw getSyntaxError();\n     }\n-\n-    private Insert parseInsert() {\n-        Insert command = new Insert(session);\n-        currentPrepared = command;\n-        if (database.getMode().onDuplicateKeyUpdate && readIf(\"IGNORE\")) {\n-            command.setIgnore(true);\n-        }\n-        read(\"INTO\");\n-        Table table = readTableOrView();\n-        command.setTable(table);\n-        Insert returnedCommand = parseInsertGivenTable(command, table);\n-        if (returnedCommand != null) {\n-            return returnedCommand;\n+    if (readIf(\"[\")) {\n+      Function function = Function.getFunction(database, \"ARRAY_GET\");\n+      function.setParameter(0, r);\n+      r = readExpression();\n+      r = new Operation(OpType.PLUS, r, ValueExpression.get(ValueInt\n+          .get(1)));\n+      function.setParameter(1, r);\n+      r = function;\n+      read(\"]\");\n+    }\n+    if (readIf(\"::\")) {\n+      // PostgreSQL compatibility\n+      if (isToken(\"PG_CATALOG\")) {\n+        read(\"PG_CATALOG\");\n+        read(\".\");\n+      }\n+      if (readIf(\"REGCLASS\")) {\n+        FunctionAlias f = findFunctionAlias(Constants.SCHEMA_MAIN,\n+            \"PG_GET_OID\");\n+        if (f == null) {\n+          throw getSyntaxError();\n+        }\n+        Expression[] args = {r};\n+        JavaFunction func = new JavaFunction(f, args);\n+        r = func;\n+      } else {\n+        Column col = parseColumnWithType(null);\n+        Function function = Function.getFunction(database, \"CAST\");\n+        function.setDataType(col);\n+        function.setParameter(0, r);\n+        r = function;\n+      }\n+    }\n+    return r;\n+  }\n+\n+  private Expression readCase() {\n+    if (readIf(\"END\")) {\n+      readIf(\"CASE\");\n+      return ValueExpression.getNull();\n+    }\n+    if (readIf(\"ELSE\")) {\n+      Expression elsePart = readExpression().optimize(session);\n+      read(\"END\");\n+      readIf(\"CASE\");\n+      return elsePart;\n+    }\n+    int i;\n+    Function function;\n+    if (readIf(\"WHEN\")) {\n+      function = Function.getFunction(database, \"CASE\");\n+      function.setParameter(0, null);\n+      i = 1;\n+      do {\n+        function.setParameter(i++, readExpression());\n+        read(\"THEN\");\n+        function.setParameter(i++, readExpression());\n+      } while (readIf(\"WHEN\"));\n+    } else {\n+      Expression expr = readExpression();\n+      if (readIf(\"END\")) {\n+        readIf(\"CASE\");\n+        return ValueExpression.getNull();\n+      }\n+      if (readIf(\"ELSE\")) {\n+        Expression elsePart = readExpression().optimize(session);\n+        read(\"END\");\n+        readIf(\"CASE\");\n+        return elsePart;\n+      }\n+      function = Function.getFunction(database, \"CASE\");\n+      function.setParameter(0, expr);\n+      i = 1;\n+      read(\"WHEN\");\n+      do {\n+        function.setParameter(i++, readExpression());\n+        read(\"THEN\");\n+        function.setParameter(i++, readExpression());\n+      } while (readIf(\"WHEN\"));\n+    }\n+    if (readIf(\"ELSE\")) {\n+      function.setParameter(i, readExpression());\n+    }\n+    read(\"END\");\n+    readIf(\"CASE\");\n+    function.doneWithParameters();\n+    return function;\n+  }\n+\n+  private int readPositiveInt() {\n+    int v = readInt();\n+    if (v < 0) {\n+      throw DbException.getInvalidValueException(\"positive integer\", v);\n+    }\n+    return v;\n+  }\n+\n+  private int readInt() {\n+    boolean minus = false;\n+    if (currentTokenType == MINUS) {\n+      minus = true;\n+      read();\n+    } else if (currentTokenType == PLUS) {\n+      read();\n+    }\n+    if (currentTokenType != VALUE) {\n+      throw DbException.getSyntaxError(sqlCommand, parseIndex, \"integer\");\n+    }\n+    if (minus) {\n+      // must do that now, otherwise Integer.MIN_VALUE would not work\n+      currentValue = currentValue.negate();\n+    }\n+    int i = currentValue.getInt();\n+    read();\n+    return i;\n+  }\n+\n+  private long readLong() {\n+    boolean minus = false;\n+    if (currentTokenType == MINUS) {\n+      minus = true;\n+      read();\n+    } else if (currentTokenType == PLUS) {\n+      read();\n+    }\n+    if (currentTokenType != VALUE) {\n+      throw DbException.getSyntaxError(sqlCommand, parseIndex, \"long\");\n+    }\n+    if (minus) {\n+      // must do that now, otherwise Long.MIN_VALUE would not work\n+      currentValue = currentValue.negate();\n+    }\n+    long i = currentValue.getLong();\n+    read();\n+    return i;\n+  }\n+\n+  private boolean readBooleanSetting() {\n+    if (currentTokenType == VALUE) {\n+      boolean result = currentValue.getBoolean();\n+      read();\n+      return result;\n+    }\n+    if (readIf(\"TRUE\") || readIf(\"ON\")) {\n+      return true;\n+    } else if (readIf(\"FALSE\") || readIf(\"OFF\")) {\n+      return false;\n+    } else {\n+      throw getSyntaxError();\n+    }\n+  }\n+\n+  private String readString() {\n+    Expression expr = readExpression().optimize(session);\n+    if (!(expr instanceof ValueExpression)) {\n+      throw DbException.getSyntaxError(sqlCommand, parseIndex, \"string\");\n+    }\n+    String s = expr.getValue(session).getString();\n+    return s;\n+  }\n+\n+  // TODO: why does this function allow defaultSchemaName=null - which resets\n+  // the parser schemaName for everyone ?\n+  private String readIdentifierWithSchema(String defaultSchemaName) {\n+    if (currentTokenType != IDENTIFIER) {\n+      throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+          \"identifier\");\n+    }\n+    String s = currentToken;\n+    read();\n+    schemaName = defaultSchemaName;\n+    if (readIf(\".\")) {\n+      schemaName = s;\n+      if (currentTokenType != IDENTIFIER) {\n+        throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+            \"identifier\");\n+      }\n+      s = currentToken;\n+      read();\n+    }\n+    if (equalsToken(\".\", currentToken)) {\n+      if (equalsToken(schemaName, database.getShortName())) {\n+        read(\".\");\n+        schemaName = s;\n+        if (currentTokenType != IDENTIFIER) {\n+          throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+              \"identifier\");\n         }\n-        if (database.getMode().onDuplicateKeyUpdate) {\n-            if (readIf(\"ON\")) {\n-                read(\"DUPLICATE\");\n-                read(\"KEY\");\n-                read(\"UPDATE\");\n-                do {\n-                    Column column = parseColumn(table);\n-                    read(\"=\");\n-                    Expression expression;\n-                    if (readIf(\"DEFAULT\")) {\n-                        expression = ValueExpression.getDefault();\n-                    } else {\n-                        expression = readExpression();\n-                    }\n-                    command.addAssignmentForDuplicate(column, expression);\n-                } while (readIf(\",\"));\n-            }\n+        s = currentToken;\n+        read();\n+      }\n+    }\n+    return s;\n+  }\n+\n+  private String readIdentifierWithSchema() {\n+    return readIdentifierWithSchema(session.getCurrentSchemaName());\n+  }\n+\n+  private String readAliasIdentifier() {\n+    return readColumnIdentifier();\n+  }\n+\n+  private String readUniqueIdentifier() {\n+    return readColumnIdentifier();\n+  }\n+\n+  private String readColumnIdentifier() {\n+    if (currentTokenType != IDENTIFIER) {\n+      throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+          \"identifier\");\n+    }\n+    String s = currentToken;\n+    read();\n+    return s;\n+  }\n+\n+  private void read(String expected) {\n+    if (currentTokenQuoted || !equalsToken(expected, currentToken)) {\n+      addExpected(expected);\n+      throw getSyntaxError();\n+    }\n+    read();\n+  }\n+\n+  private boolean readIf(String token) {\n+    if (!currentTokenQuoted && equalsToken(token, currentToken)) {\n+      read();\n+      return true;\n+    }\n+    addExpected(token);\n+    return false;\n+  }\n+\n+  /*\n+   * Reads passed token in list, in order and returns true on first match.\n+   * If none of the token matches returns false\n+   */\n+  private boolean readIfOr(String... tokens) {\n+    for (String token : tokens) {\n+      if (readIf(token)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /*\n+   * Reads every token in list, in order - returns true if all are found.\n+   * If any are not found, returns false - AND resets parsing back to state when called.\n+   */\n+  private boolean readIfAll(String... tokens) {\n+    // save parse location in case we have to fail this test\n+    int start = lastParseIndex;\n+    for (String token : tokens) {\n+      if (!currentTokenQuoted && equalsToken(token, currentToken)) {\n+        read();\n+      } else {\n+        // read failed - revert parse location to before when called\n+        parseIndex = start;\n+        read();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isToken(String token) {\n+    boolean result = equalsToken(token, currentToken) &&\n+        !currentTokenQuoted;\n+    if (result) {\n+      return true;\n+    }\n+    addExpected(token);\n+    return false;\n+  }\n+\n+  private boolean equalsToken(String a, String b) {\n+    if (a == null) {\n+      return b == null;\n+    } else if (a.equals(b)) {\n+      return true;\n+    } else if (!identifiersToUpper && a.equalsIgnoreCase(b)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private static boolean equalsTokenIgnoreCase(String a, String b) {\n+    if (a == null) {\n+      return b == null;\n+    } else if (a.equals(b)) {\n+      return true;\n+    } else if (a.equalsIgnoreCase(b)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTokenInList(Collection<String> upperCaseTokenList) {\n+    String upperCaseCurrentToken = currentToken.toUpperCase();\n+    return upperCaseTokenList.contains(upperCaseCurrentToken);\n+  }\n+\n+  private void addExpected(String token) {\n+    if (expectedList != null) {\n+      expectedList.add(token);\n+    }\n+  }\n+\n+  private void read() {\n+    currentTokenQuoted = false;\n+    if (expectedList != null) {\n+      expectedList.clear();\n+    }\n+    int[] types = characterTypes;\n+    lastParseIndex = parseIndex;\n+    int i = parseIndex;\n+    int type = types[i];\n+    while (type == 0) {\n+      type = types[++i];\n+    }\n+    int start = i;\n+    char[] chars = sqlCommandChars;\n+    char c = chars[i++];\n+    currentToken = \"\";\n+    switch (type) {\n+      case CHAR_NAME:\n+        while (true) {\n+          type = types[i];\n+          if (type != CHAR_NAME && type != CHAR_VALUE) {\n+            break;\n+          }\n+          i++;\n         }\n-        if (database.getMode().isolationLevelInSelectOrInsertStatement) {\n-            parseIsolationClause();\n+        currentToken = StringUtils.cache(sqlCommand.substring(\n+            start, i));\n+        currentTokenType = getTokenType(currentToken);\n+        parseIndex = i;\n+        return;\n+      case CHAR_QUOTED: {\n+        String result = null;\n+        while (true) {\n+          for (int begin = i; ; i++) {\n+            if (chars[i] == '\\\"') {\n+              if (result == null) {\n+                result = sqlCommand.substring(begin, i);\n+              } else {\n+                result += sqlCommand.substring(begin - 1, i);\n+              }\n+              break;\n+            }\n+          }\n+          if (chars[++i] != '\\\"') {\n+            break;\n+          }\n+          i++;\n         }\n-        return command;\n-    }\n-\n-    private Insert parseInsertGivenTable(Insert command, Table table) {\n-        Column[] columns = null;\n-        if (readIf(\"(\")) {\n-            if (isSelect()) {\n-                command.setQuery(parseSelect());\n-                read(\")\");\n-                return command;\n+        currentToken = StringUtils.cache(result);\n+        parseIndex = i;\n+        currentTokenQuoted = true;\n+        currentTokenType = IDENTIFIER;\n+        return;\n+      }\n+      case CHAR_SPECIAL_2:\n+        if (types[i] == CHAR_SPECIAL_2) {\n+          i++;\n+        }\n+        currentToken = sqlCommand.substring(start, i);\n+        currentTokenType = getSpecialType(currentToken);\n+        parseIndex = i;\n+        return;\n+      case CHAR_SPECIAL_1:\n+        currentToken = sqlCommand.substring(start, i);\n+        currentTokenType = getSpecialType(currentToken);\n+        parseIndex = i;\n+        return;\n+      case CHAR_VALUE:\n+        if (c == '0' && chars[i] == 'X') {\n+          // hex number\n+          long number = 0;\n+          start += 2;\n+          i++;\n+          while (true) {\n+            c = chars[i];\n+            if ((c < '0' || c > '9') && (c < 'A' || c > 'F')) {\n+              checkLiterals(false);\n+              currentValue = ValueInt.get((int) number);\n+              currentTokenType = VALUE;\n+              currentToken = \"0\";\n+              parseIndex = i;\n+              return;\n+            }\n+            number = (number << 4) + c -\n+                (c >= 'A' ? ('A' - 0xa) : ('0'));\n+            if (number > Integer.MAX_VALUE) {\n+              readHexDecimal(start, i);\n+              return;\n             }\n-            columns = parseColumnList(table);\n-            command.setColumns(columns);\n-        }\n-        if (readIf(\"DIRECT\")) {\n-            command.setInsertFromSelect(true);\n-        }\n-        if (readIf(\"SORTED\")) {\n-            command.setSortedInsertMode(true);\n+            i++;\n+          }\n         }\n-        if (readIf(\"DEFAULT\")) {\n-            read(\"VALUES\");\n-            Expression[] expr = {};\n-            command.addRow(expr);\n-        } else if (readIf(\"VALUES\")) {\n-            read(\"(\");\n-            do {\n-                ArrayList<Expression> values = New.arrayList();\n-                if (!readIf(\")\")) {\n-                    do {\n-                        if (readIf(\"DEFAULT\")) {\n-                            values.add(null);\n-                        } else {\n-                            values.add(readExpression());\n-                        }\n-                    } while (readIfMore());\n-                }\n-                command.addRow(values.toArray(new Expression[0]));\n-                // the following condition will allow (..),; and (..);\n-            } while (readIf(\",\") && readIf(\"(\"));\n-        } else if (readIf(\"SET\")) {\n-            if (columns != null) {\n-                throw getSyntaxError();\n-            }\n-            ArrayList<Column> columnList = New.arrayList();\n-            ArrayList<Expression> values = New.arrayList();\n-            do {\n-                columnList.add(parseColumn(table));\n-                read(\"=\");\n-                Expression expression;\n-                if (readIf(\"DEFAULT\")) {\n-                    expression = ValueExpression.getDefault();\n-                } else {\n-                    expression = readExpression();\n-                }\n-                values.add(expression);\n-            } while (readIf(\",\"));\n-            command.setColumns(columnList.toArray(new Column[0]));\n-            command.addRow(values.toArray(new Expression[0]));\n-        } else {\n-            command.setQuery(parseSelect());\n+        long number = c - '0';\n+        while (true) {\n+          c = chars[i];\n+          if (c < '0' || c > '9') {\n+            if (c == '.' || c == 'E' || c == 'L') {\n+              readDecimal(start, i);\n+              break;\n+            }\n+            checkLiterals(false);\n+            currentValue = ValueInt.get((int) number);\n+            currentTokenType = VALUE;\n+            currentToken = \"0\";\n+            parseIndex = i;\n+            break;\n+          }\n+          number = number * 10 + (c - '0');\n+          if (number > Integer.MAX_VALUE) {\n+            readDecimal(start, i);\n+            break;\n+          }\n+          i++;\n+        }\n+        return;\n+      case CHAR_DOT:\n+        if (types[i] != CHAR_VALUE) {\n+          currentTokenType = KEYWORD;\n+          currentToken = \".\";\n+          parseIndex = i;\n+          return;\n+        }\n+        readDecimal(i - 1, i);\n+        return;\n+      case CHAR_STRING: {\n+        String result = null;\n+        while (true) {\n+          for (int begin = i; ; i++) {\n+            if (chars[i] == '\\'') {\n+              if (result == null) {\n+                result = sqlCommand.substring(begin, i);\n+              } else {\n+                result += sqlCommand.substring(begin - 1, i);\n+              }\n+              break;\n+            }\n+          }\n+          if (chars[++i] != '\\'') {\n+            break;\n+          }\n+          i++;\n         }\n-        return null;\n+        currentToken = \"'\";\n+        checkLiterals(true);\n+        currentValue = ValueString.get(StringUtils.cache(result),\n+            database.getMode().treatEmptyStringsAsNull);\n+        parseIndex = i;\n+        currentTokenType = VALUE;\n+        return;\n+      }\n+      case CHAR_DOLLAR_QUOTED_STRING: {\n+        String result = null;\n+        int begin = i - 1;\n+        while (types[i] == CHAR_DOLLAR_QUOTED_STRING) {\n+          i++;\n+        }\n+        result = sqlCommand.substring(begin, i);\n+        currentToken = \"'\";\n+        checkLiterals(true);\n+        currentValue = ValueString.get(StringUtils.cache(result),\n+            database.getMode().treatEmptyStringsAsNull);\n+        parseIndex = i;\n+        currentTokenType = VALUE;\n+        return;\n+      }\n+      case CHAR_END:\n+        currentToken = \"\";\n+        currentTokenType = END;\n+        parseIndex = i;\n+        return;\n+      default:\n+        throw getSyntaxError();\n     }\n+  }\n \n-    /**\n-     * MySQL compatibility. REPLACE is similar to MERGE.\n-     */\n-    private Replace parseReplace() {\n-        Replace command = new Replace(session);\n-        currentPrepared = command;\n-        read(\"INTO\");\n-        Table table = readTableOrView();\n-        command.setTable(table);\n-        if (readIf(\"(\")) {\n-            if (isSelect()) {\n-                command.setQuery(parseSelect());\n-                read(\")\");\n-                return command;\n-            }\n-            Column[] columns = parseColumnList(table);\n-            command.setColumns(columns);\n-        }\n-        if (readIf(\"VALUES\")) {\n-            do {\n-                ArrayList<Expression> values = New.arrayList();\n-                read(\"(\");\n-                if (!readIf(\")\")) {\n-                    do {\n-                        if (readIf(\"DEFAULT\")) {\n-                            values.add(null);\n-                        } else {\n-                            values.add(readExpression());\n-                        }\n-                    } while (readIfMore());\n-                }\n-                command.addRow(values.toArray(new Expression[0]));\n-            } while (readIf(\",\"));\n-        } else {\n-            command.setQuery(parseSelect());\n-        }\n-        return command;\n-    }\n+  private void readParameterIndex() {\n+    int i = parseIndex;\n \n-    private TableFilter readTableFilter() {\n-        Table table;\n-        String alias = null;\n-        if (readIf(\"(\")) {\n-            if (isSelect()) {\n-                Query query = parseSelectUnion();\n-                read(\")\");\n-                query.setParameterList(new ArrayList<>(parameters));\n-                query.init();\n-                Session s;\n-                if (createView != null) {\n-                    s = database.getSystemSession();\n-                } else {\n-                    s = session;\n-                }\n-                alias = session.getNextSystemIdentifier(sqlCommand);\n-                table = TableView.createTempView(s, session.getUser(), alias,\n-                        query, currentSelect);\n+    char[] chars = sqlCommandChars;\n+    char c = chars[i++];\n+    long number = c - '0';\n+    while (true) {\n+      c = chars[i];\n+      if (c < '0' || c > '9') {\n+        currentValue = ValueInt.get((int) number);\n+        currentTokenType = VALUE;\n+        currentToken = \"0\";\n+        parseIndex = i;\n+        break;\n+      }\n+      number = number * 10 + (c - '0');\n+      if (number > Integer.MAX_VALUE) {\n+        throw DbException.getInvalidValueException(\n+            \"parameter index\", number);\n+      }\n+      i++;\n+    }\n+  }\n+\n+  private void checkLiterals(boolean text) {\n+    if (!literalsChecked && !session.getAllowLiterals()) {\n+      int allowed = database.getAllowLiterals();\n+      if (allowed == Constants.ALLOW_LITERALS_NONE ||\n+          (text && allowed != Constants.ALLOW_LITERALS_ALL)) {\n+        throw DbException.get(ErrorCode.LITERALS_ARE_NOT_ALLOWED);\n+      }\n+    }\n+  }\n+\n+  private void readHexDecimal(int start, int i) {\n+    char[] chars = sqlCommandChars;\n+    char c;\n+    do {\n+      c = chars[++i];\n+    } while ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F'));\n+    parseIndex = i;\n+    String sub = sqlCommand.substring(start, i);\n+    BigDecimal bd = new BigDecimal(new BigInteger(sub, 16));\n+    checkLiterals(false);\n+    currentValue = ValueDecimal.get(bd);\n+    currentTokenType = VALUE;\n+  }\n+\n+  private void readDecimal(int start, int i) {\n+    char[] chars = sqlCommandChars;\n+    int[] types = characterTypes;\n+    // go until the first non-number\n+    while (true) {\n+      int t = types[i];\n+      if (t != CHAR_DOT && t != CHAR_VALUE) {\n+        break;\n+      }\n+      i++;\n+    }\n+    boolean containsE = false;\n+    if (chars[i] == 'E' || chars[i] == 'e') {\n+      containsE = true;\n+      i++;\n+      if (chars[i] == '+' || chars[i] == '-') {\n+        i++;\n+      }\n+      if (types[i] != CHAR_VALUE) {\n+        throw getSyntaxError();\n+      }\n+      while (types[++i] == CHAR_VALUE) {\n+        // go until the first non-number\n+      }\n+    }\n+    parseIndex = i;\n+    String sub = sqlCommand.substring(start, i);\n+    checkLiterals(false);\n+    if (!containsE && sub.indexOf('.') < 0) {\n+      BigInteger bi = new BigInteger(sub);\n+      if (bi.compareTo(ValueLong.MAX_BI) <= 0) {\n+        // parse constants like \"10000000L\"\n+        if (chars[i] == 'L') {\n+          parseIndex++;\n+        }\n+        currentValue = ValueLong.get(bi.longValue());\n+        currentTokenType = VALUE;\n+        return;\n+      }\n+    }\n+    BigDecimal bd;\n+    try {\n+      bd = new BigDecimal(sub);\n+    } catch (NumberFormatException e) {\n+      throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1, e, sub);\n+    }\n+    currentValue = ValueDecimal.get(bd);\n+    currentTokenType = VALUE;\n+  }\n+\n+  public Session getSession() {\n+    return session;\n+  }\n+\n+  private void initialize(String sql) {\n+    if (sql == null) {\n+      sql = \"\";\n+    }\n+    originalSQL = sql;\n+    sqlCommand = sql;\n+    int len = sql.length() + 1;\n+    char[] command = new char[len];\n+    int[] types = new int[len];\n+    len--;\n+    sql.getChars(0, len, command, 0);\n+    boolean changed = false;\n+    command[len] = ' ';\n+    int startLoop = 0;\n+    int lastType = 0;\n+    for (int i = 0; i < len; i++) {\n+      char c = command[i];\n+      int type = 0;\n+      switch (c) {\n+        case '/':\n+          if (command[i + 1] == '*') {\n+            // block comment\n+            changed = true;\n+            command[i] = ' ';\n+            command[i + 1] = ' ';\n+            startLoop = i;\n+            i += 2;\n+            checkRunOver(i, len, startLoop);\n+            while (command[i] != '*' || command[i + 1] != '/') {\n+              command[i++] = ' ';\n+              checkRunOver(i, len, startLoop);\n+            }\n+            command[i] = ' ';\n+            command[i + 1] = ' ';\n+            i++;\n+          } else if (command[i + 1] == '/') {\n+            // single line comment\n+            changed = true;\n+            startLoop = i;\n+            while (true) {\n+              c = command[i];\n+              if (c == '\\n' || c == '\\r' || i >= len - 1) {\n+                break;\n+              }\n+              command[i++] = ' ';\n+              checkRunOver(i, len, startLoop);\n+            }\n+          } else {\n+            type = CHAR_SPECIAL_1;\n+          }\n+          break;\n+        case '-':\n+          if (command[i + 1] == '-') {\n+            // single line comment\n+            changed = true;\n+            startLoop = i;\n+            while (true) {\n+              c = command[i];\n+              if (c == '\\n' || c == '\\r' || i >= len - 1) {\n+                break;\n+              }\n+              command[i++] = ' ';\n+              checkRunOver(i, len, startLoop);\n+            }\n+          } else {\n+            type = CHAR_SPECIAL_1;\n+          }\n+          break;\n+        case '$':\n+          if (command[i + 1] == '$' && (i == 0 || command[i - 1] <= ' ')) {\n+            // dollar quoted string\n+            changed = true;\n+            command[i] = ' ';\n+            command[i + 1] = ' ';\n+            startLoop = i;\n+            i += 2;\n+            checkRunOver(i, len, startLoop);\n+            while (command[i] != '$' || command[i + 1] != '$') {\n+              types[i++] = CHAR_DOLLAR_QUOTED_STRING;\n+              checkRunOver(i, len, startLoop);\n+            }\n+            command[i] = ' ';\n+            command[i + 1] = ' ';\n+            i++;\n+          } else {\n+            if (lastType == CHAR_NAME || lastType == CHAR_VALUE) {\n+              // $ inside an identifier is supported\n+              type = CHAR_NAME;\n             } else {\n-                TableFilter top;\n-                top = readTableFilter();\n-                top = readJoin(top);\n-                read(\")\");\n-                alias = readFromAlias(null);\n-                if (alias != null) {\n-                    top.setAlias(alias);\n-                }\n-                return top;\n-            }\n-        } else if (readIf(\"VALUES\")) {\n-            table = parseValuesTable(0).getTable();\n-        } else {\n-            String tableName = readIdentifierWithSchema(null);\n-            Schema schema = getSchema();\n-            boolean foundLeftBracket = readIf(\"(\");\n-            if (foundLeftBracket && readIf(\"INDEX\")) {\n-                // Sybase compatibility with\n-                // \"select * from test (index table1_index)\"\n-                readIdentifierWithSchema(null);\n-                read(\")\");\n-                foundLeftBracket = false;\n-            }\n-            if (foundLeftBracket) {\n-                Schema mainSchema = database.getSchema(Constants.SCHEMA_MAIN);\n-                if (equalsToken(tableName, RangeTable.NAME)\n-                        || equalsToken(tableName, RangeTable.ALIAS)) {\n-                    Expression min = readExpression();\n-                    read(\",\");\n-                    Expression max = readExpression();\n-                    if (readIf(\",\")) {\n-                        Expression step = readExpression();\n-                        read(\")\");\n-                        table = new RangeTable(mainSchema, min, max, step,\n-                                false);\n-                    } else {\n-                        read(\")\");\n-                        table = new RangeTable(mainSchema, min, max, false);\n-                    }\n-                } else {\n-                    Expression expr = readFunction(schema, tableName);\n-                    if (!(expr instanceof FunctionCall)) {\n-                        throw getSyntaxError();\n-                    }\n-                    FunctionCall call = (FunctionCall) expr;\n-                    if (!call.isDeterministic()) {\n-                        recompileAlways = true;\n-                    }\n-                    table = new FunctionTable(mainSchema, session, expr, call);\n-                }\n-            } else if (equalsToken(\"DUAL\", tableName)) {\n-                table = getDualTable(false);\n-            } else if (database.getMode().sysDummy1 &&\n-                    equalsToken(\"SYSDUMMY1\", tableName)) {\n-                table = getDualTable(false);\n+              // but not at the start, to support PostgreSQL $1\n+              type = CHAR_SPECIAL_1;\n+            }\n+          }\n+          break;\n+        case '(':\n+        case ')':\n+        case '{':\n+        case '}':\n+        case '*':\n+        case ',':\n+        case ';':\n+        case '+':\n+        case '%':\n+        case '?':\n+        case '@':\n+        case ']':\n+          type = CHAR_SPECIAL_1;\n+          break;\n+        case '!':\n+        case '<':\n+        case '>':\n+        case '|':\n+        case '=':\n+        case ':':\n+        case '&':\n+        case '~':\n+          type = CHAR_SPECIAL_2;\n+          break;\n+        case '.':\n+          type = CHAR_DOT;\n+          break;\n+        case '\\'':\n+          type = types[i] = CHAR_STRING;\n+          startLoop = i;\n+          while (command[++i] != '\\'') {\n+            checkRunOver(i, len, startLoop);\n+          }\n+          break;\n+        case '[':\n+          if (database.getMode().squareBracketQuotedNames) {\n+            // SQL Server alias for \"\n+            command[i] = '\"';\n+            changed = true;\n+            type = types[i] = CHAR_QUOTED;\n+            startLoop = i;\n+            while (command[++i] != ']') {\n+              checkRunOver(i, len, startLoop);\n+            }\n+            command[i] = '\"';\n+          } else {\n+            type = CHAR_SPECIAL_1;\n+          }\n+          break;\n+        case '`':\n+          // MySQL alias for \", but not case sensitive\n+          command[i] = '\"';\n+          changed = true;\n+          type = types[i] = CHAR_QUOTED;\n+          startLoop = i;\n+          while (command[++i] != '`') {\n+            checkRunOver(i, len, startLoop);\n+            c = command[i];\n+            command[i] = Character.toUpperCase(c);\n+          }\n+          command[i] = '\"';\n+          break;\n+        case '\\\"':\n+          type = types[i] = CHAR_QUOTED;\n+          startLoop = i;\n+          while (command[++i] != '\\\"') {\n+            checkRunOver(i, len, startLoop);\n+          }\n+          break;\n+        case '_':\n+          type = CHAR_NAME;\n+          break;\n+        case '#':\n+          if (database.getMode().supportPoundSymbolForColumnNames) {\n+            type = CHAR_NAME;\n+          } else {\n+            type = CHAR_SPECIAL_1;\n+          }\n+          break;\n+        default:\n+          if (c >= 'a' && c <= 'z') {\n+            if (identifiersToUpper) {\n+              command[i] = (char) (c - ('a' - 'A'));\n+              changed = true;\n+            }\n+            type = CHAR_NAME;\n+          } else if (c >= 'A' && c <= 'Z') {\n+            type = CHAR_NAME;\n+          } else if (c >= '0' && c <= '9') {\n+            type = CHAR_VALUE;\n+          } else {\n+            if (c <= ' ' || Character.isSpaceChar(c)) {\n+              // whitespace\n+            } else if (Character.isJavaIdentifierPart(c)) {\n+              type = CHAR_NAME;\n+              if (identifiersToUpper) {\n+                char u = Character.toUpperCase(c);\n+                if (u != c) {\n+                  command[i] = u;\n+                  changed = true;\n+                }\n+              }\n             } else {\n-                table = readTableOrView(tableName);\n-            }\n+              type = CHAR_SPECIAL_1;\n+            }\n+          }\n+      }\n+      types[i] = type;\n+      lastType = type;\n+    }\n+    sqlCommandChars = command;\n+    types[len] = CHAR_END;\n+    characterTypes = types;\n+    if (changed) {\n+      sqlCommand = new String(command);\n+    }\n+    parseIndex = 0;\n+  }\n+\n+  private void checkRunOver(int i, int len, int startLoop) {\n+    if (i >= len) {\n+      parseIndex = startLoop;\n+      throw getSyntaxError();\n+    }\n+  }\n+\n+  private int getSpecialType(String s) {\n+    char c0 = s.charAt(0);\n+    if (s.length() == 1) {\n+      switch (c0) {\n+        case '?':\n+        case '$':\n+          return PARAMETER;\n+        case '@':\n+          return AT;\n+        case '+':\n+          return PLUS;\n+        case '-':\n+          return MINUS;\n+        case '{':\n+        case '}':\n+        case '*':\n+        case '/':\n+        case '%':\n+        case ';':\n+        case ',':\n+        case ':':\n+        case '[':\n+        case ']':\n+        case '~':\n+          return KEYWORD;\n+        case '(':\n+          return OPEN;\n+        case ')':\n+          return CLOSE;\n+        case '<':\n+          return SMALLER;\n+        case '>':\n+          return BIGGER;\n+        case '=':\n+          return EQUAL;\n+        default:\n+          break;\n+      }\n+    } else if (s.length() == 2) {\n+      switch (c0) {\n+        case ':':\n+          if (\"::\".equals(s)) {\n+            return KEYWORD;\n+          } else if (\":=\".equals(s)) {\n+            return KEYWORD;\n+          }\n+          break;\n+        case '>':\n+          if (\">=\".equals(s)) {\n+            return BIGGER_EQUAL;\n+          }\n+          break;\n+        case '<':\n+          if (\"<=\".equals(s)) {\n+            return SMALLER_EQUAL;\n+          } else if (\"<>\".equals(s)) {\n+            return NOT_EQUAL;\n+          }\n+          break;\n+        case '!':\n+          if (\"!=\".equals(s)) {\n+            return NOT_EQUAL;\n+          } else if (\"!~\".equals(s)) {\n+            return KEYWORD;\n+          }\n+          break;\n+        case '|':\n+          if (\"||\".equals(s)) {\n+            return STRING_CONCAT;\n+          }\n+          break;\n+        case '&':\n+          if (\"&&\".equals(s)) {\n+            return SPATIAL_INTERSECTS;\n+          }\n+          break;\n+      }\n+    }\n+    throw getSyntaxError();\n+  }\n+\n+  private int getTokenType(String s) {\n+    int len = s.length();\n+    if (len == 0) {\n+      throw getSyntaxError();\n+    }\n+    if (!identifiersToUpper) {\n+      // if not yet converted to uppercase, do it now\n+      s = StringUtils.toUpperEnglish(s);\n+    }\n+    return getSaveTokenType(s, database.getMode().supportOffsetFetch, false);\n+  }\n+\n+  private boolean isKeyword(String s) {\n+    if (!identifiersToUpper) {\n+      // if not yet converted to uppercase, do it now\n+      s = StringUtils.toUpperEnglish(s);\n+    }\n+    return ParserUtil.isKeyword(s, false);\n+  }\n+\n+  private static int getSaveTokenType(String s, boolean supportOffsetFetch,\n+                                      boolean functionsAsKeywords) {\n+    return ParserUtil\n+        .getSaveTokenType(s, supportOffsetFetch, functionsAsKeywords);\n+  }\n+\n+  private Column parseColumnForTable(String columnName,\n+                                     boolean defaultNullable) {\n+    Column column;\n+    boolean isIdentity = readIf(\"IDENTITY\");\n+    if (isIdentity || readIf(\"BIGSERIAL\")) {\n+      // Check if any of them are disallowed in the current Mode\n+      if (isIdentity && database.getMode().\n+          disallowedTypes.contains(\"IDENTITY\")) {\n+        throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n+            currentToken);\n+      }\n+      column = new Column(columnName, Value.LONG);\n+      column.setOriginalSQL(\"IDENTITY\");\n+      parseAutoIncrement(column);\n+      // PostgreSQL compatibility\n+      if (!database.getMode().serialColumnIsNotPK) {\n+        column.setPrimaryKey(true);\n+      }\n+    } else if (readIf(\"SERIAL\")) {\n+      column = new Column(columnName, Value.INT);\n+      column.setOriginalSQL(\"SERIAL\");\n+      parseAutoIncrement(column);\n+      // PostgreSQL compatibility\n+      if (!database.getMode().serialColumnIsNotPK) {\n+        column.setPrimaryKey(true);\n+      }\n+    } else {\n+      column = parseColumnWithType(columnName);\n+    }\n+    if (readIf(\"INVISIBLE\")) {\n+      column.setVisible(false);\n+    } else if (readIf(\"VISIBLE\")) {\n+      column.setVisible(true);\n+    }\n+    NullConstraintType nullConstraint = parseNotNullConstraint();\n+    switch (nullConstraint) {\n+      case NULL_IS_ALLOWED:\n+        column.setNullable(true);\n+        break;\n+      case NULL_IS_NOT_ALLOWED:\n+        column.setNullable(false);\n+        break;\n+      case NO_NULL_CONSTRAINT_FOUND:\n+        // domains may be defined as not nullable\n+        column.setNullable(defaultNullable & column.isNullable());\n+        break;\n+      default:\n+        throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n+            \"Internal Error - unhandled case: \" + nullConstraint.name());\n+    }\n+    if (readIf(\"AS\")) {\n+      if (isIdentity) {\n+        getSyntaxError();\n+      }\n+      Expression expr = readExpression();\n+      column.setComputedExpression(expr);\n+    } else if (readIf(\"DEFAULT\")) {\n+      Expression defaultExpression = readExpression();\n+      column.setDefaultExpression(session, defaultExpression);\n+    } else if (readIf(\"GENERATED\")) {\n+      if (!readIf(\"ALWAYS\")) {\n+        read(\"BY\");\n+        read(\"DEFAULT\");\n+      }\n+      read(\"AS\");\n+      read(\"IDENTITY\");\n+      long start = 1, increment = 1;\n+      if (readIf(\"(\")) {\n+        read(\"START\");\n+        readIf(\"WITH\");\n+        start = readLong();\n+        readIf(\",\");\n+        if (readIf(\"INCREMENT\")) {\n+          readIf(\"BY\");\n+          increment = readLong();\n         }\n-        IndexHints indexHints = null;\n-        // for backward compatibility, handle case where USE is a table alias\n-        if (readIf(\"USE\")) {\n-            if (readIf(\"INDEX\")) {\n-                indexHints = parseIndexHints(table);\n+        read(\")\");\n+      }\n+      column.setPrimaryKey(true);\n+      column.setAutoIncrement(true, start, increment);\n+    }\n+    if (NullConstraintType.NULL_IS_NOT_ALLOWED == parseNotNullConstraint()) {\n+      column.setNullable(false);\n+    }\n+    if (readIf(\"AUTO_INCREMENT\") || readIf(\"BIGSERIAL\") || readIf(\"SERIAL\")) {\n+      parseAutoIncrement(column);\n+      parseNotNullConstraint();\n+    } else if (readIf(\"IDENTITY\")) {\n+      parseAutoIncrement(column);\n+      column.setPrimaryKey(true);\n+      parseNotNullConstraint();\n+    }\n+    if (readIf(\"NULL_TO_DEFAULT\")) {\n+      column.setConvertNullToDefault(true);\n+    }\n+    if (readIf(\"SEQUENCE\")) {\n+      Sequence sequence = readSequence();\n+      column.setSequence(sequence);\n+    }\n+    if (readIf(\"SELECTIVITY\")) {\n+      int value = readPositiveInt();\n+      column.setSelectivity(value);\n+    }\n+    String comment = readCommentIf();\n+    if (comment != null) {\n+      column.setComment(comment);\n+    }\n+    return column;\n+  }\n+\n+  private void parseAutoIncrement(Column column) {\n+    long start = 1, increment = 1;\n+    if (readIf(\"(\")) {\n+      start = readLong();\n+      if (readIf(\",\")) {\n+        increment = readLong();\n+      }\n+      read(\")\");\n+    }\n+    column.setAutoIncrement(true, start, increment);\n+  }\n+\n+  private String readCommentIf() {\n+    if (readIf(\"COMMENT\")) {\n+      readIf(\"IS\");\n+      return readString();\n+    }\n+    return null;\n+  }\n+\n+  private Column parseColumnWithType(String columnName) {\n+    String original = currentToken;\n+    boolean regular = false;\n+    if (readIf(\"LONG\")) {\n+      if (readIf(\"RAW\")) {\n+        original += \" RAW\";\n+      }\n+    } else if (readIf(\"DOUBLE\")) {\n+      if (readIf(\"PRECISION\")) {\n+        original += \" PRECISION\";\n+      }\n+    } else if (readIf(\"CHARACTER\")) {\n+      if (readIf(\"VARYING\")) {\n+        original += \" VARYING\";\n+      }\n+    } else if (readIf(\"TIME\")) {\n+      if (readIf(\"WITHOUT\")) {\n+        read(\"TIME\");\n+        read(\"ZONE\");\n+        original += \" WITHOUT TIME ZONE\";\n+      }\n+    } else if (readIf(\"TIMESTAMP\")) {\n+      if (readIf(\"WITH\")) {\n+        read(\"TIME\");\n+        read(\"ZONE\");\n+        original += \" WITH TIME ZONE\";\n+      } else if (readIf(\"WITHOUT\")) {\n+        read(\"TIME\");\n+        read(\"ZONE\");\n+        original += \" WITHOUT TIME ZONE\";\n+      }\n+    } else {\n+      regular = true;\n+    }\n+    long precision = -1;\n+    int displaySize = -1;\n+    String[] enumerators = null;\n+    int scale = -1;\n+    String comment = null;\n+    Column templateColumn = null;\n+    DataType dataType;\n+    if (!identifiersToUpper) {\n+      original = StringUtils.toUpperEnglish(original);\n+    }\n+    UserDataType userDataType = database.findUserDataType(original);\n+    if (userDataType != null) {\n+      templateColumn = userDataType.getColumn();\n+      dataType = DataType.getDataType(templateColumn.getType());\n+      comment = templateColumn.getComment();\n+      original = templateColumn.getOriginalSQL();\n+      precision = templateColumn.getPrecision();\n+      displaySize = templateColumn.getDisplaySize();\n+      scale = templateColumn.getScale();\n+      enumerators = templateColumn.getEnumerators();\n+    } else {\n+      Mode mode = database.getMode();\n+      dataType = DataType.getTypeByName(original, mode);\n+      if (dataType == null || mode.disallowedTypes.contains(original)) {\n+        throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n+            currentToken);\n+      }\n+    }\n+    if (database.getIgnoreCase() && dataType.type == Value.STRING &&\n+        !equalsToken(\"VARCHAR_CASESENSITIVE\", original)) {\n+      original = \"VARCHAR_IGNORECASE\";\n+      dataType = DataType.getTypeByName(original, database.getMode());\n+    }\n+    if (regular) {\n+      read();\n+    }\n+    precision = precision == -1 ? dataType.defaultPrecision : precision;\n+    displaySize = displaySize == -1 ? dataType.defaultDisplaySize\n+        : displaySize;\n+    scale = scale == -1 ? dataType.defaultScale : scale;\n+    if (dataType.supportsPrecision || dataType.supportsScale) {\n+      if (readIf(\"(\")) {\n+        if (!readIf(\"MAX\")) {\n+          long p = readLong();\n+          if (readIf(\"K\")) {\n+            p *= 1024;\n+          } else if (readIf(\"M\")) {\n+            p *= 1024 * 1024;\n+          } else if (readIf(\"G\")) {\n+            p *= 1024 * 1024 * 1024;\n+          }\n+          if (p > Long.MAX_VALUE) {\n+            p = Long.MAX_VALUE;\n+          }\n+          original += \"(\" + p;\n+          // Oracle syntax\n+          readIfOr(\"CHAR\", \"BYTE\");\n+          if (dataType.supportsScale) {\n+            if (readIf(\",\")) {\n+              scale = readInt();\n+              original += \", \" + scale;\n             } else {\n-                alias = \"USE\";\n-            }\n-        } else {\n-            alias = readFromAlias(alias);\n-            if (alias != null) {\n-                // if alias present, a second chance to parse index hints\n-                if (readIf(\"USE\")) {\n-                    read(\"INDEX\");\n-                    indexHints = parseIndexHints(table);\n-                }\n-            }\n+              // special case: TIMESTAMP(5) actually means\n+              // TIMESTAMP(23, 5)\n+              if (dataType.type == Value.TIMESTAMP) {\n+                scale = MathUtils.convertLongToInt(p);\n+                p = precision;\n+              } else {\n+                scale = 0;\n+              }\n+            }\n+          }\n+          precision = p;\n+          displaySize = MathUtils.convertLongToInt(precision);\n+          original += \")\";\n         }\n-        // inherit alias for CTE as views from table name\n-        if (table.isView() && table.isTableExpression() && alias == null) {\n-            alias = table.getName();\n+        read(\")\");\n+      }\n+    } else if (dataType.type == Value.ENUM) {\n+      if (readIf(\"(\")) {\n+        java.util.List<String> enumeratorList = new ArrayList<>();\n+        original += '(';\n+        String enumerator0 = readString();\n+        enumeratorList.add(enumerator0);\n+        original += \"'\" + enumerator0 + \"'\";\n+        while (readIf(\",\")) {\n+          original += ',';\n+          String enumeratorN = readString();\n+          original += \"'\" + enumeratorN + \"'\";\n+          enumeratorList.add(enumeratorN);\n         }\n-        return new TableFilter(session, table, alias, rightsChecked,\n-                currentSelect, orderInFrom++, indexHints);\n-    }\n-\n-    private IndexHints parseIndexHints(Table table) {\n-        if (table == null) {\n-            throw getSyntaxError();\n+        read(\")\");\n+        original += ')';\n+        enumerators = enumeratorList.toArray(new String[0]);\n+      }\n+      try {\n+        ValueEnum.check(enumerators);\n+      } catch (DbException e) {\n+        throw e.addSQL(original);\n+      }\n+    } else if (readIf(\"(\")) {\n+      // Support for MySQL: INT(11), MEDIUMINT(8) and so on.\n+      // Just ignore the precision.\n+      readPositiveInt();\n+      read(\")\");\n+    }\n+    if (readIf(\"FOR\")) {\n+      read(\"BIT\");\n+      read(\"DATA\");\n+      if (dataType.type == Value.STRING) {\n+        dataType = DataType.getTypeByName(\"BINARY\", database.getMode());\n+      }\n+    }\n+    // MySQL compatibility\n+    readIf(\"UNSIGNED\");\n+    int type = dataType.type;\n+    if (scale > precision) {\n+      throw DbException.get(ErrorCode.INVALID_VALUE_SCALE_PRECISION,\n+          Integer.toString(scale), Long.toString(precision));\n+    }\n+\n+\n+    Column column = new Column(columnName, type, precision, scale,\n+        displaySize, enumerators);\n+    if (templateColumn != null) {\n+      column.setNullable(templateColumn.isNullable());\n+      column.setDefaultExpression(session,\n+          templateColumn.getDefaultExpression());\n+      int selectivity = templateColumn.getSelectivity();\n+      if (selectivity != Constants.SELECTIVITY_DEFAULT) {\n+        column.setSelectivity(selectivity);\n+      }\n+      Expression checkConstraint = templateColumn.getCheckConstraint(\n+          session, columnName);\n+      column.addCheckConstraint(session, checkConstraint);\n+    }\n+    column.setComment(comment);\n+    column.setOriginalSQL(original);\n+    return column;\n+  }\n+\n+  private Prepared parseCreate() {\n+    boolean orReplace = false;\n+    if (readIf(\"OR\")) {\n+      read(\"REPLACE\");\n+      orReplace = true;\n+    }\n+    boolean force = readIf(\"FORCE\");\n+    if (readIf(\"VIEW\")) {\n+      return parseCreateView(force, orReplace);\n+    } else if (readIf(\"ALIAS\")) {\n+      return parseCreateFunctionAlias(force);\n+    } else if (readIf(\"SEQUENCE\")) {\n+      return parseCreateSequence();\n+    } else if (readIf(\"USER\")) {\n+      return parseCreateUser();\n+    } else if (readIf(\"TRIGGER\")) {\n+      return parseCreateTrigger(force);\n+    } else if (readIf(\"ROLE\")) {\n+      return parseCreateRole();\n+    } else if (readIf(\"SCHEMA\")) {\n+      return parseCreateSchema();\n+    } else if (readIf(\"CONSTANT\")) {\n+      return parseCreateConstant();\n+    } else if (readIf(\"DOMAIN\")) {\n+      return parseCreateUserDataType();\n+    } else if (readIf(\"TYPE\")) {\n+      return parseCreateUserDataType();\n+    } else if (readIf(\"DATATYPE\")) {\n+      return parseCreateUserDataType();\n+    } else if (readIf(\"AGGREGATE\")) {\n+      return parseCreateAggregate(force);\n+    } else if (readIf(\"LINKED\")) {\n+      return parseCreateLinkedTable(false, false, force);\n+    }\n+    // tables or linked tables\n+    boolean memory = false, cached = false;\n+    if (readIf(\"MEMORY\")) {\n+      memory = true;\n+    } else if (readIf(\"CACHED\")) {\n+      cached = true;\n+    }\n+    if (readIf(\"LOCAL\")) {\n+      read(\"TEMPORARY\");\n+      if (readIf(\"LINKED\")) {\n+        return parseCreateLinkedTable(true, false, force);\n+      }\n+      read(\"TABLE\");\n+      return parseCreateTable(true, false, cached);\n+    } else if (readIf(\"GLOBAL\")) {\n+      read(\"TEMPORARY\");\n+      if (readIf(\"LINKED\")) {\n+        return parseCreateLinkedTable(true, true, force);\n+      }\n+      read(\"TABLE\");\n+      return parseCreateTable(true, true, cached);\n+    } else if (readIf(\"TEMP\") || readIf(\"TEMPORARY\")) {\n+      if (readIf(\"LINKED\")) {\n+        return parseCreateLinkedTable(true, true, force);\n+      }\n+      read(\"TABLE\");\n+      return parseCreateTable(true, true, cached);\n+    } else if (readIf(\"TABLE\")) {\n+      if (!cached && !memory) {\n+        cached = database.getDefaultTableType() == Table.TYPE_CACHED;\n+      }\n+      return parseCreateTable(false, false, cached);\n+    } else if (readIf(\"SYNONYM\")) {\n+      return parseCreateSynonym(orReplace);\n+    } else {\n+      boolean hash = false, primaryKey = false;\n+      boolean unique = false, spatial = false;\n+      String indexName = null;\n+      Schema oldSchema = null;\n+      boolean ifNotExists = false;\n+      if (readIf(\"PRIMARY\")) {\n+        read(\"KEY\");\n+        if (readIf(\"HASH\")) {\n+          hash = true;\n+        }\n+        primaryKey = true;\n+        if (!isToken(\"ON\")) {\n+          ifNotExists = readIfNotExists();\n+          indexName = readIdentifierWithSchema(null);\n+          oldSchema = getSchema();\n+        }\n+      } else {\n+        if (readIf(\"UNIQUE\")) {\n+          unique = true;\n+        }\n+        if (readIf(\"HASH\")) {\n+          hash = true;\n+        }\n+        if (readIf(\"SPATIAL\")) {\n+          spatial = true;\n         }\n-        read(\"(\");\n-        LinkedHashSet<String> indexNames = new LinkedHashSet<>();\n-        if (!readIf(\")\")) {\n-            do {\n-                String indexName = readIdentifierWithSchema();\n-                Index index = table.getIndex(indexName);\n-                indexNames.add(index.getName());\n-            } while (readIf(\",\"));\n-            read(\")\");\n+        if (readIf(\"INDEX\")) {\n+          if (!isToken(\"ON\")) {\n+            ifNotExists = readIfNotExists();\n+            indexName = readIdentifierWithSchema(null);\n+            oldSchema = getSchema();\n+          }\n+        } else {\n+          throw getSyntaxError();\n+        }\n+      }\n+      read(\"ON\");\n+      String tableName = readIdentifierWithSchema();\n+      checkSchema(oldSchema);\n+      CreateIndex command = new CreateIndex(session, getSchema());\n+      command.setIfNotExists(ifNotExists);\n+      command.setPrimaryKey(primaryKey);\n+      command.setTableName(tableName);\n+      command.setUnique(unique);\n+      command.setIndexName(indexName);\n+      command.setComment(readCommentIf());\n+      read(\"(\");\n+      command.setIndexColumns(parseIndexColumnList());\n+\n+      if (readIf(\"USING\")) {\n+        if (hash) {\n+          throw getSyntaxError();\n+        }\n+        if (spatial) {\n+          throw getSyntaxError();\n+        }\n+        if (readIf(\"BTREE\")) {\n+          // default\n+        } else if (readIf(\"RTREE\")) {\n+          spatial = true;\n+        } else if (readIf(\"HASH\")) {\n+          hash = true;\n+        } else {\n+          throw getSyntaxError();\n+        }\n+\n+      }\n+      command.setHash(hash);\n+      command.setSpatial(spatial);\n+      return command;\n+    }\n+  }\n+\n+  /**\n+   * @return true if we expect to see a TABLE clause\n+   */\n+  private boolean addRoleOrRight(GrantRevoke command) {\n+    if (readIf(\"SELECT\")) {\n+      command.addRight(Right.SELECT);\n+      return true;\n+    } else if (readIf(\"DELETE\")) {\n+      command.addRight(Right.DELETE);\n+      return true;\n+    } else if (readIf(\"INSERT\")) {\n+      command.addRight(Right.INSERT);\n+      return true;\n+    } else if (readIf(\"UPDATE\")) {\n+      command.addRight(Right.UPDATE);\n+      return true;\n+    } else if (readIf(\"ALL\")) {\n+      command.addRight(Right.ALL);\n+      return true;\n+    } else if (readIf(\"ALTER\")) {\n+      read(\"ANY\");\n+      read(\"SCHEMA\");\n+      command.addRight(Right.ALTER_ANY_SCHEMA);\n+      command.addTable(null);\n+      return false;\n+    } else if (readIf(\"CONNECT\")) {\n+      // ignore this right\n+      return true;\n+    } else if (readIf(\"RESOURCE\")) {\n+      // ignore this right\n+      return true;\n+    } else {\n+      command.addRoleName(readUniqueIdentifier());\n+      return false;\n+    }\n+  }\n+\n+  private GrantRevoke parseGrantRevoke(int operationType) {\n+    GrantRevoke command = new GrantRevoke(session);\n+    command.setOperationType(operationType);\n+    boolean tableClauseExpected = addRoleOrRight(command);\n+    while (readIf(\",\")) {\n+      addRoleOrRight(command);\n+      if (command.isRightMode() && command.isRoleMode()) {\n+        throw DbException\n+            .get(ErrorCode.ROLES_AND_RIGHT_CANNOT_BE_MIXED);\n+      }\n+    }\n+    if (tableClauseExpected) {\n+      if (readIf(\"ON\")) {\n+        if (readIf(\"SCHEMA\")) {\n+          Schema schema = database.getSchema(readAliasIdentifier());\n+          command.setSchema(schema);\n+        } else {\n+          do {\n+            Table table = readTableOrView();\n+            command.addTable(table);\n+          } while (readIf(\",\"));\n+        }\n+      }\n+    }\n+    if (operationType == CommandInterface.GRANT) {\n+      read(\"TO\");\n+    } else {\n+      read(\"FROM\");\n+    }\n+    command.setGranteeName(readUniqueIdentifier());\n+    return command;\n+  }\n+\n+  private Select parseValues() {\n+    Select command = new Select(session);\n+    currentSelect = command;\n+    TableFilter filter = parseValuesTable(0);\n+    ArrayList<Expression> list = New.arrayList();\n+    list.add(new Wildcard(null, null));\n+    command.setExpressions(list);\n+    command.addTableFilter(filter, true);\n+    command.init();\n+    return command;\n+  }\n+\n+  private TableFilter parseValuesTable(int orderInFrom) {\n+    Schema mainSchema = database.getSchema(Constants.SCHEMA_MAIN);\n+    TableFunction tf = (TableFunction) Function.getFunction(database,\n+        \"TABLE\");\n+    ArrayList<Column> columns = New.arrayList();\n+    ArrayList<ArrayList<Expression>> rows = New.arrayList();\n+    do {\n+      int i = 0;\n+      ArrayList<Expression> row = New.arrayList();\n+      boolean multiColumn = readIf(\"(\");\n+      do {\n+        Expression expr = readExpression();\n+        expr = expr.optimize(session);\n+        int type = expr.getType();\n+        long prec;\n+        int scale, displaySize;\n+        Column column;\n+        String columnName = \"C\" + (i + 1);\n+        if (rows.isEmpty()) {\n+          if (type == Value.UNKNOWN) {\n+            type = Value.STRING;\n+          }\n+          DataType dt = DataType.getDataType(type);\n+          prec = dt.defaultPrecision;\n+          scale = dt.defaultScale;\n+          displaySize = dt.defaultDisplaySize;\n+          column = new Column(columnName, type, prec, scale,\n+              displaySize);\n+          columns.add(column);\n+        }\n+        prec = expr.getPrecision();\n+        scale = expr.getScale();\n+        displaySize = expr.getDisplaySize();\n+        if (i >= columns.size()) {\n+          throw DbException\n+              .get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n+        }\n+        Column c = columns.get(i);\n+        type = Value.getHigherOrder(c.getType(), type);\n+        prec = Math.max(c.getPrecision(), prec);\n+        scale = Math.max(c.getScale(), scale);\n+        displaySize = Math.max(c.getDisplaySize(), displaySize);\n+        column = new Column(columnName, type, prec, scale, displaySize);\n+        columns.set(i, column);\n+        row.add(expr);\n+        i++;\n+      } while (multiColumn && readIf(\",\"));\n+      if (multiColumn) {\n+        read(\")\");\n+      }\n+      rows.add(row);\n+    } while (readIf(\",\"));\n+    int columnCount = columns.size();\n+    int rowCount = rows.size();\n+    for (int i = 0; i < rowCount; i++) {\n+      if (rows.get(i).size() != columnCount) {\n+        throw DbException.get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n+      }\n+    }\n+    for (int i = 0; i < columnCount; i++) {\n+      Column c = columns.get(i);\n+      if (c.getType() == Value.UNKNOWN) {\n+        c = new Column(c.getName(), Value.STRING, 0, 0, 0);\n+        columns.set(i, c);\n+      }\n+      Expression[] array = new Expression[rowCount];\n+      for (int j = 0; j < rowCount; j++) {\n+        array[j] = rows.get(j).get(i);\n+      }\n+      ExpressionList list = new ExpressionList(array);\n+      tf.setParameter(i, list);\n+    }\n+    tf.setColumns(columns);\n+    tf.doneWithParameters();\n+    Table table = new FunctionTable(mainSchema, session, tf, tf);\n+    TableFilter filter = new TableFilter(session, table, null,\n+        rightsChecked, currentSelect, orderInFrom,\n+        null);\n+    return filter;\n+  }\n+\n+  private Call parseCall() {\n+    Call command = new Call(session);\n+    currentPrepared = command;\n+    command.setExpression(readExpression());\n+    return command;\n+  }\n+\n+  private CreateRole parseCreateRole() {\n+    CreateRole command = new CreateRole(session);\n+    command.setIfNotExists(readIfNotExists());\n+    command.setRoleName(readUniqueIdentifier());\n+    return command;\n+  }\n+\n+  private CreateSchema parseCreateSchema() {\n+    CreateSchema command = new CreateSchema(session);\n+    command.setIfNotExists(readIfNotExists());\n+    command.setSchemaName(readUniqueIdentifier());\n+    if (readIf(\"AUTHORIZATION\")) {\n+      command.setAuthorization(readUniqueIdentifier());\n+    } else {\n+      command.setAuthorization(session.getUser().getName());\n+    }\n+    if (readIf(\"WITH\")) {\n+      command.setTableEngineParams(readTableEngineParams());\n+    }\n+    return command;\n+  }\n+\n+  private ArrayList<String> readTableEngineParams() {\n+    ArrayList<String> tableEngineParams = New.arrayList();\n+    do {\n+      tableEngineParams.add(readUniqueIdentifier());\n+    } while (readIf(\",\"));\n+    return tableEngineParams;\n+  }\n+\n+  private CreateSequence parseCreateSequence() {\n+    boolean ifNotExists = readIfNotExists();\n+    String sequenceName = readIdentifierWithSchema();\n+    CreateSequence command = new CreateSequence(session, getSchema());\n+    command.setIfNotExists(ifNotExists);\n+    command.setSequenceName(sequenceName);\n+    while (true) {\n+      if (readIf(\"START\")) {\n+        readIf(\"WITH\");\n+        command.setStartWith(readExpression());\n+      } else if (readIf(\"INCREMENT\")) {\n+        readIf(\"BY\");\n+        command.setIncrement(readExpression());\n+      } else if (readIf(\"MINVALUE\")) {\n+        command.setMinValue(readExpression());\n+      } else if (readIf(\"NOMINVALUE\")) {\n+        command.setMinValue(null);\n+      } else if (readIf(\"MAXVALUE\")) {\n+        command.setMaxValue(readExpression());\n+      } else if (readIf(\"NOMAXVALUE\")) {\n+        command.setMaxValue(null);\n+      } else if (readIf(\"CYCLE\")) {\n+        command.setCycle(true);\n+      } else if (readIf(\"NOCYCLE\")) {\n+        command.setCycle(false);\n+      } else if (readIf(\"NO\")) {\n+        if (readIf(\"MINVALUE\")) {\n+          command.setMinValue(null);\n+        } else if (readIf(\"MAXVALUE\")) {\n+          command.setMaxValue(null);\n+        } else if (readIf(\"CYCLE\")) {\n+          command.setCycle(false);\n+        } else if (readIf(\"CACHE\")) {\n+          command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+        } else {\n+          break;\n+        }\n+      } else if (readIf(\"CACHE\")) {\n+        command.setCacheSize(readExpression());\n+      } else if (readIf(\"NOCACHE\")) {\n+        command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+      } else if (readIf(\"BELONGS_TO_TABLE\")) {\n+        command.setBelongsToTable(true);\n+      } else if (readIf(\"ORDER\")) {\n+        // Oracle compatibility\n+      } else {\n+        break;\n+      }\n+    }\n+    return command;\n+  }\n+\n+  private boolean readIfNotExists() {\n+    if (readIf(\"IF\")) {\n+      read(\"NOT\");\n+      read(\"EXISTS\");\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean readIfAffinity() {\n+    return readIf(\"AFFINITY\") || readIf(\"SHARD\");\n+  }\n+\n+  private CreateConstant parseCreateConstant() {\n+    boolean ifNotExists = readIfNotExists();\n+    String constantName = readIdentifierWithSchema();\n+    Schema schema = getSchema();\n+    if (isKeyword(constantName)) {\n+      throw DbException.get(ErrorCode.CONSTANT_ALREADY_EXISTS_1,\n+          constantName);\n+    }\n+    read(\"VALUE\");\n+    Expression expr = readExpression();\n+    CreateConstant command = new CreateConstant(session, schema);\n+    command.setConstantName(constantName);\n+    command.setExpression(expr);\n+    command.setIfNotExists(ifNotExists);\n+    return command;\n+  }\n+\n+  private CreateAggregate parseCreateAggregate(boolean force) {\n+    boolean ifNotExists = readIfNotExists();\n+    CreateAggregate command = new CreateAggregate(session);\n+    command.setForce(force);\n+    String name = readIdentifierWithSchema();\n+    if (isKeyword(name) || Function.getFunction(database, name) != null ||\n+        getAggregateType(name) != null) {\n+      throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1,\n+          name);\n+    }\n+    command.setName(name);\n+    command.setSchema(getSchema());\n+    command.setIfNotExists(ifNotExists);\n+    read(\"FOR\");\n+    command.setJavaClassMethod(readUniqueIdentifier());\n+    return command;\n+  }\n+\n+  private CreateUserDataType parseCreateUserDataType() {\n+    boolean ifNotExists = readIfNotExists();\n+    CreateUserDataType command = new CreateUserDataType(session);\n+    command.setTypeName(readUniqueIdentifier());\n+    read(\"AS\");\n+    Column col = parseColumnForTable(\"VALUE\", true);\n+    if (readIf(\"CHECK\")) {\n+      Expression expr = readExpression();\n+      col.addCheckConstraint(session, expr);\n+    }\n+    col.rename(null);\n+    command.setColumn(col);\n+    command.setIfNotExists(ifNotExists);\n+    return command;\n+  }\n+\n+  private CreateTrigger parseCreateTrigger(boolean force) {\n+    boolean ifNotExists = readIfNotExists();\n+    String triggerName = readIdentifierWithSchema(null);\n+    Schema schema = getSchema();\n+    boolean insteadOf, isBefore;\n+    if (readIf(\"INSTEAD\")) {\n+      read(\"OF\");\n+      isBefore = true;\n+      insteadOf = true;\n+    } else if (readIf(\"BEFORE\")) {\n+      insteadOf = false;\n+      isBefore = true;\n+    } else {\n+      read(\"AFTER\");\n+      insteadOf = false;\n+      isBefore = false;\n+    }\n+    int typeMask = 0;\n+    boolean onRollback = false;\n+    do {\n+      if (readIf(\"INSERT\")) {\n+        typeMask |= Trigger.INSERT;\n+      } else if (readIf(\"UPDATE\")) {\n+        typeMask |= Trigger.UPDATE;\n+      } else if (readIf(\"DELETE\")) {\n+        typeMask |= Trigger.DELETE;\n+      } else if (readIf(\"SELECT\")) {\n+        typeMask |= Trigger.SELECT;\n+      } else if (readIf(\"ROLLBACK\")) {\n+        onRollback = true;\n+      } else {\n+        throw getSyntaxError();\n+      }\n+    } while (readIf(\",\"));\n+    read(\"ON\");\n+    String tableName = readIdentifierWithSchema();\n+    checkSchema(schema);\n+    CreateTrigger command = new CreateTrigger(session, getSchema());\n+    command.setForce(force);\n+    command.setTriggerName(triggerName);\n+    command.setIfNotExists(ifNotExists);\n+    command.setInsteadOf(insteadOf);\n+    command.setBefore(isBefore);\n+    command.setOnRollback(onRollback);\n+    command.setTypeMask(typeMask);\n+    command.setTableName(tableName);\n+    if (readIf(\"FOR\")) {\n+      read(\"EACH\");\n+      read(\"ROW\");\n+      command.setRowBased(true);\n+    } else {\n+      command.setRowBased(false);\n+    }\n+    if (readIf(\"QUEUE\")) {\n+      command.setQueueSize(readPositiveInt());\n+    }\n+    command.setNoWait(readIf(\"NOWAIT\"));\n+    if (readIf(\"AS\")) {\n+      command.setTriggerSource(readString());\n+    } else {\n+      read(\"CALL\");\n+      command.setTriggerClassName(readUniqueIdentifier());\n+    }\n+    return command;\n+  }\n+\n+  private CreateUser parseCreateUser() {\n+    CreateUser command = new CreateUser(session);\n+    command.setIfNotExists(readIfNotExists());\n+    command.setUserName(readUniqueIdentifier());\n+    command.setComment(readCommentIf());\n+    if (readIf(\"PASSWORD\")) {\n+      command.setPassword(readExpression());\n+    } else if (readIf(\"SALT\")) {\n+      command.setSalt(readExpression());\n+      read(\"HASH\");\n+      command.setHash(readExpression());\n+    } else if (readIf(\"IDENTIFIED\")) {\n+      read(\"BY\");\n+      // uppercase if not quoted\n+      command.setPassword(ValueExpression.get(ValueString\n+          .get(readColumnIdentifier())));\n+    } else {\n+      throw getSyntaxError();\n+    }\n+    if (readIf(\"ADMIN\")) {\n+      command.setAdmin(true);\n+    }\n+    return command;\n+  }\n+\n+  private CreateFunctionAlias parseCreateFunctionAlias(boolean force) {\n+    boolean ifNotExists = readIfNotExists();\n+    final boolean newAliasSameNameAsBuiltin =\n+        Function.getFunction(database, currentToken) != null;\n+    String aliasName;\n+    if (database.isAllowBuiltinAliasOverride() && newAliasSameNameAsBuiltin) {\n+      aliasName = currentToken;\n+      schemaName = session.getCurrentSchemaName();\n+      read();\n+    } else {\n+      aliasName = readIdentifierWithSchema();\n+    }\n+    if (database.isAllowBuiltinAliasOverride() && newAliasSameNameAsBuiltin) {\n+      // fine\n+    } else if (isKeyword(aliasName) ||\n+        Function.getFunction(database, aliasName) != null ||\n+        getAggregateType(aliasName) != null) {\n+      throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1,\n+          aliasName);\n+    }\n+    CreateFunctionAlias command = new CreateFunctionAlias(session,\n+        getSchema());\n+    command.setForce(force);\n+    command.setAliasName(aliasName);\n+    command.setIfNotExists(ifNotExists);\n+    command.setDeterministic(readIf(\"DETERMINISTIC\"));\n+    command.setBufferResultSetToLocalTemp(!readIf(\"NOBUFFER\"));\n+    if (readIf(\"AS\")) {\n+      command.setSource(readString());\n+    } else {\n+      read(\"FOR\");\n+      command.setJavaClassMethod(readUniqueIdentifier());\n+    }\n+    return command;\n+  }\n+\n+  private Prepared parseWith() {\n+    List<TableView> viewsCreated = new ArrayList<>();\n+    readIf(\"RECURSIVE\");\n+\n+    // this WITH statement might not be a temporary view - allow optional keyword to\n+    // tell us that this keyword. This feature will not be documented - H2 internal use only.\n+    boolean isPersistent = readIf(\"PERSISTENT\");\n+\n+    // this WITH statement is not a temporary view - it is part of a persistent view\n+    // as in CREATE VIEW abc AS WITH my_cte - this auto detects that condition\n+    if (session.isParsingCreateView()) {\n+      isPersistent = true;\n+    }\n+\n+    do {\n+      viewsCreated.add(parseSingleCommonTableExpression(isPersistent));\n+    } while (readIf(\",\"));\n+\n+    Prepared p = null;\n+    // reverse the order of constructed CTE views - as the destruction order\n+    // (since later created view may depend on previously created views -\n+    //  we preserve that dependency order in the destruction sequence )\n+    // used in setCteCleanups\n+    Collections.reverse(viewsCreated);\n+\n+    if (isToken(\"SELECT\")) {\n+      Query query = parseSelectUnion();\n+      query.setPrepareAlways(true);\n+      query.setNeverLazy(true);\n+      p = query;\n+    } else if (readIf(\"INSERT\")) {\n+      p = parseInsert();\n+      p.setPrepareAlways(true);\n+    } else if (readIf(\"UPDATE\")) {\n+      p = parseUpdate();\n+      p.setPrepareAlways(true);\n+    } else if (readIf(\"MERGE\")) {\n+      p = parseMerge();\n+      p.setPrepareAlways(true);\n+    } else if (readIf(\"DELETE\")) {\n+      p = parseDelete();\n+      p.setPrepareAlways(true);\n+    } else if (readIf(\"CREATE\")) {\n+      if (!isToken(\"TABLE\")) {\n+        throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n+            WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n+\n+      }\n+      p = parseCreate();\n+      p.setPrepareAlways(true);\n+    } else {\n+      throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n+          WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n+    }\n+\n+    // clean up temporary views starting with last to first (in case of\n+    // dependencies) - but only if they are not persistent\n+    if (!isPersistent) {\n+      p.setCteCleanups(viewsCreated);\n+    }\n+    return p;\n+  }\n+\n+  private TableView parseSingleCommonTableExpression(boolean isPersistent) {\n+    String cteViewName = readIdentifierWithSchema();\n+    Schema schema = getSchema();\n+    Table recursiveTable = null;\n+    ArrayList<Column> columns = New.arrayList();\n+    String[] cols = null;\n+    Database db = database;\n+\n+    // column names are now optional - they can be inferred from the named\n+    // query, if not supplied by user\n+    if (readIf(\"(\")) {\n+      cols = parseColumnList();\n+      for (String c : cols) {\n+        // we don't really know the type of the column, so STRING will\n+        // have to do, UNKNOWN does not work here\n+        columns.add(new Column(c, Value.STRING));\n+      }\n+    }\n+\n+    Table oldViewFound = null;\n+    if (isPersistent) {\n+      oldViewFound = getSchema().findTableOrView(session, cteViewName);\n+    } else {\n+      oldViewFound = session.findLocalTempTable(cteViewName);\n+    }\n+    // this persistent check conflicts with check 10 lines down\n+    if (oldViewFound != null) {\n+      if (!(oldViewFound instanceof TableView)) {\n+        throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1,\n+            cteViewName);\n+      }\n+      TableView tv = (TableView) oldViewFound;\n+      if (!tv.isTableExpression()) {\n+        throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1,\n+            cteViewName);\n+      }\n+      if (isPersistent) {\n+        oldViewFound.lock(session, true, true);\n+        database.removeSchemaObject(session, oldViewFound);\n+\n+      } else {\n+        session.removeLocalTempTable(oldViewFound);\n+      }\n+      oldViewFound = null;\n+    }\n+    /*\n+     * This table is created as a workaround because recursive table\n+     * expressions need to reference something that look like themselves to\n+     * work (its removed after creation in this method). Only create table\n+     * data and table if we don't have a working CTE already.\n+     */\n+    recursiveTable = TableView.createShadowTableForRecursiveTableExpression(\n+        isPersistent, session, cteViewName, schema, columns, db);\n+    List<Column> columnTemplateList;\n+    String[] querySQLOutput = new String[] {null};\n+    try {\n+      read(\"AS\");\n+      read(\"(\");\n+      Query withQuery = parseSelect();\n+      if (isPersistent) {\n+        withQuery.session = session;\n+      }\n+      read(\")\");\n+      columnTemplateList = TableView\n+          .createQueryColumnTemplateList(cols, withQuery, querySQLOutput);\n+\n+    } finally {\n+      TableView.destroyShadowTableForRecursiveExpression(isPersistent, session,\n+          recursiveTable);\n+    }\n+\n+    TableView view = createCTEView(cteViewName,\n+        querySQLOutput[0], columnTemplateList,\n+        true/* allowRecursiveQueryDetection */,\n+        true/* add to session */,\n+        isPersistent, session);\n+\n+    return view;\n+  }\n+\n+  private TableView createCTEView(String cteViewName, String querySQL,\n+                                  List<Column> columnTemplateList,\n+                                  boolean allowRecursiveQueryDetection,\n+                                  boolean addViewToSession,\n+                                  boolean isPersistent, Session targetSession) {\n+    Database db = targetSession.getDatabase();\n+    Schema schema = getSchemaWithDefault();\n+    int id = db.allocateObjectId();\n+    Column[] columnTemplateArray = columnTemplateList.toArray(new Column[0]);\n+\n+    // No easy way to determine if this is a recursive query up front, so we just compile\n+    // it twice - once without the flag set, and if we didn't see a recursive term,\n+    // then we just compile it again.\n+    TableView view;\n+    synchronized (targetSession) {\n+      view = new TableView(schema, id, cteViewName, querySQL,\n+          parameters, columnTemplateArray, targetSession,\n+          allowRecursiveQueryDetection, false /* literalsChecked */,\n+          true /* isTableExpression */,\n+          isPersistent);\n+      if (!view.isRecursiveQueryDetected() && allowRecursiveQueryDetection) {\n+        if (isPersistent) {\n+          db.addSchemaObject(targetSession, view);\n+          view.lock(targetSession, true, true);\n+          targetSession.getDatabase().removeSchemaObject(targetSession, view);\n+        } else {\n+          session.removeLocalTempTable(view);\n+        }\n+        view = new TableView(schema, id, cteViewName, querySQL, parameters,\n+            columnTemplateArray, targetSession,\n+            false/* assume recursive */, false /* literalsChecked */,\n+            true /* isTableExpression */,\n+            isPersistent);\n+      }\n+      // both removeSchemaObject and removeLocalTempTable hold meta locks\n+      targetSession.getDatabase().unlockMeta(targetSession);\n+    }\n+    view.setTableExpression(true);\n+    view.setTemporary(!isPersistent);\n+    view.setHidden(true);\n+    view.setOnCommitDrop(false);\n+    if (addViewToSession) {\n+      if (isPersistent) {\n+        db.addSchemaObject(targetSession, view);\n+        view.unlock(targetSession);\n+        db.unlockMeta(targetSession);\n+      } else {\n+        targetSession.addLocalTempTable(view);\n+      }\n+    }\n+    return view;\n+  }\n+\n+  private CreateView parseCreateView(boolean force, boolean orReplace) {\n+    boolean ifNotExists = readIfNotExists();\n+    boolean isTableExpression = readIf(\"TABLE_EXPRESSION\");\n+    String viewName = readIdentifierWithSchema();\n+    CreateView command = new CreateView(session, getSchema());\n+    this.createView = command;\n+    command.setViewName(viewName);\n+    command.setIfNotExists(ifNotExists);\n+    command.setComment(readCommentIf());\n+    command.setOrReplace(orReplace);\n+    command.setForce(force);\n+    command.setTableExpression(isTableExpression);\n+    if (readIf(\"(\")) {\n+      String[] cols = parseColumnList();\n+      command.setColumnNames(cols);\n+    }\n+    String select = StringUtils.cache(sqlCommand\n+        .substring(parseIndex));\n+    read(\"AS\");\n+    try {\n+      Query query;\n+      session.setParsingCreateView(true, viewName);\n+      try {\n+        query = parseSelect();\n+        query.prepare();\n+      } finally {\n+        session.setParsingCreateView(false, viewName);\n+      }\n+      command.setSelect(query);\n+    } catch (DbException e) {\n+      if (force) {\n+        command.setSelectSQL(select);\n+        while (currentTokenType != END) {\n+          read();\n+        }\n+      } else {\n+        throw e;\n+      }\n+    }\n+    return command;\n+  }\n+\n+  private TransactionCommand parseCheckpoint() {\n+    TransactionCommand command;\n+    if (readIf(\"SYNC\")) {\n+      command = new TransactionCommand(session,\n+          CommandInterface.CHECKPOINT_SYNC);\n+    } else {\n+      command = new TransactionCommand(session,\n+          CommandInterface.CHECKPOINT);\n+    }\n+    return command;\n+  }\n+\n+  private Prepared parseAlter() {\n+    if (readIf(\"TABLE\")) {\n+      return parseAlterTable();\n+    } else if (readIf(\"USER\")) {\n+      return parseAlterUser();\n+    } else if (readIf(\"INDEX\")) {\n+      return parseAlterIndex();\n+    } else if (readIf(\"SCHEMA\")) {\n+      return parseAlterSchema();\n+    } else if (readIf(\"SEQUENCE\")) {\n+      return parseAlterSequence();\n+    } else if (readIf(\"VIEW\")) {\n+      return parseAlterView();\n+    }\n+    throw getSyntaxError();\n+  }\n+\n+  private void checkSchema(Schema old) {\n+    if (old != null && getSchema() != old) {\n+      throw DbException.get(ErrorCode.SCHEMA_NAME_MUST_MATCH);\n+    }\n+  }\n+\n+  private AlterIndexRename parseAlterIndex() {\n+    boolean ifExists = readIfExists(false);\n+    String indexName = readIdentifierWithSchema();\n+    Schema old = getSchema();\n+    AlterIndexRename command = new AlterIndexRename(session);\n+    command.setOldSchema(old);\n+    command.setOldName(indexName);\n+    command.setIfExists(ifExists);\n+    read(\"RENAME\");\n+    read(\"TO\");\n+    String newName = readIdentifierWithSchema(old.getName());\n+    checkSchema(old);\n+    command.setNewName(newName);\n+    return command;\n+  }\n+\n+  private AlterView parseAlterView() {\n+    AlterView command = new AlterView(session);\n+    boolean ifExists = readIfExists(false);\n+    command.setIfExists(ifExists);\n+    String viewName = readIdentifierWithSchema();\n+    Table tableView = getSchema().findTableOrView(session, viewName);\n+    if (!(tableView instanceof TableView) && !ifExists) {\n+      throw DbException.get(ErrorCode.VIEW_NOT_FOUND_1, viewName);\n+    }\n+    TableView view = (TableView) tableView;\n+    command.setView(view);\n+    read(\"RECOMPILE\");\n+    return command;\n+  }\n+\n+  private Prepared parseAlterSchema() {\n+    boolean ifExists = readIfExists(false);\n+    String schemaName = readIdentifierWithSchema();\n+    Schema old = getSchema();\n+    read(\"RENAME\");\n+    read(\"TO\");\n+    String newName = readIdentifierWithSchema(old.getName());\n+    Schema schema = findSchema(schemaName);\n+    if (schema == null) {\n+      if (ifExists) {\n+        return new NoOperation(session);\n+      }\n+      throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schemaName);\n+    }\n+    AlterSchemaRename command = new AlterSchemaRename(session);\n+    command.setOldSchema(schema);\n+    checkSchema(old);\n+    command.setNewName(newName);\n+    return command;\n+  }\n+\n+  private AlterSequence parseAlterSequence() {\n+    boolean ifExists = readIfExists(false);\n+    String sequenceName = readIdentifierWithSchema();\n+    AlterSequence command = new AlterSequence(session, getSchema());\n+    command.setSequenceName(sequenceName);\n+    command.setIfExists(ifExists);\n+    while (true) {\n+      if (readIf(\"RESTART\")) {\n+        read(\"WITH\");\n+        command.setStartWith(readExpression());\n+      } else if (readIf(\"INCREMENT\")) {\n+        read(\"BY\");\n+        command.setIncrement(readExpression());\n+      } else if (readIf(\"MINVALUE\")) {\n+        command.setMinValue(readExpression());\n+      } else if (readIf(\"NOMINVALUE\")) {\n+        command.setMinValue(null);\n+      } else if (readIf(\"MAXVALUE\")) {\n+        command.setMaxValue(readExpression());\n+      } else if (readIf(\"NOMAXVALUE\")) {\n+        command.setMaxValue(null);\n+      } else if (readIf(\"CYCLE\")) {\n+        command.setCycle(true);\n+      } else if (readIf(\"NOCYCLE\")) {\n+        command.setCycle(false);\n+      } else if (readIf(\"NO\")) {\n+        if (readIf(\"MINVALUE\")) {\n+          command.setMinValue(null);\n+        } else if (readIf(\"MAXVALUE\")) {\n+          command.setMaxValue(null);\n+        } else if (readIf(\"CYCLE\")) {\n+          command.setCycle(false);\n+        } else if (readIf(\"CACHE\")) {\n+          command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+        } else {\n+          break;\n+        }\n+      } else if (readIf(\"CACHE\")) {\n+        command.setCacheSize(readExpression());\n+      } else if (readIf(\"NOCACHE\")) {\n+        command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+      } else {\n+        break;\n+      }\n+    }\n+    return command;\n+  }\n+\n+  private AlterUser parseAlterUser() {\n+    String userName = readUniqueIdentifier();\n+    if (readIf(\"SET\")) {\n+      AlterUser command = new AlterUser(session);\n+      command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n+      command.setUser(database.getUser(userName));\n+      if (readIf(\"PASSWORD\")) {\n+        command.setPassword(readExpression());\n+      } else if (readIf(\"SALT\")) {\n+        command.setSalt(readExpression());\n+        read(\"HASH\");\n+        command.setHash(readExpression());\n+      } else {\n+        throw getSyntaxError();\n+      }\n+      return command;\n+    } else if (readIf(\"RENAME\")) {\n+      read(\"TO\");\n+      AlterUser command = new AlterUser(session);\n+      command.setType(CommandInterface.ALTER_USER_RENAME);\n+      command.setUser(database.getUser(userName));\n+      String newName = readUniqueIdentifier();\n+      command.setNewName(newName);\n+      return command;\n+    } else if (readIf(\"ADMIN\")) {\n+      AlterUser command = new AlterUser(session);\n+      command.setType(CommandInterface.ALTER_USER_ADMIN);\n+      User user = database.getUser(userName);\n+      command.setUser(user);\n+      if (readIf(\"TRUE\")) {\n+        command.setAdmin(true);\n+      } else if (readIf(\"FALSE\")) {\n+        command.setAdmin(false);\n+      } else {\n+        throw getSyntaxError();\n+      }\n+      return command;\n+    }\n+    throw getSyntaxError();\n+  }\n+\n+  private void readIfEqualOrTo() {\n+    if (!readIf(\"=\")) {\n+      readIf(\"TO\");\n+    }\n+  }\n+\n+  private Prepared parseSet() {\n+    if (readIf(\"@\")) {\n+      Set command = new Set(session, SetTypes.VARIABLE);\n+      command.setString(readAliasIdentifier());\n+      readIfEqualOrTo();\n+      command.setExpression(readExpression());\n+      return command;\n+    } else if (readIf(\"AUTOCOMMIT\")) {\n+      readIfEqualOrTo();\n+      boolean value = readBooleanSetting();\n+      int setting = value ? CommandInterface.SET_AUTOCOMMIT_TRUE\n+          : CommandInterface.SET_AUTOCOMMIT_FALSE;\n+      return new TransactionCommand(session, setting);\n+    } else if (readIf(\"MVCC\")) {\n+      readIfEqualOrTo();\n+      boolean value = readBooleanSetting();\n+      Set command = new Set(session, SetTypes.MVCC);\n+      command.setInt(value ? 1 : 0);\n+      return command;\n+    } else if (readIf(\"EXCLUSIVE\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.EXCLUSIVE);\n+      command.setExpression(readExpression());\n+      return command;\n+    } else if (readIf(\"IGNORECASE\")) {\n+      readIfEqualOrTo();\n+      boolean value = readBooleanSetting();\n+      Set command = new Set(session, SetTypes.IGNORECASE);\n+      command.setInt(value ? 1 : 0);\n+      return command;\n+    } else if (readIf(\"PASSWORD\")) {\n+      readIfEqualOrTo();\n+      AlterUser command = new AlterUser(session);\n+      command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n+      command.setUser(session.getUser());\n+      command.setPassword(readExpression());\n+      return command;\n+    } else if (readIf(\"SALT\")) {\n+      readIfEqualOrTo();\n+      AlterUser command = new AlterUser(session);\n+      command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n+      command.setUser(session.getUser());\n+      command.setSalt(readExpression());\n+      read(\"HASH\");\n+      command.setHash(readExpression());\n+      return command;\n+    } else if (readIf(\"MODE\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.MODE);\n+      command.setString(readAliasIdentifier());\n+      return command;\n+    } else if (readIf(\"COMPRESS_LOB\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.COMPRESS_LOB);\n+      if (currentTokenType == VALUE) {\n+        command.setString(readString());\n+      } else {\n+        command.setString(readUniqueIdentifier());\n+      }\n+      return command;\n+    } else if (readIf(\"DATABASE\")) {\n+      readIfEqualOrTo();\n+      read(\"COLLATION\");\n+      return parseSetCollation();\n+    } else if (readIf(\"COLLATION\")) {\n+      readIfEqualOrTo();\n+      return parseSetCollation();\n+    } else if (readIf(\"BINARY_COLLATION\")) {\n+      readIfEqualOrTo();\n+      return parseSetBinaryCollation();\n+    } else if (readIf(\"CLUSTER\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.CLUSTER);\n+      command.setString(readString());\n+      return command;\n+    } else if (readIf(\"DATABASE_EVENT_LISTENER\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.DATABASE_EVENT_LISTENER);\n+      command.setString(readString());\n+      return command;\n+    } else if (readIf(\"ALLOW_LITERALS\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.ALLOW_LITERALS);\n+      if (readIf(\"NONE\")) {\n+        command.setInt(Constants.ALLOW_LITERALS_NONE);\n+      } else if (readIf(\"ALL\")) {\n+        command.setInt(Constants.ALLOW_LITERALS_ALL);\n+      } else if (readIf(\"NUMBERS\")) {\n+        command.setInt(Constants.ALLOW_LITERALS_NUMBERS);\n+      } else {\n+        command.setInt(readPositiveInt());\n+      }\n+      return command;\n+    } else if (readIf(\"DEFAULT_TABLE_TYPE\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.DEFAULT_TABLE_TYPE);\n+      if (readIf(\"MEMORY\")) {\n+        command.setInt(Table.TYPE_MEMORY);\n+      } else if (readIf(\"CACHED\")) {\n+        command.setInt(Table.TYPE_CACHED);\n+      } else {\n+        command.setInt(readPositiveInt());\n+      }\n+      return command;\n+    } else if (readIf(\"CREATE\")) {\n+      readIfEqualOrTo();\n+      // Derby compatibility (CREATE=TRUE in the database URL)\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"HSQLDB.DEFAULT_TABLE_TYPE\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"PAGE_STORE\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"CACHE_TYPE\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"FILE_LOCK\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"DB_CLOSE_ON_EXIT\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"AUTO_SERVER\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"AUTO_SERVER_PORT\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"AUTO_RECONNECT\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"ASSERT\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"ACCESS_MODE_DATA\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"OPEN_NEW\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"JMX\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"PAGE_SIZE\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"RECOVER\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"NAMES\")) {\n+      // Quercus PHP MySQL driver compatibility\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"SCOPE_GENERATED_KEYS\")) {\n+      readIfEqualOrTo();\n+      read();\n+      return new NoOperation(session);\n+    } else if (readIf(\"SCHEMA\")) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.SCHEMA);\n+      command.setString(readAliasIdentifier());\n+      return command;\n+    } else if (readIf(\"DATESTYLE\")) {\n+      // PostgreSQL compatibility\n+      readIfEqualOrTo();\n+      if (!readIf(\"ISO\")) {\n+        String s = readString();\n+        if (!equalsToken(s, \"ISO\")) {\n+          throw getSyntaxError();\n+        }\n+      }\n+      return new NoOperation(session);\n+    } else if (readIf(\"SEARCH_PATH\") ||\n+        readIf(SetTypes.getTypeName(SetTypes.SCHEMA_SEARCH_PATH))) {\n+      readIfEqualOrTo();\n+      Set command = new Set(session, SetTypes.SCHEMA_SEARCH_PATH);\n+      ArrayList<String> list = New.arrayList();\n+      list.add(readAliasIdentifier());\n+      while (readIf(\",\")) {\n+        list.add(readAliasIdentifier());\n+      }\n+      command.setStringArray(list.toArray(new String[0]));\n+      return command;\n+    } else if (readIf(\"JAVA_OBJECT_SERIALIZER\")) {\n+      readIfEqualOrTo();\n+      return parseSetJavaObjectSerializer();\n+    } else {\n+      if (isToken(\"LOGSIZE\")) {\n+        // HSQLDB compatibility\n+        currentToken = SetTypes.getTypeName(SetTypes.MAX_LOG_SIZE);\n+      }\n+      if (isToken(\"FOREIGN_KEY_CHECKS\")) {\n+        // MySQL compatibility\n+        currentToken = SetTypes\n+            .getTypeName(SetTypes.REFERENTIAL_INTEGRITY);\n+      }\n+      int type = SetTypes.getType(currentToken);\n+      if (type < 0) {\n+        throw getSyntaxError();\n+      }\n+      read();\n+      readIfEqualOrTo();\n+      Set command = new Set(session, type);\n+      command.setExpression(readExpression());\n+      return command;\n+    }\n+  }\n+\n+  private Prepared parseUse() {\n+    readIfEqualOrTo();\n+    Set command = new Set(session, SetTypes.SCHEMA);\n+    command.setString(readAliasIdentifier());\n+    return command;\n+  }\n+\n+  private Set parseSetCollation() {\n+    Set command = new Set(session, SetTypes.COLLATION);\n+    String name = readAliasIdentifier();\n+    command.setString(name);\n+    if (equalsToken(name, CompareMode.OFF)) {\n+      return command;\n+    }\n+    Collator coll = CompareMode.getCollator(name);\n+    if (coll == null) {\n+      throw DbException.getInvalidValueException(\"collation\", name);\n+    }\n+    if (readIf(\"STRENGTH\")) {\n+      if (readIf(\"PRIMARY\")) {\n+        command.setInt(Collator.PRIMARY);\n+      } else if (readIf(\"SECONDARY\")) {\n+        command.setInt(Collator.SECONDARY);\n+      } else if (readIf(\"TERTIARY\")) {\n+        command.setInt(Collator.TERTIARY);\n+      } else if (readIf(\"IDENTICAL\")) {\n+        command.setInt(Collator.IDENTICAL);\n+      }\n+    } else {\n+      command.setInt(coll.getStrength());\n+    }\n+    return command;\n+  }\n+\n+  private Set parseSetBinaryCollation() {\n+    Set command = new Set(session, SetTypes.BINARY_COLLATION);\n+    String name = readAliasIdentifier();\n+    command.setString(name);\n+    if (equalsToken(name, CompareMode.UNSIGNED) ||\n+        equalsToken(name, CompareMode.SIGNED)) {\n+      return command;\n+    }\n+    throw DbException.getInvalidValueException(\"BINARY_COLLATION\", name);\n+  }\n+\n+  private Set parseSetJavaObjectSerializer() {\n+    Set command = new Set(session, SetTypes.JAVA_OBJECT_SERIALIZER);\n+    String name = readString();\n+    command.setString(name);\n+    return command;\n+  }\n+\n+  private RunScriptCommand parseRunScript() {\n+    RunScriptCommand command = new RunScriptCommand(session);\n+    read(\"FROM\");\n+    command.setFileNameExpr(readExpression());\n+    if (readIf(\"COMPRESSION\")) {\n+      command.setCompressionAlgorithm(readUniqueIdentifier());\n+    }\n+    if (readIf(\"CIPHER\")) {\n+      command.setCipher(readUniqueIdentifier());\n+      if (readIf(\"PASSWORD\")) {\n+        command.setPassword(readExpression());\n+      }\n+    }\n+    if (readIf(\"CHARSET\")) {\n+      command.setCharset(Charset.forName(readString()));\n+    }\n+    return command;\n+  }\n+\n+  private ScriptCommand parseScript() {\n+    ScriptCommand command = new ScriptCommand(session);\n+    boolean data = true, passwords = true, settings = true;\n+    boolean dropTables = false, simple = false;\n+    if (readIf(\"SIMPLE\")) {\n+      simple = true;\n+    }\n+    if (readIf(\"NODATA\")) {\n+      data = false;\n+    }\n+    if (readIf(\"NOPASSWORDS\")) {\n+      passwords = false;\n+    }\n+    if (readIf(\"NOSETTINGS\")) {\n+      settings = false;\n+    }\n+    if (readIf(\"DROP\")) {\n+      dropTables = true;\n+    }\n+    if (readIf(\"BLOCKSIZE\")) {\n+      long blockSize = readLong();\n+      command.setLobBlockSize(blockSize);\n+    }\n+    command.setData(data);\n+    command.setPasswords(passwords);\n+    command.setSettings(settings);\n+    command.setDrop(dropTables);\n+    command.setSimple(simple);\n+    if (readIf(\"TO\")) {\n+      command.setFileNameExpr(readExpression());\n+      if (readIf(\"COMPRESSION\")) {\n+        command.setCompressionAlgorithm(readUniqueIdentifier());\n+      }\n+      if (readIf(\"CIPHER\")) {\n+        command.setCipher(readUniqueIdentifier());\n+        if (readIf(\"PASSWORD\")) {\n+          command.setPassword(readExpression());\n+        }\n+      }\n+      if (readIf(\"CHARSET\")) {\n+        command.setCharset(Charset.forName(readString()));\n+      }\n+    }\n+    if (readIf(\"SCHEMA\")) {\n+      HashSet<String> schemaNames = new HashSet<>();\n+      do {\n+        schemaNames.add(readUniqueIdentifier());\n+      } while (readIf(\",\"));\n+      command.setSchemaNames(schemaNames);\n+    } else if (readIf(\"TABLE\")) {\n+      ArrayList<Table> tables = New.arrayList();\n+      do {\n+        tables.add(readTableOrView());\n+      } while (readIf(\",\"));\n+      command.setTables(tables);\n+    }\n+    return command;\n+  }\n+\n+  private Table readTableOrView() {\n+    return readTableOrView(readIdentifierWithSchema(null));\n+  }\n+\n+  private Table readTableOrView(String tableName) {\n+    // same algorithm than readSequence\n+    if (schemaName != null) {\n+      return getSchema().getTableOrView(session, tableName);\n+    }\n+    Table table = database.getSchema(session.getCurrentSchemaName())\n+        .resolveTableOrView(session, tableName);\n+    if (table != null) {\n+      return table;\n+    }\n+    String[] schemaNames = session.getSchemaSearchPath();\n+    if (schemaNames != null) {\n+      for (String name : schemaNames) {\n+        Schema s = database.getSchema(name);\n+        table = s.resolveTableOrView(session, tableName);\n+        if (table != null) {\n+          return table;\n         }\n-        return IndexHints.createUseIndexHints(indexNames);\n+      }\n     }\n+    throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, tableName);\n+  }\n \n-    private String readFromAlias(String alias, List<String> excludeIdentifiers) {\n-        if (readIf(\"AS\")) {\n-            alias = readAliasIdentifier();\n-        } else if (currentTokenType == IDENTIFIER && !isTokenInList(excludeIdentifiers)) {\n-                alias = readAliasIdentifier();\n+  private FunctionAlias findFunctionAlias(String schema, String aliasName) {\n+    FunctionAlias functionAlias = database.getSchema(schema).findFunction(\n+        aliasName);\n+    if (functionAlias != null) {\n+      return functionAlias;\n+    }\n+    String[] schemaNames = session.getSchemaSearchPath();\n+    if (schemaNames != null) {\n+      for (String n : schemaNames) {\n+        functionAlias = database.getSchema(n).findFunction(aliasName);\n+        if (functionAlias != null) {\n+          return functionAlias;\n         }\n-        return alias;\n+      }\n     }\n+    return null;\n+  }\n \n-    private String readFromAlias(String alias) {\n-        // left and right are not keywords (because they are functions as\n-        // well)\n-        List<String> excludeIdentifiers = Arrays.asList(\"LEFT\", \"RIGHT\", \"FULL\");\n-        return readFromAlias(alias, excludeIdentifiers);\n+  private Sequence findSequence(String schema, String sequenceName) {\n+    Sequence sequence = database.getSchema(schema).findSequence(\n+        sequenceName);\n+    if (sequence != null) {\n+      return sequence;\n     }\n-\n-    private Prepared parseTruncate() {\n-        read(\"TABLE\");\n-        Table table = readTableOrView();\n-        TruncateTable command = new TruncateTable(session);\n-        command.setTable(table);\n+    String[] schemaNames = session.getSchemaSearchPath();\n+    if (schemaNames != null) {\n+      for (String n : schemaNames) {\n+        sequence = database.getSchema(n).findSequence(sequenceName);\n+        if (sequence != null) {\n+          return sequence;\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Sequence readSequence() {\n+    // same algorithm as readTableOrView\n+    String sequenceName = readIdentifierWithSchema(null);\n+    if (schemaName != null) {\n+      return getSchema().getSequence(sequenceName);\n+    }\n+    Sequence sequence = findSequence(session.getCurrentSchemaName(),\n+        sequenceName);\n+    if (sequence != null) {\n+      return sequence;\n+    }\n+    throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n+  }\n+\n+  private Prepared parseAlterTable() {\n+    boolean ifTableExists = readIfExists(false);\n+    String tableName = readIdentifierWithSchema();\n+    Schema schema = getSchema();\n+    if (readIf(\"ADD\")) {\n+      Prepared command = parseAlterTableAddConstraintIf(tableName,\n+          schema, ifTableExists);\n+      if (command != null) {\n         return command;\n-    }\n-\n-    private boolean readIfExists(boolean ifExists) {\n-        if (readIf(\"IF\")) {\n-            read(\"EXISTS\");\n-            ifExists = true;\n-        }\n-        return ifExists;\n-    }\n-\n-    private Prepared parseComment() {\n-        int type = 0;\n-        read(\"ON\");\n-        boolean column = false;\n-        if (readIf(\"TABLE\") || readIf(\"VIEW\")) {\n-            type = DbObject.TABLE_OR_VIEW;\n-        } else if (readIf(\"COLUMN\")) {\n-            column = true;\n-            type = DbObject.TABLE_OR_VIEW;\n-        } else if (readIf(\"CONSTANT\")) {\n-            type = DbObject.CONSTANT;\n-        } else if (readIf(\"CONSTRAINT\")) {\n-            type = DbObject.CONSTRAINT;\n-        } else if (readIf(\"ALIAS\")) {\n-            type = DbObject.FUNCTION_ALIAS;\n-        } else if (readIf(\"INDEX\")) {\n-            type = DbObject.INDEX;\n-        } else if (readIf(\"ROLE\")) {\n-            type = DbObject.ROLE;\n-        } else if (readIf(\"SCHEMA\")) {\n-            type = DbObject.SCHEMA;\n-        } else if (readIf(\"SEQUENCE\")) {\n-            type = DbObject.SEQUENCE;\n-        } else if (readIf(\"TRIGGER\")) {\n-            type = DbObject.TRIGGER;\n-        } else if (readIf(\"USER\")) {\n-            type = DbObject.USER;\n-        } else if (readIf(\"DOMAIN\")) {\n-            type = DbObject.USER_DATATYPE;\n-        } else {\n-            throw getSyntaxError();\n-        }\n-        SetComment command = new SetComment(session);\n-        String objectName;\n-        if (column) {\n-            // can't use readIdentifierWithSchema() because\n-            // it would not read schema.table.column correctly\n-            // if the db name is equal to the schema name\n-            ArrayList<String> list = New.arrayList();\n-            do {\n-                list.add(readUniqueIdentifier());\n-            } while (readIf(\".\"));\n-            schemaName = session.getCurrentSchemaName();\n-            if (list.size() == 4) {\n-                if (!equalsToken(database.getShortName(), list.remove(0))) {\n-                    throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                            \"database name\");\n-                }\n-            }\n-            if (list.size() == 3) {\n-                schemaName = list.remove(0);\n-            }\n-            if (list.size() != 2) {\n-                throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                        \"table.column\");\n-            }\n-            objectName = list.get(0);\n-            command.setColumn(true);\n-            command.setColumnName(list.get(1));\n-        } else {\n-            objectName = readIdentifierWithSchema();\n-        }\n-        command.setSchemaName(schemaName);\n-        command.setObjectName(objectName);\n-        command.setObjectType(type);\n-        read(\"IS\");\n-        command.setCommentExpression(readExpression());\n+      }\n+      return parseAlterTableAddColumn(tableName, schema, ifTableExists);\n+    } else if (readIf(\"SET\")) {\n+      read(\"REFERENTIAL_INTEGRITY\");\n+      int type = CommandInterface.ALTER_TABLE_SET_REFERENTIAL_INTEGRITY;\n+      boolean value = readBooleanSetting();\n+      AlterTableSet command = new AlterTableSet(session,\n+          schema, type, value);\n+      command.setTableName(tableName);\n+      command.setIfTableExists(ifTableExists);\n+      if (readIf(\"CHECK\")) {\n+        command.setCheckExisting(true);\n+      } else if (readIf(\"NOCHECK\")) {\n+        command.setCheckExisting(false);\n+      }\n+      return command;\n+    } else if (readIf(\"RENAME\")) {\n+      if (readIf(\"COLUMN\")) {\n+        // PostgreSQL syntax\n+        String columnName = readColumnIdentifier();\n+        read(\"TO\");\n+        AlterTableRenameColumn command = new AlterTableRenameColumn(\n+            session, schema);\n+        command.setTableName(tableName);\n+        command.setIfTableExists(ifTableExists);\n+        command.setOldColumnName(columnName);\n+        String newName = readColumnIdentifier();\n+        command.setNewColumnName(newName);\n         return command;\n-    }\n-\n-    private Prepared parseDrop() {\n-        if (readIf(\"TABLE\")) {\n-            boolean ifExists = readIfExists(false);\n-            String tableName = readIdentifierWithSchema();\n-            DropTable command = new DropTable(session, getSchema());\n-            command.setTableName(tableName);\n-            while (readIf(\",\")) {\n-                tableName = readIdentifierWithSchema();\n-                DropTable next = new DropTable(session, getSchema());\n-                next.setTableName(tableName);\n-                command.addNextDropTable(next);\n-            }\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            if (readIf(\"CASCADE\")) {\n-                command.setDropAction(ConstraintActionType.CASCADE);\n-                readIf(\"CONSTRAINTS\");\n-            } else if (readIf(\"RESTRICT\")) {\n-                command.setDropAction(ConstraintActionType.RESTRICT);\n-            } else if (readIf(\"IGNORE\")) {\n-                command.setDropAction(ConstraintActionType.SET_DEFAULT);\n-            }\n-            return command;\n-        } else if (readIf(\"INDEX\")) {\n-            boolean ifExists = readIfExists(false);\n-            String indexName = readIdentifierWithSchema();\n-            DropIndex command = new DropIndex(session, getSchema());\n-            command.setIndexName(indexName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"USER\")) {\n-            boolean ifExists = readIfExists(false);\n-            DropUser command = new DropUser(session);\n-            command.setUserName(readUniqueIdentifier());\n-            ifExists = readIfExists(ifExists);\n-            readIf(\"CASCADE\");\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"SEQUENCE\")) {\n-            boolean ifExists = readIfExists(false);\n-            String sequenceName = readIdentifierWithSchema();\n-            DropSequence command = new DropSequence(session, getSchema());\n-            command.setSequenceName(sequenceName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"CONSTANT\")) {\n-            boolean ifExists = readIfExists(false);\n-            String constantName = readIdentifierWithSchema();\n-            DropConstant command = new DropConstant(session, getSchema());\n-            command.setConstantName(constantName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"TRIGGER\")) {\n-            boolean ifExists = readIfExists(false);\n-            String triggerName = readIdentifierWithSchema();\n-            DropTrigger command = new DropTrigger(session, getSchema());\n-            command.setTriggerName(triggerName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"VIEW\")) {\n-            boolean ifExists = readIfExists(false);\n-            String viewName = readIdentifierWithSchema();\n-            DropView command = new DropView(session, getSchema());\n-            command.setViewName(viewName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            ConstraintActionType dropAction = parseCascadeOrRestrict();\n-            if (dropAction != null) {\n-                command.setDropAction(dropAction);\n-            }\n-            return command;\n-        } else if (readIf(\"ROLE\")) {\n-            boolean ifExists = readIfExists(false);\n-            DropRole command = new DropRole(session);\n-            command.setRoleName(readUniqueIdentifier());\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"ALIAS\")) {\n-            boolean ifExists = readIfExists(false);\n-            String aliasName = readIdentifierWithSchema();\n-            DropFunctionAlias command = new DropFunctionAlias(session,\n-                    getSchema());\n-            command.setAliasName(aliasName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"SCHEMA\")) {\n-            boolean ifExists = readIfExists(false);\n-            DropSchema command = new DropSchema(session);\n-            command.setSchemaName(readUniqueIdentifier());\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"ALL\")) {\n-            read(\"OBJECTS\");\n-            DropDatabase command = new DropDatabase(session);\n-            command.setDropAllObjects(true);\n-            if (readIf(\"DELETE\")) {\n-                read(\"FILES\");\n-                command.setDeleteFiles(true);\n-            }\n-            return command;\n-        } else if (readIf(\"DOMAIN\")) {\n-            return parseDropUserDataType();\n-        } else if (readIf(\"TYPE\")) {\n-            return parseDropUserDataType();\n-        } else if (readIf(\"DATATYPE\")) {\n-            return parseDropUserDataType();\n-        } else if (readIf(\"AGGREGATE\")) {\n-            return parseDropAggregate();\n-        } else if (readIf(\"SYNONYM\")) {\n-            boolean ifExists = readIfExists(false);\n-            String synonymName = readIdentifierWithSchema();\n-            DropSynonym command = new DropSynonym(session, getSchema());\n-            command.setSynonymName(synonymName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        }\n-        throw getSyntaxError();\n-    }\n-\n-    private DropUserDataType parseDropUserDataType() {\n-        boolean ifExists = readIfExists(false);\n-        DropUserDataType command = new DropUserDataType(session);\n-        command.setTypeName(readUniqueIdentifier());\n-        ifExists = readIfExists(ifExists);\n-        command.setIfExists(ifExists);\n-        return command;\n-    }\n-\n-    private DropAggregate parseDropAggregate() {\n-        boolean ifExists = readIfExists(false);\n-        DropAggregate command = new DropAggregate(session);\n-        command.setName(readUniqueIdentifier());\n-        ifExists = readIfExists(ifExists);\n-        command.setIfExists(ifExists);\n-        return command;\n-    }\n-\n-    private TableFilter readJoin(TableFilter top) {\n-        TableFilter last = top;\n-        while (true) {\n-            TableFilter join;\n-            if (readIf(\"RIGHT\")) {\n-                readIf(\"OUTER\");\n-                read(\"JOIN\");\n-                // the right hand side is the 'inner' table usually\n-                join = readTableFilter();\n-                join = readJoin(join);\n-                Expression on = null;\n-                if (readIf(\"ON\")) {\n-                    on = readExpression();\n-                }\n-                addJoin(join, top, true, on);\n-                top = join;\n-            } else if (readIf(\"LEFT\")) {\n-                readIf(\"OUTER\");\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                join = readJoin(join);\n-                Expression on = null;\n-                if (readIf(\"ON\")) {\n-                    on = readExpression();\n-                }\n-                addJoin(top, join, true, on);\n-            } else if (readIf(\"FULL\")) {\n-                throw getSyntaxError();\n-            } else if (readIf(\"INNER\")) {\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                top = readJoin(top);\n-                Expression on = null;\n-                if (readIf(\"ON\")) {\n-                    on = readExpression();\n-                }\n-                addJoin(top, join, false, on);\n-            } else if (readIf(\"JOIN\")) {\n-                join = readTableFilter();\n-                top = readJoin(top);\n-                Expression on = null;\n-                if (readIf(\"ON\")) {\n-                    on = readExpression();\n-                }\n-                addJoin(top, join, false, on);\n-            } else if (readIf(\"CROSS\")) {\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                addJoin(top, join, false, null);\n-            } else if (readIf(\"NATURAL\")) {\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                Column[] tableCols = last.getTable().getColumns();\n-                Column[] joinCols = join.getTable().getColumns();\n-                String tableSchema = last.getTable().getSchema().getName();\n-                String joinSchema = join.getTable().getSchema().getName();\n-                Expression on = null;\n-                for (Column tc : tableCols) {\n-                    String tableColumnName = tc.getName();\n-                    for (Column c : joinCols) {\n-                        String joinColumnName = c.getName();\n-                        if (equalsToken(tableColumnName, joinColumnName)) {\n-                            join.addNaturalJoinColumn(c);\n-                            Expression tableExpr = new ExpressionColumn(\n-                                    database, tableSchema,\n-                                    last.getTableAlias(), tableColumnName);\n-                            Expression joinExpr = new ExpressionColumn(\n-                                    database, joinSchema, join.getTableAlias(),\n-                                    joinColumnName);\n-                            Expression equal = new Comparison(session,\n-                                    Comparison.EQUAL, tableExpr, joinExpr);\n-                            if (on == null) {\n-                                on = equal;\n-                            } else {\n-                                on = new ConditionAndOr(ConditionAndOr.AND, on,\n-                                        equal);\n-                            }\n-                        }\n-                    }\n-                }\n-                addJoin(top, join, false, on);\n-            } else {\n-                break;\n-            }\n-            last = join;\n-        }\n-        return top;\n-    }\n-\n-    /**\n-     * Add one join to another. This method creates nested join between them if\n-     * required.\n-     *\n-     * @param top parent join\n-     * @param join child join\n-     * @param outer if child join is an outer join\n-     * @param on the join condition\n-     * @see TableFilter#addJoin(TableFilter, boolean, Expression)\n-     */\n-    private void addJoin(TableFilter top, TableFilter join, boolean outer, Expression on) {\n-        if (join.getJoin() != null) {\n-            String joinTable = Constants.PREFIX_JOIN + parseIndex;\n-            TableFilter n = new TableFilter(session, getDualTable(true),\n-                    joinTable, rightsChecked, currentSelect, join.getOrderInFrom(),\n-                    null);\n-            n.setNestedJoin(join);\n-            join = n;\n-        }\n-        top.addJoin(join, outer, on);\n-    }\n-\n-    private Prepared parseExecute() {\n-        ExecuteProcedure command = new ExecuteProcedure(session);\n-        String procedureName = readAliasIdentifier();\n-        Procedure p = session.getProcedure(procedureName);\n-        if (p == null) {\n-            throw DbException.get(ErrorCode.FUNCTION_ALIAS_NOT_FOUND_1,\n-                    procedureName);\n-        }\n-        command.setProcedure(p);\n-        if (readIf(\"(\")) {\n-            for (int i = 0;; i++) {\n-                command.setExpression(i, readExpression());\n-                if (readIf(\")\")) {\n-                    break;\n-                }\n-                read(\",\");\n-            }\n-        }\n-        return command;\n-    }\n-\n-    private DeallocateProcedure parseDeallocate() {\n-        readIf(\"PLAN\");\n-        String procedureName = readAliasIdentifier();\n-        DeallocateProcedure command = new DeallocateProcedure(session);\n-        command.setProcedureName(procedureName);\n-        return command;\n-    }\n-\n-    private Explain parseExplain() {\n-        Explain command = new Explain(session);\n-        if (readIf(\"ANALYZE\")) {\n-            command.setExecuteCommand(true);\n-        } else {\n-            if (readIf(\"PLAN\")) {\n-                readIf(\"FOR\");\n-            }\n-        }\n-        if (isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"(\") || isToken(\"WITH\")) {\n-            Query query = parseSelect();\n-            query.setNeverLazy(true);\n-            command.setCommand(query);\n-        } else if (readIf(\"DELETE\")) {\n-            command.setCommand(parseDelete());\n-        } else if (readIf(\"UPDATE\")) {\n-            command.setCommand(parseUpdate());\n-        } else if (readIf(\"INSERT\")) {\n-            command.setCommand(parseInsert());\n-        } else if (readIf(\"MERGE\")) {\n-            command.setCommand(parseMerge());\n-        } else {\n-            throw getSyntaxError();\n-        }\n-        return command;\n-    }\n-\n-    private Query parseSelect() {\n-        Query command = null;\n-        int paramIndex = parameters.size();\n-        command = parseSelectUnion();\n-        ArrayList<Parameter> params = New.arrayList();\n-        for (int i = paramIndex, size = parameters.size(); i < size; i++) {\n-            params.add(parameters.get(i));\n-        }\n-        command.setParameterList(params);\n-        command.init();\n-        return command;\n-    }\n-\n-    private Prepared parseWithStatementOrQuery() {\n-        int paramIndex = parameters.size();\n-        Prepared command = parseWith();\n-        ArrayList<Parameter> params = New.arrayList();\n-        for (int i = paramIndex, size = parameters.size(); i < size; i++) {\n-            params.add(parameters.get(i));\n-        }\n-        command.setParameterList(params);\n-        if (command instanceof Query) {\n-            Query query = (Query) command;\n-            query.init();\n-        }\n-        return command;\n-    }\n-\n-    private Query parseSelectUnion() {\n-        int start = lastParseIndex;\n-        Query command = parseSelectSub();\n-        return parseSelectUnionExtension(command, start, false);\n-    }\n-\n-    private Query parseSelectUnionExtension(Query command, int start,\n-            boolean unionOnly) {\n-        while (true) {\n-            if (readIf(\"UNION\")) {\n-                SelectUnion union = new SelectUnion(session, command);\n-                if (readIf(\"ALL\")) {\n-                    union.setUnionType(SelectUnion.UnionType.UNION_ALL);\n-                } else {\n-                    readIf(\"DISTINCT\");\n-                    union.setUnionType(SelectUnion.UnionType.UNION);\n-                }\n-                union.setRight(parseSelectSub());\n-                command = union;\n-            } else if (readIf(\"MINUS\") || readIf(\"EXCEPT\")) {\n-                SelectUnion union = new SelectUnion(session, command);\n-                union.setUnionType(SelectUnion.UnionType.EXCEPT);\n-                union.setRight(parseSelectSub());\n-                command = union;\n-            } else if (readIf(\"INTERSECT\")) {\n-                SelectUnion union = new SelectUnion(session, command);\n-                union.setUnionType(SelectUnion.UnionType.INTERSECT);\n-                union.setRight(parseSelectSub());\n-                command = union;\n-            } else {\n-                break;\n-            }\n-        }\n-        if (!unionOnly) {\n-            parseEndOfQuery(command);\n-        }\n-        setSQL(command, null, start);\n-        return command;\n-    }\n-\n-    private void parseEndOfQuery(Query command) {\n-        if (readIf(\"ORDER\")) {\n-            read(\"BY\");\n-            Select oldSelect = currentSelect;\n-            if (command instanceof Select) {\n-                currentSelect = (Select) command;\n-            }\n-            ArrayList<SelectOrderBy> orderList = New.arrayList();\n-            do {\n-                boolean canBeNumber = true;\n-                if (readIf(\"=\")) {\n-                    canBeNumber = false;\n-                }\n-                SelectOrderBy order = new SelectOrderBy();\n-                Expression expr = readExpression();\n-                if (canBeNumber && expr instanceof ValueExpression &&\n-                        expr.getType() == Value.INT) {\n-                    order.columnIndexExpr = expr;\n-                } else if (expr instanceof Parameter) {\n-                    recompileAlways = true;\n-                    order.columnIndexExpr = expr;\n-                } else {\n-                    order.expression = expr;\n-                }\n-                if (readIf(\"DESC\")) {\n-                    order.descending = true;\n-                } else {\n-                    readIf(\"ASC\");\n-                }\n-                if (readIf(\"NULLS\")) {\n-                    if (readIf(\"FIRST\")) {\n-                        order.nullsFirst = true;\n-                    } else {\n-                        read(\"LAST\");\n-                        order.nullsLast = true;\n-                    }\n-                }\n-                orderList.add(order);\n-            } while (readIf(\",\"));\n-            command.setOrder(orderList);\n-            currentSelect = oldSelect;\n-        }\n-        if (database.getMode().supportOffsetFetch) {\n-            // make sure aggregate functions will not work here\n-            Select temp = currentSelect;\n-            currentSelect = null;\n-\n-            // http://sqlpro.developpez.com/SQL2008/\n-            if (readIf(\"OFFSET\")) {\n-                command.setOffset(readExpression().optimize(session));\n-                if (!readIf(\"ROW\")) {\n-                    readIf(\"ROWS\");\n-                }\n-            }\n-            if (readIf(\"FETCH\")) {\n-                if (!readIf(\"FIRST\")) {\n-                    read(\"NEXT\");\n-                }\n-                if (readIf(\"ROW\")) {\n-                    command.setLimit(ValueExpression.get(ValueInt.get(1)));\n-                } else {\n-                    Expression limit = readExpression().optimize(session);\n-                    command.setLimit(limit);\n-                    if (!readIf(\"ROW\")) {\n-                        read(\"ROWS\");\n-                    }\n-                }\n-                read(\"ONLY\");\n-            }\n-\n-            currentSelect = temp;\n-        }\n-        if (readIf(\"LIMIT\")) {\n-            Select temp = currentSelect;\n-            // make sure aggregate functions will not work here\n-            currentSelect = null;\n-            Expression limit = readExpression().optimize(session);\n-            command.setLimit(limit);\n-            if (readIf(\"OFFSET\")) {\n-                Expression offset = readExpression().optimize(session);\n-                command.setOffset(offset);\n-            } else if (readIf(\",\")) {\n-                // MySQL: [offset, ] rowcount\n-                Expression offset = limit;\n-                limit = readExpression().optimize(session);\n-                command.setOffset(offset);\n-                command.setLimit(limit);\n-            }\n-            if (readIf(\"SAMPLE_SIZE\")) {\n-                Expression sampleSize = readExpression().optimize(session);\n-                command.setSampleSize(sampleSize);\n-            }\n-            currentSelect = temp;\n-        }\n-        if (readIf(\"FOR\")) {\n-            if (readIf(\"UPDATE\")) {\n-                if (readIf(\"OF\")) {\n-                    do {\n-                        readIdentifierWithSchema();\n-                    } while (readIf(\",\"));\n-                } else if (readIf(\"NOWAIT\")) {\n-                    // TODO parser: select for update nowait: should not wait\n-                }\n-                command.setForUpdate(true);\n-            } else if (readIf(\"READ\") || readIf(\"FETCH\")) {\n-                read(\"ONLY\");\n-            }\n-        }\n-        if (database.getMode().isolationLevelInSelectOrInsertStatement) {\n-            parseIsolationClause();\n-        }\n-    }\n-\n-    /**\n-     * DB2 isolation clause\n-     */\n-    private void parseIsolationClause() {\n-        if (readIf(\"WITH\")) {\n-            if (readIf(\"RR\") || readIf(\"RS\")) {\n-                // concurrent-access-resolution clause\n-                if (readIf(\"USE\")) {\n-                    read(\"AND\");\n-                    read(\"KEEP\");\n-                    if (readIf(\"SHARE\") || readIf(\"UPDATE\") ||\n-                            readIf(\"EXCLUSIVE\")) {\n-                        // ignore\n-                    }\n-                    read(\"LOCKS\");\n-                }\n-            } else if (readIf(\"CS\") || readIf(\"UR\")) {\n-                // ignore\n-            }\n-        }\n-    }\n-\n-    private Query parseSelectSub() {\n-        if (readIf(\"(\")) {\n-            Query command = parseSelectUnion();\n-            read(\")\");\n-            return command;\n-        }\n-        if (readIf(\"WITH\")) {\n-            Query query = null;\n-            try {\n-                query = (Query) parseWith();\n-            } catch (ClassCastException e) {\n-                throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n-                        \"WITH statement supports only SELECT (query) in this context\");\n-            }\n-            // recursive can not be lazy\n-            query.setNeverLazy(true);\n-            return query;\n-        }\n-        Select select = parseSelectSimple();\n-        return select;\n-    }\n-\n-    private void parseSelectSimpleFromPart(Select command) {\n-        do {\n-            TableFilter filter = readTableFilter();\n-            parseJoinTableFilter(filter, command);\n-        } while (readIf(\",\"));\n-\n-        // Parser can reorder joined table filters, need to explicitly sort them\n-        // to get the order as it was in the original query.\n-        if (session.isForceJoinOrder()) {\n-            sortTableFilters(command.getTopFilters());\n-        }\n-    }\n-\n-    private static void sortTableFilters(ArrayList<TableFilter> filters) {\n-        if (filters.size() < 2) {\n-            return;\n-        }\n-        // Most probably we are already sorted correctly.\n-        boolean sorted = true;\n-        TableFilter prev = filters.get(0);\n-        for (int i = 1; i < filters.size(); i++) {\n-            TableFilter next = filters.get(i);\n-            if (compareTableFilters(prev, next) > 0) {\n-                sorted = false;\n-                break;\n-            }\n-            prev = next;\n-        }\n-        // If not, then sort manually.\n-        if (!sorted) {\n-            Collections.sort(filters, TABLE_FILTER_COMPARATOR);\n-        }\n-    }\n-\n-    /**\n-     * Find out which of the table filters appears first in the \"from\" clause.\n-     *\n-     * @param o1 the first table filter\n-     * @param o2 the second table filter\n-     * @return -1 if o1 appears first, and 1 if o2 appears first\n-     */\n-    static int compareTableFilters(TableFilter o1, TableFilter o2) {\n-        assert o1.getOrderInFrom() != o2.getOrderInFrom();\n-        return o1.getOrderInFrom() > o2.getOrderInFrom() ? 1 : -1;\n-    }\n-\n-    private void parseJoinTableFilter(TableFilter top, final Select command) {\n-        top = readJoin(top);\n-        command.addTableFilter(top, true);\n-        boolean isOuter = false;\n-        while (true) {\n-            TableFilter n = top.getNestedJoin();\n-            if (n != null) {\n-                n.visit(new TableFilterVisitor() {\n-                    @Override\n-                    public void accept(TableFilter f) {\n-                        command.addTableFilter(f, false);\n-                    }\n-                });\n-            }\n-            TableFilter join = top.getJoin();\n-            if (join == null) {\n-                break;\n-            }\n-            isOuter = isOuter | join.isJoinOuter();\n-            if (isOuter) {\n-                command.addTableFilter(join, false);\n-            } else {\n-                // make flat so the optimizer can work better\n-                Expression on = join.getJoinCondition();\n-                if (on != null) {\n-                    command.addCondition(on);\n-                }\n-                join.removeJoinCondition();\n-                top.removeJoin();\n-                command.addTableFilter(join, true);\n-            }\n-            top = join;\n-        }\n-    }\n-\n-    private void parseSelectSimpleSelectPart(Select command) {\n-        Select temp = currentSelect;\n-        // make sure aggregate functions will not work in TOP and LIMIT\n-        currentSelect = null;\n-        if (readIf(\"TOP\")) {\n-            // can't read more complex expressions here because\n-            // SELECT TOP 1 +? A FROM TEST could mean\n-            // SELECT TOP (1+?) A FROM TEST or\n-            // SELECT TOP 1 (+?) AS A FROM TEST\n-            Expression limit = readTerm().optimize(session);\n-            command.setLimit(limit);\n-        } else if (readIf(\"LIMIT\")) {\n-            Expression offset = readTerm().optimize(session);\n-            command.setOffset(offset);\n-            Expression limit = readTerm().optimize(session);\n-            command.setLimit(limit);\n-        }\n-        currentSelect = temp;\n-        if (readIf(\"DISTINCT\")) {\n-            command.setDistinct(true);\n-        } else {\n-            readIf(\"ALL\");\n-        }\n-        ArrayList<Expression> expressions = New.arrayList();\n-        do {\n-            if (readIf(\"*\")) {\n-                expressions.add(new Wildcard(null, null));\n-            } else {\n-                Expression expr = readExpression();\n-                if (readIf(\"AS\") || currentTokenType == IDENTIFIER) {\n-                    String alias = readAliasIdentifier();\n-                    boolean aliasColumnName = database.getSettings().aliasColumnName;\n-                    aliasColumnName |= database.getMode().aliasColumnName;\n-                    expr = new Alias(expr, alias, aliasColumnName);\n-                }\n-                expressions.add(expr);\n-            }\n-        } while (readIf(\",\"));\n-        command.setExpressions(expressions);\n-    }\n-\n-    private Select parseSelectSimple() {\n-        boolean fromFirst;\n-        if (readIf(\"SELECT\")) {\n-            fromFirst = false;\n-        } else if (readIf(\"FROM\")) {\n-            fromFirst = true;\n-        } else {\n-            throw getSyntaxError();\n-        }\n-        Select command = new Select(session);\n-        int start = lastParseIndex;\n-        Select oldSelect = currentSelect;\n-        currentSelect = command;\n-        currentPrepared = command;\n-        if (fromFirst) {\n-            parseSelectSimpleFromPart(command);\n-            read(\"SELECT\");\n-            parseSelectSimpleSelectPart(command);\n-        } else {\n-            parseSelectSimpleSelectPart(command);\n-            if (!readIf(\"FROM\")) {\n-                // select without FROM: convert to SELECT ... FROM\n-                // SYSTEM_RANGE(1,1)\n-                Table dual = getDualTable(false);\n-                TableFilter filter = new TableFilter(session, dual, null,\n-                        rightsChecked, currentSelect, 0,\n-                        null);\n-                command.addTableFilter(filter, true);\n-            } else {\n-                parseSelectSimpleFromPart(command);\n-            }\n-        }\n-        if (readIf(\"WHERE\")) {\n-            Expression condition = readExpression();\n-            command.addCondition(condition);\n-        }\n-        // the group by is read for the outer select (or not a select)\n-        // so that columns that are not grouped can be used\n-        currentSelect = oldSelect;\n-        if (readIf(\"GROUP\")) {\n-            read(\"BY\");\n-            command.setGroupQuery();\n-            ArrayList<Expression> list = New.arrayList();\n-            do {\n-                Expression expr = readExpression();\n-                list.add(expr);\n-            } while (readIf(\",\"));\n-            command.setGroupBy(list);\n-        }\n-        currentSelect = command;\n-        if (readIf(\"HAVING\")) {\n-            command.setGroupQuery();\n-            Expression condition = readExpression();\n-            command.setHaving(condition);\n-        }\n-        command.setParameterList(parameters);\n-        currentSelect = oldSelect;\n-        setSQL(command, \"SELECT\", start);\n-        return command;\n-    }\n-\n-    private Table getDualTable(boolean noColumns) {\n-        Schema main = database.findSchema(Constants.SCHEMA_MAIN);\n-        Expression one = ValueExpression.get(ValueLong.get(1));\n-        return new RangeTable(main, one, one, noColumns);\n-    }\n-\n-    private void setSQL(Prepared command, String start, int startIndex) {\n-        String sql = originalSQL.substring(startIndex, lastParseIndex).trim();\n-        if (start != null) {\n-            sql = start + \" \" + sql;\n-        }\n-        command.setSQL(sql);\n-    }\n-\n-    private Expression readExpression() {\n-        Expression r = readAnd();\n-        while (readIf(\"OR\")) {\n-            r = new ConditionAndOr(ConditionAndOr.OR, r, readAnd());\n-        }\n-        return r;\n-    }\n-\n-    private Expression readAnd() {\n-        Expression r = readCondition();\n-        while (readIf(\"AND\")) {\n-            r = new ConditionAndOr(ConditionAndOr.AND, r, readCondition());\n-        }\n-        return r;\n-    }\n-\n-    private Expression readCondition() {\n-        if (readIf(\"NOT\")) {\n-            return new ConditionNot(readCondition());\n-        }\n-        if (readIf(\"EXISTS\")) {\n-            read(\"(\");\n-            Query query = parseSelect();\n-            // can not reduce expression because it might be a union except\n-            // query with distinct\n-            read(\")\");\n-            return new ConditionExists(query);\n-        }\n-        if (readIf(\"INTERSECTS\")) {\n-            read(\"(\");\n-            Expression r1 = readConcat();\n-            read(\",\");\n-            Expression r2 = readConcat();\n-            read(\")\");\n-            return new Comparison(session, Comparison.SPATIAL_INTERSECTS, r1,\n-                    r2);\n-        }\n-        Expression r = readConcat();\n-        while (true) {\n-            // special case: NOT NULL is not part of an expression (as in CREATE\n-            // TABLE TEST(ID INT DEFAULT 0 NOT NULL))\n-            int backup = parseIndex;\n-            boolean not = false;\n-            if (readIf(\"NOT\")) {\n-                not = true;\n-                if (isToken(\"NULL\")) {\n-                    // this really only works for NOT NULL!\n-                    parseIndex = backup;\n-                    currentToken = \"NOT\";\n-                    break;\n-                }\n-            }\n-            if (readIf(\"LIKE\")) {\n-                Expression b = readConcat();\n-                Expression esc = null;\n-                if (readIf(\"ESCAPE\")) {\n-                    esc = readConcat();\n-                }\n-                recompileAlways = true;\n-                r = new CompareLike(database, r, b, esc, false);\n-            } else if (readIf(\"ILIKE\")) {\n-                Function function = Function.getFunction(database, \"CAST\");\n-                function.setDataType(new Column(\"X\", Value.STRING_IGNORECASE));\n-                function.setParameter(0, r);\n-                r = function;\n-                Expression b = readConcat();\n-                Expression esc = null;\n-                if (readIf(\"ESCAPE\")) {\n-                    esc = readConcat();\n-                }\n-                recompileAlways = true;\n-                r = new CompareLike(database, r, b, esc, false);\n-            } else if (readIf(\"REGEXP\")) {\n-                Expression b = readConcat();\n-                recompileAlways = true;\n-                r = new CompareLike(database, r, b, null, true);\n-            } else if (readIf(\"IS\")) {\n-                if (readIf(\"NOT\")) {\n-                    if (readIf(\"NULL\")) {\n-                        r = new Comparison(session, Comparison.IS_NOT_NULL, r,\n-                                null);\n-                    } else if (readIf(\"DISTINCT\")) {\n-                        read(\"FROM\");\n-                        r = new Comparison(session, Comparison.EQUAL_NULL_SAFE,\n-                                r, readConcat());\n-                    } else {\n-                        r = new Comparison(session,\n-                                Comparison.NOT_EQUAL_NULL_SAFE, r, readConcat());\n-                    }\n-                } else if (readIf(\"NULL\")) {\n-                    r = new Comparison(session, Comparison.IS_NULL, r, null);\n-                } else if (readIf(\"DISTINCT\")) {\n-                    read(\"FROM\");\n-                    r = new Comparison(session, Comparison.NOT_EQUAL_NULL_SAFE,\n-                            r, readConcat());\n-                } else {\n-                    r = new Comparison(session, Comparison.EQUAL_NULL_SAFE, r,\n-                            readConcat());\n-                }\n-            } else if (readIf(\"IN\")) {\n-                read(\"(\");\n-                if (readIf(\")\")) {\n-                    if (database.getMode().prohibitEmptyInPredicate) {\n-                        throw getSyntaxError();\n-                    }\n-                    r = ValueExpression.get(ValueBoolean.get(false));\n-                } else {\n-                    if (isSelect()) {\n-                        Query query = parseSelect();\n-                        // can not be lazy because we have to call\n-                        // method ResultInterface.containsDistinct\n-                        // which is not supported for lazy execution\n-                        query.setNeverLazy(true);\n-                        r = new ConditionInSelect(database, r, query, false,\n-                                Comparison.EQUAL);\n-                    } else {\n-                        ArrayList<Expression> v = New.arrayList();\n-                        Expression last;\n-                        do {\n-                            last = readExpression();\n-                            v.add(last);\n-                        } while (readIf(\",\"));\n-                        if (v.size() == 1 && (last instanceof Subquery)) {\n-                            Subquery s = (Subquery) last;\n-                            Query q = s.getQuery();\n-                            r = new ConditionInSelect(database, r, q, false,\n-                                    Comparison.EQUAL);\n-                        } else {\n-                            r = new ConditionIn(database, r, v);\n-                        }\n-                    }\n-                    read(\")\");\n-                }\n-            } else if (readIf(\"BETWEEN\")) {\n-                Expression low = readConcat();\n-                read(\"AND\");\n-                Expression high = readConcat();\n-                Expression condLow = new Comparison(session,\n-                        Comparison.SMALLER_EQUAL, low, r);\n-                Expression condHigh = new Comparison(session,\n-                        Comparison.BIGGER_EQUAL, high, r);\n-                r = new ConditionAndOr(ConditionAndOr.AND, condLow, condHigh);\n-            } else {\n-                int compareType = getCompareType(currentTokenType);\n-                if (compareType < 0) {\n-                    break;\n-                }\n-                read();\n-                if (readIf(\"ALL\")) {\n-                    read(\"(\");\n-                    Query query = parseSelect();\n-                    r = new ConditionInSelect(database, r, query, true,\n-                            compareType);\n-                    read(\")\");\n-                } else if (readIf(\"ANY\") || readIf(\"SOME\")) {\n-                    read(\"(\");\n-                    if (currentTokenType == PARAMETER && compareType == 0) {\n-                        Parameter p = readParameter();\n-                        r = new ConditionInParameter(database, r, p);\n-                    } else {\n-                        Query query = parseSelect();\n-                        r = new ConditionInSelect(database, r, query, false,\n-                                compareType);\n-                    }\n-                    read(\")\");\n-                } else {\n-                    Expression right = readConcat();\n-                    if (SysProperties.OLD_STYLE_OUTER_JOIN &&\n-                            readIf(\"(\") && readIf(\"+\") && readIf(\")\")) {\n-                        // support for a subset of old-fashioned Oracle outer\n-                        // join with (+)\n-                        if (r instanceof ExpressionColumn &&\n-                                right instanceof ExpressionColumn) {\n-                            ExpressionColumn leftCol = (ExpressionColumn) r;\n-                            ExpressionColumn rightCol = (ExpressionColumn) right;\n-                            ArrayList<TableFilter> filters = currentSelect\n-                                    .getTopFilters();\n-                            for (TableFilter f : filters) {\n-                                while (f != null) {\n-                                    leftCol.mapColumns(f, 0);\n-                                    rightCol.mapColumns(f, 0);\n-                                    f = f.getJoin();\n-                                }\n-                            }\n-                            TableFilter leftFilter = leftCol.getTableFilter();\n-                            TableFilter rightFilter = rightCol.getTableFilter();\n-                            r = new Comparison(session, compareType, r, right);\n-                            if (leftFilter != null && rightFilter != null) {\n-                                int idx = filters.indexOf(rightFilter);\n-                                if (idx >= 0) {\n-                                    filters.remove(idx);\n-                                    leftFilter.addJoin(rightFilter, true, r);\n-                                } else {\n-                                    rightFilter.mapAndAddFilter(r);\n-                                }\n-                                r = ValueExpression.get(ValueBoolean.get(true));\n-                            }\n-                        }\n-                    } else {\n-                        r = new Comparison(session, compareType, r, right);\n-                    }\n-                }\n-            }\n-            if (not) {\n-                r = new ConditionNot(r);\n-            }\n-        }\n-        return r;\n-    }\n-\n-    private Expression readConcat() {\n-        Expression r = readSum();\n-        while (true) {\n-            if (readIf(\"||\")) {\n-                r = new Operation(OpType.CONCAT, r, readSum());\n-            } else if (readIf(\"~\")) {\n-                if (readIf(\"*\")) {\n-                    Function function = Function.getFunction(database, \"CAST\");\n-                    function.setDataType(new Column(\"X\",\n-                            Value.STRING_IGNORECASE));\n-                    function.setParameter(0, r);\n-                    r = function;\n-                }\n-                r = new CompareLike(database, r, readSum(), null, true);\n-            } else if (readIf(\"!~\")) {\n-                if (readIf(\"*\")) {\n-                    Function function = Function.getFunction(database, \"CAST\");\n-                    function.setDataType(new Column(\"X\",\n-                            Value.STRING_IGNORECASE));\n-                    function.setParameter(0, r);\n-                    r = function;\n-                }\n-                r = new ConditionNot(new CompareLike(database, r, readSum(),\n-                        null, true));\n-            } else {\n-                return r;\n-            }\n-        }\n-    }\n-\n-    private Expression readSum() {\n-        Expression r = readFactor();\n-        while (true) {\n-            if (readIf(\"+\")) {\n-                r = new Operation(OpType.PLUS, r, readFactor());\n-            } else if (readIf(\"-\")) {\n-                r = new Operation(OpType.MINUS, r, readFactor());\n-            } else {\n-                return r;\n-            }\n-        }\n-    }\n-\n-    private Expression readFactor() {\n-        Expression r = readTerm();\n-        while (true) {\n-            if (readIf(\"*\")) {\n-                r = new Operation(OpType.MULTIPLY, r, readTerm());\n-            } else if (readIf(\"/\")) {\n-                r = new Operation(OpType.DIVIDE, r, readTerm());\n-            } else if (readIf(\"%\")) {\n-                r = new Operation(OpType.MODULUS, r, readTerm());\n-            } else {\n-                return r;\n-            }\n-        }\n-    }\n-\n-    private Expression readAggregate(AggregateType aggregateType, String aggregateName) {\n-        if (currentSelect == null) {\n-            throw getSyntaxError();\n-        }\n-        currentSelect.setGroupQuery();\n-        Aggregate r;\n-        if (aggregateType == AggregateType.COUNT) {\n-            if (readIf(\"*\")) {\n-                r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect,\n-                        false);\n-            } else {\n-                boolean distinct = readIf(\"DISTINCT\");\n-                Expression on = readExpression();\n-                if (on instanceof Wildcard && !distinct) {\n-                    // PostgreSQL compatibility: count(t.*)\n-                    r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect,\n-                            false);\n-                } else {\n-                    r = new Aggregate(AggregateType.COUNT, on, currentSelect,\n-                            distinct);\n-                }\n-            }\n-        } else if (aggregateType == AggregateType.GROUP_CONCAT) {\n-            boolean distinct = readIf(\"DISTINCT\");\n-\n-            if (equalsToken(\"GROUP_CONCAT\", aggregateName)) {\n-                r = new Aggregate(AggregateType.GROUP_CONCAT,\n-                    readExpression(), currentSelect, distinct);\n-                if (readIf(\"ORDER\")) {\n-                    read(\"BY\");\n-                    r.setGroupConcatOrder(parseSimpleOrderList());\n-                }\n-\n-                if (readIf(\"SEPARATOR\")) {\n-                    r.setGroupConcatSeparator(readExpression());\n-                }\n-            } else if (equalsToken(\"STRING_AGG\", aggregateName)) {\n-                // PostgreSQL compatibility: string_agg(expression, delimiter)\n-                r = new Aggregate(AggregateType.GROUP_CONCAT,\n-                    readExpression(), currentSelect, distinct);\n-                read(\",\");\n-                r.setGroupConcatSeparator(readExpression());\n-                if (readIf(\"ORDER\")) {\n-                    read(\"BY\");\n-                    r.setGroupConcatOrder(parseSimpleOrderList());\n-                }\n-            } else {\n-                r = null;\n-            }\n-        } else {\n-            boolean distinct = readIf(\"DISTINCT\");\n-            r = new Aggregate(aggregateType, readExpression(), currentSelect,\n-                    distinct);\n-        }\n-        read(\")\");\n-        if (r != null && readIf(\"FILTER\")) {\n-            read(\"(\");\n-            read(\"WHERE\");\n-            Expression condition = readExpression();\n-            read(\")\");\n-            r.setFilterCondition(condition);\n-        }\n-        return r;\n-    }\n-\n-    private ArrayList<SelectOrderBy> parseSimpleOrderList() {\n-        ArrayList<SelectOrderBy> orderList = New.arrayList();\n-        do {\n-            SelectOrderBy order = new SelectOrderBy();\n-            Expression expr = readExpression();\n-            order.expression = expr;\n-            if (readIf(\"DESC\")) {\n-                order.descending = true;\n-            } else {\n-                readIf(\"ASC\");\n-            }\n-            orderList.add(order);\n-        } while (readIf(\",\"));\n-        return orderList;\n-    }\n-\n-    private JavaFunction readJavaFunction(Schema schema, String functionName) {\n-        FunctionAlias functionAlias = null;\n-        if (schema != null) {\n-            functionAlias = schema.findFunction(functionName);\n-        } else {\n-            functionAlias = findFunctionAlias(session.getCurrentSchemaName(),\n-                    functionName);\n-        }\n-        if (functionAlias == null) {\n-            throw DbException.get(ErrorCode.FUNCTION_NOT_FOUND_1, functionName);\n-        }\n-        Expression[] args;\n-        ArrayList<Expression> argList = New.arrayList();\n-        int numArgs = 0;\n-        while (!readIf(\")\")) {\n-            if (numArgs++ > 0) {\n-                read(\",\");\n-            }\n-            argList.add(readExpression());\n-        }\n-        args = argList.toArray(new Expression[0]);\n-        JavaFunction func = new JavaFunction(functionAlias, args);\n-        return func;\n-    }\n-\n-    private JavaAggregate readJavaAggregate(UserAggregate aggregate) {\n-        ArrayList<Expression> params = New.arrayList();\n-        do {\n-            params.add(readExpression());\n-        } while (readIf(\",\"));\n-        read(\")\");\n-        Expression filterCondition;\n-        if (readIf(\"FILTER\")) {\n-            read(\"(\");\n-            read(\"WHERE\");\n-            filterCondition = readExpression();\n-            read(\")\");\n-        } else {\n-            filterCondition = null;\n-        }\n-        Expression[] list = params.toArray(new Expression[0]);\n-        JavaAggregate agg = new JavaAggregate(aggregate, list, currentSelect, filterCondition);\n-        currentSelect.setGroupQuery();\n-        return agg;\n-    }\n-\n-    private AggregateType getAggregateType(String name) {\n-        if (!identifiersToUpper) {\n-            // if not yet converted to uppercase, do it now\n-            name = StringUtils.toUpperEnglish(name);\n-        }\n-        return Aggregate.getAggregateType(name);\n-    }\n-\n-    private Expression readFunction(Schema schema, String name) {\n-        if (schema != null) {\n-            return readJavaFunction(schema, name);\n-        }\n-        AggregateType agg = getAggregateType(name);\n-        if (agg != null) {\n-            return readAggregate(agg, name);\n-        }\n-        Function function = Function.getFunction(database, name);\n-        if (function == null) {\n-            UserAggregate aggregate = database.findAggregate(name);\n-            if (aggregate != null) {\n-                return readJavaAggregate(aggregate);\n-            }\n-            return readJavaFunction(null, name);\n-        }\n-        switch (function.getFunctionType()) {\n-        case Function.CAST: {\n-            function.setParameter(0, readExpression());\n-            read(\"AS\");\n-            Column type = parseColumnWithType(null);\n-            function.setDataType(type);\n-            read(\")\");\n-            break;\n-        }\n-        case Function.CONVERT: {\n-            if (database.getMode().swapConvertFunctionParameters) {\n-                Column type = parseColumnWithType(null);\n-                function.setDataType(type);\n-                read(\",\");\n-                function.setParameter(0, readExpression());\n-                read(\")\");\n-            } else {\n-                function.setParameter(0, readExpression());\n-                read(\",\");\n-                Column type = parseColumnWithType(null);\n-                function.setDataType(type);\n-                read(\")\");\n-            }\n-            break;\n-        }\n-        case Function.EXTRACT: {\n-            function.setParameter(0,\n-                    ValueExpression.get(ValueString.get(currentToken)));\n-            read();\n-            read(\"FROM\");\n-            function.setParameter(1, readExpression());\n-            read(\")\");\n-            break;\n-        }\n-        case Function.DATE_ADD:\n-        case Function.DATE_DIFF: {\n-            if (Function.isDatePart(currentToken)) {\n-                function.setParameter(0,\n-                        ValueExpression.get(ValueString.get(currentToken)));\n-                read();\n-            } else {\n-                function.setParameter(0, readExpression());\n-            }\n-            read(\",\");\n-            function.setParameter(1, readExpression());\n-            read(\",\");\n-            function.setParameter(2, readExpression());\n-            read(\")\");\n-            break;\n-        }\n-        case Function.SUBSTRING: {\n-            // Different variants include:\n-            // SUBSTRING(X,1)\n-            // SUBSTRING(X,1,1)\n-            // SUBSTRING(X FROM 1 FOR 1) -- Postgres\n-            // SUBSTRING(X FROM 1) -- Postgres\n-            // SUBSTRING(X FOR 1) -- Postgres\n-            function.setParameter(0, readExpression());\n-            if (readIf(\"FROM\")) {\n-                function.setParameter(1, readExpression());\n-                if (readIf(\"FOR\")) {\n-                    function.setParameter(2, readExpression());\n-                }\n-            } else if (readIf(\"FOR\")) {\n-                function.setParameter(1, ValueExpression.get(ValueInt.get(0)));\n-                function.setParameter(2, readExpression());\n-            } else {\n-                read(\",\");\n-                function.setParameter(1, readExpression());\n-                if (readIf(\",\")) {\n-                    function.setParameter(2, readExpression());\n-                }\n-            }\n-            read(\")\");\n-            break;\n-        }\n-        case Function.POSITION: {\n-            // can't read expression because IN would be read too early\n-            function.setParameter(0, readConcat());\n-            if (!readIf(\",\")) {\n-                read(\"IN\");\n-            }\n-            function.setParameter(1, readExpression());\n-            read(\")\");\n-            break;\n-        }\n-        case Function.TRIM: {\n-            Expression space = null;\n-            if (readIf(\"LEADING\")) {\n-                function = Function.getFunction(database, \"LTRIM\");\n-                if (!readIf(\"FROM\")) {\n-                    space = readExpression();\n-                    read(\"FROM\");\n-                }\n-            } else if (readIf(\"TRAILING\")) {\n-                function = Function.getFunction(database, \"RTRIM\");\n-                if (!readIf(\"FROM\")) {\n-                    space = readExpression();\n-                    read(\"FROM\");\n-                }\n-            } else if (readIf(\"BOTH\")) {\n-                if (!readIf(\"FROM\")) {\n-                    space = readExpression();\n-                    read(\"FROM\");\n-                }\n-            }\n-            Expression p0 = readExpression();\n-            if (readIf(\",\")) {\n-                space = readExpression();\n-            } else if (readIf(\"FROM\")) {\n-                space = p0;\n-                p0 = readExpression();\n-            }\n-            function.setParameter(0, p0);\n-            if (space != null) {\n-                function.setParameter(1, space);\n-            }\n-            read(\")\");\n-            break;\n-        }\n-        case Function.TABLE:\n-        case Function.TABLE_DISTINCT: {\n-            int i = 0;\n-            ArrayList<Column> columns = New.arrayList();\n-            do {\n-                String columnName = readAliasIdentifier();\n-                Column column = parseColumnWithType(columnName);\n-                columns.add(column);\n-                read(\"=\");\n-                function.setParameter(i, readExpression());\n-                i++;\n-            } while (readIf(\",\"));\n-            read(\")\");\n-            TableFunction tf = (TableFunction) function;\n-            tf.setColumns(columns);\n-            break;\n-        }\n-        case Function.ROW_NUMBER:\n-            read(\")\");\n-            read(\"OVER\");\n-            read(\"(\");\n-            read(\")\");\n-            if (currentSelect == null && currentPrepared == null) {\n-                throw getSyntaxError();\n-            }\n-            return new Rownum(currentSelect == null ? currentPrepared\n-                    : currentSelect);\n-        default:\n-            if (!readIf(\")\")) {\n-                int i = 0;\n-                do {\n-                    function.setParameter(i++, readExpression());\n-                } while (readIf(\",\"));\n-                read(\")\");\n-            }\n-        }\n-        function.doneWithParameters();\n-        return function;\n-    }\n-\n-    private Expression readFunctionWithoutParameters(String name) {\n-        if (readIf(\"(\")) {\n-            read(\")\");\n-        }\n-        if (database.isAllowBuiltinAliasOverride()) {\n-            FunctionAlias functionAlias = database.getSchema(session.getCurrentSchemaName()).findFunction(name);\n-            if (functionAlias != null) {\n-                JavaFunction func = new JavaFunction(functionAlias, new Expression[0]);\n-                return func;\n-            }\n-        }\n-        Function function = Function.getFunction(database, name);\n-        function.doneWithParameters();\n-        return function;\n-    }\n-\n-    private Expression readWildcardOrSequenceValue(String schema,\n-            String objectName) {\n-        if (readIf(\"*\")) {\n-            return new Wildcard(schema, objectName);\n-        }\n-        if (schema == null) {\n-            schema = session.getCurrentSchemaName();\n-        }\n-        if (readIf(\"NEXTVAL\")) {\n-            Sequence sequence = findSequence(schema, objectName);\n-            if (sequence != null) {\n-                return new SequenceValue(sequence);\n-            }\n-        } else if (readIf(\"CURRVAL\")) {\n-            Sequence sequence = findSequence(schema, objectName);\n-            if (sequence != null) {\n-                Function function = Function.getFunction(database, \"CURRVAL\");\n-                function.setParameter(0, ValueExpression.get(ValueString\n-                        .get(sequence.getSchema().getName())));\n-                function.setParameter(1, ValueExpression.get(ValueString\n-                        .get(sequence.getName())));\n-                function.doneWithParameters();\n-                return function;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private Expression readTermObjectDot(String objectName) {\n-        Expression expr = readWildcardOrSequenceValue(null, objectName);\n-        if (expr != null) {\n-            return expr;\n-        }\n-        String name = readColumnIdentifier();\n-        Schema s = database.findSchema(objectName);\n-        if ((!SysProperties.OLD_STYLE_OUTER_JOIN || s != null) && readIf(\"(\")) {\n-            // only if the token before the dot is a valid schema name,\n-            // otherwise the old style Oracle outer join doesn't work:\n-            // t.x = t2.x(+)\n-            // this additional check is not required\n-            // if the old style outer joins are not supported\n-            return readFunction(s, name);\n-        } else if (readIf(\".\")) {\n-            String schema = objectName;\n-            objectName = name;\n-            expr = readWildcardOrSequenceValue(schema, objectName);\n-            if (expr != null) {\n-                return expr;\n-            }\n-            name = readColumnIdentifier();\n-            if (readIf(\"(\")) {\n-                String databaseName = schema;\n-                if (!equalsToken(database.getShortName(), databaseName)) {\n-                    throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n-                            databaseName);\n-                }\n-                schema = objectName;\n-                return readFunction(database.getSchema(schema), name);\n-            } else if (readIf(\".\")) {\n-                String databaseName = schema;\n-                if (!equalsToken(database.getShortName(), databaseName)) {\n-                    throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n-                            databaseName);\n-                }\n-                schema = objectName;\n-                objectName = name;\n-                expr = readWildcardOrSequenceValue(schema, objectName);\n-                if (expr != null) {\n-                    return expr;\n-                }\n-                name = readColumnIdentifier();\n-                return new ExpressionColumn(database, schema, objectName, name);\n-            }\n-            return new ExpressionColumn(database, schema, objectName, name);\n-        }\n-        return new ExpressionColumn(database, null, objectName, name);\n-    }\n-\n-    private Parameter readParameter() {\n-        // there must be no space between ? and the number\n-        boolean indexed = Character.isDigit(sqlCommandChars[parseIndex]);\n-\n-        Parameter p;\n-        if (indexed) {\n-            readParameterIndex();\n-            if (indexedParameterList == null) {\n-                if (parameters == null) {\n-                    // this can occur when parsing expressions only (for\n-                    // example check constraints)\n-                    throw getSyntaxError();\n-                } else if (!parameters.isEmpty()) {\n-                    throw DbException\n-                            .get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n-                }\n-                indexedParameterList = New.arrayList();\n-            }\n-            int index = currentValue.getInt() - 1;\n-            if (index < 0 || index >= Constants.MAX_PARAMETER_INDEX) {\n-                throw DbException.getInvalidValueException(\n-                        \"parameter index\", index);\n-            }\n-            if (indexedParameterList.size() <= index) {\n-                indexedParameterList.ensureCapacity(index + 1);\n-                while (indexedParameterList.size() <= index) {\n-                    indexedParameterList.add(null);\n-                }\n-            }\n-            p = indexedParameterList.get(index);\n-            if (p == null) {\n-                p = new Parameter(index);\n-                indexedParameterList.set(index, p);\n-            }\n-            read();\n-        } else {\n-            read();\n-            if (indexedParameterList != null) {\n-                throw DbException\n-                        .get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n-            }\n-            p = new Parameter(parameters.size());\n-        }\n-        parameters.add(p);\n-        return p;\n-    }\n-\n-    private Expression readTerm() {\n-        Expression r;\n-        switch (currentTokenType) {\n-        case AT:\n-            read();\n-            r = new Variable(session, readAliasIdentifier());\n-            if (readIf(\":=\")) {\n-                Expression value = readExpression();\n-                Function function = Function.getFunction(database, \"SET\");\n-                function.setParameter(0, r);\n-                function.setParameter(1, value);\n-                r = function;\n-            }\n-            break;\n-        case PARAMETER:\n-            r = readParameter();\n-            break;\n-        case KEYWORD:\n-            if (isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"WITH\")) {\n-                Query query = parseSelect();\n-                r = new Subquery(query);\n-            } else {\n-                throw getSyntaxError();\n-            }\n-            break;\n-        case IDENTIFIER:\n-            String name = currentToken;\n-            if (currentTokenQuoted) {\n-                read();\n-                if (readIf(\"(\")) {\n-                    r = readFunction(null, name);\n-                } else if (readIf(\".\")) {\n-                    r = readTermObjectDot(name);\n-                } else {\n-                    r = new ExpressionColumn(database, null, null, name);\n-                }\n-            } else {\n-                read();\n-                if (readIf(\".\")) {\n-                    r = readTermObjectDot(name);\n-                } else if (equalsToken(\"CASE\", name)) {\n-                    // CASE must be processed before (,\n-                    // otherwise CASE(3) would be a function call, which it is\n-                    // not\n-                    r = readCase();\n-                } else if (readIf(\"(\")) {\n-                    r = readFunction(null, name);\n-                } else if (equalsToken(\"CURRENT_USER\", name)) {\n-                    r = readFunctionWithoutParameters(\"USER\");\n-                } else if (equalsToken(\"CURRENT_TIMESTAMP\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                } else if (equalsToken(\"SYSDATE\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                } else if (equalsToken(\"SYSTIMESTAMP\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                } else if (equalsToken(\"CURRENT_DATE\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n-                } else if (equalsToken(\"TODAY\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n-                } else if (equalsToken(\"CURRENT_TIME\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n-                } else if (equalsToken(\"SYSTIME\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n-                } else if (equalsToken(\"CURRENT\", name)) {\n-                    if (readIf(\"TIMESTAMP\")) {\n-                        r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                    } else if (readIf(\"TIME\")) {\n-                        r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n-                    } else if (readIf(\"DATE\")) {\n-                        r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n-                    } else {\n-                        r = new ExpressionColumn(database, null, null, name);\n-                    }\n-                } else if (equalsToken(\"NEXT\", name) && readIf(\"VALUE\")) {\n-                    read(\"FOR\");\n-                    Sequence sequence = readSequence();\n-                    r = new SequenceValue(sequence);\n-                } else if (equalsToken(\"TIME\", name)) {\n-                    boolean without = readIf(\"WITHOUT\");\n-                    if (without) {\n-                        read(\"TIME\");\n-                        read(\"ZONE\");\n-                    }\n-                    if (currentTokenType != VALUE\n-                            || currentValue.getType() != Value.STRING) {\n-                        if (without) {\n-                            throw getSyntaxError();\n-                        }\n-                        r = new ExpressionColumn(database, null, null, name);\n-                    } else {\n-                        String time = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueTime.parse(time));\n-                    }\n-                } else if (equalsToken(\"TIMESTAMP\", name)) {\n-                    if (readIf(\"WITH\")) {\n-                        read(\"TIME\");\n-                        read(\"ZONE\");\n-                        if (currentTokenType != VALUE\n-                                || currentValue.getType() != Value.STRING) {\n-                            throw getSyntaxError();\n-                        }\n-                        String timestamp = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueTimestampTimeZone.parse(timestamp));\n-                    } else {\n-                        boolean without = readIf(\"WITHOUT\");\n-                        if (without) {\n-                            read(\"TIME\");\n-                            read(\"ZONE\");\n-                        }\n-                        if (currentTokenType != VALUE\n-                                || currentValue.getType() != Value.STRING) {\n-                            if (without) {\n-                                throw getSyntaxError();\n-                            }\n-                            r = new ExpressionColumn(database, null, null, name);\n-                        } else {\n-                            String timestamp = currentValue.getString();\n-                            read();\n-                            r = ValueExpression.get(ValueTimestamp.parse(timestamp, database.getMode()));\n-                        }\n-                    }\n-                } else if (currentTokenType == VALUE &&\n-                        currentValue.getType() == Value.STRING) {\n-                    if (equalsToken(\"DATE\", name) ||\n-                            equalsToken(\"D\", name)) {\n-                        String date = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueDate.parse(date));\n-                    } else if (equalsToken(\"T\", name)) {\n-                        String time = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueTime.parse(time));\n-                    } else if (equalsToken(\"TS\", name)) {\n-                        String timestamp = currentValue.getString();\n-                        read();\n-                        r = ValueExpression\n-                                .get(ValueTimestamp.parse(timestamp, database.getMode()));\n-                    } else if (equalsToken(\"X\", name)) {\n-                        read();\n-                        byte[] buffer = StringUtils\n-                                .convertHexToBytes(currentValue.getString());\n-                        r = ValueExpression.get(ValueBytes.getNoCopy(buffer));\n-                    } else if (equalsToken(\"E\", name)) {\n-                        String text = currentValue.getString();\n-                        // the PostgreSQL ODBC driver uses\n-                        // LIKE E'PROJECT\\\\_DATA' instead of LIKE\n-                        // 'PROJECT\\_DATA'\n-                        // N: SQL-92 \"National Language\" strings\n-                        text = StringUtils.replaceAll(text, \"\\\\\\\\\", \"\\\\\");\n-                        read();\n-                        r = ValueExpression.get(ValueString.get(text));\n-                    } else if (equalsToken(\"N\", name)) {\n-                        // SQL-92 \"National Language\" strings\n-                        String text = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueString.get(text));\n-                    } else {\n-                        r = new ExpressionColumn(database, null, null, name);\n-                    }\n-                } else {\n-                    r = new ExpressionColumn(database, null, null, name);\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            read();\n-            if (currentTokenType == VALUE) {\n-                r = ValueExpression.get(currentValue.negate());\n-                if (r.getType() == Value.LONG &&\n-                        r.getValue(session).getLong() == Integer.MIN_VALUE) {\n-                    // convert Integer.MIN_VALUE to type 'int'\n-                    // (Integer.MAX_VALUE+1 is of type 'long')\n-                    r = ValueExpression.get(ValueInt.get(Integer.MIN_VALUE));\n-                } else if (r.getType() == Value.DECIMAL &&\n-                        r.getValue(session).getBigDecimal()\n-                                .compareTo(ValueLong.MIN_BD) == 0) {\n-                    // convert Long.MIN_VALUE to type 'long'\n-                    // (Long.MAX_VALUE+1 is of type 'decimal')\n-                    r = ValueExpression.get(ValueLong.MIN);\n-                }\n-                read();\n-            } else {\n-                r = new Operation(OpType.NEGATE, readTerm(), null);\n-            }\n-            break;\n-        case PLUS:\n-            read();\n-            r = readTerm();\n-            break;\n-        case OPEN:\n-            read();\n-            if (readIf(\")\")) {\n-                r = new ExpressionList(new Expression[0]);\n-            } else {\n-                r = readExpression();\n-                if (readIf(\",\")) {\n-                    ArrayList<Expression> list = New.arrayList();\n-                    list.add(r);\n-                    while (!readIf(\")\")) {\n-                        r = readExpression();\n-                        list.add(r);\n-                        if (!readIf(\",\")) {\n-                            read(\")\");\n-                            break;\n-                        }\n-                    }\n-                    r = new ExpressionList(list.toArray(new Expression[0]));\n-                } else {\n-                    read(\")\");\n-                }\n-            }\n-            break;\n-        case TRUE:\n-            read();\n-            r = ValueExpression.get(ValueBoolean.get(true));\n-            break;\n-        case FALSE:\n-            read();\n-            r = ValueExpression.get(ValueBoolean.get(false));\n-            break;\n-        case ROWNUM:\n-            read();\n-            if (readIf(\"(\")) {\n-                read(\")\");\n-            }\n-            if (currentSelect == null && currentPrepared == null) {\n-                throw getSyntaxError();\n-            }\n-            r = new Rownum(currentSelect == null ? currentPrepared\n-                    : currentSelect);\n-            break;\n-        case NULL:\n-            read();\n-            r = ValueExpression.getNull();\n-            break;\n-        case VALUE:\n-            r = ValueExpression.get(currentValue);\n-            read();\n-            break;\n-        default:\n-            throw getSyntaxError();\n-        }\n-        if (readIf(\"[\")) {\n-            Function function = Function.getFunction(database, \"ARRAY_GET\");\n-            function.setParameter(0, r);\n-            r = readExpression();\n-            r = new Operation(OpType.PLUS, r, ValueExpression.get(ValueInt\n-                    .get(1)));\n-            function.setParameter(1, r);\n-            r = function;\n-            read(\"]\");\n-        }\n-        if (readIf(\"::\")) {\n-            // PostgreSQL compatibility\n-            if (isToken(\"PG_CATALOG\")) {\n-                read(\"PG_CATALOG\");\n-                read(\".\");\n-            }\n-            if (readIf(\"REGCLASS\")) {\n-                FunctionAlias f = findFunctionAlias(Constants.SCHEMA_MAIN,\n-                        \"PG_GET_OID\");\n-                if (f == null) {\n-                    throw getSyntaxError();\n-                }\n-                Expression[] args = { r };\n-                JavaFunction func = new JavaFunction(f, args);\n-                r = func;\n-            } else {\n-                Column col = parseColumnWithType(null);\n-                Function function = Function.getFunction(database, \"CAST\");\n-                function.setDataType(col);\n-                function.setParameter(0, r);\n-                r = function;\n-            }\n-        }\n-        return r;\n-    }\n-\n-    private Expression readCase() {\n-        if (readIf(\"END\")) {\n-            readIf(\"CASE\");\n-            return ValueExpression.getNull();\n-        }\n-        if (readIf(\"ELSE\")) {\n-            Expression elsePart = readExpression().optimize(session);\n-            read(\"END\");\n-            readIf(\"CASE\");\n-            return elsePart;\n-        }\n-        int i;\n-        Function function;\n-        if (readIf(\"WHEN\")) {\n-            function = Function.getFunction(database, \"CASE\");\n-            function.setParameter(0, null);\n-            i = 1;\n-            do {\n-                function.setParameter(i++, readExpression());\n-                read(\"THEN\");\n-                function.setParameter(i++, readExpression());\n-            } while (readIf(\"WHEN\"));\n-        } else {\n-            Expression expr = readExpression();\n-            if (readIf(\"END\")) {\n-                readIf(\"CASE\");\n-                return ValueExpression.getNull();\n-            }\n-            if (readIf(\"ELSE\")) {\n-                Expression elsePart = readExpression().optimize(session);\n-                read(\"END\");\n-                readIf(\"CASE\");\n-                return elsePart;\n-            }\n-            function = Function.getFunction(database, \"CASE\");\n-            function.setParameter(0, expr);\n-            i = 1;\n-            read(\"WHEN\");\n-            do {\n-                function.setParameter(i++, readExpression());\n-                read(\"THEN\");\n-                function.setParameter(i++, readExpression());\n-            } while (readIf(\"WHEN\"));\n-        }\n-        if (readIf(\"ELSE\")) {\n-            function.setParameter(i, readExpression());\n-        }\n-        read(\"END\");\n-        readIf(\"CASE\");\n-        function.doneWithParameters();\n-        return function;\n-    }\n-\n-    private int readPositiveInt() {\n-        int v = readInt();\n-        if (v < 0) {\n-            throw DbException.getInvalidValueException(\"positive integer\", v);\n-        }\n-        return v;\n-    }\n-\n-    private int readInt() {\n-        boolean minus = false;\n-        if (currentTokenType == MINUS) {\n-            minus = true;\n-            read();\n-        } else if (currentTokenType == PLUS) {\n-            read();\n-        }\n-        if (currentTokenType != VALUE) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex, \"integer\");\n-        }\n-        if (minus) {\n-            // must do that now, otherwise Integer.MIN_VALUE would not work\n-            currentValue = currentValue.negate();\n-        }\n-        int i = currentValue.getInt();\n-        read();\n-        return i;\n-    }\n-\n-    private long readLong() {\n-        boolean minus = false;\n-        if (currentTokenType == MINUS) {\n-            minus = true;\n-            read();\n-        } else if (currentTokenType == PLUS) {\n-            read();\n-        }\n-        if (currentTokenType != VALUE) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex, \"long\");\n-        }\n-        if (minus) {\n-            // must do that now, otherwise Long.MIN_VALUE would not work\n-            currentValue = currentValue.negate();\n-        }\n-        long i = currentValue.getLong();\n-        read();\n-        return i;\n-    }\n-\n-    private boolean readBooleanSetting() {\n-        if (currentTokenType == VALUE) {\n-            boolean result = currentValue.getBoolean();\n-            read();\n-            return result;\n-        }\n-        if (readIf(\"TRUE\") || readIf(\"ON\")) {\n-            return true;\n-        } else if (readIf(\"FALSE\") || readIf(\"OFF\")) {\n-            return false;\n-        } else {\n-            throw getSyntaxError();\n-        }\n-    }\n-\n-    private String readString() {\n-        Expression expr = readExpression().optimize(session);\n-        if (!(expr instanceof ValueExpression)) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex, \"string\");\n-        }\n-        String s = expr.getValue(session).getString();\n-        return s;\n-    }\n-\n-    // TODO: why does this function allow defaultSchemaName=null - which resets\n-    // the parser schemaName for everyone ?\n-    private String readIdentifierWithSchema(String defaultSchemaName) {\n-        if (currentTokenType != IDENTIFIER) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                    \"identifier\");\n-        }\n-        String s = currentToken;\n-        read();\n-        schemaName = defaultSchemaName;\n-        if (readIf(\".\")) {\n-            schemaName = s;\n-            if (currentTokenType != IDENTIFIER) {\n-                throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                        \"identifier\");\n-            }\n-            s = currentToken;\n-            read();\n-        }\n-        if (equalsToken(\".\", currentToken)) {\n-            if (equalsToken(schemaName, database.getShortName())) {\n-                read(\".\");\n-                schemaName = s;\n-                if (currentTokenType != IDENTIFIER) {\n-                    throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                            \"identifier\");\n-                }\n-                s = currentToken;\n-                read();\n-            }\n-        }\n-        return s;\n-    }\n-\n-    private String readIdentifierWithSchema() {\n-        return readIdentifierWithSchema(session.getCurrentSchemaName());\n-    }\n-\n-    private String readAliasIdentifier() {\n-        return readColumnIdentifier();\n-    }\n-\n-    private String readUniqueIdentifier() {\n-        return readColumnIdentifier();\n-    }\n-\n-    private String readColumnIdentifier() {\n-        if (currentTokenType != IDENTIFIER) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                    \"identifier\");\n-        }\n-        String s = currentToken;\n-        read();\n-        return s;\n-    }\n-\n-    private void read(String expected) {\n-        if (currentTokenQuoted || !equalsToken(expected, currentToken)) {\n-            addExpected(expected);\n-            throw getSyntaxError();\n-        }\n-        read();\n-    }\n-\n-    private boolean readIf(String token) {\n-        if (!currentTokenQuoted && equalsToken(token, currentToken)) {\n-            read();\n-            return true;\n-        }\n-        addExpected(token);\n-        return false;\n-    }\n-\n-    /*\n-     * Reads passed token in list, in order and returns true on first match.\n-     * If none of the token matches returns false\n-     */\n-    private boolean readIfOr(String... tokens) {\n-        for (String token: tokens) {\n-            if (readIf(token)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /*\n-     * Reads every token in list, in order - returns true if all are found.\n-     * If any are not found, returns false - AND resets parsing back to state when called.\n-     */\n-    private boolean readIfAll(String... tokens) {\n-        // save parse location in case we have to fail this test\n-        int start = lastParseIndex;\n-        for (String token: tokens) {\n-            if (!currentTokenQuoted && equalsToken(token, currentToken)) {\n-                read();\n-            } else {\n-                // read failed - revert parse location to before when called\n-                parseIndex = start;\n-                read();\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private boolean isToken(String token) {\n-        boolean result = equalsToken(token, currentToken) &&\n-                !currentTokenQuoted;\n-        if (result) {\n-            return true;\n-        }\n-        addExpected(token);\n-        return false;\n-    }\n-\n-    private boolean equalsToken(String a, String b) {\n-        if (a == null) {\n-            return b == null;\n-        } else if (a.equals(b)) {\n-            return true;\n-        } else if (!identifiersToUpper && a.equalsIgnoreCase(b)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static boolean equalsTokenIgnoreCase(String a, String b) {\n-        if (a == null) {\n-            return b == null;\n-        } else if (a.equals(b)) {\n-            return true;\n-        } else if (a.equalsIgnoreCase(b)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private boolean isTokenInList(Collection<String> upperCaseTokenList) {\n-        String upperCaseCurrentToken = currentToken.toUpperCase();\n-        return upperCaseTokenList.contains(upperCaseCurrentToken);\n-    }\n-\n-    private void addExpected(String token) {\n-        if (expectedList != null) {\n-            expectedList.add(token);\n-        }\n-    }\n-\n-    private void read() {\n-        currentTokenQuoted = false;\n-        if (expectedList != null) {\n-            expectedList.clear();\n-        }\n-        int[] types = characterTypes;\n-        lastParseIndex = parseIndex;\n-        int i = parseIndex;\n-        int type = types[i];\n-        while (type == 0) {\n-            type = types[++i];\n-        }\n-        int start = i;\n-        char[] chars = sqlCommandChars;\n-        char c = chars[i++];\n-        currentToken = \"\";\n-        switch (type) {\n-        case CHAR_NAME:\n-            while (true) {\n-                type = types[i];\n-                if (type != CHAR_NAME && type != CHAR_VALUE) {\n-                    break;\n-                }\n-                i++;\n-            }\n-            currentToken = StringUtils.cache(sqlCommand.substring(\n-                    start, i));\n-            currentTokenType = getTokenType(currentToken);\n-            parseIndex = i;\n-            return;\n-        case CHAR_QUOTED: {\n-            String result = null;\n-            while (true) {\n-                for (int begin = i;; i++) {\n-                    if (chars[i] == '\\\"') {\n-                        if (result == null) {\n-                            result = sqlCommand.substring(begin, i);\n-                        } else {\n-                            result += sqlCommand.substring(begin - 1, i);\n-                        }\n-                        break;\n-                    }\n-                }\n-                if (chars[++i] != '\\\"') {\n-                    break;\n-                }\n-                i++;\n-            }\n-            currentToken = StringUtils.cache(result);\n-            parseIndex = i;\n-            currentTokenQuoted = true;\n-            currentTokenType = IDENTIFIER;\n-            return;\n-        }\n-        case CHAR_SPECIAL_2:\n-            if (types[i] == CHAR_SPECIAL_2) {\n-                i++;\n-            }\n-            currentToken = sqlCommand.substring(start, i);\n-            currentTokenType = getSpecialType(currentToken);\n-            parseIndex = i;\n-            return;\n-        case CHAR_SPECIAL_1:\n-            currentToken = sqlCommand.substring(start, i);\n-            currentTokenType = getSpecialType(currentToken);\n-            parseIndex = i;\n-            return;\n-        case CHAR_VALUE:\n-            if (c == '0' && chars[i] == 'X') {\n-                // hex number\n-                long number = 0;\n-                start += 2;\n-                i++;\n-                while (true) {\n-                    c = chars[i];\n-                    if ((c < '0' || c > '9') && (c < 'A' || c > 'F')) {\n-                        checkLiterals(false);\n-                        currentValue = ValueInt.get((int) number);\n-                        currentTokenType = VALUE;\n-                        currentToken = \"0\";\n-                        parseIndex = i;\n-                        return;\n-                    }\n-                    number = (number << 4) + c -\n-                            (c >= 'A' ? ('A' - 0xa) : ('0'));\n-                    if (number > Integer.MAX_VALUE) {\n-                        readHexDecimal(start, i);\n-                        return;\n-                    }\n-                    i++;\n-                }\n-            }\n-            long number = c - '0';\n-            while (true) {\n-                c = chars[i];\n-                if (c < '0' || c > '9') {\n-                    if (c == '.' || c == 'E' || c == 'L') {\n-                        readDecimal(start, i);\n-                        break;\n-                    }\n-                    checkLiterals(false);\n-                    currentValue = ValueInt.get((int) number);\n-                    currentTokenType = VALUE;\n-                    currentToken = \"0\";\n-                    parseIndex = i;\n-                    break;\n-                }\n-                number = number * 10 + (c - '0');\n-                if (number > Integer.MAX_VALUE) {\n-                    readDecimal(start, i);\n-                    break;\n-                }\n-                i++;\n-            }\n-            return;\n-        case CHAR_DOT:\n-            if (types[i] != CHAR_VALUE) {\n-                currentTokenType = KEYWORD;\n-                currentToken = \".\";\n-                parseIndex = i;\n-                return;\n-            }\n-            readDecimal(i - 1, i);\n-            return;\n-        case CHAR_STRING: {\n-            String result = null;\n-            while (true) {\n-                for (int begin = i;; i++) {\n-                    if (chars[i] == '\\'') {\n-                        if (result == null) {\n-                            result = sqlCommand.substring(begin, i);\n-                        } else {\n-                            result += sqlCommand.substring(begin - 1, i);\n-                        }\n-                        break;\n-                    }\n-                }\n-                if (chars[++i] != '\\'') {\n-                    break;\n-                }\n-                i++;\n-            }\n-            currentToken = \"'\";\n-            checkLiterals(true);\n-            currentValue = ValueString.get(StringUtils.cache(result),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            parseIndex = i;\n-            currentTokenType = VALUE;\n-            return;\n-        }\n-        case CHAR_DOLLAR_QUOTED_STRING: {\n-            String result = null;\n-            int begin = i - 1;\n-            while (types[i] == CHAR_DOLLAR_QUOTED_STRING) {\n-                i++;\n-            }\n-            result = sqlCommand.substring(begin, i);\n-            currentToken = \"'\";\n-            checkLiterals(true);\n-            currentValue = ValueString.get(StringUtils.cache(result),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            parseIndex = i;\n-            currentTokenType = VALUE;\n-            return;\n-        }\n-        case CHAR_END:\n-            currentToken = \"\";\n-            currentTokenType = END;\n-            parseIndex = i;\n-            return;\n-        default:\n-            throw getSyntaxError();\n-        }\n-    }\n-\n-    private void readParameterIndex() {\n-        int i = parseIndex;\n-\n-        char[] chars = sqlCommandChars;\n-        char c = chars[i++];\n-        long number = c - '0';\n-        while (true) {\n-            c = chars[i];\n-            if (c < '0' || c > '9') {\n-                currentValue = ValueInt.get((int) number);\n-                currentTokenType = VALUE;\n-                currentToken = \"0\";\n-                parseIndex = i;\n-                break;\n-            }\n-            number = number * 10 + (c - '0');\n-            if (number > Integer.MAX_VALUE) {\n-                throw DbException.getInvalidValueException(\n-                        \"parameter index\", number);\n-            }\n-            i++;\n-        }\n-    }\n-\n-    private void checkLiterals(boolean text) {\n-        if (!literalsChecked && !session.getAllowLiterals()) {\n-            int allowed = database.getAllowLiterals();\n-            if (allowed == Constants.ALLOW_LITERALS_NONE ||\n-                    (text && allowed != Constants.ALLOW_LITERALS_ALL)) {\n-                throw DbException.get(ErrorCode.LITERALS_ARE_NOT_ALLOWED);\n-            }\n-        }\n-    }\n-\n-    private void readHexDecimal(int start, int i) {\n-        char[] chars = sqlCommandChars;\n-        char c;\n-        do {\n-            c = chars[++i];\n-        } while ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F'));\n-        parseIndex = i;\n-        String sub = sqlCommand.substring(start, i);\n-        BigDecimal bd = new BigDecimal(new BigInteger(sub, 16));\n-        checkLiterals(false);\n-        currentValue = ValueDecimal.get(bd);\n-        currentTokenType = VALUE;\n-    }\n-\n-    private void readDecimal(int start, int i) {\n-        char[] chars = sqlCommandChars;\n-        int[] types = characterTypes;\n-        // go until the first non-number\n-        while (true) {\n-            int t = types[i];\n-            if (t != CHAR_DOT && t != CHAR_VALUE) {\n-                break;\n-            }\n-            i++;\n-        }\n-        boolean containsE = false;\n-        if (chars[i] == 'E' || chars[i] == 'e') {\n-            containsE = true;\n-            i++;\n-            if (chars[i] == '+' || chars[i] == '-') {\n-                i++;\n-            }\n-            if (types[i] != CHAR_VALUE) {\n-                throw getSyntaxError();\n-            }\n-            while (types[++i] == CHAR_VALUE) {\n-                // go until the first non-number\n-            }\n-        }\n-        parseIndex = i;\n-        String sub = sqlCommand.substring(start, i);\n-        checkLiterals(false);\n-        if (!containsE && sub.indexOf('.') < 0) {\n-            BigInteger bi = new BigInteger(sub);\n-            if (bi.compareTo(ValueLong.MAX_BI) <= 0) {\n-                // parse constants like \"10000000L\"\n-                if (chars[i] == 'L') {\n-                    parseIndex++;\n-                }\n-                currentValue = ValueLong.get(bi.longValue());\n-                currentTokenType = VALUE;\n-                return;\n-            }\n-        }\n-        BigDecimal bd;\n-        try {\n-            bd = new BigDecimal(sub);\n-        } catch (NumberFormatException e) {\n-            throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1, e, sub);\n-        }\n-        currentValue = ValueDecimal.get(bd);\n-        currentTokenType = VALUE;\n-    }\n-\n-    public Session getSession() {\n-        return session;\n-    }\n-\n-    private void initialize(String sql) {\n-        if (sql == null) {\n-            sql = \"\";\n-        }\n-        originalSQL = sql;\n-        sqlCommand = sql;\n-        int len = sql.length() + 1;\n-        char[] command = new char[len];\n-        int[] types = new int[len];\n-        len--;\n-        sql.getChars(0, len, command, 0);\n-        boolean changed = false;\n-        command[len] = ' ';\n-        int startLoop = 0;\n-        int lastType = 0;\n-        for (int i = 0; i < len; i++) {\n-            char c = command[i];\n-            int type = 0;\n-            switch (c) {\n-            case '/':\n-                if (command[i + 1] == '*') {\n-                    // block comment\n-                    changed = true;\n-                    command[i] = ' ';\n-                    command[i + 1] = ' ';\n-                    startLoop = i;\n-                    i += 2;\n-                    checkRunOver(i, len, startLoop);\n-                    while (command[i] != '*' || command[i + 1] != '/') {\n-                        command[i++] = ' ';\n-                        checkRunOver(i, len, startLoop);\n-                    }\n-                    command[i] = ' ';\n-                    command[i + 1] = ' ';\n-                    i++;\n-                } else if (command[i + 1] == '/') {\n-                    // single line comment\n-                    changed = true;\n-                    startLoop = i;\n-                    while (true) {\n-                        c = command[i];\n-                        if (c == '\\n' || c == '\\r' || i >= len - 1) {\n-                            break;\n-                        }\n-                        command[i++] = ' ';\n-                        checkRunOver(i, len, startLoop);\n-                    }\n-                } else {\n-                    type = CHAR_SPECIAL_1;\n-                }\n-                break;\n-            case '-':\n-                if (command[i + 1] == '-') {\n-                    // single line comment\n-                    changed = true;\n-                    startLoop = i;\n-                    while (true) {\n-                        c = command[i];\n-                        if (c == '\\n' || c == '\\r' || i >= len - 1) {\n-                            break;\n-                        }\n-                        command[i++] = ' ';\n-                        checkRunOver(i, len, startLoop);\n-                    }\n-                } else {\n-                    type = CHAR_SPECIAL_1;\n-                }\n-                break;\n-            case '$':\n-                if (command[i + 1] == '$' && (i == 0 || command[i - 1] <= ' ')) {\n-                    // dollar quoted string\n-                    changed = true;\n-                    command[i] = ' ';\n-                    command[i + 1] = ' ';\n-                    startLoop = i;\n-                    i += 2;\n-                    checkRunOver(i, len, startLoop);\n-                    while (command[i] != '$' || command[i + 1] != '$') {\n-                        types[i++] = CHAR_DOLLAR_QUOTED_STRING;\n-                        checkRunOver(i, len, startLoop);\n-                    }\n-                    command[i] = ' ';\n-                    command[i + 1] = ' ';\n-                    i++;\n-                } else {\n-                    if (lastType == CHAR_NAME || lastType == CHAR_VALUE) {\n-                        // $ inside an identifier is supported\n-                        type = CHAR_NAME;\n-                    } else {\n-                        // but not at the start, to support PostgreSQL $1\n-                        type = CHAR_SPECIAL_1;\n-                    }\n-                }\n-                break;\n-            case '(':\n-            case ')':\n-            case '{':\n-            case '}':\n-            case '*':\n-            case ',':\n-            case ';':\n-            case '+':\n-            case '%':\n-            case '?':\n-            case '@':\n-            case ']':\n-                type = CHAR_SPECIAL_1;\n-                break;\n-            case '!':\n-            case '<':\n-            case '>':\n-            case '|':\n-            case '=':\n-            case ':':\n-            case '&':\n-            case '~':\n-                type = CHAR_SPECIAL_2;\n-                break;\n-            case '.':\n-                type = CHAR_DOT;\n-                break;\n-            case '\\'':\n-                type = types[i] = CHAR_STRING;\n-                startLoop = i;\n-                while (command[++i] != '\\'') {\n-                    checkRunOver(i, len, startLoop);\n-                }\n-                break;\n-            case '[':\n-                if (database.getMode().squareBracketQuotedNames) {\n-                    // SQL Server alias for \"\n-                    command[i] = '\"';\n-                    changed = true;\n-                    type = types[i] = CHAR_QUOTED;\n-                    startLoop = i;\n-                    while (command[++i] != ']') {\n-                        checkRunOver(i, len, startLoop);\n-                    }\n-                    command[i] = '\"';\n-                } else {\n-                    type = CHAR_SPECIAL_1;\n-                }\n-                break;\n-            case '`':\n-                // MySQL alias for \", but not case sensitive\n-                command[i] = '\"';\n-                changed = true;\n-                type = types[i] = CHAR_QUOTED;\n-                startLoop = i;\n-                while (command[++i] != '`') {\n-                    checkRunOver(i, len, startLoop);\n-                    c = command[i];\n-                    command[i] = Character.toUpperCase(c);\n-                }\n-                command[i] = '\"';\n-                break;\n-            case '\\\"':\n-                type = types[i] = CHAR_QUOTED;\n-                startLoop = i;\n-                while (command[++i] != '\\\"') {\n-                    checkRunOver(i, len, startLoop);\n-                }\n-                break;\n-            case '_':\n-                type = CHAR_NAME;\n-                break;\n-            case '#':\n-                if (database.getMode().supportPoundSymbolForColumnNames) {\n-                    type = CHAR_NAME;\n-                } else {\n-                    type = CHAR_SPECIAL_1;\n-                }\n-                break;\n-            default:\n-                if (c >= 'a' && c <= 'z') {\n-                    if (identifiersToUpper) {\n-                        command[i] = (char) (c - ('a' - 'A'));\n-                        changed = true;\n-                    }\n-                    type = CHAR_NAME;\n-                } else if (c >= 'A' && c <= 'Z') {\n-                    type = CHAR_NAME;\n-                } else if (c >= '0' && c <= '9') {\n-                    type = CHAR_VALUE;\n-                } else {\n-                    if (c <= ' ' || Character.isSpaceChar(c)) {\n-                        // whitespace\n-                    } else if (Character.isJavaIdentifierPart(c)) {\n-                        type = CHAR_NAME;\n-                        if (identifiersToUpper) {\n-                            char u = Character.toUpperCase(c);\n-                            if (u != c) {\n-                                command[i] = u;\n-                                changed = true;\n-                            }\n-                        }\n-                    } else {\n-                        type = CHAR_SPECIAL_1;\n-                    }\n-                }\n-            }\n-            types[i] = type;\n-            lastType = type;\n-        }\n-        sqlCommandChars = command;\n-        types[len] = CHAR_END;\n-        characterTypes = types;\n-        if (changed) {\n-            sqlCommand = new String(command);\n-        }\n-        parseIndex = 0;\n-    }\n-\n-    private void checkRunOver(int i, int len, int startLoop) {\n-        if (i >= len) {\n-            parseIndex = startLoop;\n-            throw getSyntaxError();\n-        }\n-    }\n-\n-    private int getSpecialType(String s) {\n-        char c0 = s.charAt(0);\n-        if (s.length() == 1) {\n-            switch (c0) {\n-            case '?':\n-            case '$':\n-                return PARAMETER;\n-            case '@':\n-                return AT;\n-            case '+':\n-                return PLUS;\n-            case '-':\n-                return MINUS;\n-            case '{':\n-            case '}':\n-            case '*':\n-            case '/':\n-            case '%':\n-            case ';':\n-            case ',':\n-            case ':':\n-            case '[':\n-            case ']':\n-            case '~':\n-                return KEYWORD;\n-            case '(':\n-                return OPEN;\n-            case ')':\n-                return CLOSE;\n-            case '<':\n-                return SMALLER;\n-            case '>':\n-                return BIGGER;\n-            case '=':\n-                return EQUAL;\n-            default:\n-                break;\n-            }\n-        } else if (s.length() == 2) {\n-            switch (c0) {\n-            case ':':\n-                if (\"::\".equals(s)) {\n-                    return KEYWORD;\n-                } else if (\":=\".equals(s)) {\n-                    return KEYWORD;\n-                }\n-                break;\n-            case '>':\n-                if (\">=\".equals(s)) {\n-                    return BIGGER_EQUAL;\n-                }\n-                break;\n-            case '<':\n-                if (\"<=\".equals(s)) {\n-                    return SMALLER_EQUAL;\n-                } else if (\"<>\".equals(s)) {\n-                    return NOT_EQUAL;\n-                }\n-                break;\n-            case '!':\n-                if (\"!=\".equals(s)) {\n-                    return NOT_EQUAL;\n-                } else if (\"!~\".equals(s)) {\n-                    return KEYWORD;\n-                }\n-                break;\n-            case '|':\n-                if (\"||\".equals(s)) {\n-                    return STRING_CONCAT;\n-                }\n-                break;\n-            case '&':\n-                if (\"&&\".equals(s)) {\n-                    return SPATIAL_INTERSECTS;\n-                }\n-                break;\n-            }\n-        }\n-        throw getSyntaxError();\n-    }\n-\n-    private int getTokenType(String s) {\n-        int len = s.length();\n-        if (len == 0) {\n-            throw getSyntaxError();\n-        }\n-        if (!identifiersToUpper) {\n-            // if not yet converted to uppercase, do it now\n-            s = StringUtils.toUpperEnglish(s);\n-        }\n-        return getSaveTokenType(s, database.getMode().supportOffsetFetch, false);\n-    }\n-\n-    private boolean isKeyword(String s) {\n-        if (!identifiersToUpper) {\n-            // if not yet converted to uppercase, do it now\n-            s = StringUtils.toUpperEnglish(s);\n-        }\n-        return ParserUtil.isKeyword(s, false);\n-    }\n-\n-    private static int getSaveTokenType(String s, boolean supportOffsetFetch, boolean functionsAsKeywords) {\n-        return ParserUtil.getSaveTokenType(s, supportOffsetFetch, functionsAsKeywords);\n-    }\n-\n-    private Column parseColumnForTable(String columnName,\n-            boolean defaultNullable) {\n-        Column column;\n-        boolean isIdentity = readIf(\"IDENTITY\");\n-        if (isIdentity || readIf(\"BIGSERIAL\")) {\n-            // Check if any of them are disallowed in the current Mode\n-            if (isIdentity && database.getMode().\n-                    disallowedTypes.contains(\"IDENTITY\")) {\n-                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                        currentToken);\n-            }\n-            column = new Column(columnName, Value.LONG);\n-            column.setOriginalSQL(\"IDENTITY\");\n-            parseAutoIncrement(column);\n-            // PostgreSQL compatibility\n-            if (!database.getMode().serialColumnIsNotPK) {\n-                column.setPrimaryKey(true);\n-            }\n-        } else if (readIf(\"SERIAL\")) {\n-            column = new Column(columnName, Value.INT);\n-            column.setOriginalSQL(\"SERIAL\");\n-            parseAutoIncrement(column);\n-            // PostgreSQL compatibility\n-            if (!database.getMode().serialColumnIsNotPK) {\n-                column.setPrimaryKey(true);\n-            }\n-        } else {\n-            column = parseColumnWithType(columnName);\n-        }\n-        if (readIf(\"INVISIBLE\")) {\n-            column.setVisible(false);\n-        } else if (readIf(\"VISIBLE\")) {\n-            column.setVisible(true);\n-        }\n-        NullConstraintType nullConstraint = parseNotNullConstraint();\n-        switch (nullConstraint) {\n-        case NULL_IS_ALLOWED:\n-            column.setNullable(true);\n-            break;\n-        case NULL_IS_NOT_ALLOWED:\n-            column.setNullable(false);\n-            break;\n-        case NO_NULL_CONSTRAINT_FOUND:\n-            // domains may be defined as not nullable\n-            column.setNullable(defaultNullable & column.isNullable());\n-            break;\n-        default:\n-            throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n-                    \"Internal Error - unhandled case: \" + nullConstraint.name());\n-        }\n-        if (readIf(\"AS\")) {\n-            if (isIdentity) {\n-                getSyntaxError();\n-            }\n-            Expression expr = readExpression();\n-            column.setComputedExpression(expr);\n-        } else if (readIf(\"DEFAULT\")) {\n-            Expression defaultExpression = readExpression();\n-            column.setDefaultExpression(session, defaultExpression);\n-        } else if (readIf(\"GENERATED\")) {\n-            if (!readIf(\"ALWAYS\")) {\n-                read(\"BY\");\n-                read(\"DEFAULT\");\n-            }\n-            read(\"AS\");\n-            read(\"IDENTITY\");\n-            long start = 1, increment = 1;\n-            if (readIf(\"(\")) {\n-                read(\"START\");\n-                readIf(\"WITH\");\n-                start = readLong();\n-                readIf(\",\");\n-                if (readIf(\"INCREMENT\")) {\n-                    readIf(\"BY\");\n-                    increment = readLong();\n-                }\n-                read(\")\");\n-            }\n-            column.setPrimaryKey(true);\n-            column.setAutoIncrement(true, start, increment);\n-        }\n-        if (NullConstraintType.NULL_IS_NOT_ALLOWED == parseNotNullConstraint()) {\n-            column.setNullable(false);\n-        }\n-        if (readIf(\"AUTO_INCREMENT\") || readIf(\"BIGSERIAL\") || readIf(\"SERIAL\")) {\n-            parseAutoIncrement(column);\n-            parseNotNullConstraint();\n-        } else if (readIf(\"IDENTITY\")) {\n-            parseAutoIncrement(column);\n-            column.setPrimaryKey(true);\n-            parseNotNullConstraint();\n-        }\n-        if (readIf(\"NULL_TO_DEFAULT\")) {\n-            column.setConvertNullToDefault(true);\n-        }\n-        if (readIf(\"SEQUENCE\")) {\n-            Sequence sequence = readSequence();\n-            column.setSequence(sequence);\n-        }\n-        if (readIf(\"SELECTIVITY\")) {\n-            int value = readPositiveInt();\n-            column.setSelectivity(value);\n-        }\n-        String comment = readCommentIf();\n-        if (comment != null) {\n-            column.setComment(comment);\n-        }\n-        return column;\n-    }\n-\n-    private void parseAutoIncrement(Column column) {\n-        long start = 1, increment = 1;\n-        if (readIf(\"(\")) {\n-            start = readLong();\n-            if (readIf(\",\")) {\n-                increment = readLong();\n-            }\n-            read(\")\");\n-        }\n-        column.setAutoIncrement(true, start, increment);\n-    }\n-\n-    private String readCommentIf() {\n-        if (readIf(\"COMMENT\")) {\n-            readIf(\"IS\");\n-            return readString();\n-        }\n-        return null;\n-    }\n-\n-    private Column parseColumnWithType(String columnName) {\n-        String original = currentToken;\n-        boolean regular = false;\n-        if (readIf(\"LONG\")) {\n-            if (readIf(\"RAW\")) {\n-                original += \" RAW\";\n-            }\n-        } else if (readIf(\"DOUBLE\")) {\n-            if (readIf(\"PRECISION\")) {\n-                original += \" PRECISION\";\n-            }\n-        } else if (readIf(\"CHARACTER\")) {\n-            if (readIf(\"VARYING\")) {\n-                original += \" VARYING\";\n-            }\n-        } else if (readIf(\"TIME\")) {\n-            if (readIf(\"WITHOUT\")) {\n-                read(\"TIME\");\n-                read(\"ZONE\");\n-                original += \" WITHOUT TIME ZONE\";\n-            }\n-        } else if (readIf(\"TIMESTAMP\")) {\n-            if (readIf(\"WITH\")) {\n-                read(\"TIME\");\n-                read(\"ZONE\");\n-                original += \" WITH TIME ZONE\";\n-            } else if (readIf(\"WITHOUT\")) {\n-                read(\"TIME\");\n-                read(\"ZONE\");\n-                original += \" WITHOUT TIME ZONE\";\n-            }\n-        } else {\n-            regular = true;\n-        }\n-        long precision = -1;\n-        int displaySize = -1;\n-        String[] enumerators = null;\n-        int scale = -1;\n-        String comment = null;\n-        Column templateColumn = null;\n-        DataType dataType;\n-        if (!identifiersToUpper) {\n-            original = StringUtils.toUpperEnglish(original);\n-        }\n-        UserDataType userDataType = database.findUserDataType(original);\n-        if (userDataType != null) {\n-            templateColumn = userDataType.getColumn();\n-            dataType = DataType.getDataType(templateColumn.getType());\n-            comment = templateColumn.getComment();\n-            original = templateColumn.getOriginalSQL();\n-            precision = templateColumn.getPrecision();\n-            displaySize = templateColumn.getDisplaySize();\n-            scale = templateColumn.getScale();\n-            enumerators = templateColumn.getEnumerators();\n-        } else {\n-            Mode mode = database.getMode();\n-            dataType = DataType.getTypeByName(original, mode);\n-            if (dataType == null || mode.disallowedTypes.contains(original)) {\n-                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                        currentToken);\n-            }\n-        }\n-        if (database.getIgnoreCase() && dataType.type == Value.STRING &&\n-                !equalsToken(\"VARCHAR_CASESENSITIVE\", original)) {\n-            original = \"VARCHAR_IGNORECASE\";\n-            dataType = DataType.getTypeByName(original, database.getMode());\n-        }\n-        if (regular) {\n-            read();\n-        }\n-        precision = precision == -1 ? dataType.defaultPrecision : precision;\n-        displaySize = displaySize == -1 ? dataType.defaultDisplaySize\n-                : displaySize;\n-        scale = scale == -1 ? dataType.defaultScale : scale;\n-        if (dataType.supportsPrecision || dataType.supportsScale) {\n-            if (readIf(\"(\")) {\n-                if (!readIf(\"MAX\")) {\n-                    long p = readLong();\n-                    if (readIf(\"K\")) {\n-                        p *= 1024;\n-                    } else if (readIf(\"M\")) {\n-                        p *= 1024 * 1024;\n-                    } else if (readIf(\"G\")) {\n-                        p *= 1024 * 1024 * 1024;\n-                    }\n-                    if (p > Long.MAX_VALUE) {\n-                        p = Long.MAX_VALUE;\n-                    }\n-                    original += \"(\" + p;\n-                    // Oracle syntax\n-                    readIfOr(\"CHAR\", \"BYTE\");\n-                    if (dataType.supportsScale) {\n-                        if (readIf(\",\")) {\n-                            scale = readInt();\n-                            original += \", \" + scale;\n-                        } else {\n-                            // special case: TIMESTAMP(5) actually means\n-                            // TIMESTAMP(23, 5)\n-                            if (dataType.type == Value.TIMESTAMP) {\n-                                scale = MathUtils.convertLongToInt(p);\n-                                p = precision;\n-                            } else {\n-                                scale = 0;\n-                            }\n-                        }\n-                    }\n-                    precision = p;\n-                    displaySize = MathUtils.convertLongToInt(precision);\n-                    original += \")\";\n-                }\n-                read(\")\");\n-            }\n-        } else if (dataType.type == Value.ENUM) {\n-            if (readIf(\"(\")) {\n-                java.util.List<String> enumeratorList = new ArrayList<>();\n-                original += '(';\n-                String enumerator0 = readString();\n-                enumeratorList.add(enumerator0);\n-                original += \"'\" + enumerator0 + \"'\";\n-                while (readIf(\",\")) {\n-                    original += ',';\n-                    String enumeratorN = readString();\n-                    original += \"'\" + enumeratorN + \"'\";\n-                    enumeratorList.add(enumeratorN);\n-                }\n-                read(\")\");\n-                original += ')';\n-                enumerators = enumeratorList.toArray(new String[0]);\n-            }\n-            try {\n-                ValueEnum.check(enumerators);\n-            } catch (DbException e) {\n-                throw e.addSQL(original);\n-            }\n-        } else if (readIf(\"(\")) {\n-            // Support for MySQL: INT(11), MEDIUMINT(8) and so on.\n-            // Just ignore the precision.\n-            readPositiveInt();\n-            read(\")\");\n-        }\n-        if (readIf(\"FOR\")) {\n-            read(\"BIT\");\n-            read(\"DATA\");\n-            if (dataType.type == Value.STRING) {\n-                dataType = DataType.getTypeByName(\"BINARY\", database.getMode());\n-            }\n-        }\n-        // MySQL compatibility\n-        readIf(\"UNSIGNED\");\n-        int type = dataType.type;\n-        if (scale > precision) {\n-            throw DbException.get(ErrorCode.INVALID_VALUE_SCALE_PRECISION,\n-                    Integer.toString(scale), Long.toString(precision));\n-        }\n-\n-\n-        Column column = new Column(columnName, type, precision, scale,\n-            displaySize, enumerators);\n-        if (templateColumn != null) {\n-            column.setNullable(templateColumn.isNullable());\n-            column.setDefaultExpression(session,\n-                    templateColumn.getDefaultExpression());\n-            int selectivity = templateColumn.getSelectivity();\n-            if (selectivity != Constants.SELECTIVITY_DEFAULT) {\n-                column.setSelectivity(selectivity);\n-            }\n-            Expression checkConstraint = templateColumn.getCheckConstraint(\n-                    session, columnName);\n-            column.addCheckConstraint(session, checkConstraint);\n-        }\n-        column.setComment(comment);\n-        column.setOriginalSQL(original);\n-        return column;\n-    }\n-\n-    private Prepared parseCreate() {\n-        boolean orReplace = false;\n-        if (readIf(\"OR\")) {\n-            read(\"REPLACE\");\n-            orReplace = true;\n-        }\n-        boolean force = readIf(\"FORCE\");\n-        if (readIf(\"VIEW\")) {\n-            return parseCreateView(force, orReplace);\n-        } else if (readIf(\"ALIAS\")) {\n-            return parseCreateFunctionAlias(force);\n-        } else if (readIf(\"SEQUENCE\")) {\n-            return parseCreateSequence();\n-        } else if (readIf(\"USER\")) {\n-            return parseCreateUser();\n-        } else if (readIf(\"TRIGGER\")) {\n-            return parseCreateTrigger(force);\n-        } else if (readIf(\"ROLE\")) {\n-            return parseCreateRole();\n-        } else if (readIf(\"SCHEMA\")) {\n-            return parseCreateSchema();\n-        } else if (readIf(\"CONSTANT\")) {\n-            return parseCreateConstant();\n-        } else if (readIf(\"DOMAIN\")) {\n-            return parseCreateUserDataType();\n-        } else if (readIf(\"TYPE\")) {\n-            return parseCreateUserDataType();\n-        } else if (readIf(\"DATATYPE\")) {\n-            return parseCreateUserDataType();\n-        } else if (readIf(\"AGGREGATE\")) {\n-            return parseCreateAggregate(force);\n-        } else if (readIf(\"LINKED\")) {\n-            return parseCreateLinkedTable(false, false, force);\n-        }\n-        // tables or linked tables\n-        boolean memory = false, cached = false;\n-        if (readIf(\"MEMORY\")) {\n-            memory = true;\n-        } else if (readIf(\"CACHED\")) {\n-            cached = true;\n-        }\n-        if (readIf(\"LOCAL\")) {\n-            read(\"TEMPORARY\");\n-            if (readIf(\"LINKED\")) {\n-                return parseCreateLinkedTable(true, false, force);\n-            }\n-            read(\"TABLE\");\n-            return parseCreateTable(true, false, cached);\n-        } else if (readIf(\"GLOBAL\")) {\n-            read(\"TEMPORARY\");\n-            if (readIf(\"LINKED\")) {\n-                return parseCreateLinkedTable(true, true, force);\n-            }\n-            read(\"TABLE\");\n-            return parseCreateTable(true, true, cached);\n-        } else if (readIf(\"TEMP\") || readIf(\"TEMPORARY\")) {\n-            if (readIf(\"LINKED\")) {\n-                return parseCreateLinkedTable(true, true, force);\n-            }\n-            read(\"TABLE\");\n-            return parseCreateTable(true, true, cached);\n-        } else if (readIf(\"TABLE\")) {\n-            if (!cached && !memory) {\n-                cached = database.getDefaultTableType() == Table.TYPE_CACHED;\n-            }\n-            return parseCreateTable(false, false, cached);\n-        } else if (readIf(\"SYNONYM\")) {\n-            return parseCreateSynonym(orReplace);\n-        } else {\n-            boolean hash = false, primaryKey = false;\n-            boolean unique = false, spatial = false;\n-            String indexName = null;\n-            Schema oldSchema = null;\n-            boolean ifNotExists = false;\n-            if (readIf(\"PRIMARY\")) {\n-                read(\"KEY\");\n-                if (readIf(\"HASH\")) {\n-                    hash = true;\n-                }\n-                primaryKey = true;\n-                if (!isToken(\"ON\")) {\n-                    ifNotExists = readIfNotExists();\n-                    indexName = readIdentifierWithSchema(null);\n-                    oldSchema = getSchema();\n-                }\n-            } else {\n-                if (readIf(\"UNIQUE\")) {\n-                    unique = true;\n-                }\n-                if (readIf(\"HASH\")) {\n-                    hash = true;\n-                }\n-                if (readIf(\"SPATIAL\")) {\n-                    spatial = true;\n-                }\n-                if (readIf(\"INDEX\")) {\n-                    if (!isToken(\"ON\")) {\n-                        ifNotExists = readIfNotExists();\n-                        indexName = readIdentifierWithSchema(null);\n-                        oldSchema = getSchema();\n-                    }\n-                } else {\n-                    throw getSyntaxError();\n-                }\n-            }\n-            read(\"ON\");\n-            String tableName = readIdentifierWithSchema();\n-            checkSchema(oldSchema);\n-            CreateIndex command = new CreateIndex(session, getSchema());\n-            command.setIfNotExists(ifNotExists);\n-            command.setPrimaryKey(primaryKey);\n-            command.setTableName(tableName);\n-            command.setUnique(unique);\n-            command.setIndexName(indexName);\n-            command.setComment(readCommentIf());\n-            read(\"(\");\n-            command.setIndexColumns(parseIndexColumnList());\n-\n-            if (readIf(\"USING\")) {\n-                if (hash) {\n-                    throw getSyntaxError();\n-                }\n-                if (spatial) {\n-                    throw getSyntaxError();\n-                }\n-                if (readIf(\"BTREE\")) {\n-                    // default\n-                } else if (readIf(\"RTREE\")) {\n-                    spatial = true;\n-                } else if (readIf(\"HASH\")) {\n-                    hash = true;\n-                } else {\n-                    throw getSyntaxError();\n-                }\n-\n-            }\n-            command.setHash(hash);\n-            command.setSpatial(spatial);\n-            return command;\n-        }\n-    }\n-\n-    /**\n-     * @return true if we expect to see a TABLE clause\n-     */\n-    private boolean addRoleOrRight(GrantRevoke command) {\n-        if (readIf(\"SELECT\")) {\n-            command.addRight(Right.SELECT);\n-            return true;\n-        } else if (readIf(\"DELETE\")) {\n-            command.addRight(Right.DELETE);\n-            return true;\n-        } else if (readIf(\"INSERT\")) {\n-            command.addRight(Right.INSERT);\n-            return true;\n-        } else if (readIf(\"UPDATE\")) {\n-            command.addRight(Right.UPDATE);\n-            return true;\n-        } else if (readIf(\"ALL\")) {\n-            command.addRight(Right.ALL);\n-            return true;\n-        } else if (readIf(\"ALTER\")) {\n-            read(\"ANY\");\n-            read(\"SCHEMA\");\n-            command.addRight(Right.ALTER_ANY_SCHEMA);\n-            command.addTable(null);\n-            return false;\n-        } else if (readIf(\"CONNECT\")) {\n-            // ignore this right\n-            return true;\n-        } else if (readIf(\"RESOURCE\")) {\n-            // ignore this right\n-            return true;\n-        } else {\n-            command.addRoleName(readUniqueIdentifier());\n-            return false;\n-        }\n-    }\n-\n-    private GrantRevoke parseGrantRevoke(int operationType) {\n-        GrantRevoke command = new GrantRevoke(session);\n-        command.setOperationType(operationType);\n-        boolean tableClauseExpected = addRoleOrRight(command);\n-        while (readIf(\",\")) {\n-            addRoleOrRight(command);\n-            if (command.isRightMode() && command.isRoleMode()) {\n-                throw DbException\n-                        .get(ErrorCode.ROLES_AND_RIGHT_CANNOT_BE_MIXED);\n-            }\n-        }\n-        if (tableClauseExpected) {\n-            if (readIf(\"ON\")) {\n-                if (readIf(\"SCHEMA\")) {\n-                    Schema schema = database.getSchema(readAliasIdentifier());\n-                    command.setSchema(schema);\n-                } else {\n-                    do {\n-                        Table table = readTableOrView();\n-                        command.addTable(table);\n-                    } while (readIf(\",\"));\n-                }\n-            }\n-        }\n-        if (operationType == CommandInterface.GRANT) {\n-            read(\"TO\");\n-        } else {\n-            read(\"FROM\");\n-        }\n-        command.setGranteeName(readUniqueIdentifier());\n-        return command;\n-    }\n-\n-    private Select parseValues() {\n-        Select command = new Select(session);\n-        currentSelect = command;\n-        TableFilter filter = parseValuesTable(0);\n-        ArrayList<Expression> list = New.arrayList();\n-        list.add(new Wildcard(null, null));\n-        command.setExpressions(list);\n-        command.addTableFilter(filter, true);\n-        command.init();\n-        return command;\n-    }\n-\n-    private TableFilter parseValuesTable(int orderInFrom) {\n-        Schema mainSchema = database.getSchema(Constants.SCHEMA_MAIN);\n-        TableFunction tf = (TableFunction) Function.getFunction(database,\n-                \"TABLE\");\n-        ArrayList<Column> columns = New.arrayList();\n-        ArrayList<ArrayList<Expression>> rows = New.arrayList();\n-        do {\n-            int i = 0;\n-            ArrayList<Expression> row = New.arrayList();\n-            boolean multiColumn = readIf(\"(\");\n-            do {\n-                Expression expr = readExpression();\n-                expr = expr.optimize(session);\n-                int type = expr.getType();\n-                long prec;\n-                int scale, displaySize;\n-                Column column;\n-                String columnName = \"C\" + (i + 1);\n-                if (rows.isEmpty()) {\n-                    if (type == Value.UNKNOWN) {\n-                        type = Value.STRING;\n-                    }\n-                    DataType dt = DataType.getDataType(type);\n-                    prec = dt.defaultPrecision;\n-                    scale = dt.defaultScale;\n-                    displaySize = dt.defaultDisplaySize;\n-                    column = new Column(columnName, type, prec, scale,\n-                            displaySize);\n-                    columns.add(column);\n-                }\n-                prec = expr.getPrecision();\n-                scale = expr.getScale();\n-                displaySize = expr.getDisplaySize();\n-                if (i >= columns.size()) {\n-                    throw DbException\n-                            .get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n-                }\n-                Column c = columns.get(i);\n-                type = Value.getHigherOrder(c.getType(), type);\n-                prec = Math.max(c.getPrecision(), prec);\n-                scale = Math.max(c.getScale(), scale);\n-                displaySize = Math.max(c.getDisplaySize(), displaySize);\n-                column = new Column(columnName, type, prec, scale, displaySize);\n-                columns.set(i, column);\n-                row.add(expr);\n-                i++;\n-            } while (multiColumn && readIf(\",\"));\n-            if (multiColumn) {\n-                read(\")\");\n-            }\n-            rows.add(row);\n-        } while (readIf(\",\"));\n-        int columnCount = columns.size();\n-        int rowCount = rows.size();\n-        for (int i = 0; i < rowCount; i++) {\n-            if (rows.get(i).size() != columnCount) {\n-                throw DbException.get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n-            }\n-        }\n-        for (int i = 0; i < columnCount; i++) {\n-            Column c = columns.get(i);\n-            if (c.getType() == Value.UNKNOWN) {\n-                c = new Column(c.getName(), Value.STRING, 0, 0, 0);\n-                columns.set(i, c);\n-            }\n-            Expression[] array = new Expression[rowCount];\n-            for (int j = 0; j < rowCount; j++) {\n-                array[j] = rows.get(j).get(i);\n-            }\n-            ExpressionList list = new ExpressionList(array);\n-            tf.setParameter(i, list);\n-        }\n-        tf.setColumns(columns);\n-        tf.doneWithParameters();\n-        Table table = new FunctionTable(mainSchema, session, tf, tf);\n-        TableFilter filter = new TableFilter(session, table, null,\n-                rightsChecked, currentSelect, orderInFrom,\n-                null);\n-        return filter;\n-    }\n-\n-    private Call parseCall() {\n-        Call command = new Call(session);\n-        currentPrepared = command;\n-        command.setExpression(readExpression());\n-        return command;\n-    }\n-\n-    private CreateRole parseCreateRole() {\n-        CreateRole command = new CreateRole(session);\n-        command.setIfNotExists(readIfNotExists());\n-        command.setRoleName(readUniqueIdentifier());\n-        return command;\n-    }\n-\n-    private CreateSchema parseCreateSchema() {\n-        CreateSchema command = new CreateSchema(session);\n-        command.setIfNotExists(readIfNotExists());\n-        command.setSchemaName(readUniqueIdentifier());\n-        if (readIf(\"AUTHORIZATION\")) {\n-            command.setAuthorization(readUniqueIdentifier());\n-        } else {\n-            command.setAuthorization(session.getUser().getName());\n-        }\n-        if (readIf(\"WITH\")) {\n-            command.setTableEngineParams(readTableEngineParams());\n-        }\n-        return command;\n-    }\n-\n-    private ArrayList<String> readTableEngineParams() {\n-        ArrayList<String> tableEngineParams = New.arrayList();\n-        do {\n-            tableEngineParams.add(readUniqueIdentifier());\n-        } while (readIf(\",\"));\n-        return tableEngineParams;\n-    }\n-\n-    private CreateSequence parseCreateSequence() {\n-        boolean ifNotExists = readIfNotExists();\n-        String sequenceName = readIdentifierWithSchema();\n-        CreateSequence command = new CreateSequence(session, getSchema());\n-        command.setIfNotExists(ifNotExists);\n-        command.setSequenceName(sequenceName);\n-        while (true) {\n-            if (readIf(\"START\")) {\n-                readIf(\"WITH\");\n-                command.setStartWith(readExpression());\n-            } else if (readIf(\"INCREMENT\")) {\n-                readIf(\"BY\");\n-                command.setIncrement(readExpression());\n-            } else if (readIf(\"MINVALUE\")) {\n-                command.setMinValue(readExpression());\n-            } else if (readIf(\"NOMINVALUE\")) {\n-                command.setMinValue(null);\n-            } else if (readIf(\"MAXVALUE\")) {\n-                command.setMaxValue(readExpression());\n-            } else if (readIf(\"NOMAXVALUE\")) {\n-                command.setMaxValue(null);\n-            } else if (readIf(\"CYCLE\")) {\n-                command.setCycle(true);\n-            } else if (readIf(\"NOCYCLE\")) {\n-                command.setCycle(false);\n-            } else if (readIf(\"NO\")) {\n-                if (readIf(\"MINVALUE\")) {\n-                    command.setMinValue(null);\n-                } else if (readIf(\"MAXVALUE\")) {\n-                    command.setMaxValue(null);\n-                } else if (readIf(\"CYCLE\")) {\n-                    command.setCycle(false);\n-                } else if (readIf(\"CACHE\")) {\n-                    command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-                } else {\n-                    break;\n-                }\n-            } else if (readIf(\"CACHE\")) {\n-                command.setCacheSize(readExpression());\n-            } else if (readIf(\"NOCACHE\")) {\n-                command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-            } else if (readIf(\"BELONGS_TO_TABLE\")) {\n-                command.setBelongsToTable(true);\n-            } else if (readIf(\"ORDER\")) {\n-                // Oracle compatibility\n-            } else {\n-                break;\n-            }\n-        }\n-        return command;\n-    }\n-\n-    private boolean readIfNotExists() {\n-        if (readIf(\"IF\")) {\n-            read(\"NOT\");\n-            read(\"EXISTS\");\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private boolean readIfAffinity() {\n-        return readIf(\"AFFINITY\") || readIf(\"SHARD\");\n-    }\n-\n-    private CreateConstant parseCreateConstant() {\n-        boolean ifNotExists = readIfNotExists();\n-        String constantName = readIdentifierWithSchema();\n-        Schema schema = getSchema();\n-        if (isKeyword(constantName)) {\n-            throw DbException.get(ErrorCode.CONSTANT_ALREADY_EXISTS_1,\n-                    constantName);\n-        }\n-        read(\"VALUE\");\n-        Expression expr = readExpression();\n-        CreateConstant command = new CreateConstant(session, schema);\n-        command.setConstantName(constantName);\n-        command.setExpression(expr);\n-        command.setIfNotExists(ifNotExists);\n-        return command;\n-    }\n-\n-    private CreateAggregate parseCreateAggregate(boolean force) {\n-        boolean ifNotExists = readIfNotExists();\n-        CreateAggregate command = new CreateAggregate(session);\n-        command.setForce(force);\n-        String name = readIdentifierWithSchema();\n-        if (isKeyword(name) || Function.getFunction(database, name) != null ||\n-                getAggregateType(name) != null) {\n-            throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1,\n-                    name);\n-        }\n-        command.setName(name);\n-        command.setSchema(getSchema());\n-        command.setIfNotExists(ifNotExists);\n-        read(\"FOR\");\n-        command.setJavaClassMethod(readUniqueIdentifier());\n-        return command;\n-    }\n-\n-    private CreateUserDataType parseCreateUserDataType() {\n-        boolean ifNotExists = readIfNotExists();\n-        CreateUserDataType command = new CreateUserDataType(session);\n-        command.setTypeName(readUniqueIdentifier());\n-        read(\"AS\");\n-        Column col = parseColumnForTable(\"VALUE\", true);\n-        if (readIf(\"CHECK\")) {\n-            Expression expr = readExpression();\n-            col.addCheckConstraint(session, expr);\n-        }\n-        col.rename(null);\n-        command.setColumn(col);\n-        command.setIfNotExists(ifNotExists);\n-        return command;\n-    }\n-\n-    private CreateTrigger parseCreateTrigger(boolean force) {\n-        boolean ifNotExists = readIfNotExists();\n-        String triggerName = readIdentifierWithSchema(null);\n-        Schema schema = getSchema();\n-        boolean insteadOf, isBefore;\n-        if (readIf(\"INSTEAD\")) {\n-            read(\"OF\");\n-            isBefore = true;\n-            insteadOf = true;\n-        } else if (readIf(\"BEFORE\")) {\n-            insteadOf = false;\n-            isBefore = true;\n-        } else {\n-            read(\"AFTER\");\n-            insteadOf = false;\n-            isBefore = false;\n-        }\n-        int typeMask = 0;\n-        boolean onRollback = false;\n-        do {\n-            if (readIf(\"INSERT\")) {\n-                typeMask |= Trigger.INSERT;\n-            } else if (readIf(\"UPDATE\")) {\n-                typeMask |= Trigger.UPDATE;\n-            } else if (readIf(\"DELETE\")) {\n-                typeMask |= Trigger.DELETE;\n-            } else if (readIf(\"SELECT\")) {\n-                typeMask |= Trigger.SELECT;\n-            } else if (readIf(\"ROLLBACK\")) {\n-                onRollback = true;\n-            } else {\n-                throw getSyntaxError();\n-            }\n-        } while (readIf(\",\"));\n-        read(\"ON\");\n-        String tableName = readIdentifierWithSchema();\n+      } else if (readIf(\"CONSTRAINT\")) {\n+        String constraintName = readIdentifierWithSchema(schema.getName());\n         checkSchema(schema);\n-        CreateTrigger command = new CreateTrigger(session, getSchema());\n-        command.setForce(force);\n-        command.setTriggerName(triggerName);\n-        command.setIfNotExists(ifNotExists);\n-        command.setInsteadOf(insteadOf);\n-        command.setBefore(isBefore);\n-        command.setOnRollback(onRollback);\n-        command.setTypeMask(typeMask);\n-        command.setTableName(tableName);\n-        if (readIf(\"FOR\")) {\n-            read(\"EACH\");\n-            read(\"ROW\");\n-            command.setRowBased(true);\n-        } else {\n-            command.setRowBased(false);\n-        }\n-        if (readIf(\"QUEUE\")) {\n-            command.setQueueSize(readPositiveInt());\n-        }\n-        command.setNoWait(readIf(\"NOWAIT\"));\n-        if (readIf(\"AS\")) {\n-            command.setTriggerSource(readString());\n-        } else {\n-            read(\"CALL\");\n-            command.setTriggerClassName(readUniqueIdentifier());\n-        }\n-        return command;\n-    }\n-\n-    private CreateUser parseCreateUser() {\n-        CreateUser command = new CreateUser(session);\n-        command.setIfNotExists(readIfNotExists());\n-        command.setUserName(readUniqueIdentifier());\n-        command.setComment(readCommentIf());\n-        if (readIf(\"PASSWORD\")) {\n-            command.setPassword(readExpression());\n-        } else if (readIf(\"SALT\")) {\n-            command.setSalt(readExpression());\n-            read(\"HASH\");\n-            command.setHash(readExpression());\n-        } else if (readIf(\"IDENTIFIED\")) {\n-            read(\"BY\");\n-            // uppercase if not quoted\n-            command.setPassword(ValueExpression.get(ValueString\n-                    .get(readColumnIdentifier())));\n-        } else {\n-            throw getSyntaxError();\n-        }\n-        if (readIf(\"ADMIN\")) {\n-            command.setAdmin(true);\n-        }\n-        return command;\n-    }\n-\n-    private CreateFunctionAlias parseCreateFunctionAlias(boolean force) {\n-        boolean ifNotExists = readIfNotExists();\n-        final boolean newAliasSameNameAsBuiltin = Function.getFunction(database, currentToken) != null;\n-        String aliasName;\n-        if (database.isAllowBuiltinAliasOverride() && newAliasSameNameAsBuiltin) {\n-            aliasName = currentToken;\n-            schemaName = session.getCurrentSchemaName();\n-            read();\n-        } else {\n-            aliasName = readIdentifierWithSchema();\n-        }\n-        if (database.isAllowBuiltinAliasOverride() && newAliasSameNameAsBuiltin) {\n-            // fine\n-        } else if (isKeyword(aliasName) ||\n-                Function.getFunction(database, aliasName) != null ||\n-                getAggregateType(aliasName) != null) {\n-            throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1,\n-                    aliasName);\n-        }\n-        CreateFunctionAlias command = new CreateFunctionAlias(session,\n-                getSchema());\n-        command.setForce(force);\n-        command.setAliasName(aliasName);\n-        command.setIfNotExists(ifNotExists);\n-        command.setDeterministic(readIf(\"DETERMINISTIC\"));\n-        command.setBufferResultSetToLocalTemp(!readIf(\"NOBUFFER\"));\n-        if (readIf(\"AS\")) {\n-            command.setSource(readString());\n-        } else {\n-            read(\"FOR\");\n-            command.setJavaClassMethod(readUniqueIdentifier());\n-        }\n-        return command;\n-    }\n-\n-    private Prepared parseWith() {\n-        List<TableView> viewsCreated = new ArrayList<>();\n-        readIf(\"RECURSIVE\");\n-\n-        // this WITH statement might not be a temporary view - allow optional keyword to\n-        // tell us that this keyword. This feature will not be documented - H2 internal use only.\n-        boolean isPersistent = readIf(\"PERSISTENT\");\n-\n-        // this WITH statement is not a temporary view - it is part of a persistent view\n-        // as in CREATE VIEW abc AS WITH my_cte - this auto detects that condition\n-        if (session.isParsingCreateView()) {\n-            isPersistent = true;\n-        }\n-\n-        do {\n-            viewsCreated.add(parseSingleCommonTableExpression(isPersistent));\n-        } while (readIf(\",\"));\n-\n-        Prepared p = null;\n-        // reverse the order of constructed CTE views - as the destruction order\n-        // (since later created view may depend on previously created views -\n-        //  we preserve that dependency order in the destruction sequence )\n-        // used in setCteCleanups\n-        Collections.reverse(viewsCreated);\n-\n-        if (isToken(\"SELECT\")) {\n-            Query query = parseSelectUnion();\n-            query.setPrepareAlways(true);\n-            query.setNeverLazy(true);\n-            p = query;\n-        } else if (readIf(\"INSERT\")) {\n-            p = parseInsert();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"UPDATE\")) {\n-            p = parseUpdate();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"MERGE\")) {\n-            p = parseMerge();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"DELETE\")) {\n-            p = parseDelete();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"CREATE\")) {\n-            if (!isToken(\"TABLE\")) {\n-                throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n-                        WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n-\n-            }\n-            p = parseCreate();\n-            p.setPrepareAlways(true);\n-        } else {\n-            throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n-                    WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n-        }\n-\n-        // clean up temporary views starting with last to first (in case of\n-        // dependencies) - but only if they are not persistent\n-        if (!isPersistent) {\n-            p.setCteCleanups(viewsCreated);\n-        }\n-        return p;\n-    }\n-\n-    private TableView parseSingleCommonTableExpression(boolean isPersistent) {\n-        String cteViewName = readIdentifierWithSchema();\n-        Schema schema = getSchema();\n-        Table recursiveTable = null;\n-        ArrayList<Column> columns = New.arrayList();\n-        String[] cols = null;\n-        Database db = database;\n-\n-        // column names are now optional - they can be inferred from the named\n-        // query, if not supplied by user\n-        if (readIf(\"(\")) {\n-            cols = parseColumnList();\n-            for (String c : cols) {\n-                // we don't really know the type of the column, so STRING will\n-                // have to do, UNKNOWN does not work here\n-                columns.add(new Column(c, Value.STRING));\n-            }\n-        }\n-\n-        Table oldViewFound = null;\n-        if (isPersistent) {\n-            oldViewFound = getSchema().findTableOrView(session, cteViewName);\n-        } else {\n-            oldViewFound = session.findLocalTempTable(cteViewName);\n-        }\n-        // this persistent check conflicts with check 10 lines down\n-        if (oldViewFound != null) {\n-            if (!(oldViewFound instanceof TableView)) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1,\n-                        cteViewName);\n-            }\n-            TableView tv = (TableView) oldViewFound;\n-            if (!tv.isTableExpression()) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1,\n-                        cteViewName);\n-            }\n-            if (isPersistent) {\n-                oldViewFound.lock(session, true, true);\n-                database.removeSchemaObject(session, oldViewFound);\n-\n-            } else {\n-                session.removeLocalTempTable(oldViewFound);\n-            }\n-            oldViewFound = null;\n-        }\n-        /*\n-         * This table is created as a workaround because recursive table\n-         * expressions need to reference something that look like themselves to\n-         * work (its removed after creation in this method). Only create table\n-         * data and table if we don't have a working CTE already.\n-         */\n-        recursiveTable = TableView.createShadowTableForRecursiveTableExpression(\n-                isPersistent, session, cteViewName, schema, columns, db);\n-        List<Column> columnTemplateList;\n-        String[] querySQLOutput = new String[]{null};\n-        try {\n-            read(\"AS\");\n-            read(\"(\");\n-            Query withQuery = parseSelect();\n-            if (isPersistent) {\n-                withQuery.session = session;\n-            }\n-            read(\")\");\n-            columnTemplateList = TableView.createQueryColumnTemplateList(cols, withQuery, querySQLOutput);\n-\n-        } finally {\n-            TableView.destroyShadowTableForRecursiveExpression(isPersistent, session, recursiveTable);\n-        }\n-\n-        TableView view = createCTEView(cteViewName,\n-                querySQLOutput[0], columnTemplateList,\n-                true/* allowRecursiveQueryDetection */,\n-                true/* add to session */,\n-                isPersistent, session);\n-\n-        return view;\n-    }\n-\n-    private TableView createCTEView(String cteViewName,  String querySQL,\n-            List<Column> columnTemplateList, boolean allowRecursiveQueryDetection,\n-            boolean addViewToSession, boolean isPersistent, Session targetSession) {\n-        Database db = targetSession.getDatabase();\n-        Schema schema = getSchemaWithDefault();\n-        int id = db.allocateObjectId();\n-        Column[] columnTemplateArray = columnTemplateList.toArray(new Column[0]);\n-\n-        // No easy way to determine if this is a recursive query up front, so we just compile\n-        // it twice - once without the flag set, and if we didn't see a recursive term,\n-        // then we just compile it again.\n-        TableView view;\n-        synchronized (targetSession) {\n-            view = new TableView(schema, id, cteViewName, querySQL,\n-                    parameters, columnTemplateArray, targetSession,\n-                    allowRecursiveQueryDetection, false /* literalsChecked */, true /* isTableExpression */,\n-                    isPersistent);\n-            if (!view.isRecursiveQueryDetected() && allowRecursiveQueryDetection) {\n-                if (isPersistent) {\n-                    db.addSchemaObject(targetSession, view);\n-                    view.lock(targetSession, true, true);\n-                    targetSession.getDatabase().removeSchemaObject(targetSession, view);\n-                } else {\n-                    session.removeLocalTempTable(view);\n-                }\n-                view = new TableView(schema, id, cteViewName, querySQL, parameters,\n-                        columnTemplateArray, targetSession,\n-                        false/* assume recursive */, false /* literalsChecked */, true /* isTableExpression */,\n-                        isPersistent);\n-            }\n-            // both removeSchemaObject and removeLocalTempTable hold meta locks\n-            targetSession.getDatabase().unlockMeta(targetSession);\n-        }\n-        view.setTableExpression(true);\n-        view.setTemporary(!isPersistent);\n-        view.setHidden(true);\n-        view.setOnCommitDrop(false);\n-        if (addViewToSession) {\n-            if (isPersistent) {\n-                db.addSchemaObject(targetSession, view);\n-                view.unlock(targetSession);\n-                db.unlockMeta(targetSession);\n-            } else {\n-                targetSession.addLocalTempTable(view);\n-            }\n-        }\n-        return view;\n-    }\n-\n-    private CreateView parseCreateView(boolean force, boolean orReplace) {\n-        boolean ifNotExists = readIfNotExists();\n-        boolean isTableExpression = readIf(\"TABLE_EXPRESSION\");\n-        String viewName = readIdentifierWithSchema();\n-        CreateView command = new CreateView(session, getSchema());\n-        this.createView = command;\n-        command.setViewName(viewName);\n-        command.setIfNotExists(ifNotExists);\n-        command.setComment(readCommentIf());\n-        command.setOrReplace(orReplace);\n-        command.setForce(force);\n-        command.setTableExpression(isTableExpression);\n-        if (readIf(\"(\")) {\n-            String[] cols = parseColumnList();\n-            command.setColumnNames(cols);\n-        }\n-        String select = StringUtils.cache(sqlCommand\n-                .substring(parseIndex));\n-        read(\"AS\");\n-        try {\n-            Query query;\n-            session.setParsingCreateView(true, viewName);\n-            try {\n-                query = parseSelect();\n-                query.prepare();\n-            } finally {\n-                session.setParsingCreateView(false, viewName);\n-            }\n-            command.setSelect(query);\n-        } catch (DbException e) {\n-            if (force) {\n-                command.setSelectSQL(select);\n-                while (currentTokenType != END) {\n-                    read();\n-                }\n-            } else {\n-                throw e;\n-            }\n-        }\n-        return command;\n-    }\n-\n-    private TransactionCommand parseCheckpoint() {\n-        TransactionCommand command;\n-        if (readIf(\"SYNC\")) {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.CHECKPOINT_SYNC);\n-        } else {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.CHECKPOINT);\n-        }\n-        return command;\n-    }\n-\n-    private Prepared parseAlter() {\n-        if (readIf(\"TABLE\")) {\n-            return parseAlterTable();\n-        } else if (readIf(\"USER\")) {\n-            return parseAlterUser();\n-        } else if (readIf(\"INDEX\")) {\n-            return parseAlterIndex();\n-        } else if (readIf(\"SCHEMA\")) {\n-            return parseAlterSchema();\n-        } else if (readIf(\"SEQUENCE\")) {\n-            return parseAlterSequence();\n-        } else if (readIf(\"VIEW\")) {\n-            return parseAlterView();\n-        }\n-        throw getSyntaxError();\n-    }\n-\n-    private void checkSchema(Schema old) {\n-        if (old != null && getSchema() != old) {\n-            throw DbException.get(ErrorCode.SCHEMA_NAME_MUST_MATCH);\n-        }\n-    }\n-\n-    private AlterIndexRename parseAlterIndex() {\n-        boolean ifExists = readIfExists(false);\n-        String indexName = readIdentifierWithSchema();\n-        Schema old = getSchema();\n-        AlterIndexRename command = new AlterIndexRename(session);\n-        command.setOldSchema(old);\n-        command.setOldName(indexName);\n-        command.setIfExists(ifExists);\n-        read(\"RENAME\");\n-        read(\"TO\");\n-        String newName = readIdentifierWithSchema(old.getName());\n-        checkSchema(old);\n-        command.setNewName(newName);\n-        return command;\n-    }\n-\n-    private AlterView parseAlterView() {\n-        AlterView command = new AlterView(session);\n-        boolean ifExists = readIfExists(false);\n-        command.setIfExists(ifExists);\n-        String viewName = readIdentifierWithSchema();\n-        Table tableView = getSchema().findTableOrView(session, viewName);\n-        if (!(tableView instanceof TableView) && !ifExists) {\n-            throw DbException.get(ErrorCode.VIEW_NOT_FOUND_1, viewName);\n-        }\n-        TableView view = (TableView) tableView;\n-        command.setView(view);\n-        read(\"RECOMPILE\");\n-        return command;\n-    }\n-\n-    private Prepared parseAlterSchema() {\n-        boolean ifExists = readIfExists(false);\n-        String schemaName = readIdentifierWithSchema();\n-        Schema old = getSchema();\n-        read(\"RENAME\");\n         read(\"TO\");\n-        String newName = readIdentifierWithSchema(old.getName());\n-        Schema schema = findSchema(schemaName);\n-        if (schema == null) {\n-            if (ifExists) {\n-                return new NoOperation(session);\n-            }\n-            throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schemaName);\n-        }\n-        AlterSchemaRename command = new AlterSchemaRename(session);\n-        command.setOldSchema(schema);\n-        checkSchema(old);\n-        command.setNewName(newName);\n-        return command;\n-    }\n-\n-    private AlterSequence parseAlterSequence() {\n-        boolean ifExists = readIfExists(false);\n-        String sequenceName = readIdentifierWithSchema();\n-        AlterSequence command = new AlterSequence(session, getSchema());\n-        command.setSequenceName(sequenceName);\n-        command.setIfExists(ifExists);\n-        while (true) {\n-            if (readIf(\"RESTART\")) {\n-                read(\"WITH\");\n-                command.setStartWith(readExpression());\n-            } else if (readIf(\"INCREMENT\")) {\n-                read(\"BY\");\n-                command.setIncrement(readExpression());\n-            } else if (readIf(\"MINVALUE\")) {\n-                command.setMinValue(readExpression());\n-            } else if (readIf(\"NOMINVALUE\")) {\n-                command.setMinValue(null);\n-            } else if (readIf(\"MAXVALUE\")) {\n-                command.setMaxValue(readExpression());\n-            } else if (readIf(\"NOMAXVALUE\")) {\n-                command.setMaxValue(null);\n-            } else if (readIf(\"CYCLE\")) {\n-                command.setCycle(true);\n-            } else if (readIf(\"NOCYCLE\")) {\n-                command.setCycle(false);\n-            } else if (readIf(\"NO\")) {\n-                if (readIf(\"MINVALUE\")) {\n-                    command.setMinValue(null);\n-                } else if (readIf(\"MAXVALUE\")) {\n-                    command.setMaxValue(null);\n-                } else if (readIf(\"CYCLE\")) {\n-                    command.setCycle(false);\n-                } else if (readIf(\"CACHE\")) {\n-                    command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-                } else {\n-                    break;\n-                }\n-            } else if (readIf(\"CACHE\")) {\n-                command.setCacheSize(readExpression());\n-            } else if (readIf(\"NOCACHE\")) {\n-                command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-            } else {\n-                break;\n-            }\n-        }\n-        return command;\n-    }\n-\n-    private AlterUser parseAlterUser() {\n-        String userName = readUniqueIdentifier();\n-        if (readIf(\"SET\")) {\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n-            command.setUser(database.getUser(userName));\n-            if (readIf(\"PASSWORD\")) {\n-                command.setPassword(readExpression());\n-            } else if (readIf(\"SALT\")) {\n-                command.setSalt(readExpression());\n-                read(\"HASH\");\n-                command.setHash(readExpression());\n-            } else {\n-                throw getSyntaxError();\n-            }\n-            return command;\n-        } else if (readIf(\"RENAME\")) {\n-            read(\"TO\");\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_RENAME);\n-            command.setUser(database.getUser(userName));\n-            String newName = readUniqueIdentifier();\n-            command.setNewName(newName);\n-            return command;\n-        } else if (readIf(\"ADMIN\")) {\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_ADMIN);\n-            User user = database.getUser(userName);\n-            command.setUser(user);\n-            if (readIf(\"TRUE\")) {\n-                command.setAdmin(true);\n-            } else if (readIf(\"FALSE\")) {\n-                command.setAdmin(false);\n-            } else {\n-                throw getSyntaxError();\n-            }\n-            return command;\n-        }\n-        throw getSyntaxError();\n-    }\n-\n-    private void readIfEqualOrTo() {\n-        if (!readIf(\"=\")) {\n-            readIf(\"TO\");\n-        }\n-    }\n-\n-    private Prepared parseSet() {\n-        if (readIf(\"@\")) {\n-            Set command = new Set(session, SetTypes.VARIABLE);\n-            command.setString(readAliasIdentifier());\n-            readIfEqualOrTo();\n-            command.setExpression(readExpression());\n-            return command;\n-        } else if (readIf(\"AUTOCOMMIT\")) {\n-            readIfEqualOrTo();\n-            boolean value = readBooleanSetting();\n-            int setting = value ? CommandInterface.SET_AUTOCOMMIT_TRUE\n-                    : CommandInterface.SET_AUTOCOMMIT_FALSE;\n-            return new TransactionCommand(session, setting);\n-        } else if (readIf(\"MVCC\")) {\n-            readIfEqualOrTo();\n-            boolean value = readBooleanSetting();\n-            Set command = new Set(session, SetTypes.MVCC);\n-            command.setInt(value ? 1 : 0);\n-            return command;\n-        } else if (readIf(\"EXCLUSIVE\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.EXCLUSIVE);\n-            command.setExpression(readExpression());\n-            return command;\n-        } else if (readIf(\"IGNORECASE\")) {\n-            readIfEqualOrTo();\n-            boolean value = readBooleanSetting();\n-            Set command = new Set(session, SetTypes.IGNORECASE);\n-            command.setInt(value ? 1 : 0);\n-            return command;\n-        } else if (readIf(\"PASSWORD\")) {\n-            readIfEqualOrTo();\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n-            command.setUser(session.getUser());\n-            command.setPassword(readExpression());\n-            return command;\n-        } else if (readIf(\"SALT\")) {\n-            readIfEqualOrTo();\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n-            command.setUser(session.getUser());\n-            command.setSalt(readExpression());\n-            read(\"HASH\");\n-            command.setHash(readExpression());\n-            return command;\n-        } else if (readIf(\"MODE\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.MODE);\n-            command.setString(readAliasIdentifier());\n-            return command;\n-        } else if (readIf(\"COMPRESS_LOB\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.COMPRESS_LOB);\n-            if (currentTokenType == VALUE) {\n-                command.setString(readString());\n-            } else {\n-                command.setString(readUniqueIdentifier());\n-            }\n-            return command;\n-        } else if (readIf(\"DATABASE\")) {\n-            readIfEqualOrTo();\n-            read(\"COLLATION\");\n-            return parseSetCollation();\n-        } else if (readIf(\"COLLATION\")) {\n-            readIfEqualOrTo();\n-            return parseSetCollation();\n-        } else if (readIf(\"BINARY_COLLATION\")) {\n-            readIfEqualOrTo();\n-            return parseSetBinaryCollation();\n-        } else if (readIf(\"CLUSTER\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.CLUSTER);\n-            command.setString(readString());\n-            return command;\n-        } else if (readIf(\"DATABASE_EVENT_LISTENER\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.DATABASE_EVENT_LISTENER);\n-            command.setString(readString());\n-            return command;\n-        } else if (readIf(\"ALLOW_LITERALS\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.ALLOW_LITERALS);\n-            if (readIf(\"NONE\")) {\n-                command.setInt(Constants.ALLOW_LITERALS_NONE);\n-            } else if (readIf(\"ALL\")) {\n-                command.setInt(Constants.ALLOW_LITERALS_ALL);\n-            } else if (readIf(\"NUMBERS\")) {\n-                command.setInt(Constants.ALLOW_LITERALS_NUMBERS);\n-            } else {\n-                command.setInt(readPositiveInt());\n-            }\n-            return command;\n-        } else if (readIf(\"DEFAULT_TABLE_TYPE\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.DEFAULT_TABLE_TYPE);\n-            if (readIf(\"MEMORY\")) {\n-                command.setInt(Table.TYPE_MEMORY);\n-            } else if (readIf(\"CACHED\")) {\n-                command.setInt(Table.TYPE_CACHED);\n-            } else {\n-                command.setInt(readPositiveInt());\n-            }\n-            return command;\n-        } else if (readIf(\"CREATE\")) {\n-            readIfEqualOrTo();\n-            // Derby compatibility (CREATE=TRUE in the database URL)\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"HSQLDB.DEFAULT_TABLE_TYPE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"PAGE_STORE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"CACHE_TYPE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"FILE_LOCK\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"DB_CLOSE_ON_EXIT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"AUTO_SERVER\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"AUTO_SERVER_PORT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"AUTO_RECONNECT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"ASSERT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"ACCESS_MODE_DATA\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"OPEN_NEW\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"JMX\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"PAGE_SIZE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"RECOVER\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"NAMES\")) {\n-            // Quercus PHP MySQL driver compatibility\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"SCOPE_GENERATED_KEYS\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"SCHEMA\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.SCHEMA);\n-            command.setString(readAliasIdentifier());\n-            return command;\n-        } else if (readIf(\"DATESTYLE\")) {\n-            // PostgreSQL compatibility\n-            readIfEqualOrTo();\n-            if (!readIf(\"ISO\")) {\n-                String s = readString();\n-                if (!equalsToken(s, \"ISO\")) {\n-                    throw getSyntaxError();\n-                }\n-            }\n-            return new NoOperation(session);\n-        } else if (readIf(\"SEARCH_PATH\") ||\n-                readIf(SetTypes.getTypeName(SetTypes.SCHEMA_SEARCH_PATH))) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.SCHEMA_SEARCH_PATH);\n-            ArrayList<String> list = New.arrayList();\n-            list.add(readAliasIdentifier());\n-            while (readIf(\",\")) {\n-                list.add(readAliasIdentifier());\n-            }\n-            command.setStringArray(list.toArray(new String[0]));\n-            return command;\n-        } else if (readIf(\"JAVA_OBJECT_SERIALIZER\")) {\n-            readIfEqualOrTo();\n-            return parseSetJavaObjectSerializer();\n-        } else {\n-            if (isToken(\"LOGSIZE\")) {\n-                // HSQLDB compatibility\n-                currentToken = SetTypes.getTypeName(SetTypes.MAX_LOG_SIZE);\n-            }\n-            if (isToken(\"FOREIGN_KEY_CHECKS\")) {\n-                // MySQL compatibility\n-                currentToken = SetTypes\n-                        .getTypeName(SetTypes.REFERENTIAL_INTEGRITY);\n-            }\n-            int type = SetTypes.getType(currentToken);\n-            if (type < 0) {\n-                throw getSyntaxError();\n-            }\n-            read();\n-            readIfEqualOrTo();\n-            Set command = new Set(session, type);\n-            command.setExpression(readExpression());\n-            return command;\n-        }\n-    }\n-\n-    private Prepared parseUse() {\n-        readIfEqualOrTo();\n-        Set command = new Set(session, SetTypes.SCHEMA);\n-        command.setString(readAliasIdentifier());\n-        return command;\n-    }\n-\n-    private Set parseSetCollation() {\n-        Set command = new Set(session, SetTypes.COLLATION);\n-        String name = readAliasIdentifier();\n-        command.setString(name);\n-        if (equalsToken(name, CompareMode.OFF)) {\n-            return command;\n-        }\n-        Collator coll = CompareMode.getCollator(name);\n-        if (coll == null) {\n-            throw DbException.getInvalidValueException(\"collation\", name);\n-        }\n-        if (readIf(\"STRENGTH\")) {\n-            if (readIf(\"PRIMARY\")) {\n-                command.setInt(Collator.PRIMARY);\n-            } else if (readIf(\"SECONDARY\")) {\n-                command.setInt(Collator.SECONDARY);\n-            } else if (readIf(\"TERTIARY\")) {\n-                command.setInt(Collator.TERTIARY);\n-            } else if (readIf(\"IDENTICAL\")) {\n-                command.setInt(Collator.IDENTICAL);\n-            }\n-        } else {\n-            command.setInt(coll.getStrength());\n-        }\n-        return command;\n-    }\n-\n-    private Set parseSetBinaryCollation() {\n-        Set command = new Set(session, SetTypes.BINARY_COLLATION);\n-        String name = readAliasIdentifier();\n-        command.setString(name);\n-        if (equalsToken(name, CompareMode.UNSIGNED) ||\n-                equalsToken(name, CompareMode.SIGNED)) {\n-            return command;\n-        }\n-        throw DbException.getInvalidValueException(\"BINARY_COLLATION\", name);\n-    }\n-\n-    private Set parseSetJavaObjectSerializer() {\n-        Set command = new Set(session, SetTypes.JAVA_OBJECT_SERIALIZER);\n-        String name = readString();\n-        command.setString(name);\n-        return command;\n-    }\n-\n-    private RunScriptCommand parseRunScript() {\n-        RunScriptCommand command = new RunScriptCommand(session);\n-        read(\"FROM\");\n-        command.setFileNameExpr(readExpression());\n-        if (readIf(\"COMPRESSION\")) {\n-            command.setCompressionAlgorithm(readUniqueIdentifier());\n-        }\n-        if (readIf(\"CIPHER\")) {\n-            command.setCipher(readUniqueIdentifier());\n-            if (readIf(\"PASSWORD\")) {\n-                command.setPassword(readExpression());\n-            }\n-        }\n-        if (readIf(\"CHARSET\")) {\n-            command.setCharset(Charset.forName(readString()));\n-        }\n-        return command;\n-    }\n-\n-    private ScriptCommand parseScript() {\n-        ScriptCommand command = new ScriptCommand(session);\n-        boolean data = true, passwords = true, settings = true;\n-        boolean dropTables = false, simple = false;\n-        if (readIf(\"SIMPLE\")) {\n-            simple = true;\n-        }\n-        if (readIf(\"NODATA\")) {\n-            data = false;\n-        }\n-        if (readIf(\"NOPASSWORDS\")) {\n-            passwords = false;\n-        }\n-        if (readIf(\"NOSETTINGS\")) {\n-            settings = false;\n-        }\n-        if (readIf(\"DROP\")) {\n-            dropTables = true;\n-        }\n-        if (readIf(\"BLOCKSIZE\")) {\n-            long blockSize = readLong();\n-            command.setLobBlockSize(blockSize);\n-        }\n-        command.setData(data);\n-        command.setPasswords(passwords);\n-        command.setSettings(settings);\n-        command.setDrop(dropTables);\n-        command.setSimple(simple);\n-        if (readIf(\"TO\")) {\n-            command.setFileNameExpr(readExpression());\n-            if (readIf(\"COMPRESSION\")) {\n-                command.setCompressionAlgorithm(readUniqueIdentifier());\n-            }\n-            if (readIf(\"CIPHER\")) {\n-                command.setCipher(readUniqueIdentifier());\n-                if (readIf(\"PASSWORD\")) {\n-                    command.setPassword(readExpression());\n-                }\n-            }\n-            if (readIf(\"CHARSET\")) {\n-                command.setCharset(Charset.forName(readString()));\n-            }\n-        }\n-        if (readIf(\"SCHEMA\")) {\n-            HashSet<String> schemaNames = new HashSet<>();\n-            do {\n-                schemaNames.add(readUniqueIdentifier());\n-            } while (readIf(\",\"));\n-            command.setSchemaNames(schemaNames);\n-        } else if (readIf(\"TABLE\")) {\n-            ArrayList<Table> tables = New.arrayList();\n-            do {\n-                tables.add(readTableOrView());\n-            } while (readIf(\",\"));\n-            command.setTables(tables);\n-        }\n+        AlterTableRenameConstraint command = new AlterTableRenameConstraint(\n+            session, schema);\n+        command.setConstraintName(constraintName);\n+        String newName = readColumnIdentifier();\n+        command.setNewConstraintName(newName);\n+        return commandIfTableExists(schema, tableName, ifTableExists, command);\n+      } else {\n+        read(\"TO\");\n+        String newName = readIdentifierWithSchema(schema.getName());\n+        checkSchema(schema);\n+        AlterTableRename command = new AlterTableRename(session,\n+            getSchema());\n+        command.setOldTableName(tableName);\n+        command.setNewTableName(newName);\n+        command.setIfTableExists(ifTableExists);\n+        command.setHidden(readIf(\"HIDDEN\"));\n         return command;\n-    }\n-\n-    private Table readTableOrView() {\n-        return readTableOrView(readIdentifierWithSchema(null));\n-    }\n-\n-    private Table readTableOrView(String tableName) {\n-        // same algorithm than readSequence\n-        if (schemaName != null) {\n-            return getSchema().getTableOrView(session, tableName);\n-        }\n-        Table table = database.getSchema(session.getCurrentSchemaName())\n-                .resolveTableOrView(session, tableName);\n-        if (table != null) {\n-            return table;\n-        }\n-        String[] schemaNames = session.getSchemaSearchPath();\n-        if (schemaNames != null) {\n-            for (String name : schemaNames) {\n-                Schema s = database.getSchema(name);\n-                table = s.resolveTableOrView(session, tableName);\n-                if (table != null) {\n-                    return table;\n-                }\n-            }\n-        }\n-        throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, tableName);\n-    }\n-\n-    private FunctionAlias findFunctionAlias(String schema, String aliasName) {\n-        FunctionAlias functionAlias = database.getSchema(schema).findFunction(\n-                aliasName);\n-        if (functionAlias != null) {\n-            return functionAlias;\n-        }\n-        String[] schemaNames = session.getSchemaSearchPath();\n-        if (schemaNames != null) {\n-            for (String n : schemaNames) {\n-                functionAlias = database.getSchema(n).findFunction(aliasName);\n-                if (functionAlias != null) {\n-                    return functionAlias;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private Sequence findSequence(String schema, String sequenceName) {\n-        Sequence sequence = database.getSchema(schema).findSequence(\n-                sequenceName);\n-        if (sequence != null) {\n-            return sequence;\n-        }\n-        String[] schemaNames = session.getSchemaSearchPath();\n-        if (schemaNames != null) {\n-            for (String n : schemaNames) {\n-                sequence = database.getSchema(n).findSequence(sequenceName);\n-                if (sequence != null) {\n-                    return sequence;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private Sequence readSequence() {\n-        // same algorithm as readTableOrView\n-        String sequenceName = readIdentifierWithSchema(null);\n-        if (schemaName != null) {\n-            return getSchema().getSequence(sequenceName);\n-        }\n-        Sequence sequence = findSequence(session.getCurrentSchemaName(),\n-                sequenceName);\n-        if (sequence != null) {\n-            return sequence;\n-        }\n-        throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n-    }\n-\n-    private Prepared parseAlterTable() {\n-        boolean ifTableExists = readIfExists(false);\n-        String tableName = readIdentifierWithSchema();\n-        Schema schema = getSchema();\n-        if (readIf(\"ADD\")) {\n-            Prepared command = parseAlterTableAddConstraintIf(tableName,\n-                    schema, ifTableExists);\n-            if (command != null) {\n-                return command;\n-            }\n-            return parseAlterTableAddColumn(tableName, schema, ifTableExists);\n-        } else if (readIf(\"SET\")) {\n-            read(\"REFERENTIAL_INTEGRITY\");\n-            int type = CommandInterface.ALTER_TABLE_SET_REFERENTIAL_INTEGRITY;\n-            boolean value = readBooleanSetting();\n-            AlterTableSet command = new AlterTableSet(session,\n-                    schema, type, value);\n-            command.setTableName(tableName);\n-            command.setIfTableExists(ifTableExists);\n-            if (readIf(\"CHECK\")) {\n-                command.setCheckExisting(true);\n-            } else if (readIf(\"NOCHECK\")) {\n-                command.setCheckExisting(false);\n-            }\n-            return command;\n-        } else if (readIf(\"RENAME\")) {\n-            if (readIf(\"COLUMN\")) {\n-                // PostgreSQL syntax\n-                String columnName = readColumnIdentifier();\n-                read(\"TO\");\n-                AlterTableRenameColumn command = new AlterTableRenameColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumnName(columnName);\n-                String newName = readColumnIdentifier();\n-                command.setNewColumnName(newName);\n-                return command;\n-            } else if (readIf(\"CONSTRAINT\")) {\n-                String constraintName = readIdentifierWithSchema(schema.getName());\n-                checkSchema(schema);\n-                read(\"TO\");\n-                AlterTableRenameConstraint command = new AlterTableRenameConstraint(\n-                        session, schema);\n-                command.setConstraintName(constraintName);\n-                String newName = readColumnIdentifier();\n-                command.setNewConstraintName(newName);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else {\n-                read(\"TO\");\n-                String newName = readIdentifierWithSchema(schema.getName());\n-                checkSchema(schema);\n-                AlterTableRename command = new AlterTableRename(session,\n-                        getSchema());\n-                command.setOldTableName(tableName);\n-                command.setNewTableName(newName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setHidden(readIf(\"HIDDEN\"));\n-                return command;\n-            }\n-        } else if (readIf(\"DROP\")) {\n-            if (readIf(\"CONSTRAINT\")) {\n-                boolean ifExists = readIfExists(false);\n-                String constraintName = readIdentifierWithSchema(schema.getName());\n-                ifExists = readIfExists(ifExists);\n-                checkSchema(schema);\n-                AlterTableDropConstraint command = new AlterTableDropConstraint(\n-                        session, getSchema(), ifExists);\n-                command.setConstraintName(constraintName);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"FOREIGN\")) {\n-                // MySQL compatibility\n-                read(\"KEY\");\n-                String constraintName = readIdentifierWithSchema(schema.getName());\n-                checkSchema(schema);\n-                AlterTableDropConstraint command = new AlterTableDropConstraint(\n-                        session, getSchema(), false);\n-                command.setConstraintName(constraintName);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"INDEX\")) {\n-                // MySQL compatibility\n-                String indexOrConstraintName = readIdentifierWithSchema();\n-                final SchemaCommand command;\n-                if (schema.findIndex(session, indexOrConstraintName) != null) {\n-                    DropIndex dropIndexCommand = new DropIndex(session, getSchema());\n-                    dropIndexCommand.setIndexName(indexOrConstraintName);\n-                    command = dropIndexCommand;\n-                } else {\n-                    AlterTableDropConstraint dropCommand = new AlterTableDropConstraint(\n-                            session, getSchema(), false/*ifExists*/);\n-                    dropCommand.setConstraintName(indexOrConstraintName);\n-                    command = dropCommand;\n-                }\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"PRIMARY\")) {\n-                read(\"KEY\");\n-                Table table = tableIfTableExists(schema, tableName, ifTableExists);\n-                if (table == null) {\n-                    return new NoOperation(session);\n-                }\n-                Index idx = table.getPrimaryKey();\n-                DropIndex command = new DropIndex(session, schema);\n-                command.setIndexName(idx.getName());\n-                return command;\n-            } else {\n-                readIf(\"COLUMN\");\n-                boolean ifExists = readIfExists(false);\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setType(CommandInterface.ALTER_TABLE_DROP_COLUMN);\n-                ArrayList<Column> columnsToRemove = New.arrayList();\n-                Table table = tableIfTableExists(schema, tableName, ifTableExists);\n-                // For Oracle compatibility - open bracket required\n-                boolean openingBracketDetected = readIf(\"(\");\n-                do {\n-                    String columnName = readColumnIdentifier();\n-                    if (table == null) {\n-                        return new NoOperation(session);\n-                    }\n-                    if (ifExists && !table.doesColumnExist(columnName)) {\n-                        return new NoOperation(session);\n-                    }\n-                    Column column = table.getColumn(columnName);\n-                    columnsToRemove.add(column);\n-                } while (readIf(\",\"));\n-                if (openingBracketDetected) {\n-                    // For Oracle compatibility - close bracket\n-                    read(\")\");\n-                }\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setColumnsToRemove(columnsToRemove);\n-                return command;\n-            }\n-        } else if (readIf(\"CHANGE\")) {\n-            // MySQL compatibility\n-            readIf(\"COLUMN\");\n-            String columnName = readColumnIdentifier();\n-            String newColumnName = readColumnIdentifier();\n-            Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-            boolean nullable = column == null ? true : column.isNullable();\n-            // new column type ignored. RENAME and MODIFY are\n-            // a single command in MySQL but two different commands in H2.\n-            parseColumnForTable(newColumnName, nullable);\n-            AlterTableRenameColumn command = new AlterTableRenameColumn(session, schema);\n-            command.setTableName(tableName);\n-            command.setIfTableExists(ifTableExists);\n-            command.setOldColumnName(columnName);\n-            command.setNewColumnName(newColumnName);\n-            return command;\n-        } else if (readIf(\"MODIFY\")) {\n-            // MySQL compatibility (optional)\n-            readIf(\"COLUMN\");\n-            // Oracle specifies (but will not require) an opening parenthesis\n-            boolean hasOpeningBracket = readIf(\"(\");\n-            String columnName = readColumnIdentifier();\n-            AlterTableAlterColumn command = null;\n-            NullConstraintType nullConstraint = parseNotNullConstraint();\n-            switch (nullConstraint) {\n-            case NULL_IS_ALLOWED:\n-            case NULL_IS_NOT_ALLOWED:\n-                command = new AlterTableAlterColumn(session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-                command.setOldColumn(column);\n-                if (nullConstraint == NullConstraintType.NULL_IS_ALLOWED) {\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n-                } else {\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n-                }\n-                break;\n-            case NO_NULL_CONSTRAINT_FOUND:\n-                command = parseAlterTableAlterColumnType(schema, tableName, columnName, ifTableExists);\n-                break;\n-            default:\n-                throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n-                        \"Internal Error - unhandled case: \" + nullConstraint.name());\n-            }\n-            if(hasOpeningBracket) {\n-                read(\")\");\n-            }\n-            return command;\n-        } else if (readIf(\"ALTER\")) {\n-            readIf(\"COLUMN\");\n-            String columnName = readColumnIdentifier();\n-            Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-            if (readIf(\"RENAME\")) {\n-                read(\"TO\");\n-                AlterTableRenameColumn command = new AlterTableRenameColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumnName(columnName);\n-                String newName = readColumnIdentifier();\n-                command.setNewColumnName(newName);\n-                return command;\n-            } else if (readIf(\"DROP\")) {\n-                // PostgreSQL compatibility\n-                if (readIf(\"DEFAULT\")) {\n-                    AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                            session, schema);\n-                    command.setTableName(tableName);\n-                    command.setIfTableExists(ifTableExists);\n-                    command.setOldColumn(column);\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n-                    command.setDefaultExpression(null);\n-                    return command;\n-                }\n-                read(\"NOT\");\n-                read(\"NULL\");\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumn(column);\n-                command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n-                return command;\n-            } else if (readIf(\"TYPE\")) {\n-                // PostgreSQL compatibility\n-                return parseAlterTableAlterColumnType(schema, tableName,\n-                        columnName, ifTableExists);\n-            } else if (readIf(\"SET\")) {\n-                if (readIf(\"DATA\")) {\n-                    // Derby compatibility\n-                    read(\"TYPE\");\n-                    return parseAlterTableAlterColumnType(schema, tableName, columnName,\n-                            ifTableExists);\n-                }\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumn(column);\n-                NullConstraintType nullConstraint = parseNotNullConstraint();\n-                switch (nullConstraint) {\n-                case NULL_IS_ALLOWED:\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n-                    break;\n-                case NULL_IS_NOT_ALLOWED:\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n-                    break;\n-                case NO_NULL_CONSTRAINT_FOUND:\n-                    if (readIf(\"DEFAULT\")) {\n-                        Expression defaultExpression = readExpression();\n-                        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n-                        command.setDefaultExpression(defaultExpression);\n-\n-                    } else if (readIf(\"INVISIBLE\")) {\n-                        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n-                        command.setVisible(false);\n-\n-                    } else if (readIf(\"VISIBLE\")) {\n-                        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n-                        command.setVisible(true);\n-                    }\n-                    break;\n-                default:\n-                    throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n-                            \"Internal Error - unhandled case: \" + nullConstraint.name());\n-                }\n-                return command;\n-            } else if (readIf(\"RESTART\")) {\n-                readIf(\"WITH\");\n-                Expression start = readExpression();\n-                AlterSequence command = new AlterSequence(session, schema);\n-                command.setColumn(column);\n-                command.setStartWith(start);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"SELECTIVITY\")) {\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_SELECTIVITY);\n-                command.setOldColumn(column);\n-                command.setSelectivity(readExpression());\n-                return command;\n-            } else {\n-                return parseAlterTableAlterColumnType(schema, tableName,\n-                        columnName, ifTableExists);\n-            }\n-        }\n-        throw getSyntaxError();\n-    }\n-\n-    private Table tableIfTableExists(Schema schema, String tableName, boolean ifTableExists) {\n-        Table table = schema.resolveTableOrView(session, tableName);\n-        if (table == null && !ifTableExists) {\n-            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, tableName);\n+      }\n+    } else if (readIf(\"DROP\")) {\n+      if (readIf(\"CONSTRAINT\")) {\n+        boolean ifExists = readIfExists(false);\n+        String constraintName = readIdentifierWithSchema(schema.getName());\n+        ifExists = readIfExists(ifExists);\n+        checkSchema(schema);\n+        AlterTableDropConstraint command = new AlterTableDropConstraint(\n+            session, getSchema(), ifExists);\n+        command.setConstraintName(constraintName);\n+        return commandIfTableExists(schema, tableName, ifTableExists, command);\n+      } else if (readIf(\"FOREIGN\")) {\n+        // MySQL compatibility\n+        read(\"KEY\");\n+        String constraintName = readIdentifierWithSchema(schema.getName());\n+        checkSchema(schema);\n+        AlterTableDropConstraint command = new AlterTableDropConstraint(\n+            session, getSchema(), false);\n+        command.setConstraintName(constraintName);\n+        return commandIfTableExists(schema, tableName, ifTableExists, command);\n+      } else if (readIf(\"INDEX\")) {\n+        // MySQL compatibility\n+        String indexOrConstraintName = readIdentifierWithSchema();\n+        final SchemaCommand command;\n+        if (schema.findIndex(session, indexOrConstraintName) != null) {\n+          DropIndex dropIndexCommand = new DropIndex(session, getSchema());\n+          dropIndexCommand.setIndexName(indexOrConstraintName);\n+          command = dropIndexCommand;\n+        } else {\n+          AlterTableDropConstraint dropCommand = new AlterTableDropConstraint(\n+              session, getSchema(), false/*ifExists*/);\n+          dropCommand.setConstraintName(indexOrConstraintName);\n+          command = dropCommand;\n+        }\n+        return commandIfTableExists(schema, tableName, ifTableExists, command);\n+      } else if (readIf(\"PRIMARY\")) {\n+        read(\"KEY\");\n+        Table table = tableIfTableExists(schema, tableName, ifTableExists);\n+        if (table == null) {\n+          return new NoOperation(session);\n         }\n-        return table;\n-    }\n-\n-    private Column columnIfTableExists(Schema schema, String tableName,\n-            String columnName, boolean ifTableExists) {\n+        Index idx = table.getPrimaryKey();\n+        DropIndex command = new DropIndex(session, schema);\n+        command.setIndexName(idx.getName());\n+        return command;\n+      } else {\n+        readIf(\"COLUMN\");\n+        boolean ifExists = readIfExists(false);\n+        AlterTableAlterColumn command = new AlterTableAlterColumn(\n+            session, schema);\n+        command.setType(CommandInterface.ALTER_TABLE_DROP_COLUMN);\n+        ArrayList<Column> columnsToRemove = New.arrayList();\n         Table table = tableIfTableExists(schema, tableName, ifTableExists);\n-        return table == null ? null : table.getColumn(columnName);\n-    }\n-\n-    private Prepared commandIfTableExists(Schema schema, String tableName,\n-            boolean ifTableExists, Prepared commandIfTableExists) {\n-        return tableIfTableExists(schema, tableName, ifTableExists) == null\n-            ? new NoOperation(session)\n-            : commandIfTableExists;\n-    }\n-\n-    private AlterTableAlterColumn parseAlterTableAlterColumnType(Schema schema,\n-            String tableName, String columnName, boolean ifTableExists) {\n-        Column oldColumn = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-        Column newColumn = parseColumnForTable(columnName,\n-                oldColumn == null ? true : oldColumn.isNullable());\n-        AlterTableAlterColumn command = new AlterTableAlterColumn(session,\n-                schema);\n+        // For Oracle compatibility - open bracket required\n+        boolean openingBracketDetected = readIf(\"(\");\n+        do {\n+          String columnName = readColumnIdentifier();\n+          if (table == null) {\n+            return new NoOperation(session);\n+          }\n+          if (ifExists && !table.doesColumnExist(columnName)) {\n+            return new NoOperation(session);\n+          }\n+          Column column = table.getColumn(columnName);\n+          columnsToRemove.add(column);\n+        } while (readIf(\",\"));\n+        if (openingBracketDetected) {\n+          // For Oracle compatibility - close bracket\n+          read(\")\");\n+        }\n         command.setTableName(tableName);\n         command.setIfTableExists(ifTableExists);\n-        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_CHANGE_TYPE);\n-        command.setOldColumn(oldColumn);\n-        command.setNewColumn(newColumn);\n+        command.setColumnsToRemove(columnsToRemove);\n         return command;\n-    }\n-\n-    private AlterTableAlterColumn parseAlterTableAddColumn(String tableName,\n-            Schema schema, boolean ifTableExists) {\n-        readIf(\"COLUMN\");\n-        AlterTableAlterColumn command = new AlterTableAlterColumn(session,\n-                schema);\n-        command.setType(CommandInterface.ALTER_TABLE_ADD_COLUMN);\n+      }\n+    } else if (readIf(\"CHANGE\")) {\n+      // MySQL compatibility\n+      readIf(\"COLUMN\");\n+      String columnName = readColumnIdentifier();\n+      String newColumnName = readColumnIdentifier();\n+      Column column =\n+          columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+      boolean nullable = column == null ? true : column.isNullable();\n+      // new column type ignored. RENAME and MODIFY are\n+      // a single command in MySQL but two different commands in H2.\n+      parseColumnForTable(newColumnName, nullable);\n+      AlterTableRenameColumn command =\n+          new AlterTableRenameColumn(session, schema);\n+      command.setTableName(tableName);\n+      command.setIfTableExists(ifTableExists);\n+      command.setOldColumnName(columnName);\n+      command.setNewColumnName(newColumnName);\n+      return command;\n+    } else if (readIf(\"MODIFY\")) {\n+      // MySQL compatibility (optional)\n+      readIf(\"COLUMN\");\n+      // Oracle specifies (but will not require) an opening parenthesis\n+      boolean hasOpeningBracket = readIf(\"(\");\n+      String columnName = readColumnIdentifier();\n+      AlterTableAlterColumn command = null;\n+      NullConstraintType nullConstraint = parseNotNullConstraint();\n+      switch (nullConstraint) {\n+        case NULL_IS_ALLOWED:\n+        case NULL_IS_NOT_ALLOWED:\n+          command = new AlterTableAlterColumn(session, schema);\n+          command.setTableName(tableName);\n+          command.setIfTableExists(ifTableExists);\n+          Column column =\n+              columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+          command.setOldColumn(column);\n+          if (nullConstraint == NullConstraintType.NULL_IS_ALLOWED) {\n+            command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n+          } else {\n+            command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n+          }\n+          break;\n+        case NO_NULL_CONSTRAINT_FOUND:\n+          command =\n+              parseAlterTableAlterColumnType(schema, tableName, columnName,\n+                  ifTableExists);\n+          break;\n+        default:\n+          throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n+              \"Internal Error - unhandled case: \" + nullConstraint.name());\n+      }\n+      if (hasOpeningBracket) {\n+        read(\")\");\n+      }\n+      return command;\n+    } else if (readIf(\"ALTER\")) {\n+      readIf(\"COLUMN\");\n+      String columnName = readColumnIdentifier();\n+      Column column =\n+          columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+      if (readIf(\"RENAME\")) {\n+        read(\"TO\");\n+        AlterTableRenameColumn command = new AlterTableRenameColumn(\n+            session, schema);\n         command.setTableName(tableName);\n         command.setIfTableExists(ifTableExists);\n-        ArrayList<Column> columnsToAdd = New.arrayList();\n-        if (readIf(\"(\")) {\n-            command.setIfNotExists(false);\n-            do {\n-                String columnName = readColumnIdentifier();\n-                Column column = parseColumnForTable(columnName, true);\n-                columnsToAdd.add(column);\n-            } while (readIf(\",\"));\n-            read(\")\");\n-        } else {\n-            boolean ifNotExists = readIfNotExists();\n-            command.setIfNotExists(ifNotExists);\n-            String columnName = readColumnIdentifier();\n-            Column column = parseColumnForTable(columnName, true);\n-            columnsToAdd.add(column);\n-        }\n-        if (readIf(\"BEFORE\")) {\n-            command.setAddBefore(readColumnIdentifier());\n-        } else if (readIf(\"AFTER\")) {\n-            command.setAddAfter(readColumnIdentifier());\n-        }\n-        command.setNewColumns(columnsToAdd);\n+        command.setOldColumnName(columnName);\n+        String newName = readColumnIdentifier();\n+        command.setNewColumnName(newName);\n         return command;\n-    }\n-\n-    private ConstraintActionType parseAction() {\n-        ConstraintActionType result = parseCascadeOrRestrict();\n-        if (result != null) {\n-            return result;\n-        }\n-        if (readIf(\"NO\")) {\n-            read(\"ACTION\");\n-            return ConstraintActionType.RESTRICT;\n-        }\n-        read(\"SET\");\n-        if (readIf(\"NULL\")) {\n-            return ConstraintActionType.SET_NULL;\n-        }\n-        read(\"DEFAULT\");\n-        return ConstraintActionType.SET_DEFAULT;\n-    }\n-\n-    private ConstraintActionType parseCascadeOrRestrict() {\n-        if (readIf(\"CASCADE\")) {\n-            return ConstraintActionType.CASCADE;\n-        } else if (readIf(\"RESTRICT\")) {\n-            return ConstraintActionType.RESTRICT;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private DefineCommand parseAlterTableAddConstraintIf(String tableName,\n-            Schema schema, boolean ifTableExists) {\n-        String constraintName = null, comment = null;\n-        boolean ifNotExists = false;\n-        boolean allowIndexDefinition = database.getMode().indexDefinitionInCreateTable;\n-        boolean allowAffinityKey = database.getMode().allowAffinityKey;\n-        if (readIf(\"CONSTRAINT\")) {\n-            ifNotExists = readIfNotExists();\n-            constraintName = readIdentifierWithSchema(schema.getName());\n-            checkSchema(schema);\n-            comment = readCommentIf();\n-            allowIndexDefinition = true;\n-        }\n-        if (readIf(\"PRIMARY\")) {\n-            read(\"KEY\");\n-            AlterTableAddConstraint command = new AlterTableAddConstraint(\n-                    session, schema, ifNotExists);\n-            command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n-            command.setComment(comment);\n-            command.setConstraintName(constraintName);\n-            command.setTableName(tableName);\n-            command.setIfTableExists(ifTableExists);\n-            if (readIf(\"HASH\")) {\n-                command.setPrimaryKeyHash(true);\n-            }\n-            read(\"(\");\n-            command.setIndexColumns(parseIndexColumnList());\n-            if (readIf(\"INDEX\")) {\n-                String indexName = readIdentifierWithSchema();\n-                command.setIndex(getSchema().findIndex(session, indexName));\n-            }\n-            return command;\n-        } else if (allowIndexDefinition && (isToken(\"INDEX\") || isToken(\"KEY\"))) {\n-            // MySQL\n-            // need to read ahead, as it could be a column name\n-            int start = lastParseIndex;\n-            read();\n-            if (DataType.getTypeByName(currentToken, database.getMode()) != null) {\n-                // known data type\n-                parseIndex = start;\n-                read();\n-                return null;\n-            }\n-            CreateIndex command = new CreateIndex(session, schema);\n-            command.setComment(comment);\n-            command.setTableName(tableName);\n-            command.setIfTableExists(ifTableExists);\n-            if (!readIf(\"(\")) {\n-                command.setIndexName(readUniqueIdentifier());\n-                read(\"(\");\n-            }\n-            command.setIndexColumns(parseIndexColumnList());\n-            // MySQL compatibility\n-            if (readIf(\"USING\")) {\n-                read(\"BTREE\");\n-            }\n-            return command;\n-        } else if (allowAffinityKey && readIfAffinity()) {\n-            read(\"KEY\");\n-            read(\"(\");\n-            CreateIndex command = createAffinityIndex(schema, tableName, parseIndexColumnList());\n-            command.setIfTableExists(ifTableExists);\n-            return command;\n-        }\n-        AlterTableAddConstraint command;\n-        if (readIf(\"CHECK\")) {\n-            command = new AlterTableAddConstraint(session, schema, ifNotExists);\n-            command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_CHECK);\n-            command.setCheckExpression(readExpression());\n-        } else if (readIf(\"UNIQUE\")) {\n-            readIf(\"KEY\");\n-            readIf(\"INDEX\");\n-            command = new AlterTableAddConstraint(session, schema, ifNotExists);\n-            command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_UNIQUE);\n-            if (!readIf(\"(\")) {\n-                constraintName = readUniqueIdentifier();\n-                read(\"(\");\n-            }\n-            command.setIndexColumns(parseIndexColumnList());\n-            if (readIf(\"INDEX\")) {\n-                String indexName = readIdentifierWithSchema();\n-                command.setIndex(getSchema().findIndex(session, indexName));\n-            }\n-            // MySQL compatibility\n-            if (readIf(\"USING\")) {\n-                read(\"BTREE\");\n-            }\n-        } else if (readIf(\"FOREIGN\")) {\n-            command = new AlterTableAddConstraint(session, schema, ifNotExists);\n-            command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n-            read(\"KEY\");\n-            read(\"(\");\n-            command.setIndexColumns(parseIndexColumnList());\n-            if (readIf(\"INDEX\")) {\n-                String indexName = readIdentifierWithSchema();\n-                command.setIndex(schema.findIndex(session, indexName));\n-            }\n-            read(\"REFERENCES\");\n-            parseReferences(command, schema, tableName);\n-        } else {\n-            if (constraintName != null) {\n-                throw getSyntaxError();\n-            }\n-            return null;\n-        }\n-        if (readIf(\"NOCHECK\")) {\n-            command.setCheckExisting(false);\n-        } else {\n-            readIf(\"CHECK\");\n-            command.setCheckExisting(true);\n-        }\n+      } else if (readIf(\"DROP\")) {\n+        // PostgreSQL compatibility\n+        if (readIf(\"DEFAULT\")) {\n+          AlterTableAlterColumn command = new AlterTableAlterColumn(\n+              session, schema);\n+          command.setTableName(tableName);\n+          command.setIfTableExists(ifTableExists);\n+          command.setOldColumn(column);\n+          command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n+          command.setDefaultExpression(null);\n+          return command;\n+        }\n+        read(\"NOT\");\n+        read(\"NULL\");\n+        AlterTableAlterColumn command = new AlterTableAlterColumn(\n+            session, schema);\n         command.setTableName(tableName);\n         command.setIfTableExists(ifTableExists);\n-        command.setConstraintName(constraintName);\n-        command.setComment(comment);\n+        command.setOldColumn(column);\n+        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n         return command;\n-    }\n-\n-    private void parseReferences(AlterTableAddConstraint command,\n-            Schema schema, String tableName) {\n-        if (readIf(\"(\")) {\n-            command.setRefTableName(schema, tableName);\n-            command.setRefIndexColumns(parseIndexColumnList());\n-        } else {\n-            String refTableName = readIdentifierWithSchema(schema.getName());\n-            command.setRefTableName(getSchema(), refTableName);\n-            if (readIf(\"(\")) {\n-                command.setRefIndexColumns(parseIndexColumnList());\n-            }\n-        }\n-        if (readIf(\"INDEX\")) {\n-            String indexName = readIdentifierWithSchema();\n-            command.setRefIndex(getSchema().findIndex(session, indexName));\n-        }\n-        while (readIf(\"ON\")) {\n-            if (readIf(\"DELETE\")) {\n-                command.setDeleteAction(parseAction());\n-            } else {\n-                read(\"UPDATE\");\n-                command.setUpdateAction(parseAction());\n-            }\n-        }\n-        if (readIf(\"NOT\")) {\n-            read(\"DEFERRABLE\");\n-        } else {\n-            readIf(\"DEFERRABLE\");\n-        }\n-    }\n-\n-    private CreateLinkedTable parseCreateLinkedTable(boolean temp,\n-            boolean globalTemp, boolean force) {\n-        read(\"TABLE\");\n-        boolean ifNotExists = readIfNotExists();\n-        String tableName = readIdentifierWithSchema();\n-        CreateLinkedTable command = new CreateLinkedTable(session, getSchema());\n-        command.setTemporary(temp);\n-        command.setGlobalTemporary(globalTemp);\n-        command.setForce(force);\n-        command.setIfNotExists(ifNotExists);\n+      } else if (readIf(\"TYPE\")) {\n+        // PostgreSQL compatibility\n+        return parseAlterTableAlterColumnType(schema, tableName,\n+            columnName, ifTableExists);\n+      } else if (readIf(\"SET\")) {\n+        if (readIf(\"DATA\")) {\n+          // Derby compatibility\n+          read(\"TYPE\");\n+          return parseAlterTableAlterColumnType(schema, tableName, columnName,\n+              ifTableExists);\n+        }\n+        AlterTableAlterColumn command = new AlterTableAlterColumn(\n+            session, schema);\n         command.setTableName(tableName);\n-        command.setComment(readCommentIf());\n-        read(\"(\");\n-        command.setDriver(readString());\n-        read(\",\");\n-        command.setUrl(readString());\n-        read(\",\");\n-        command.setUser(readString());\n-        read(\",\");\n-        command.setPassword(readString());\n-        read(\",\");\n-        String originalTable = readString();\n-        if (readIf(\",\")) {\n-            command.setOriginalSchema(originalTable);\n-            originalTable = readString();\n-        }\n-        command.setOriginalTable(originalTable);\n-        read(\")\");\n-        if (readIf(\"EMIT\")) {\n-            read(\"UPDATES\");\n-            command.setEmitUpdates(true);\n-        } else if (readIf(\"READONLY\")) {\n-            command.setReadOnly(true);\n+        command.setIfTableExists(ifTableExists);\n+        command.setOldColumn(column);\n+        NullConstraintType nullConstraint = parseNotNullConstraint();\n+        switch (nullConstraint) {\n+          case NULL_IS_ALLOWED:\n+            command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n+            break;\n+          case NULL_IS_NOT_ALLOWED:\n+            command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n+            break;\n+          case NO_NULL_CONSTRAINT_FOUND:\n+            if (readIf(\"DEFAULT\")) {\n+              Expression defaultExpression = readExpression();\n+              command\n+                  .setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n+              command.setDefaultExpression(defaultExpression);\n+\n+            } else if (readIf(\"INVISIBLE\")) {\n+              command.setType(\n+                  CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n+              command.setVisible(false);\n+\n+            } else if (readIf(\"VISIBLE\")) {\n+              command.setType(\n+                  CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n+              command.setVisible(true);\n+            }\n+            break;\n+          default:\n+            throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n+                \"Internal Error - unhandled case: \" + nullConstraint.name());\n         }\n         return command;\n-    }\n-\n-    private CreateTable parseCreateTable(boolean temp, boolean globalTemp,\n-            boolean persistIndexes) {\n-        boolean ifNotExists = readIfNotExists();\n-        String tableName = readIdentifierWithSchema();\n-        if (temp && globalTemp && equalsToken(\"SESSION\", schemaName)) {\n-            // support weird syntax: declare global temporary table session.xy\n-            // (...) not logged\n-            schemaName = session.getCurrentSchemaName();\n-            globalTemp = false;\n-        }\n-        Schema schema = getSchema();\n-        CreateTable command = new CreateTable(session, schema);\n-        command.setPersistIndexes(persistIndexes);\n-        command.setTemporary(temp);\n-        command.setGlobalTemporary(globalTemp);\n-        command.setIfNotExists(ifNotExists);\n+      } else if (readIf(\"RESTART\")) {\n+        readIf(\"WITH\");\n+        Expression start = readExpression();\n+        AlterSequence command = new AlterSequence(session, schema);\n+        command.setColumn(column);\n+        command.setStartWith(start);\n+        return commandIfTableExists(schema, tableName, ifTableExists, command);\n+      } else if (readIf(\"SELECTIVITY\")) {\n+        AlterTableAlterColumn command = new AlterTableAlterColumn(\n+            session, schema);\n         command.setTableName(tableName);\n-        command.setComment(readCommentIf());\n-        if (readIf(\"(\")) {\n-            if (!readIf(\")\")) {\n-                do {\n-                    DefineCommand c = parseAlterTableAddConstraintIf(tableName,\n-                            schema, false);\n-                    if (c != null) {\n-                        command.addConstraintCommand(c);\n-                    } else {\n-                        String columnName = readColumnIdentifier();\n-                        Column column = parseColumnForTable(columnName, true);\n-                        if (column.isAutoIncrement() && column.isPrimaryKey()) {\n-                            column.setPrimaryKey(false);\n-                            IndexColumn[] cols = { new IndexColumn() };\n-                            cols[0].columnName = column.getName();\n-                            AlterTableAddConstraint pk = new AlterTableAddConstraint(\n-                                    session, schema, false);\n-                            pk.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n-                            pk.setTableName(tableName);\n-                            pk.setIndexColumns(cols);\n-                            command.addConstraintCommand(pk);\n-                        }\n-                        command.addColumn(column);\n-                        String constraintName = null;\n-                        if (readIf(\"CONSTRAINT\")) {\n-                            constraintName = readColumnIdentifier();\n-                        }\n-                        // For compatibility with Apache Ignite.\n-                        boolean allowAffinityKey = database.getMode().allowAffinityKey;\n-                        boolean affinity = allowAffinityKey && readIfAffinity();\n-                        if (readIf(\"PRIMARY\")) {\n-                            read(\"KEY\");\n-                            boolean hash = readIf(\"HASH\");\n-                            IndexColumn[] cols = { new IndexColumn() };\n-                            cols[0].columnName = column.getName();\n-                            AlterTableAddConstraint pk = new AlterTableAddConstraint(\n-                                    session, schema, false);\n-                            pk.setPrimaryKeyHash(hash);\n-                            pk.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n-                            pk.setTableName(tableName);\n-                            pk.setIndexColumns(cols);\n-                            command.addConstraintCommand(pk);\n-                            if (readIf(\"AUTO_INCREMENT\")) {\n-                                parseAutoIncrement(column);\n-                            }\n-                            if (affinity) {\n-                                CreateIndex idx = createAffinityIndex(schema, tableName, cols);\n-                                command.addConstraintCommand(idx);\n-                            }\n-                        } else if (affinity) {\n-                            read(\"KEY\");\n-                            IndexColumn[] cols = { new IndexColumn() };\n-                            cols[0].columnName = column.getName();\n-                            CreateIndex idx = createAffinityIndex(schema, tableName, cols);\n-                            command.addConstraintCommand(idx);\n-                        } else if (readIf(\"UNIQUE\")) {\n-                            AlterTableAddConstraint unique = new AlterTableAddConstraint(\n-                                    session, schema, false);\n-                            unique.setConstraintName(constraintName);\n-                            unique.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_UNIQUE);\n-                            IndexColumn[] cols = { new IndexColumn() };\n-                            cols[0].columnName = columnName;\n-                            unique.setIndexColumns(cols);\n-                            unique.setTableName(tableName);\n-                            command.addConstraintCommand(unique);\n-                        }\n-                        if (NullConstraintType.NULL_IS_NOT_ALLOWED == parseNotNullConstraint()) {\n-                            column.setNullable(false);\n-                        }\n-                        if (readIf(\"CHECK\")) {\n-                            Expression expr = readExpression();\n-                            column.addCheckConstraint(session, expr);\n-                        }\n-                        if (readIf(\"REFERENCES\")) {\n-                            AlterTableAddConstraint ref = new AlterTableAddConstraint(\n-                                    session, schema, false);\n-                            ref.setConstraintName(constraintName);\n-                            ref.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n-                            IndexColumn[] cols = { new IndexColumn() };\n-                            cols[0].columnName = columnName;\n-                            ref.setIndexColumns(cols);\n-                            ref.setTableName(tableName);\n-                            parseReferences(ref, schema, tableName);\n-                            command.addConstraintCommand(ref);\n-                        }\n-                    }\n-                } while (readIfMore());\n-            }\n-        }\n-        // Allows \"COMMENT='comment'\" in DDL statements (MySQL syntax)\n-        if (readIf(\"COMMENT\")) {\n-            if (readIf(\"=\")) {\n-                // read the complete string comment, but nothing with it for now\n-                readString();\n-            }\n-        }\n-        if (readIf(\"ENGINE\")) {\n-            if (readIf(\"=\")) {\n-                // map MySQL engine types onto H2 behavior\n-                String tableEngine = readUniqueIdentifier();\n-                if (\"InnoDb\".equalsIgnoreCase(tableEngine)) {\n-                    // ok\n-                } else if (!\"MyISAM\".equalsIgnoreCase(tableEngine)) {\n-                    throw DbException.getUnsupportedException(tableEngine);\n-                }\n-            } else {\n-                command.setTableEngine(readUniqueIdentifier());\n-            }\n-        }\n-        if (readIf(\"WITH\")) {\n-            command.setTableEngineParams(readTableEngineParams());\n-        }\n-        // MySQL compatibility\n-        if (readIf(\"AUTO_INCREMENT\")) {\n-            read(\"=\");\n-            if (currentTokenType != VALUE ||\n-                    currentValue.getType() != Value.INT) {\n-                throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                        \"integer\");\n-            }\n-            read();\n-        }\n-        readIf(\"DEFAULT\");\n-        if (readIf(\"CHARSET\")) {\n-            read(\"=\");\n-            if (!readIf(\"UTF8\")) {\n-                read(\"UTF8MB4\");\n-            }\n-        }\n-        if (temp) {\n-            if (readIf(\"ON\")) {\n-                read(\"COMMIT\");\n-                if (readIf(\"DROP\")) {\n-                    command.setOnCommitDrop();\n-                } else if (readIf(\"DELETE\")) {\n-                    read(\"ROWS\");\n-                    command.setOnCommitTruncate();\n-                }\n-            } else if (readIf(\"NOT\")) {\n-                if (readIf(\"PERSISTENT\")) {\n-                    command.setPersistData(false);\n-                } else {\n-                    read(\"LOGGED\");\n-                }\n-            }\n-            if (readIf(\"TRANSACTIONAL\")) {\n-                command.setTransactional(true);\n-            }\n-        } else if (!persistIndexes && readIf(\"NOT\")) {\n-            read(\"PERSISTENT\");\n-            command.setPersistData(false);\n-        }\n-        if (readIf(\"HIDDEN\")) {\n-            command.setHidden(true);\n-        }\n-        if (readIf(\"AS\")) {\n-            if (readIf(\"SORTED\")) {\n-                command.setSortedInsertMode(true);\n-            }\n-            command.setQuery(parseSelect());\n-        }\n-        // for MySQL compatibility\n-        if (readIf(\"ROW_FORMAT\")) {\n-            if (readIf(\"=\")) {\n-                readColumnIdentifier();\n-            }\n-        }\n+        command.setIfTableExists(ifTableExists);\n+        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_SELECTIVITY);\n+        command.setOldColumn(column);\n+        command.setSelectivity(readExpression());\n         return command;\n-    }\n-\n-    /**\n-     * Enumeration describing null constraints\n-     */\n-    private enum NullConstraintType {\n-        NULL_IS_ALLOWED, NULL_IS_NOT_ALLOWED, NO_NULL_CONSTRAINT_FOUND\n-    }\n-\n-    private NullConstraintType parseNotNullConstraint() {\n-        NullConstraintType nullConstraint = NullConstraintType.NO_NULL_CONSTRAINT_FOUND;\n-        if (isToken(\"NOT\") || isToken(\"NULL\")) {\n-            if (readIf(\"NOT\")) {\n-                read(\"NULL\");\n-                nullConstraint = NullConstraintType.NULL_IS_NOT_ALLOWED;\n-            } else {\n-                read(\"NULL\");\n-                nullConstraint = NullConstraintType.NULL_IS_ALLOWED;\n+      } else {\n+        return parseAlterTableAlterColumnType(schema, tableName,\n+            columnName, ifTableExists);\n+      }\n+    }\n+    throw getSyntaxError();\n+  }\n+\n+  private Table tableIfTableExists(Schema schema, String tableName,\n+                                   boolean ifTableExists) {\n+    Table table = schema.resolveTableOrView(session, tableName);\n+    if (table == null && !ifTableExists) {\n+      throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, tableName);\n+    }\n+    return table;\n+  }\n+\n+  private Column columnIfTableExists(Schema schema, String tableName,\n+                                     String columnName, boolean ifTableExists) {\n+    Table table = tableIfTableExists(schema, tableName, ifTableExists);\n+    return table == null ? null : table.getColumn(columnName);\n+  }\n+\n+  private Prepared commandIfTableExists(Schema schema, String tableName,\n+                                        boolean ifTableExists,\n+                                        Prepared commandIfTableExists) {\n+    return tableIfTableExists(schema, tableName, ifTableExists) == null\n+        ? new NoOperation(session)\n+        : commandIfTableExists;\n+  }\n+\n+  private AlterTableAlterColumn parseAlterTableAlterColumnType(Schema schema,\n+                                                               String tableName,\n+                                                               String columnName,\n+                                                               boolean ifTableExists) {\n+    Column oldColumn =\n+        columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+    Column newColumn = parseColumnForTable(columnName,\n+        oldColumn == null ? true : oldColumn.isNullable());\n+    AlterTableAlterColumn command = new AlterTableAlterColumn(session,\n+        schema);\n+    command.setTableName(tableName);\n+    command.setIfTableExists(ifTableExists);\n+    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_CHANGE_TYPE);\n+    command.setOldColumn(oldColumn);\n+    command.setNewColumn(newColumn);\n+    return command;\n+  }\n+\n+  private AlterTableAlterColumn parseAlterTableAddColumn(String tableName,\n+                                                         Schema schema,\n+                                                         boolean ifTableExists) {\n+    readIf(\"COLUMN\");\n+    AlterTableAlterColumn command = new AlterTableAlterColumn(session,\n+        schema);\n+    command.setType(CommandInterface.ALTER_TABLE_ADD_COLUMN);\n+    command.setTableName(tableName);\n+    command.setIfTableExists(ifTableExists);\n+    ArrayList<Column> columnsToAdd = New.arrayList();\n+    if (readIf(\"(\")) {\n+      command.setIfNotExists(false);\n+      do {\n+        String columnName = readColumnIdentifier();\n+        Column column = parseColumnForTable(columnName, true);\n+        columnsToAdd.add(column);\n+      } while (readIf(\",\"));\n+      read(\")\");\n+    } else {\n+      boolean ifNotExists = readIfNotExists();\n+      command.setIfNotExists(ifNotExists);\n+      String columnName = readColumnIdentifier();\n+      Column column = parseColumnForTable(columnName, true);\n+      columnsToAdd.add(column);\n+    }\n+    if (readIf(\"BEFORE\")) {\n+      command.setAddBefore(readColumnIdentifier());\n+    } else if (readIf(\"AFTER\")) {\n+      command.setAddAfter(readColumnIdentifier());\n+    }\n+    command.setNewColumns(columnsToAdd);\n+    return command;\n+  }\n+\n+  private ConstraintActionType parseAction() {\n+    ConstraintActionType result = parseCascadeOrRestrict();\n+    if (result != null) {\n+      return result;\n+    }\n+    if (readIf(\"NO\")) {\n+      read(\"ACTION\");\n+      return ConstraintActionType.RESTRICT;\n+    }\n+    read(\"SET\");\n+    if (readIf(\"NULL\")) {\n+      return ConstraintActionType.SET_NULL;\n+    }\n+    read(\"DEFAULT\");\n+    return ConstraintActionType.SET_DEFAULT;\n+  }\n+\n+  private ConstraintActionType parseCascadeOrRestrict() {\n+    if (readIf(\"CASCADE\")) {\n+      return ConstraintActionType.CASCADE;\n+    } else if (readIf(\"RESTRICT\")) {\n+      return ConstraintActionType.RESTRICT;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private DefineCommand parseAlterTableAddConstraintIf(String tableName,\n+                                                       Schema schema,\n+                                                       boolean ifTableExists) {\n+    String constraintName = null, comment = null;\n+    boolean ifNotExists = false;\n+    boolean allowIndexDefinition =\n+        database.getMode().indexDefinitionInCreateTable;\n+    boolean allowAffinityKey = database.getMode().allowAffinityKey;\n+    if (readIf(\"CONSTRAINT\")) {\n+      ifNotExists = readIfNotExists();\n+      constraintName = readIdentifierWithSchema(schema.getName());\n+      checkSchema(schema);\n+      comment = readCommentIf();\n+      allowIndexDefinition = true;\n+    }\n+    if (readIf(\"PRIMARY\")) {\n+      read(\"KEY\");\n+      AlterTableAddConstraint command = new AlterTableAddConstraint(\n+          session, schema, ifNotExists);\n+      command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n+      command.setComment(comment);\n+      command.setConstraintName(constraintName);\n+      command.setTableName(tableName);\n+      command.setIfTableExists(ifTableExists);\n+      if (readIf(\"HASH\")) {\n+        command.setPrimaryKeyHash(true);\n+      }\n+      read(\"(\");\n+      command.setIndexColumns(parseIndexColumnList());\n+      if (readIf(\"INDEX\")) {\n+        String indexName = readIdentifierWithSchema();\n+        command.setIndex(getSchema().findIndex(session, indexName));\n+      }\n+      return command;\n+    } else if (allowIndexDefinition && (isToken(\"INDEX\") || isToken(\"KEY\"))) {\n+      // MySQL\n+      // need to read ahead, as it could be a column name\n+      int start = lastParseIndex;\n+      read();\n+      if (DataType.getTypeByName(currentToken, database.getMode()) != null) {\n+        // known data type\n+        parseIndex = start;\n+        read();\n+        return null;\n+      }\n+      CreateIndex command = new CreateIndex(session, schema);\n+      command.setComment(comment);\n+      command.setTableName(tableName);\n+      command.setIfTableExists(ifTableExists);\n+      if (!readIf(\"(\")) {\n+        command.setIndexName(readUniqueIdentifier());\n+        read(\"(\");\n+      }\n+      command.setIndexColumns(parseIndexColumnList());\n+      // MySQL compatibility\n+      if (readIf(\"USING\")) {\n+        read(\"BTREE\");\n+      }\n+      return command;\n+    } else if (allowAffinityKey && readIfAffinity()) {\n+      read(\"KEY\");\n+      read(\"(\");\n+      CreateIndex command =\n+          createAffinityIndex(schema, tableName, parseIndexColumnList());\n+      command.setIfTableExists(ifTableExists);\n+      return command;\n+    }\n+    AlterTableAddConstraint command;\n+    if (readIf(\"CHECK\")) {\n+      command = new AlterTableAddConstraint(session, schema, ifNotExists);\n+      command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_CHECK);\n+      command.setCheckExpression(readExpression());\n+    } else if (readIf(\"UNIQUE\")) {\n+      readIf(\"KEY\");\n+      readIf(\"INDEX\");\n+      command = new AlterTableAddConstraint(session, schema, ifNotExists);\n+      command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_UNIQUE);\n+      if (!readIf(\"(\")) {\n+        constraintName = readUniqueIdentifier();\n+        read(\"(\");\n+      }\n+      command.setIndexColumns(parseIndexColumnList());\n+      if (readIf(\"INDEX\")) {\n+        String indexName = readIdentifierWithSchema();\n+        command.setIndex(getSchema().findIndex(session, indexName));\n+      }\n+      // MySQL compatibility\n+      if (readIf(\"USING\")) {\n+        read(\"BTREE\");\n+      }\n+    } else if (readIf(\"FOREIGN\")) {\n+      command = new AlterTableAddConstraint(session, schema, ifNotExists);\n+      command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n+      read(\"KEY\");\n+      read(\"(\");\n+      command.setIndexColumns(parseIndexColumnList());\n+      if (readIf(\"INDEX\")) {\n+        String indexName = readIdentifierWithSchema();\n+        command.setIndex(schema.findIndex(session, indexName));\n+      }\n+      read(\"REFERENCES\");\n+      parseReferences(command, schema, tableName);\n+    } else {\n+      if (constraintName != null) {\n+        throw getSyntaxError();\n+      }\n+      return null;\n+    }\n+    if (readIf(\"NOCHECK\")) {\n+      command.setCheckExisting(false);\n+    } else {\n+      readIf(\"CHECK\");\n+      command.setCheckExisting(true);\n+    }\n+    command.setTableName(tableName);\n+    command.setIfTableExists(ifTableExists);\n+    command.setConstraintName(constraintName);\n+    command.setComment(comment);\n+    return command;\n+  }\n+\n+  private void parseReferences(AlterTableAddConstraint command,\n+                               Schema schema, String tableName) {\n+    if (readIf(\"(\")) {\n+      command.setRefTableName(schema, tableName);\n+      command.setRefIndexColumns(parseIndexColumnList());\n+    } else {\n+      String refTableName = readIdentifierWithSchema(schema.getName());\n+      command.setRefTableName(getSchema(), refTableName);\n+      if (readIf(\"(\")) {\n+        command.setRefIndexColumns(parseIndexColumnList());\n+      }\n+    }\n+    if (readIf(\"INDEX\")) {\n+      String indexName = readIdentifierWithSchema();\n+      command.setRefIndex(getSchema().findIndex(session, indexName));\n+    }\n+    while (readIf(\"ON\")) {\n+      if (readIf(\"DELETE\")) {\n+        command.setDeleteAction(parseAction());\n+      } else {\n+        read(\"UPDATE\");\n+        command.setUpdateAction(parseAction());\n+      }\n+    }\n+    if (readIf(\"NOT\")) {\n+      read(\"DEFERRABLE\");\n+    } else {\n+      readIf(\"DEFERRABLE\");\n+    }\n+  }\n+\n+  private CreateLinkedTable parseCreateLinkedTable(boolean temp,\n+                                                   boolean globalTemp,\n+                                                   boolean force) {\n+    read(\"TABLE\");\n+    boolean ifNotExists = readIfNotExists();\n+    String tableName = readIdentifierWithSchema();\n+    CreateLinkedTable command = new CreateLinkedTable(session, getSchema());\n+    command.setTemporary(temp);\n+    command.setGlobalTemporary(globalTemp);\n+    command.setForce(force);\n+    command.setIfNotExists(ifNotExists);\n+    command.setTableName(tableName);\n+    command.setComment(readCommentIf());\n+    read(\"(\");\n+    command.setDriver(readString());\n+    read(\",\");\n+    command.setUrl(readString());\n+    read(\",\");\n+    command.setUser(readString());\n+    read(\",\");\n+    command.setPassword(readString());\n+    read(\",\");\n+    String originalTable = readString();\n+    if (readIf(\",\")) {\n+      command.setOriginalSchema(originalTable);\n+      originalTable = readString();\n+    }\n+    command.setOriginalTable(originalTable);\n+    read(\")\");\n+    if (readIf(\"EMIT\")) {\n+      read(\"UPDATES\");\n+      command.setEmitUpdates(true);\n+    } else if (readIf(\"READONLY\")) {\n+      command.setReadOnly(true);\n+    }\n+    return command;\n+  }\n+\n+  private CreateTable parseCreateTable(boolean temp, boolean globalTemp,\n+                                       boolean persistIndexes) {\n+    boolean ifNotExists = readIfNotExists();\n+    String tableName = readIdentifierWithSchema();\n+    if (temp && globalTemp && equalsToken(\"SESSION\", schemaName)) {\n+      // support weird syntax: declare global temporary table session.xy\n+      // (...) not logged\n+      schemaName = session.getCurrentSchemaName();\n+      globalTemp = false;\n+    }\n+    Schema schema = getSchema();\n+    CreateTable command = new CreateTable(session, schema);\n+    command.setPersistIndexes(persistIndexes);\n+    command.setTemporary(temp);\n+    command.setGlobalTemporary(globalTemp);\n+    command.setIfNotExists(ifNotExists);\n+    command.setTableName(tableName);\n+    command.setComment(readCommentIf());\n+    if (readIf(\"(\")) {\n+      if (!readIf(\")\")) {\n+        do {\n+          DefineCommand c = parseAlterTableAddConstraintIf(tableName,\n+              schema, false);\n+          if (c != null) {\n+            command.addConstraintCommand(c);\n+          } else {\n+            String columnName = readColumnIdentifier();\n+            Column column = parseColumnForTable(columnName, true);\n+            if (column.isAutoIncrement() && column.isPrimaryKey()) {\n+              column.setPrimaryKey(false);\n+              IndexColumn[] cols = {new IndexColumn()};\n+              cols[0].columnName = column.getName();\n+              AlterTableAddConstraint pk = new AlterTableAddConstraint(\n+                  session, schema, false);\n+              pk.setType(\n+                  CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n+              pk.setTableName(tableName);\n+              pk.setIndexColumns(cols);\n+              command.addConstraintCommand(pk);\n+            }\n+            command.addColumn(column);\n+            String constraintName = null;\n+            if (readIf(\"CONSTRAINT\")) {\n+              constraintName = readColumnIdentifier();\n             }\n-            if (database.getMode().getEnum() == ModeEnum.Oracle) {\n-                if (readIf(\"ENABLE\")) {\n-                    // Leave constraint 'as is'\n-                    readIf(\"VALIDATE\");\n-                    // Turn off constraint, allow NULLs\n-                    if (readIf(\"NOVALIDATE\")) {\n-                        nullConstraint = NullConstraintType.NULL_IS_ALLOWED;\n-                    }\n-                }\n-                // Turn off constraint, allow NULLs\n-                if (readIf(\"DISABLE\")) {\n-                    nullConstraint = NullConstraintType.NULL_IS_ALLOWED;\n-                    // ignore validate\n-                    readIf(\"VALIDATE\");\n-                    // ignore novalidate\n-                    readIf(\"NOVALIDATE\");\n-                }\n+            // For compatibility with Apache Ignite.\n+            boolean allowAffinityKey = database.getMode().allowAffinityKey;\n+            boolean affinity = allowAffinityKey && readIfAffinity();\n+            if (readIf(\"PRIMARY\")) {\n+              read(\"KEY\");\n+              boolean hash = readIf(\"HASH\");\n+              IndexColumn[] cols = {new IndexColumn()};\n+              cols[0].columnName = column.getName();\n+              AlterTableAddConstraint pk = new AlterTableAddConstraint(\n+                  session, schema, false);\n+              pk.setPrimaryKeyHash(hash);\n+              pk.setType(\n+                  CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n+              pk.setTableName(tableName);\n+              pk.setIndexColumns(cols);\n+              command.addConstraintCommand(pk);\n+              if (readIf(\"AUTO_INCREMENT\")) {\n+                parseAutoIncrement(column);\n+              }\n+              if (affinity) {\n+                CreateIndex idx = createAffinityIndex(schema, tableName, cols);\n+                command.addConstraintCommand(idx);\n+              }\n+            } else if (affinity) {\n+              read(\"KEY\");\n+              IndexColumn[] cols = {new IndexColumn()};\n+              cols[0].columnName = column.getName();\n+              CreateIndex idx = createAffinityIndex(schema, tableName, cols);\n+              command.addConstraintCommand(idx);\n+            } else if (readIf(\"UNIQUE\")) {\n+              AlterTableAddConstraint unique = new AlterTableAddConstraint(\n+                  session, schema, false);\n+              unique.setConstraintName(constraintName);\n+              unique\n+                  .setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_UNIQUE);\n+              IndexColumn[] cols = {new IndexColumn()};\n+              cols[0].columnName = columnName;\n+              unique.setIndexColumns(cols);\n+              unique.setTableName(tableName);\n+              command.addConstraintCommand(unique);\n+            }\n+            if (NullConstraintType.NULL_IS_NOT_ALLOWED ==\n+                parseNotNullConstraint()) {\n+              column.setNullable(false);\n             }\n+            if (readIf(\"CHECK\")) {\n+              Expression expr = readExpression();\n+              column.addCheckConstraint(session, expr);\n+            }\n+            if (readIf(\"REFERENCES\")) {\n+              AlterTableAddConstraint ref = new AlterTableAddConstraint(\n+                  session, schema, false);\n+              ref.setConstraintName(constraintName);\n+              ref.setType(\n+                  CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n+              IndexColumn[] cols = {new IndexColumn()};\n+              cols[0].columnName = columnName;\n+              ref.setIndexColumns(cols);\n+              ref.setTableName(tableName);\n+              parseReferences(ref, schema, tableName);\n+              command.addConstraintCommand(ref);\n+            }\n+          }\n+        } while (readIfMore());\n+      }\n+    }\n+    // Allows \"COMMENT='comment'\" in DDL statements (MySQL syntax)\n+    if (readIf(\"COMMENT\")) {\n+      if (readIf(\"=\")) {\n+        // read the complete string comment, but nothing with it for now\n+        readString();\n+      }\n+    }\n+    if (readIf(\"ENGINE\")) {\n+      if (readIf(\"=\")) {\n+        // map MySQL engine types onto H2 behavior\n+        String tableEngine = readUniqueIdentifier();\n+        if (\"InnoDb\".equalsIgnoreCase(tableEngine)) {\n+          // ok\n+        } else if (!\"MyISAM\".equalsIgnoreCase(tableEngine)) {\n+          throw DbException.getUnsupportedException(tableEngine);\n+        }\n+      } else {\n+        command.setTableEngine(readUniqueIdentifier());\n+      }\n+    }\n+    if (readIf(\"WITH\")) {\n+      command.setTableEngineParams(readTableEngineParams());\n+    }\n+    // MySQL compatibility\n+    if (readIf(\"AUTO_INCREMENT\")) {\n+      read(\"=\");\n+      if (currentTokenType != VALUE ||\n+          currentValue.getType() != Value.INT) {\n+        throw DbException.getSyntaxError(sqlCommand, parseIndex,\n+            \"integer\");\n+      }\n+      read();\n+    }\n+    readIf(\"DEFAULT\");\n+    if (readIf(\"CHARSET\")) {\n+      read(\"=\");\n+      if (!readIf(\"UTF8\")) {\n+        read(\"UTF8MB4\");\n+      }\n+    }\n+    if (temp) {\n+      if (readIf(\"ON\")) {\n+        read(\"COMMIT\");\n+        if (readIf(\"DROP\")) {\n+          command.setOnCommitDrop();\n+        } else if (readIf(\"DELETE\")) {\n+          read(\"ROWS\");\n+          command.setOnCommitTruncate();\n         }\n-        return nullConstraint;\n-    }\n-\n-    private CreateSynonym parseCreateSynonym(boolean orReplace) {\n-        boolean ifNotExists = readIfNotExists();\n-        String name = readIdentifierWithSchema();\n-        Schema synonymSchema = getSchema();\n-        read(\"FOR\");\n-        String tableName = readIdentifierWithSchema();\n-\n-        Schema targetSchema = getSchema();\n-        CreateSynonym command = new CreateSynonym(session, synonymSchema);\n-        command.setName(name);\n-        command.setSynonymFor(tableName);\n-        command.setSynonymForSchema(targetSchema);\n-        command.setComment(readCommentIf());\n-        command.setIfNotExists(ifNotExists);\n-        command.setOrReplace(orReplace);\n-        return command;\n-    }\n-\n-    private CreateIndex createAffinityIndex(Schema schema, String tableName, IndexColumn[] indexColumns) {\n-        CreateIndex idx = new CreateIndex(session, schema);\n-        idx.setTableName(tableName);\n-        idx.setIndexColumns(indexColumns);\n-        idx.setAffinity(true);\n-        return idx;\n-    }\n-\n-    private static int getCompareType(int tokenType) {\n-        switch (tokenType) {\n-        case EQUAL:\n-            return Comparison.EQUAL;\n-        case BIGGER_EQUAL:\n-            return Comparison.BIGGER_EQUAL;\n-        case BIGGER:\n-            return Comparison.BIGGER;\n-        case SMALLER:\n-            return Comparison.SMALLER;\n-        case SMALLER_EQUAL:\n-            return Comparison.SMALLER_EQUAL;\n-        case NOT_EQUAL:\n-            return Comparison.NOT_EQUAL;\n-        case SPATIAL_INTERSECTS:\n-            return Comparison.SPATIAL_INTERSECTS;\n-        default:\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * Add double quotes around an identifier if required.\n-     *\n-     * @param s the identifier\n-     * @return the quoted identifier\n-     */\n-    public static String quoteIdentifier(String s) {\n-        if (s == null) {\n-            return \"\\\"\\\"\";\n-        }\n-        if (ParserUtil.isSimpleIdentifier(s, false)) {\n-            return s;\n-        }\n-        return StringUtils.quoteIdentifier(s);\n-    }\n-\n-    public void setLiteralsChecked(boolean literalsChecked) {\n-        this.literalsChecked = literalsChecked;\n-    }\n-\n-    public void setRightsChecked(boolean rightsChecked) {\n-        this.rightsChecked = rightsChecked;\n-    }\n-\n-    public void setSuppliedParameterList(ArrayList<Parameter> suppliedParameterList) {\n-        this.suppliedParameterList = suppliedParameterList;\n-    }\n-\n-    /**\n-     * Parse a SQL code snippet that represents an expression.\n-     *\n-     * @param sql the code snippet\n-     * @return the expression object\n-     */\n-    public Expression parseExpression(String sql) {\n-        parameters = New.arrayList();\n-        initialize(sql);\n-        read();\n-        return readExpression();\n-    }\n-\n-    /**\n-     * Parse a SQL code snippet that represents a table name.\n-     *\n-     * @param sql the code snippet\n-     * @return the table object\n-     */\n-    public Table parseTableName(String sql) {\n-        parameters = New.arrayList();\n-        initialize(sql);\n-        read();\n-        return readTableOrView();\n-    }\n+      } else if (readIf(\"NOT\")) {\n+        if (readIf(\"PERSISTENT\")) {\n+          command.setPersistData(false);\n+        } else {\n+          read(\"LOGGED\");\n+        }\n+      }\n+      if (readIf(\"TRANSACTIONAL\")) {\n+        command.setTransactional(true);\n+      }\n+    } else if (!persistIndexes && readIf(\"NOT\")) {\n+      read(\"PERSISTENT\");\n+      command.setPersistData(false);\n+    }\n+    if (readIf(\"HIDDEN\")) {\n+      command.setHidden(true);\n+    }\n+    if (readIf(\"AS\")) {\n+      if (readIf(\"SORTED\")) {\n+        command.setSortedInsertMode(true);\n+      }\n+      command.setQuery(parseSelect());\n+    }\n+    // for MySQL compatibility\n+    if (readIf(\"ROW_FORMAT\")) {\n+      if (readIf(\"=\")) {\n+        readColumnIdentifier();\n+      }\n+    }\n+    return command;\n+  }\n+\n+  /**\n+   * Enumeration describing null constraints\n+   */\n+  private enum NullConstraintType {\n+    NULL_IS_ALLOWED, NULL_IS_NOT_ALLOWED, NO_NULL_CONSTRAINT_FOUND\n+  }\n+\n+  private NullConstraintType parseNotNullConstraint() {\n+    NullConstraintType nullConstraint =\n+        NullConstraintType.NO_NULL_CONSTRAINT_FOUND;\n+    if (isToken(\"NOT\") || isToken(\"NULL\")) {\n+      if (readIf(\"NOT\")) {\n+        read(\"NULL\");\n+        nullConstraint = NullConstraintType.NULL_IS_NOT_ALLOWED;\n+      } else {\n+        read(\"NULL\");\n+        nullConstraint = NullConstraintType.NULL_IS_ALLOWED;\n+      }\n+      if (database.getMode().getEnum() == ModeEnum.Oracle) {\n+        if (readIf(\"ENABLE\")) {\n+          // Leave constraint 'as is'\n+          readIf(\"VALIDATE\");\n+          // Turn off constraint, allow NULLs\n+          if (readIf(\"NOVALIDATE\")) {\n+            nullConstraint = NullConstraintType.NULL_IS_ALLOWED;\n+          }\n+        }\n+        // Turn off constraint, allow NULLs\n+        if (readIf(\"DISABLE\")) {\n+          nullConstraint = NullConstraintType.NULL_IS_ALLOWED;\n+          // ignore validate\n+          readIf(\"VALIDATE\");\n+          // ignore novalidate\n+          readIf(\"NOVALIDATE\");\n+        }\n+      }\n+    }\n+    return nullConstraint;\n+  }\n+\n+  private CreateSynonym parseCreateSynonym(boolean orReplace) {\n+    boolean ifNotExists = readIfNotExists();\n+    String name = readIdentifierWithSchema();\n+    Schema synonymSchema = getSchema();\n+    read(\"FOR\");\n+    String tableName = readIdentifierWithSchema();\n+\n+    Schema targetSchema = getSchema();\n+    CreateSynonym command = new CreateSynonym(session, synonymSchema);\n+    command.setName(name);\n+    command.setSynonymFor(tableName);\n+    command.setSynonymForSchema(targetSchema);\n+    command.setComment(readCommentIf());\n+    command.setIfNotExists(ifNotExists);\n+    command.setOrReplace(orReplace);\n+    return command;\n+  }\n+\n+  private CreateIndex createAffinityIndex(Schema schema, String tableName,\n+                                          IndexColumn[] indexColumns) {\n+    CreateIndex idx = new CreateIndex(session, schema);\n+    idx.setTableName(tableName);\n+    idx.setIndexColumns(indexColumns);\n+    idx.setAffinity(true);\n+    return idx;\n+  }\n+\n+  private static int getCompareType(int tokenType) {\n+    switch (tokenType) {\n+      case EQUAL:\n+        return Comparison.EQUAL;\n+      case BIGGER_EQUAL:\n+        return Comparison.BIGGER_EQUAL;\n+      case BIGGER:\n+        return Comparison.BIGGER;\n+      case SMALLER:\n+        return Comparison.SMALLER;\n+      case SMALLER_EQUAL:\n+        return Comparison.SMALLER_EQUAL;\n+      case NOT_EQUAL:\n+        return Comparison.NOT_EQUAL;\n+      case SPATIAL_INTERSECTS:\n+        return Comparison.SPATIAL_INTERSECTS;\n+      default:\n+        return -1;\n+    }\n+  }\n+\n+  /**\n+   * Add double quotes around an identifier if required.\n+   *\n+   * @param s the identifier\n+   * @return the quoted identifier\n+   */\n+  public static String quoteIdentifier(String s) {\n+    if (s == null) {\n+      return \"\\\"\\\"\";\n+    }\n+    if (ParserUtil.isSimpleIdentifier(s, false)) {\n+      return s;\n+    }\n+    return StringUtils.quoteIdentifier(s);\n+  }\n+\n+  public void setLiteralsChecked(boolean literalsChecked) {\n+    this.literalsChecked = literalsChecked;\n+  }\n+\n+  public void setRightsChecked(boolean rightsChecked) {\n+    this.rightsChecked = rightsChecked;\n+  }\n+\n+  public void setSuppliedParameterList(\n+      ArrayList<Parameter> suppliedParameterList) {\n+    this.suppliedParameterList = suppliedParameterList;\n+  }\n+\n+  /**\n+   * Parse a SQL code snippet that represents an expression.\n+   *\n+   * @param sql the code snippet\n+   * @return the expression object\n+   */\n+  public Expression parseExpression(String sql) {\n+    parameters = New.arrayList();\n+    initialize(sql);\n+    read();\n+    return readExpression();\n+  }\n+\n+  /**\n+   * Parse a SQL code snippet that represents a table name.\n+   *\n+   * @param sql the code snippet\n+   * @return the table object\n+   */\n+  public Table parseTableName(String sql) {\n+    parameters = New.arrayList();\n+    initialize(sql);\n+    read();\n+    return readTableOrView();\n+  }\n }\n",
            "diff_size": 11813
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/411/Parser.java\nindex 76588612d8..7a52f26c35 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/411/Parser.java\n@@ -1136,8 +1136,7 @@ public class Parser {\n             TableView temporarySourceTableView = createCTEView(\n                     command.getQueryAlias(), querySQLOutput[0],\n                     columnTemplateList, false/* no recursion */,\n-                    false/* do not add to session */,\n-                    false /* isPersistent */,\n+        false/* do not add to session */, false/* isPersistent */,\n                     session);\n             TableFilter sourceTableFilter = new TableFilter(session,\n                     temporarySourceTableView, command.getQueryAlias(),\n@@ -1156,8 +1155,7 @@ public class Parser {\n             }\n             Prepared preparedQuery = prepare(session, buff.toString(), null/*paramValues*/);\n             command.setQuery((Select) preparedQuery);\n-\n-        }\n+    }\n         read(\"ON\");\n         read(\"(\");\n         Expression condition = readExpression();\n@@ -1202,8 +1200,7 @@ public class Parser {\n             targetMatchQuerySQL.append(\n                     \" AS \" + command.getTargetTableFilter().getTableAlias());\n         }\n-        targetMatchQuerySQL\n-                .append(\" WHERE \").append(command.getOnCondition().getSQL());\n+        targetMatchQuerySQL.append(\" WHERE \").append(command.getOnCondition().getSQL());\n         command.setTargetMatchQuery(\n                 (Select) parse(targetMatchQuerySQL.toString()));\n \n@@ -1473,7 +1470,7 @@ public class Parser {\n         if (readIf(\"AS\")) {\n             alias = readAliasIdentifier();\n         } else if (currentTokenType == IDENTIFIER && !isTokenInList(excludeIdentifiers)) {\n-                alias = readAliasIdentifier();\n+    alias = readAliasIdentifier();\n         }\n         return alias;\n     }\n@@ -3108,8 +3105,7 @@ public class Parser {\n                         read(\"TIME\");\n                         read(\"ZONE\");\n                     }\n-                    if (currentTokenType != VALUE\n-                            || currentValue.getType() != Value.STRING) {\n+                    if (currentTokenType != VALUE || currentValue.getType() != Value.STRING) {\n                         if (without) {\n                             throw getSyntaxError();\n                         }\n@@ -3123,8 +3119,7 @@ public class Parser {\n                     if (readIf(\"WITH\")) {\n                         read(\"TIME\");\n                         read(\"ZONE\");\n-                        if (currentTokenType != VALUE\n-                                || currentValue.getType() != Value.STRING) {\n+                        if (currentTokenType != VALUE || currentValue.getType() != Value.STRING) {\n                             throw getSyntaxError();\n                         }\n                         String timestamp = currentValue.getString();\n@@ -3136,8 +3131,7 @@ public class Parser {\n                             read(\"TIME\");\n                             read(\"ZONE\");\n                         }\n-                        if (currentTokenType != VALUE\n-                                || currentValue.getType() != Value.STRING) {\n+                        if (currentTokenType != VALUE || currentValue.getType() != Value.STRING) {\n                             if (without) {\n                                 throw getSyntaxError();\n                             }\n@@ -3508,7 +3502,7 @@ public class Parser {\n      * If none of the token matches returns false\n      */\n     private boolean readIfOr(String... tokens) {\n-        for (String token: tokens) {\n+        for (String token : tokens) {\n             if (readIf(token)) {\n                 return true;\n             }\n@@ -3523,7 +3517,7 @@ public class Parser {\n     private boolean readIfAll(String... tokens) {\n         // save parse location in case we have to fail this test\n         int start = lastParseIndex;\n-        for (String token: tokens) {\n+        for (String token : tokens) {\n             if (!currentTokenQuoted && equalsToken(token, currentToken)) {\n                 read();\n             } else {\n@@ -4465,10 +4459,7 @@ public class Parser {\n             throw DbException.get(ErrorCode.INVALID_VALUE_SCALE_PRECISION,\n                     Integer.toString(scale), Long.toString(precision));\n         }\n-\n-\n-        Column column = new Column(columnName, type, precision, scale,\n-            displaySize, enumerators);\n+Column column = new Column(columnName, type, precision, scale, displaySize, enumerators);\n         if (templateColumn != null) {\n             column.setNullable(templateColumn.isNullable());\n             column.setDefaultExpression(session,\n@@ -5083,8 +5074,7 @@ public class Parser {\n         if (session.isParsingCreateView()) {\n             isPersistent = true;\n         }\n-\n-        do {\n+do {\n             viewsCreated.add(parseSingleCommonTableExpression(isPersistent));\n         } while (readIf(\",\"));\n \n@@ -5116,8 +5106,7 @@ public class Parser {\n             if (!isToken(\"TABLE\")) {\n                 throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n                         WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n-\n-            }\n+    }\n             p = parseCreate();\n             p.setPrepareAlways(true);\n         } else {\n@@ -5172,8 +5161,7 @@ public class Parser {\n             if (isPersistent) {\n                 oldViewFound.lock(session, true, true);\n                 database.removeSchemaObject(session, oldViewFound);\n-\n-            } else {\n+    } else {\n                 session.removeLocalTempTable(oldViewFound);\n             }\n             oldViewFound = null;\n@@ -5197,21 +5185,19 @@ public class Parser {\n             }\n             read(\")\");\n             columnTemplateList = TableView.createQueryColumnTemplateList(cols, withQuery, querySQLOutput);\n-\n-        } finally {\n+    } finally {\n             TableView.destroyShadowTableForRecursiveExpression(isPersistent, session, recursiveTable);\n         }\n \n         TableView view = createCTEView(cteViewName,\n                 querySQLOutput[0], columnTemplateList,\n-                true/* allowRecursiveQueryDetection */,\n-                true/* add to session */,\n-                isPersistent, session);\n+        true/* allowRecursiveQueryDetection */,\n+        true/* add to session */, isPersistent, session);\n \n         return view;\n     }\n \n-    private TableView createCTEView(String cteViewName,  String querySQL,\n+    private TableView createCTEView(String cteViewName, String querySQL,\n             List<Column> columnTemplateList, boolean allowRecursiveQueryDetection,\n             boolean addViewToSession, boolean isPersistent, Session targetSession) {\n         Database db = targetSession.getDatabase();\n@@ -5226,7 +5212,7 @@ public class Parser {\n         synchronized (targetSession) {\n             view = new TableView(schema, id, cteViewName, querySQL,\n                     parameters, columnTemplateArray, targetSession,\n-                    allowRecursiveQueryDetection, false /* literalsChecked */, true /* isTableExpression */,\n+                    allowRecursiveQueryDetection, false/* literalsChecked */, true/* isTableExpression */,\n                     isPersistent);\n             if (!view.isRecursiveQueryDetected() && allowRecursiveQueryDetection) {\n                 if (isPersistent) {\n@@ -5238,7 +5224,7 @@ public class Parser {\n                 }\n                 view = new TableView(schema, id, cteViewName, querySQL, parameters,\n                         columnTemplateArray, targetSession,\n-                        false/* assume recursive */, false /* literalsChecked */, true /* isTableExpression */,\n+        false/* assume recursive */, false/* literalsChecked */, true/* isTableExpression */,\n                         isPersistent);\n             }\n             // both removeSchemaObject and removeLocalTempTable hold meta locks\n@@ -6095,7 +6081,7 @@ public class Parser {\n                 throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n                         \"Internal Error - unhandled case: \" + nullConstraint.name());\n             }\n-            if(hasOpeningBracket) {\n+            if (hasOpeningBracket) {\n                 read(\")\");\n             }\n             return command;\n@@ -6163,12 +6149,10 @@ public class Parser {\n                         Expression defaultExpression = readExpression();\n                         command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n                         command.setDefaultExpression(defaultExpression);\n-\n-                    } else if (readIf(\"INVISIBLE\")) {\n+    } else if (readIf(\"INVISIBLE\")) {\n                         command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n                         command.setVisible(false);\n-\n-                    } else if (readIf(\"VISIBLE\")) {\n+    } else if (readIf(\"VISIBLE\")) {\n                         command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n                         command.setVisible(true);\n                     }\n@@ -6218,9 +6202,7 @@ public class Parser {\n \n     private Prepared commandIfTableExists(Schema schema, String tableName,\n             boolean ifTableExists, Prepared commandIfTableExists) {\n-        return tableIfTableExists(schema, tableName, ifTableExists) == null\n-            ? new NoOperation(session)\n-            : commandIfTableExists;\n+        return tableIfTableExists(schema, tableName, ifTableExists) == null ? new NoOperation(session) : commandIfTableExists;\n     }\n \n     private AlterTableAlterColumn parseAlterTableAlterColumnType(Schema schema,\n@@ -6675,7 +6657,8 @@ public class Parser {\n      * Enumeration describing null constraints\n      */\n     private enum NullConstraintType {\n-        NULL_IS_ALLOWED, NULL_IS_NOT_ALLOWED, NO_NULL_CONSTRAINT_FOUND\n+        NULL_IS_ALLOWED, NULL_IS_NOT_ALLOWED,\n+NO_NULL_CONSTRAINT_FOUND\n     }\n \n     private NullConstraintType parseNotNullConstraint() {\n@@ -6810,4 +6793,4 @@ public class Parser {\n         read();\n         return readTableOrView();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 44
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/411/Parser.java\nindex 76588612d8..73666635ce 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/411/Parser.java\n@@ -174,17 +174,16 @@ import org.h2.value.ValueTimestampTimeZone;\n  * @author Noel Grandin\n  * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  */\n+\n+\n public class Parser {\n \n-    private static final String WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS =\n-            \"WITH statement supports only SELECT, CREATE TABLE, INSERT, UPDATE, MERGE or DELETE statements\";\n+    private static final String WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS = \"WITH statement supports only SELECT, CREATE TABLE, INSERT, UPDATE, MERGE or DELETE statements\";\n \n     // used during the tokenizer phase\n     private static final int CHAR_END = 1, CHAR_VALUE = 2, CHAR_QUOTED = 3;\n-    private static final int CHAR_NAME = 4, CHAR_SPECIAL_1 = 5,\n-            CHAR_SPECIAL_2 = 6;\n-    private static final int CHAR_STRING = 7, CHAR_DOT = 8,\n-            CHAR_DOLLAR_QUOTED_STRING = 9;\n+    private static final int CHAR_NAME = 4, CHAR_SPECIAL_1 = 5, CHAR_SPECIAL_2 = 6;\n+    private static final int CHAR_STRING = 7, CHAR_DOT = 8, CHAR_DOLLAR_QUOTED_STRING = 9;\n \n     // this are token types\n     private static final int KEYWORD = ParserUtil.KEYWORD;\n@@ -200,15 +199,12 @@ public class Parser {\n     private static final int MINUS = 20, PLUS = 21, STRING_CONCAT = 22;\n     private static final int OPEN = 23, CLOSE = 24;\n     private static final int SPATIAL_INTERSECTS = 25;\n-\n-    private static final Comparator<TableFilter> TABLE_FILTER_COMPARATOR =\n-            new Comparator<TableFilter>() {\n-        @Override\n-        public int compare(TableFilter o1, TableFilter o2) {\n-            return o1 == o2 ? 0 : compareTableFilters(o1, o2);\n-        }\n-    };\n-\n+    private static final Comparator<TableFilter> TABLE_FILTER_COMPARATOR = new Comparator<TableFilter>() {\n+@Override\n+public int compare(TableFilter o1, TableFilter o2) {\n+    return o1 == o2 ? 0 : compareTableFilters(o1, o2);\n+}\n+};\n     private final Database database;\n     private final Session session;\n     /**\n@@ -256,6 +252,8 @@ public class Parser {\n      * @param sql the SQL statement to parse\n      * @return the prepared object\n      */\n+\n+\n     public Prepared prepare(String sql) {\n         Prepared p = parse(sql);\n         p.prepare();\n@@ -271,6 +269,8 @@ public class Parser {\n      * @param sql the SQL statement to parse\n      * @return the command object\n      */\n+\n+\n     public Command prepareCommand(String sql) {\n         try {\n             Prepared p = parse(sql);\n@@ -304,6 +304,8 @@ public class Parser {\n      * @param sql the SQL statement to parse\n      * @return the prepared object\n      */\n+\n+\n     Prepared parse(String sql) {\n         Prepared p;\n         try {\n@@ -383,12 +385,12 @@ public class Parser {\n                 } else if (readIf(\"CREATE\")) {\n                     c = parseCreate();\n                 } else if (readIf(\"CALL\")) {\n-                    c = parseCall();\n-                } else if (readIf(\"CHECKPOINT\")) {\n-                    c = parseCheckpoint();\n-                } else if (readIf(\"COMMENT\")) {\n-                    c = parseComment();\n-                }\n+                           c = parseCall();\n+                       } else if (readIf(\"CHECKPOINT\")) {\n+                           c = parseCheckpoint();\n+                       } else if (readIf(\"COMMENT\")) {\n+                                  c = parseComment();\n+                              }\n                 break;\n             case 'd':\n             case 'D':\n@@ -398,10 +400,10 @@ public class Parser {\n                     c = parseDrop();\n                 } else if (readIf(\"DECLARE\")) {\n                     // support for DECLARE GLOBAL TEMPORARY TABLE...\n-                    c = parseCreate();\n-                } else if (readIf(\"DEALLOCATE\")) {\n-                    c = parseDeallocate();\n-                }\n+                           c = parseCreate();\n+                       } else if (readIf(\"DEALLOCATE\")) {\n+                           c = parseDeallocate();\n+                       }\n                 break;\n             case 'e':\n             case 'E':\n@@ -454,12 +456,12 @@ public class Parser {\n                 } else if (readIf(\"REVOKE\")) {\n                     c = parseGrantRevoke(CommandInterface.REVOKE);\n                 } else if (readIf(\"RUNSCRIPT\")) {\n-                    c = parseRunScript();\n-                } else if (readIf(\"RELEASE\")) {\n-                    c = parseReleaseSavepoint();\n-                } else if (readIf(\"REPLACE\")) {\n-                    c = parseReplace();\n-                }\n+                           c = parseRunScript();\n+                       } else if (readIf(\"RELEASE\")) {\n+                           c = parseReleaseSavepoint();\n+                       } else if (readIf(\"REPLACE\")) {\n+                                  c = parseReplace();\n+                              }\n                 break;\n             case 's':\n             case 'S':\n@@ -468,14 +470,14 @@ public class Parser {\n                 } else if (readIf(\"SET\")) {\n                     c = parseSet();\n                 } else if (readIf(\"SAVEPOINT\")) {\n-                    c = parseSavepoint();\n-                } else if (readIf(\"SCRIPT\")) {\n-                    c = parseScript();\n-                } else if (readIf(\"SHUTDOWN\")) {\n-                    c = parseShutdown();\n-                } else if (readIf(\"SHOW\")) {\n-                    c = parseShow();\n-                }\n+                           c = parseSavepoint();\n+                       } else if (readIf(\"SCRIPT\")) {\n+                           c = parseScript();\n+                       } else if (readIf(\"SHUTDOWN\")) {\n+                                  c = parseShutdown();\n+                              } else if (readIf(\"SHOW\")) {\n+                                  c = parseShow();\n+                              }\n                 break;\n             case 't':\n             case 'T':\n@@ -510,8 +512,7 @@ public class Parser {\n                 throw getSyntaxError();\n             }\n             if (indexedParameterList != null) {\n-                for (int i = 0, size = indexedParameterList.size();\n-                        i < size; i++) {\n+                for (int i = 0, size = indexedParameterList.size(); i < size; i++) {\n                     if (indexedParameterList.get(i) == null) {\n                         indexedParameterList.set(i, new Parameter(i));\n                     }\n@@ -556,8 +557,7 @@ public class Parser {\n             buff.appendExceptFirst(\", \");\n             buff.append(e);\n         }\n-        return DbException.getSyntaxError(sqlCommand, parseIndex,\n-                buff.toString());\n+        return DbException.getSyntaxError(sqlCommand, parseIndex, buff.toString());\n     }\n \n     private Prepared parseBackup() {\n@@ -591,13 +591,11 @@ public class Parser {\n     private TransactionCommand parseCommit() {\n         TransactionCommand command;\n         if (readIf(\"TRANSACTION\")) {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.COMMIT_TRANSACTION);\n+            command = new TransactionCommand(session, CommandInterface.COMMIT_TRANSACTION);\n             command.setTransactionName(readUniqueIdentifier());\n             return command;\n         }\n-        command = new TransactionCommand(session,\n-                CommandInterface.COMMIT);\n+        command = new TransactionCommand(session, CommandInterface.COMMIT);\n         readIf(\"WORK\");\n         return command;\n     }\n@@ -609,38 +607,34 @@ public class Parser {\n         } else if (readIf(\"COMPACT\")) {\n             type = CommandInterface.SHUTDOWN_COMPACT;\n         } else if (readIf(\"DEFRAG\")) {\n-            type = CommandInterface.SHUTDOWN_DEFRAG;\n-        } else {\n-            readIf(\"SCRIPT\");\n-        }\n+                   type = CommandInterface.SHUTDOWN_DEFRAG;\n+               } else {\n+                   readIf(\"SCRIPT\");\n+               }\n         return new TransactionCommand(session, type);\n     }\n \n     private TransactionCommand parseRollback() {\n         TransactionCommand command;\n         if (readIf(\"TRANSACTION\")) {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.ROLLBACK_TRANSACTION);\n+            command = new TransactionCommand(session, CommandInterface.ROLLBACK_TRANSACTION);\n             command.setTransactionName(readUniqueIdentifier());\n             return command;\n         }\n         if (readIf(\"TO\")) {\n             read(\"SAVEPOINT\");\n-            command = new TransactionCommand(session,\n-                    CommandInterface.ROLLBACK_TO_SAVEPOINT);\n+            command = new TransactionCommand(session, CommandInterface.ROLLBACK_TO_SAVEPOINT);\n             command.setSavepointName(readUniqueIdentifier());\n         } else {\n             readIf(\"WORK\");\n-            command = new TransactionCommand(session,\n-                    CommandInterface.ROLLBACK);\n+            command = new TransactionCommand(session, CommandInterface.ROLLBACK);\n         }\n         return command;\n     }\n \n     private Prepared parsePrepare() {\n         if (readIf(\"COMMIT\")) {\n-            TransactionCommand command = new TransactionCommand(session,\n-                    CommandInterface.PREPARE_COMMIT);\n+            TransactionCommand command = new TransactionCommand(session, CommandInterface.PREPARE_COMMIT);\n             command.setTransactionName(readUniqueIdentifier());\n             return command;\n         }\n@@ -665,8 +659,7 @@ public class Parser {\n     }\n \n     private TransactionCommand parseSavepoint() {\n-        TransactionCommand command = new TransactionCommand(session,\n-                CommandInterface.SAVEPOINT);\n+        TransactionCommand command = new TransactionCommand(session, CommandInterface.SAVEPOINT);\n         command.setSavepointName(readUniqueIdentifier());\n         return command;\n     }\n@@ -687,8 +680,7 @@ public class Parser {\n             if (equalsToken(\"SESSION\", schemaName)) {\n                 // for local temporary tables\n                 schema = database.getSchema(session.getCurrentSchemaName());\n-            } else if (database.getMode().sysDummy1 &&\n-                    \"SYSIBM\".equals(schemaName)) {\n+            } else if (database.getMode().sysDummy1 && \"SYSIBM\".equals(schemaName)) {\n                 // IBM DB2 and Apache Derby compatibility: SYSIBM.SYSDUMMY1\n                 schema = database.getSchema(session.getCurrentSchemaName());\n             }\n@@ -730,6 +722,7 @@ public class Parser {\n      * I gave up. I think this needs a bigger effort to fix his, as part of bigger, dedicated story.\n      *\n      */\n+\n     private Schema getSchemaWithDefault() {\n         if (schemaName == null) {\n             schemaName = session.getCurrentSchemaName();\n@@ -753,18 +746,15 @@ public class Parser {\n                     tableAlias = columnName;\n                     columnName = readColumnIdentifier();\n                     if (!equalsToken(catalogName, database.getShortName())) {\n-                        throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n-                                catalogName);\n+                        throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1, catalogName);\n                     }\n                 }\n-                if (!equalsToken(schema, filter.getTable().getSchema()\n-                        .getName())) {\n+                if (!equalsToken(schema, filter.getTable().getSchema().getName())) {\n                     throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schema);\n                 }\n             }\n             if (!equalsToken(tableAlias, filter.getTableAlias())) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1,\n-                        tableAlias);\n+                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, tableAlias);\n             }\n         }\n         if (database.getSettings().rowId) {\n@@ -845,14 +835,18 @@ public class Parser {\n         if (readIf(\"AS\")) {\n             alias = readAliasIdentifier();\n         } else if (currentTokenType == IDENTIFIER) {\n-            if (!equalsTokenIgnoreCase(currentToken, \"SET\")\n-                    && (excludeTokens == null || !isTokenInList(excludeTokens))) {\n+            if (!equalsTokenIgnoreCase(currentToken, \"SET\") && (excludeTokens == null || !isTokenInList(excludeTokens))) {\n                 // SET is not a keyword (PostgreSQL supports it as a table name)\n                 alias = readAliasIdentifier();\n             }\n         }\n-        return new TableFilter(session, table, alias, rightsChecked,\n-                currentSelect, orderInFrom, null);\n+        return new TableFilter(session,\n+            table,\n+                alias,\n+                    rightsChecked,\n+                        currentSelect,\n+                            orderInFrom,\n+                                null);\n     }\n \n     private Delete parseDelete() {\n@@ -893,6 +887,7 @@ public class Parser {\n             columns.add(column);\n             if (readIf(\"ASC\")) {\n                 // ignore\n+\n             } else if (readIf(\"DESC\")) {\n                 column.sortType = SortOrder.DESCENDING;\n             }\n@@ -920,13 +915,12 @@ public class Parser {\n \n     private Column[] parseColumnList(Table table) {\n         ArrayList<Column> columns = New.arrayList();\n-        HashSet<Column> set = new HashSet<>();\n+        HashSet<Column> set = new HashSet< >();\n         if (!readIf(\")\")) {\n             do {\n                 Column column = parseColumn(table);\n                 if (!set.add(column)) {\n-                    throw DbException.get(ErrorCode.DUPLICATE_COLUMN_NAME_1,\n-                            column.getSQL());\n+                    throw DbException.get(ErrorCode.DUPLICATE_COLUMN_NAME_1, column.getSQL());\n                 }\n                 columns.add(column);\n             } while (readIfMore());\n@@ -951,8 +945,7 @@ public class Parser {\n     }\n \n     private Prepared parseHelp() {\n-        StringBuilder buff = new StringBuilder(\n-                \"SELECT * FROM INFORMATION_SCHEMA.HELP\");\n+        StringBuilder buff = new StringBuilder(\"SELECT * FROM INFORMATION_SCHEMA.HELP\");\n         int i = 0;\n         ArrayList<Value> paramValues = New.arrayList();\n         while (currentTokenType != END) {\n@@ -978,61 +971,55 @@ public class Parser {\n             buff.append(\"'UNICODE' AS CLIENT_ENCODING FROM DUAL\");\n         } else if (readIf(\"DEFAULT_TRANSACTION_ISOLATION\")) {\n             // for PostgreSQL compatibility\n-            buff.append(\"'read committed' AS DEFAULT_TRANSACTION_ISOLATION \" +\n-                    \"FROM DUAL\");\n+            buff.append(\"'read committed' AS DEFAULT_TRANSACTION_ISOLATION \" + \"FROM DUAL\");\n         } else if (readIf(\"TRANSACTION\")) {\n             // for PostgreSQL compatibility\n-            read(\"ISOLATION\");\n-            read(\"LEVEL\");\n-            buff.append(\"'read committed' AS TRANSACTION_ISOLATION \" +\n-                    \"FROM DUAL\");\n-        } else if (readIf(\"DATESTYLE\")) {\n+                   read(\"ISOLATION\");\n+                   read(\"LEVEL\");\n+                   buff.append(\"'read committed' AS TRANSACTION_ISOLATION \" + \"FROM DUAL\");\n+               } else if (readIf(\"DATESTYLE\")) {\n             // for PostgreSQL compatibility\n-            buff.append(\"'ISO' AS DATESTYLE FROM DUAL\");\n-        } else if (readIf(\"SERVER_VERSION\")) {\n+                   buff.append(\"'ISO' AS DATESTYLE FROM DUAL\");\n+               } else if (readIf(\"SERVER_VERSION\")) {\n             // for PostgreSQL compatibility\n-            buff.append(\"'8.1.4' AS SERVER_VERSION FROM DUAL\");\n-        } else if (readIf(\"SERVER_ENCODING\")) {\n+                          buff.append(\"'8.1.4' AS SERVER_VERSION FROM DUAL\");\n+                      } else if (readIf(\"SERVER_ENCODING\")) {\n             // for PostgreSQL compatibility\n-            buff.append(\"'UTF8' AS SERVER_ENCODING FROM DUAL\");\n-        } else if (readIf(\"TABLES\")) {\n+                          buff.append(\"'UTF8' AS SERVER_ENCODING FROM DUAL\");\n+                      } else if (readIf(\"TABLES\")) {\n             // for MySQL compatibility\n-            String schema = Constants.SCHEMA_MAIN;\n-            if (readIf(\"FROM\")) {\n-                schema = readUniqueIdentifier();\n-            }\n-            buff.append(\"TABLE_NAME, TABLE_SCHEMA FROM \"\n-                    + \"INFORMATION_SCHEMA.TABLES \"\n-                    + \"WHERE TABLE_SCHEMA=? ORDER BY TABLE_NAME\");\n-            paramValues.add(ValueString.get(schema));\n-        } else if (readIf(\"COLUMNS\")) {\n+                                 String schema = Constants.SCHEMA_MAIN;\n+                                 if (readIf(\"FROM\")) {\n+                                     schema = readUniqueIdentifier();\n+                                 }\n+                                 buff.append(\"TABLE_NAME, TABLE_SCHEMA FROM \" + \"INFORMATION_SCHEMA.TABLES \" + \"WHERE TABLE_SCHEMA=? ORDER BY TABLE_NAME\");\n+                                 paramValues.add(ValueString.get(schema));\n+                             } else if (readIf(\"COLUMNS\")) {\n             // for MySQL compatibility\n-            read(\"FROM\");\n-            String tableName = readIdentifierWithSchema();\n-            String schemaName = getSchema().getName();\n-            paramValues.add(ValueString.get(tableName));\n-            if (readIf(\"FROM\")) {\n-                schemaName = readUniqueIdentifier();\n-            }\n-            buff.append(\"C.COLUMN_NAME FIELD, \"\n-                    + \"C.TYPE_NAME || '(' || C.NUMERIC_PRECISION || ')' TYPE, \"\n-                    + \"C.IS_NULLABLE \\\"NULL\\\", \"\n-                    + \"CASE (SELECT MAX(I.INDEX_TYPE_NAME) FROM \"\n-                    + \"INFORMATION_SCHEMA.INDEXES I \"\n-                    + \"WHERE I.TABLE_SCHEMA=C.TABLE_SCHEMA \"\n-                    + \"AND I.TABLE_NAME=C.TABLE_NAME \"\n-                    + \"AND I.COLUMN_NAME=C.COLUMN_NAME)\"\n-                    + \"WHEN 'PRIMARY KEY' THEN 'PRI' \"\n-                    + \"WHEN 'UNIQUE INDEX' THEN 'UNI' ELSE '' END KEY, \"\n-                    + \"IFNULL(COLUMN_DEFAULT, 'NULL') DEFAULT \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMNS C \"\n-                    + \"WHERE C.TABLE_NAME=? AND C.TABLE_SCHEMA=? \"\n-                    + \"ORDER BY C.ORDINAL_POSITION\");\n-            paramValues.add(ValueString.get(schemaName));\n-        } else if (readIf(\"DATABASES\") || readIf(\"SCHEMAS\")) {\n+                                 read(\"FROM\");\n+                                 String tableName = readIdentifierWithSchema();\n+                                 String schemaName = getSchema().getName();\n+                                 paramValues.add(ValueString.get(tableName));\n+                                 if (readIf(\"FROM\")) {\n+                                     schemaName = readUniqueIdentifier();\n+                                 }\n+                                 buff.append(\"C.COLUMN_NAME FIELD, \" + \"C.TYPE_NAME || '(' || C.NUMERIC_PRECISION || ')' TYPE, \"\n+                                 + \"C.IS_NULLABLE \\\"NULL\\\", \"\n+                                 + \"CASE (SELECT MAX(I.INDEX_TYPE_NAME) FROM \"\n+                                 + \"INFORMATION_SCHEMA.INDEXES I \"\n+                                 + \"WHERE I.TABLE_SCHEMA=C.TABLE_SCHEMA \"\n+                                 + \"AND I.TABLE_NAME=C.TABLE_NAME \"\n+                                 + \"AND I.COLUMN_NAME=C.COLUMN_NAME)\"\n+                                 + \"WHEN 'PRIMARY KEY' THEN 'PRI' \"\n+                                 + \"WHEN 'UNIQUE INDEX' THEN 'UNI' ELSE '' END KEY, \"\n+                                 + \"IFNULL(COLUMN_DEFAULT, 'NULL') DEFAULT \"\n+                                 + \"FROM INFORMATION_SCHEMA.COLUMNS C \"\n+                                 + \"WHERE C.TABLE_NAME=? AND C.TABLE_SCHEMA=? \" + \"ORDER BY C.ORDINAL_POSITION\");\n+                                 paramValues.add(ValueString.get(schemaName));\n+                             } else if (readIf(\"DATABASES\") || readIf(\"SCHEMAS\")) {\n             // for MySQL compatibility\n-            buff.append(\"SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA\");\n-        }\n+                                        buff.append(\"SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA\");\n+                                    }\n         boolean b = session.getAllowLiterals();\n         try {\n             // need to temporarily enable it, in case we are in\n@@ -1044,8 +1031,7 @@ public class Parser {\n         }\n     }\n \n-    private static Prepared prepare(Session s, String sql,\n-            ArrayList<Value> paramValues) {\n+    private static Prepared prepare(Session s, String sql, ArrayList<Value> paramValues) {\n         Prepared prep = s.prepare(sql);\n         ArrayList<Parameter> params = prep.getParameters();\n         if (params != null) {\n@@ -1062,6 +1048,7 @@ public class Parser {\n         while (readIf(\"(\")) {\n             // need to read ahead, it could be a nested union:\n             // ((select 1) union (select 1))\n+\n         }\n         boolean select = isToken(\"SELECT\") || isToken(\"FROM\") || isToken(\"WITH\");\n         parseIndex = start;\n@@ -1069,7 +1056,6 @@ public class Parser {\n         return select;\n     }\n \n-\n     private Prepared parseMerge() {\n         Merge command = new Merge(session);\n         currentPrepared = command;\n@@ -1079,7 +1065,6 @@ public class Parser {\n         TableFilter targetTableFilter = readSimpleTableFilter(0, excludeIdentifiers);\n         command.setTargetTableFilter(targetTableFilter);\n         Table table = command.getTargetTable();\n-\n         if (readIf(\"USING\")) {\n             return parseMergeUsing(command, start);\n         }\n@@ -1121,7 +1106,6 @@ public class Parser {\n     private MergeUsing parseMergeUsing(Merge oldCommand, int start) {\n         MergeUsing command = new MergeUsing(oldCommand);\n         currentPrepared = command;\n-\n         if (readIf(\"(\")) {\n             /* a select query is supplied */\n             if (isSelect()) {\n@@ -1129,41 +1113,28 @@ public class Parser {\n                 read(\")\");\n             }\n             command.setQueryAlias(readFromAlias(null, Arrays.asList(\"ON\")));\n-\n-            String[] querySQLOutput = new String[]{null};\n-            List<Column> columnTemplateList = TableView.createQueryColumnTemplateList(null, command.getQuery(),\n-                    querySQLOutput);\n-            TableView temporarySourceTableView = createCTEView(\n-                    command.getQueryAlias(), querySQLOutput[0],\n-                    columnTemplateList, false/* no recursion */,\n-                    false/* do not add to session */,\n-                    false /* isPersistent */,\n-                    session);\n-            TableFilter sourceTableFilter = new TableFilter(session,\n-                    temporarySourceTableView, command.getQueryAlias(),\n-                    rightsChecked, (Select) command.getQuery(), 0, null);\n+            String[] querySQLOutput = new String[] { null };\n+            List<Column> columnTemplateList = TableView.createQueryColumnTemplateList(null, command.getQuery(), querySQLOutput);\n+            TableView temporarySourceTableView = createCTEView(command.getQueryAlias(), querySQLOutput[0], columnTemplateList, false/* no recursion */, false/* do not add to session */, false /* isPersistent */, session);\n+            TableFilter sourceTableFilter = new TableFilter(session, temporarySourceTableView, command.getQueryAlias(), rightsChecked, (Select) command.getQuery(), 0, null);\n             command.setSourceTableFilter(sourceTableFilter);\n         } else {\n             /* Its a table name, simulate a query by building a select query for the table */\n             List<String> excludeIdentifiers = Arrays.asList(\"ON\");\n             TableFilter sourceTableFilter = readSimpleTableFilter(0, excludeIdentifiers);\n             command.setSourceTableFilter(sourceTableFilter);\n-\n-            StringBuilder buff = new StringBuilder(\"SELECT * FROM \")\n-                    .append(sourceTableFilter.getTable().getName());\n+            StringBuilder buff = new StringBuilder(\"SELECT * FROM \").append(sourceTableFilter.getTable().getName());\n             if (sourceTableFilter.getTableAlias() != null) {\n                 buff.append(\" AS \").append(sourceTableFilter.getTableAlias());\n             }\n             Prepared preparedQuery = prepare(session, buff.toString(), null/*paramValues*/);\n             command.setQuery((Select) preparedQuery);\n-\n         }\n         read(\"ON\");\n         read(\"(\");\n         Expression condition = readExpression();\n         command.setOnCondition(condition);\n         read(\")\");\n-\n         if (readIfAll(\"WHEN\", \"MATCHED\", \"THEN\")) {\n             int startMatched = lastParseIndex;\n             if (readIf(\"UPDATE\")) {\n@@ -1191,22 +1162,16 @@ public class Parser {\n                 command.setInsertCommand(insertCommand);\n             }\n         }\n-\n         setSQL(command, \"MERGE\", start);\n \n         // build and prepare the targetMatchQuery ready to test each rows\n         // existence in the target table (using source row to match)\n-        StringBuilder targetMatchQuerySQL = new StringBuilder(\n-                \"SELECT _ROWID_ FROM \" + command.getTargetTable().getName());\n+        StringBuilder targetMatchQuerySQL = new StringBuilder(\"SELECT _ROWID_ FROM \" + command.getTargetTable().getName());\n         if (command.getTargetTableFilter().getTableAlias() != null) {\n-            targetMatchQuerySQL.append(\n-                    \" AS \" + command.getTargetTableFilter().getTableAlias());\n+            targetMatchQuerySQL.append(\" AS \" + command.getTargetTableFilter().getTableAlias());\n         }\n-        targetMatchQuerySQL\n-                .append(\" WHERE \").append(command.getOnCondition().getSQL());\n-        command.setTargetMatchQuery(\n-                (Select) parse(targetMatchQuerySQL.toString()));\n-\n+        targetMatchQuerySQL.append(\" WHERE \").append(command.getOnCondition().getSQL());\n+        command.setTargetMatchQuery((Select) parse(targetMatchQuerySQL.toString()));\n         return command;\n     }\n \n@@ -1285,33 +1250,34 @@ public class Parser {\n                 // the following condition will allow (..),; and (..);\n             } while (readIf(\",\") && readIf(\"(\"));\n         } else if (readIf(\"SET\")) {\n-            if (columns != null) {\n-                throw getSyntaxError();\n-            }\n-            ArrayList<Column> columnList = New.arrayList();\n-            ArrayList<Expression> values = New.arrayList();\n-            do {\n-                columnList.add(parseColumn(table));\n-                read(\"=\");\n-                Expression expression;\n-                if (readIf(\"DEFAULT\")) {\n-                    expression = ValueExpression.getDefault();\n-                } else {\n-                    expression = readExpression();\n-                }\n-                values.add(expression);\n-            } while (readIf(\",\"));\n-            command.setColumns(columnList.toArray(new Column[0]));\n-            command.addRow(values.toArray(new Expression[0]));\n-        } else {\n-            command.setQuery(parseSelect());\n-        }\n+                   if (columns != null) {\n+                       throw getSyntaxError();\n+                   }\n+                   ArrayList<Column> columnList = New.arrayList();\n+                   ArrayList<Expression> values = New.arrayList();\n+                   do {\n+                       columnList.add(parseColumn(table));\n+                       read(\"=\");\n+                       Expression expression;\n+                       if (readIf(\"DEFAULT\")) {\n+                           expression = ValueExpression.getDefault();\n+                       } else {\n+                           expression = readExpression();\n+                       }\n+                       values.add(expression);\n+                   } while (readIf(\",\"));\n+                   command.setColumns(columnList.toArray(new Column[0]));\n+                   command.addRow(values.toArray(new Expression[0]));\n+               } else {\n+                   command.setQuery(parseSelect());\n+               }\n         return null;\n     }\n \n     /**\n      * MySQL compatibility. REPLACE is similar to MERGE.\n      */\n+\n     private Replace parseReplace() {\n         Replace command = new Replace(session);\n         currentPrepared = command;\n@@ -1355,7 +1321,7 @@ public class Parser {\n             if (isSelect()) {\n                 Query query = parseSelectUnion();\n                 read(\")\");\n-                query.setParameterList(new ArrayList<>(parameters));\n+                query.setParameterList(new ArrayList< >(parameters));\n                 query.init();\n                 Session s;\n                 if (createView != null) {\n@@ -1364,8 +1330,7 @@ public class Parser {\n                     s = session;\n                 }\n                 alias = session.getNextSystemIdentifier(sqlCommand);\n-                table = TableView.createTempView(s, session.getUser(), alias,\n-                        query, currentSelect);\n+                table = TableView.createTempView(s, session.getUser(), alias, query, currentSelect);\n             } else {\n                 TableFilter top;\n                 top = readTableFilter();\n@@ -1392,16 +1357,14 @@ public class Parser {\n             }\n             if (foundLeftBracket) {\n                 Schema mainSchema = database.getSchema(Constants.SCHEMA_MAIN);\n-                if (equalsToken(tableName, RangeTable.NAME)\n-                        || equalsToken(tableName, RangeTable.ALIAS)) {\n+                if (equalsToken(tableName, RangeTable.NAME) || equalsToken(tableName, RangeTable.ALIAS)) {\n                     Expression min = readExpression();\n                     read(\",\");\n                     Expression max = readExpression();\n                     if (readIf(\",\")) {\n                         Expression step = readExpression();\n                         read(\")\");\n-                        table = new RangeTable(mainSchema, min, max, step,\n-                                false);\n+                        table = new RangeTable(mainSchema, min, max, step, false);\n                     } else {\n                         read(\")\");\n                         table = new RangeTable(mainSchema, min, max, false);\n@@ -1419,12 +1382,11 @@ public class Parser {\n                 }\n             } else if (equalsToken(\"DUAL\", tableName)) {\n                 table = getDualTable(false);\n-            } else if (database.getMode().sysDummy1 &&\n-                    equalsToken(\"SYSDUMMY1\", tableName)) {\n-                table = getDualTable(false);\n-            } else {\n-                table = readTableOrView(tableName);\n-            }\n+            } else if (database.getMode().sysDummy1 && equalsToken(\"SYSDUMMY1\", tableName)) {\n+                       table = getDualTable(false);\n+                   } else {\n+                       table = readTableOrView(tableName);\n+                   }\n         }\n         IndexHints indexHints = null;\n         // for backward compatibility, handle case where USE is a table alias\n@@ -1448,8 +1410,13 @@ public class Parser {\n         if (table.isView() && table.isTableExpression() && alias == null) {\n             alias = table.getName();\n         }\n-        return new TableFilter(session, table, alias, rightsChecked,\n-                currentSelect, orderInFrom++, indexHints);\n+        return new TableFilter(session,\n+            table,\n+                alias,\n+                    rightsChecked,\n+                        currentSelect,\n+                            orderInFrom++,\n+                                indexHints);\n     }\n \n     private IndexHints parseIndexHints(Table table) {\n@@ -1457,7 +1424,7 @@ public class Parser {\n             throw getSyntaxError();\n         }\n         read(\"(\");\n-        LinkedHashSet<String> indexNames = new LinkedHashSet<>();\n+        LinkedHashSet<String> indexNames = new LinkedHashSet< >();\n         if (!readIf(\")\")) {\n             do {\n                 String indexName = readIdentifierWithSchema();\n@@ -1473,7 +1440,7 @@ public class Parser {\n         if (readIf(\"AS\")) {\n             alias = readAliasIdentifier();\n         } else if (currentTokenType == IDENTIFIER && !isTokenInList(excludeIdentifiers)) {\n-                alias = readAliasIdentifier();\n+            alias = readAliasIdentifier();\n         }\n         return alias;\n     }\n@@ -1511,28 +1478,28 @@ public class Parser {\n             column = true;\n             type = DbObject.TABLE_OR_VIEW;\n         } else if (readIf(\"CONSTANT\")) {\n-            type = DbObject.CONSTANT;\n-        } else if (readIf(\"CONSTRAINT\")) {\n-            type = DbObject.CONSTRAINT;\n-        } else if (readIf(\"ALIAS\")) {\n-            type = DbObject.FUNCTION_ALIAS;\n-        } else if (readIf(\"INDEX\")) {\n-            type = DbObject.INDEX;\n-        } else if (readIf(\"ROLE\")) {\n-            type = DbObject.ROLE;\n-        } else if (readIf(\"SCHEMA\")) {\n-            type = DbObject.SCHEMA;\n-        } else if (readIf(\"SEQUENCE\")) {\n-            type = DbObject.SEQUENCE;\n-        } else if (readIf(\"TRIGGER\")) {\n-            type = DbObject.TRIGGER;\n-        } else if (readIf(\"USER\")) {\n-            type = DbObject.USER;\n-        } else if (readIf(\"DOMAIN\")) {\n-            type = DbObject.USER_DATATYPE;\n-        } else {\n-            throw getSyntaxError();\n-        }\n+                   type = DbObject.CONSTANT;\n+               } else if (readIf(\"CONSTRAINT\")) {\n+                   type = DbObject.CONSTRAINT;\n+               } else if (readIf(\"ALIAS\")) {\n+                          type = DbObject.FUNCTION_ALIAS;\n+                      } else if (readIf(\"INDEX\")) {\n+                          type = DbObject.INDEX;\n+                      } else if (readIf(\"ROLE\")) {\n+                                 type = DbObject.ROLE;\n+                             } else if (readIf(\"SCHEMA\")) {\n+                                 type = DbObject.SCHEMA;\n+                             } else if (readIf(\"SEQUENCE\")) {\n+                                        type = DbObject.SEQUENCE;\n+                                    } else if (readIf(\"TRIGGER\")) {\n+                                        type = DbObject.TRIGGER;\n+                                    } else if (readIf(\"USER\")) {\n+                                               type = DbObject.USER;\n+                                           } else if (readIf(\"DOMAIN\")) {\n+                                               type = DbObject.USER_DATATYPE;\n+                                           } else {\n+                                               throw getSyntaxError();\n+                                           }\n         SetComment command = new SetComment(session);\n         String objectName;\n         if (column) {\n@@ -1546,16 +1513,14 @@ public class Parser {\n             schemaName = session.getCurrentSchemaName();\n             if (list.size() == 4) {\n                 if (!equalsToken(database.getShortName(), list.remove(0))) {\n-                    throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                            \"database name\");\n+                    throw DbException.getSyntaxError(sqlCommand, parseIndex, \"database name\");\n                 }\n             }\n             if (list.size() == 3) {\n                 schemaName = list.remove(0);\n             }\n             if (list.size() != 2) {\n-                throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                        \"table.column\");\n+                throw DbException.getSyntaxError(sqlCommand, parseIndex, \"table.column\");\n             }\n             objectName = list.get(0);\n             command.setColumn(true);\n@@ -1591,26 +1556,26 @@ public class Parser {\n             } else if (readIf(\"RESTRICT\")) {\n                 command.setDropAction(ConstraintActionType.RESTRICT);\n             } else if (readIf(\"IGNORE\")) {\n-                command.setDropAction(ConstraintActionType.SET_DEFAULT);\n-            }\n+                       command.setDropAction(ConstraintActionType.SET_DEFAULT);\n+                   }\n             return command;\n         } else if (readIf(\"INDEX\")) {\n-            boolean ifExists = readIfExists(false);\n-            String indexName = readIdentifierWithSchema();\n-            DropIndex command = new DropIndex(session, getSchema());\n-            command.setIndexName(indexName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n+        boolean ifExists = readIfExists(false);\n+        String indexName = readIdentifierWithSchema();\n+        DropIndex command = new DropIndex(session, getSchema());\n+        command.setIndexName(indexName);\n+        ifExists = readIfExists(ifExists);\n+        command.setIfExists(ifExists);\n+        return command;\n         } else if (readIf(\"USER\")) {\n-            boolean ifExists = readIfExists(false);\n-            DropUser command = new DropUser(session);\n-            command.setUserName(readUniqueIdentifier());\n-            ifExists = readIfExists(ifExists);\n-            readIf(\"CASCADE\");\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"SEQUENCE\")) {\n+                                     boolean ifExists = readIfExists(false);\n+                                     DropUser command = new DropUser(session);\n+                                     command.setUserName(readUniqueIdentifier());\n+                                     ifExists = readIfExists(ifExists);\n+                                     readIf(\"CASCADE\");\n+                                     command.setIfExists(ifExists);\n+                                     return command;\n+               } else if (readIf(\"SEQUENCE\")) {\n             boolean ifExists = readIfExists(false);\n             String sequenceName = readIdentifierWithSchema();\n             DropSequence command = new DropSequence(session, getSchema());\n@@ -1618,7 +1583,7 @@ public class Parser {\n             ifExists = readIfExists(ifExists);\n             command.setIfExists(ifExists);\n             return command;\n-        } else if (readIf(\"CONSTANT\")) {\n+               } else if (readIf(\"CONSTANT\")) {\n             boolean ifExists = readIfExists(false);\n             String constantName = readIdentifierWithSchema();\n             DropConstant command = new DropConstant(session, getSchema());\n@@ -1626,75 +1591,74 @@ public class Parser {\n             ifExists = readIfExists(ifExists);\n             command.setIfExists(ifExists);\n             return command;\n-        } else if (readIf(\"TRIGGER\")) {\n-            boolean ifExists = readIfExists(false);\n-            String triggerName = readIdentifierWithSchema();\n-            DropTrigger command = new DropTrigger(session, getSchema());\n-            command.setTriggerName(triggerName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"VIEW\")) {\n-            boolean ifExists = readIfExists(false);\n-            String viewName = readIdentifierWithSchema();\n-            DropView command = new DropView(session, getSchema());\n-            command.setViewName(viewName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            ConstraintActionType dropAction = parseCascadeOrRestrict();\n-            if (dropAction != null) {\n-                command.setDropAction(dropAction);\n-            }\n-            return command;\n-        } else if (readIf(\"ROLE\")) {\n-            boolean ifExists = readIfExists(false);\n-            DropRole command = new DropRole(session);\n-            command.setRoleName(readUniqueIdentifier());\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"ALIAS\")) {\n-            boolean ifExists = readIfExists(false);\n-            String aliasName = readIdentifierWithSchema();\n-            DropFunctionAlias command = new DropFunctionAlias(session,\n-                    getSchema());\n-            command.setAliasName(aliasName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"SCHEMA\")) {\n-            boolean ifExists = readIfExists(false);\n-            DropSchema command = new DropSchema(session);\n-            command.setSchemaName(readUniqueIdentifier());\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        } else if (readIf(\"ALL\")) {\n-            read(\"OBJECTS\");\n-            DropDatabase command = new DropDatabase(session);\n-            command.setDropAllObjects(true);\n-            if (readIf(\"DELETE\")) {\n-                read(\"FILES\");\n-                command.setDeleteFiles(true);\n-            }\n-            return command;\n-        } else if (readIf(\"DOMAIN\")) {\n-            return parseDropUserDataType();\n-        } else if (readIf(\"TYPE\")) {\n-            return parseDropUserDataType();\n-        } else if (readIf(\"DATATYPE\")) {\n-            return parseDropUserDataType();\n-        } else if (readIf(\"AGGREGATE\")) {\n-            return parseDropAggregate();\n-        } else if (readIf(\"SYNONYM\")) {\n-            boolean ifExists = readIfExists(false);\n-            String synonymName = readIdentifierWithSchema();\n-            DropSynonym command = new DropSynonym(session, getSchema());\n-            command.setSynonymName(synonymName);\n-            ifExists = readIfExists(ifExists);\n-            command.setIfExists(ifExists);\n-            return command;\n-        }\n+                      } else if (readIf(\"TRIGGER\")) {\n+                   boolean ifExists = readIfExists(false);\n+                   String triggerName = readIdentifierWithSchema();\n+                   DropTrigger command = new DropTrigger(session, getSchema());\n+                   command.setTriggerName(triggerName);\n+                   ifExists = readIfExists(ifExists);\n+                   command.setIfExists(ifExists);\n+                   return command;\n+                      } else if (readIf(\"VIEW\")) {\n+                   boolean ifExists = readIfExists(false);\n+                   String viewName = readIdentifierWithSchema();\n+                   DropView command = new DropView(session, getSchema());\n+                   command.setViewName(viewName);\n+                   ifExists = readIfExists(ifExists);\n+                   command.setIfExists(ifExists);\n+                   ConstraintActionType dropAction = parseCascadeOrRestrict();\n+                   if (dropAction != null) {\n+                       command.setDropAction(dropAction);\n+                   }\n+                   return command;\n+                             } else if (readIf(\"ROLE\")) {\n+                          boolean ifExists = readIfExists(false);\n+                          DropRole command = new DropRole(session);\n+                          command.setRoleName(readUniqueIdentifier());\n+                          ifExists = readIfExists(ifExists);\n+                          command.setIfExists(ifExists);\n+                          return command;\n+                             } else if (readIf(\"ALIAS\")) {\n+                          boolean ifExists = readIfExists(false);\n+                          String aliasName = readIdentifierWithSchema();\n+                          DropFunctionAlias command = new DropFunctionAlias(session, getSchema());\n+                          command.setAliasName(aliasName);\n+                          ifExists = readIfExists(ifExists);\n+                          command.setIfExists(ifExists);\n+                          return command;\n+                                    } else if (readIf(\"SCHEMA\")) {\n+                                 boolean ifExists = readIfExists(false);\n+                                 DropSchema command = new DropSchema(session);\n+                                 command.setSchemaName(readUniqueIdentifier());\n+                                 ifExists = readIfExists(ifExists);\n+                                 command.setIfExists(ifExists);\n+                                 return command;\n+                                    } else if (readIf(\"ALL\")) {\n+                                               read(\"OBJECTS\");\n+                                               DropDatabase command = new DropDatabase(session);\n+                                               command.setDropAllObjects(true);\n+                                               if (readIf(\"DELETE\")) {\n+                                                   read(\"FILES\");\n+                                                   command.setDeleteFiles(true);\n+                                               }\n+                                               return command;\n+                                           } else if (readIf(\"DOMAIN\")) {\n+                                        return parseDropUserDataType();\n+                                           } else if (readIf(\"TYPE\")) {\n+                                        return parseDropUserDataType();\n+                                                  } else if (readIf(\"DATATYPE\")) {\n+                                               return parseDropUserDataType();\n+                                                  } else if (readIf(\"AGGREGATE\")) {\n+                                               return parseDropAggregate();\n+                                                         } else if (readIf(\"SYNONYM\")) {\n+                                                             boolean ifExists = readIfExists(false);\n+                                                             String synonymName = readIdentifierWithSchema();\n+                                                             DropSynonym command = new DropSynonym(session, getSchema());\n+                                                             command.setSynonymName(synonymName);\n+                                                             ifExists = readIfExists(ifExists);\n+                                                             command.setIfExists(ifExists);\n+                                                             return command;\n+                                                         }\n         throw getSyntaxError();\n     }\n \n@@ -1743,63 +1707,63 @@ public class Parser {\n                 }\n                 addJoin(top, join, true, on);\n             } else if (readIf(\"FULL\")) {\n-                throw getSyntaxError();\n-            } else if (readIf(\"INNER\")) {\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                top = readJoin(top);\n-                Expression on = null;\n-                if (readIf(\"ON\")) {\n-                    on = readExpression();\n-                }\n-                addJoin(top, join, false, on);\n-            } else if (readIf(\"JOIN\")) {\n-                join = readTableFilter();\n-                top = readJoin(top);\n-                Expression on = null;\n-                if (readIf(\"ON\")) {\n-                    on = readExpression();\n-                }\n-                addJoin(top, join, false, on);\n-            } else if (readIf(\"CROSS\")) {\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                addJoin(top, join, false, null);\n-            } else if (readIf(\"NATURAL\")) {\n-                read(\"JOIN\");\n-                join = readTableFilter();\n-                Column[] tableCols = last.getTable().getColumns();\n-                Column[] joinCols = join.getTable().getColumns();\n-                String tableSchema = last.getTable().getSchema().getName();\n-                String joinSchema = join.getTable().getSchema().getName();\n-                Expression on = null;\n-                for (Column tc : tableCols) {\n-                    String tableColumnName = tc.getName();\n-                    for (Column c : joinCols) {\n-                        String joinColumnName = c.getName();\n-                        if (equalsToken(tableColumnName, joinColumnName)) {\n-                            join.addNaturalJoinColumn(c);\n-                            Expression tableExpr = new ExpressionColumn(\n-                                    database, tableSchema,\n-                                    last.getTableAlias(), tableColumnName);\n-                            Expression joinExpr = new ExpressionColumn(\n-                                    database, joinSchema, join.getTableAlias(),\n-                                    joinColumnName);\n-                            Expression equal = new Comparison(session,\n-                                    Comparison.EQUAL, tableExpr, joinExpr);\n-                            if (on == null) {\n-                                on = equal;\n-                            } else {\n-                                on = new ConditionAndOr(ConditionAndOr.AND, on,\n-                                        equal);\n-                            }\n-                        }\n-                    }\n-                }\n-                addJoin(top, join, false, on);\n-            } else {\n-                break;\n-            }\n+                       throw getSyntaxError();\n+                   } else if (readIf(\"INNER\")) {\n+                       read(\"JOIN\");\n+                       join = readTableFilter();\n+                       top = readJoin(top);\n+                       Expression on = null;\n+                       if (readIf(\"ON\")) {\n+                           on = readExpression();\n+                       }\n+                       addJoin(top, join, false, on);\n+                   } else if (readIf(\"JOIN\")) {\n+                              join = readTableFilter();\n+                              top = readJoin(top);\n+                              Expression on = null;\n+                              if (readIf(\"ON\")) {\n+                                  on = readExpression();\n+                              }\n+                              addJoin(top, join, false, on);\n+                          } else if (readIf(\"CROSS\")) {\n+                              read(\"JOIN\");\n+                              join = readTableFilter();\n+                              addJoin(top, join, false, null);\n+                          } else if (readIf(\"NATURAL\")) {\n+                                     read(\"JOIN\");\n+                                     join = readTableFilter();\n+                                     Column[] tableCols = last.getTable().getColumns();\n+                                     Column[] joinCols = join.getTable().getColumns();\n+                                     String tableSchema = last.getTable().getSchema().getName();\n+                                     String joinSchema = join.getTable().getSchema().getName();\n+                                     Expression on = null;\n+                                     for (Column tc : tableCols) {\n+                                         String tableColumnName = tc.getName();\n+                                         for (Column c : joinCols) {\n+                                             String joinColumnName = c.getName();\n+                                             if (equalsToken(tableColumnName, joinColumnName)) {\n+                                                 join.addNaturalJoinColumn(c);\n+                                                 Expression tableExpr = new ExpressionColumn(database,\n+                                                     tableSchema,\n+                                                         last.getTableAlias(),\n+                                                             tableColumnName);\n+                                                 Expression joinExpr = new ExpressionColumn(database,\n+                                                     joinSchema,\n+                                                         join.getTableAlias(),\n+                                                             joinColumnName);\n+                                                 Expression equal = new Comparison(session, Comparison.EQUAL, tableExpr, joinExpr);\n+                                                 if (on == null) {\n+                                                     on = equal;\n+                                                 } else {\n+                                                     on = new ConditionAndOr(ConditionAndOr.AND, on, equal);\n+                                                 }\n+                                             }\n+                                         }\n+                                     }\n+                                     addJoin(top, join, false, on);\n+                                 } else {\n+                              break;\n+                                 }\n             last = join;\n         }\n         return top;\n@@ -1815,12 +1779,13 @@ public class Parser {\n      * @param on the join condition\n      * @see TableFilter#addJoin(TableFilter, boolean, Expression)\n      */\n-    private void addJoin(TableFilter top, TableFilter join, boolean outer, Expression on) {\n+\n+    private void addJoin(TableFilter top,\n+            TableFilter join,\n+            boolean outer, Expression on) {\n         if (join.getJoin() != null) {\n             String joinTable = Constants.PREFIX_JOIN + parseIndex;\n-            TableFilter n = new TableFilter(session, getDualTable(true),\n-                    joinTable, rightsChecked, currentSelect, join.getOrderInFrom(),\n-                    null);\n+            TableFilter n = new TableFilter(session, getDualTable(true), joinTable, rightsChecked, currentSelect, join.getOrderInFrom(), null);\n             n.setNestedJoin(join);\n             join = n;\n         }\n@@ -1832,8 +1797,7 @@ public class Parser {\n         String procedureName = readAliasIdentifier();\n         Procedure p = session.getProcedure(procedureName);\n         if (p == null) {\n-            throw DbException.get(ErrorCode.FUNCTION_ALIAS_NOT_FOUND_1,\n-                    procedureName);\n+            throw DbException.get(ErrorCode.FUNCTION_ALIAS_NOT_FOUND_1, procedureName);\n         }\n         command.setProcedure(p);\n         if (readIf(\"(\")) {\n@@ -1872,14 +1836,14 @@ public class Parser {\n         } else if (readIf(\"DELETE\")) {\n             command.setCommand(parseDelete());\n         } else if (readIf(\"UPDATE\")) {\n-            command.setCommand(parseUpdate());\n-        } else if (readIf(\"INSERT\")) {\n-            command.setCommand(parseInsert());\n-        } else if (readIf(\"MERGE\")) {\n-            command.setCommand(parseMerge());\n-        } else {\n-            throw getSyntaxError();\n-        }\n+                   command.setCommand(parseUpdate());\n+               } else if (readIf(\"INSERT\")) {\n+                   command.setCommand(parseInsert());\n+               } else if (readIf(\"MERGE\")) {\n+                          command.setCommand(parseMerge());\n+                      } else {\n+                          throw getSyntaxError();\n+                      }\n         return command;\n     }\n \n@@ -1917,8 +1881,7 @@ public class Parser {\n         return parseSelectUnionExtension(command, start, false);\n     }\n \n-    private Query parseSelectUnionExtension(Query command, int start,\n-            boolean unionOnly) {\n+    private Query parseSelectUnionExtension(Query command, int start, boolean unionOnly) {\n         while (true) {\n             if (readIf(\"UNION\")) {\n                 SelectUnion union = new SelectUnion(session, command);\n@@ -1936,13 +1899,13 @@ public class Parser {\n                 union.setRight(parseSelectSub());\n                 command = union;\n             } else if (readIf(\"INTERSECT\")) {\n-                SelectUnion union = new SelectUnion(session, command);\n-                union.setUnionType(SelectUnion.UnionType.INTERSECT);\n-                union.setRight(parseSelectSub());\n-                command = union;\n-            } else {\n+                       SelectUnion union = new SelectUnion(session, command);\n+                       union.setUnionType(SelectUnion.UnionType.INTERSECT);\n+                       union.setRight(parseSelectSub());\n+                       command = union;\n+                   } else {\n                 break;\n-            }\n+                   }\n         }\n         if (!unionOnly) {\n             parseEndOfQuery(command);\n@@ -1966,8 +1929,7 @@ public class Parser {\n                 }\n                 SelectOrderBy order = new SelectOrderBy();\n                 Expression expr = readExpression();\n-                if (canBeNumber && expr instanceof ValueExpression &&\n-                        expr.getType() == Value.INT) {\n+                if (canBeNumber && expr instanceof ValueExpression && expr.getType() == Value.INT) {\n                     order.columnIndexExpr = expr;\n                 } else if (expr instanceof Parameter) {\n                     recompileAlways = true;\n@@ -2020,7 +1982,6 @@ public class Parser {\n                 }\n                 read(\"ONLY\");\n             }\n-\n             currentSelect = temp;\n         }\n         if (readIf(\"LIMIT\")) {\n@@ -2053,6 +2014,7 @@ public class Parser {\n                     } while (readIf(\",\"));\n                 } else if (readIf(\"NOWAIT\")) {\n                     // TODO parser: select for update nowait: should not wait\n+\n                 }\n                 command.setForUpdate(true);\n             } else if (readIf(\"READ\") || readIf(\"FETCH\")) {\n@@ -2067,6 +2029,7 @@ public class Parser {\n     /**\n      * DB2 isolation clause\n      */\n+\n     private void parseIsolationClause() {\n         if (readIf(\"WITH\")) {\n             if (readIf(\"RR\") || readIf(\"RS\")) {\n@@ -2074,14 +2037,15 @@ public class Parser {\n                 if (readIf(\"USE\")) {\n                     read(\"AND\");\n                     read(\"KEEP\");\n-                    if (readIf(\"SHARE\") || readIf(\"UPDATE\") ||\n-                            readIf(\"EXCLUSIVE\")) {\n+                    if (readIf(\"SHARE\") || readIf(\"UPDATE\") || readIf(\"EXCLUSIVE\")) {\n                         // ignore\n+\n                     }\n                     read(\"LOCKS\");\n                 }\n             } else if (readIf(\"CS\") || readIf(\"UR\")) {\n                 // ignore\n+\n             }\n         }\n     }\n@@ -2097,8 +2061,7 @@ public class Parser {\n             try {\n                 query = (Query) parseWith();\n             } catch (ClassCastException e) {\n-                throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n-                        \"WITH statement supports only SELECT (query) in this context\");\n+                throw DbException.get(ErrorCode.SYNTAX_ERROR_1, \"WITH statement supports only SELECT (query) in this context\");\n             }\n             // recursive can not be lazy\n             query.setNeverLazy(true);\n@@ -2149,6 +2112,8 @@ public class Parser {\n      * @param o2 the second table filter\n      * @return -1 if o1 appears first, and 1 if o2 appears first\n      */\n+\n+\n     static int compareTableFilters(TableFilter o1, TableFilter o2) {\n         assert o1.getOrderInFrom() != o2.getOrderInFrom();\n         return o1.getOrderInFrom() > o2.getOrderInFrom() ? 1 : -1;\n@@ -2254,9 +2219,7 @@ public class Parser {\n                 // select without FROM: convert to SELECT ... FROM\n                 // SYSTEM_RANGE(1,1)\n                 Table dual = getDualTable(false);\n-                TableFilter filter = new TableFilter(session, dual, null,\n-                        rightsChecked, currentSelect, 0,\n-                        null);\n+                TableFilter filter = new TableFilter(session, dual, null, rightsChecked, currentSelect, 0, null);\n                 command.addTableFilter(filter, true);\n             } else {\n                 parseSelectSimpleFromPart(command);\n@@ -2339,8 +2302,7 @@ public class Parser {\n             read(\",\");\n             Expression r2 = readConcat();\n             read(\")\");\n-            return new Comparison(session, Comparison.SPATIAL_INTERSECTS, r1,\n-                    r2);\n+            return new Comparison(session, Comparison.SPATIAL_INTERSECTS, r1, r2);\n         }\n         Expression r = readConcat();\n         while (true) {\n@@ -2378,136 +2340,123 @@ public class Parser {\n                 recompileAlways = true;\n                 r = new CompareLike(database, r, b, esc, false);\n             } else if (readIf(\"REGEXP\")) {\n-                Expression b = readConcat();\n-                recompileAlways = true;\n-                r = new CompareLike(database, r, b, null, true);\n-            } else if (readIf(\"IS\")) {\n-                if (readIf(\"NOT\")) {\n-                    if (readIf(\"NULL\")) {\n-                        r = new Comparison(session, Comparison.IS_NOT_NULL, r,\n-                                null);\n-                    } else if (readIf(\"DISTINCT\")) {\n-                        read(\"FROM\");\n-                        r = new Comparison(session, Comparison.EQUAL_NULL_SAFE,\n-                                r, readConcat());\n-                    } else {\n-                        r = new Comparison(session,\n-                                Comparison.NOT_EQUAL_NULL_SAFE, r, readConcat());\n-                    }\n-                } else if (readIf(\"NULL\")) {\n-                    r = new Comparison(session, Comparison.IS_NULL, r, null);\n-                } else if (readIf(\"DISTINCT\")) {\n-                    read(\"FROM\");\n-                    r = new Comparison(session, Comparison.NOT_EQUAL_NULL_SAFE,\n-                            r, readConcat());\n-                } else {\n-                    r = new Comparison(session, Comparison.EQUAL_NULL_SAFE, r,\n-                            readConcat());\n-                }\n-            } else if (readIf(\"IN\")) {\n-                read(\"(\");\n-                if (readIf(\")\")) {\n-                    if (database.getMode().prohibitEmptyInPredicate) {\n-                        throw getSyntaxError();\n-                    }\n-                    r = ValueExpression.get(ValueBoolean.get(false));\n-                } else {\n-                    if (isSelect()) {\n-                        Query query = parseSelect();\n+                       Expression b = readConcat();\n+                       recompileAlways = true;\n+                       r = new CompareLike(database, r, b, null, true);\n+                   } else if (readIf(\"IS\")) {\n+                       if (readIf(\"NOT\")) {\n+                           if (readIf(\"NULL\")) {\n+                               r = new Comparison(session, Comparison.IS_NOT_NULL, r, null);\n+                           } else if (readIf(\"DISTINCT\")) {\n+                               read(\"FROM\");\n+                               r = new Comparison(session, Comparison.EQUAL_NULL_SAFE, r, readConcat());\n+                           } else {\n+                               r = new Comparison(session, Comparison.NOT_EQUAL_NULL_SAFE, r, readConcat());\n+                           }\n+                       } else if (readIf(\"NULL\")) {\n+                           r = new Comparison(session, Comparison.IS_NULL, r, null);\n+                       } else if (readIf(\"DISTINCT\")) {\n+                                  read(\"FROM\");\n+                                  r = new Comparison(session, Comparison.NOT_EQUAL_NULL_SAFE, r, readConcat());\n+                              } else {\n+                                  r = new Comparison(session, Comparison.EQUAL_NULL_SAFE, r, readConcat());\n+                              }\n+                   } else if (readIf(\"IN\")) {\n+                              read(\"(\");\n+                              if (readIf(\")\")) {\n+                                  if (database.getMode().prohibitEmptyInPredicate) {\n+                                      throw getSyntaxError();\n+                                  }\n+                                  r = ValueExpression.get(ValueBoolean.get(false));\n+                              } else {\n+                                  if (isSelect()) {\n+                                      Query query = parseSelect();\n                         // can not be lazy because we have to call\n                         // method ResultInterface.containsDistinct\n                         // which is not supported for lazy execution\n-                        query.setNeverLazy(true);\n-                        r = new ConditionInSelect(database, r, query, false,\n-                                Comparison.EQUAL);\n-                    } else {\n-                        ArrayList<Expression> v = New.arrayList();\n-                        Expression last;\n-                        do {\n-                            last = readExpression();\n-                            v.add(last);\n-                        } while (readIf(\",\"));\n-                        if (v.size() == 1 && (last instanceof Subquery)) {\n-                            Subquery s = (Subquery) last;\n-                            Query q = s.getQuery();\n-                            r = new ConditionInSelect(database, r, q, false,\n-                                    Comparison.EQUAL);\n-                        } else {\n-                            r = new ConditionIn(database, r, v);\n-                        }\n-                    }\n-                    read(\")\");\n-                }\n-            } else if (readIf(\"BETWEEN\")) {\n-                Expression low = readConcat();\n-                read(\"AND\");\n-                Expression high = readConcat();\n-                Expression condLow = new Comparison(session,\n-                        Comparison.SMALLER_EQUAL, low, r);\n-                Expression condHigh = new Comparison(session,\n-                        Comparison.BIGGER_EQUAL, high, r);\n-                r = new ConditionAndOr(ConditionAndOr.AND, condLow, condHigh);\n-            } else {\n-                int compareType = getCompareType(currentTokenType);\n-                if (compareType < 0) {\n-                    break;\n-                }\n-                read();\n-                if (readIf(\"ALL\")) {\n-                    read(\"(\");\n-                    Query query = parseSelect();\n-                    r = new ConditionInSelect(database, r, query, true,\n-                            compareType);\n-                    read(\")\");\n-                } else if (readIf(\"ANY\") || readIf(\"SOME\")) {\n-                    read(\"(\");\n-                    if (currentTokenType == PARAMETER && compareType == 0) {\n-                        Parameter p = readParameter();\n-                        r = new ConditionInParameter(database, r, p);\n-                    } else {\n-                        Query query = parseSelect();\n-                        r = new ConditionInSelect(database, r, query, false,\n-                                compareType);\n-                    }\n-                    read(\")\");\n-                } else {\n-                    Expression right = readConcat();\n-                    if (SysProperties.OLD_STYLE_OUTER_JOIN &&\n-                            readIf(\"(\") && readIf(\"+\") && readIf(\")\")) {\n+                                      query.setNeverLazy(true);\n+                                      r = new ConditionInSelect(database, r, query, false, Comparison.EQUAL);\n+                                  } else {\n+                                      ArrayList<Expression> v = New.arrayList();\n+                                      Expression last;\n+                                      do {\n+                                          last = readExpression();\n+                                          v.add(last);\n+                                      } while (readIf(\",\"));\n+                                      if (v.size() == 1 && (last instanceof Subquery)) {\n+                                          Subquery s = (Subquery) last;\n+                                          Query q = s.getQuery();\n+                                          r = new ConditionInSelect(database, r, q, false, Comparison.EQUAL);\n+                                      } else {\n+                                          r = new ConditionIn(database, r, v);\n+                                      }\n+                                  }\n+                                  read(\")\");\n+                              }\n+                          } else if (readIf(\"BETWEEN\")) {\n+                              Expression low = readConcat();\n+                              read(\"AND\");\n+                              Expression high = readConcat();\n+                              Expression condLow = new Comparison(session, Comparison.SMALLER_EQUAL, low, r);\n+                              Expression condHigh = new Comparison(session, Comparison.BIGGER_EQUAL, high, r);\n+                              r = new ConditionAndOr(ConditionAndOr.AND, condLow, condHigh);\n+                          } else {\n+                              int compareType = getCompareType(currentTokenType);\n+                              if (compareType < 0) {\n+                                  break;\n+                              }\n+                              read();\n+                              if (readIf(\"ALL\")) {\n+                                  read(\"(\");\n+                                  Query query = parseSelect();\n+                                  r = new ConditionInSelect(database, r, query, true, compareType);\n+                                  read(\")\");\n+                              } else if (readIf(\"ANY\") || readIf(\"SOME\")) {\n+                                  read(\"(\");\n+                                  if (currentTokenType == PARAMETER && compareType == 0) {\n+                                      Parameter p = readParameter();\n+                                      r = new ConditionInParameter(database, r, p);\n+                                  } else {\n+                                      Query query = parseSelect();\n+                                      r = new ConditionInSelect(database, r, query, false, compareType);\n+                                  }\n+                                  read(\")\");\n+                              } else {\n+                                  Expression right = readConcat();\n+                                  if (SysProperties.OLD_STYLE_OUTER_JOIN && readIf(\"(\")\n+                                  && readIf(\"+\") && readIf(\")\")) {\n                         // support for a subset of old-fashioned Oracle outer\n                         // join with (+)\n-                        if (r instanceof ExpressionColumn &&\n-                                right instanceof ExpressionColumn) {\n-                            ExpressionColumn leftCol = (ExpressionColumn) r;\n-                            ExpressionColumn rightCol = (ExpressionColumn) right;\n-                            ArrayList<TableFilter> filters = currentSelect\n-                                    .getTopFilters();\n-                            for (TableFilter f : filters) {\n-                                while (f != null) {\n-                                    leftCol.mapColumns(f, 0);\n-                                    rightCol.mapColumns(f, 0);\n-                                    f = f.getJoin();\n-                                }\n-                            }\n-                            TableFilter leftFilter = leftCol.getTableFilter();\n-                            TableFilter rightFilter = rightCol.getTableFilter();\n-                            r = new Comparison(session, compareType, r, right);\n-                            if (leftFilter != null && rightFilter != null) {\n-                                int idx = filters.indexOf(rightFilter);\n-                                if (idx >= 0) {\n-                                    filters.remove(idx);\n-                                    leftFilter.addJoin(rightFilter, true, r);\n-                                } else {\n-                                    rightFilter.mapAndAddFilter(r);\n-                                }\n-                                r = ValueExpression.get(ValueBoolean.get(true));\n-                            }\n-                        }\n-                    } else {\n-                        r = new Comparison(session, compareType, r, right);\n-                    }\n-                }\n-            }\n+                                      if (r instanceof ExpressionColumn && right instanceof ExpressionColumn) {\n+                                          ExpressionColumn leftCol = (ExpressionColumn) r;\n+                                          ExpressionColumn rightCol = (ExpressionColumn) right;\n+                                          ArrayList<TableFilter> filters = currentSelect.getTopFilters();\n+                                          for (TableFilter f : filters) {\n+                                              while (f != null) {\n+                                                  leftCol.mapColumns(f, 0);\n+                                                  rightCol.mapColumns(f, 0);\n+                                                  f = f.getJoin();\n+                                              }\n+                                          }\n+                                          TableFilter leftFilter = leftCol.getTableFilter();\n+                                          TableFilter rightFilter = rightCol.getTableFilter();\n+                                          r = new Comparison(session, compareType, r, right);\n+                                          if (leftFilter != null && rightFilter != null) {\n+                                              int idx = filters.indexOf(rightFilter);\n+                                              if (idx >= 0) {\n+                                                  filters.remove(idx);\n+                                                  leftFilter.addJoin(rightFilter, true, r);\n+                                              } else {\n+                                                  rightFilter.mapAndAddFilter(r);\n+                                              }\n+                                              r = ValueExpression.get(ValueBoolean.get(true));\n+                                          }\n+                                      }\n+                                  } else {\n+                                      r = new Comparison(session, compareType, r, right);\n+                                  }\n+                              }\n+                          }\n             if (not) {\n                 r = new ConditionNot(r);\n             }\n@@ -2523,25 +2472,22 @@ public class Parser {\n             } else if (readIf(\"~\")) {\n                 if (readIf(\"*\")) {\n                     Function function = Function.getFunction(database, \"CAST\");\n-                    function.setDataType(new Column(\"X\",\n-                            Value.STRING_IGNORECASE));\n+                    function.setDataType(new Column(\"X\", Value.STRING_IGNORECASE));\n                     function.setParameter(0, r);\n                     r = function;\n                 }\n                 r = new CompareLike(database, r, readSum(), null, true);\n             } else if (readIf(\"!~\")) {\n-                if (readIf(\"*\")) {\n-                    Function function = Function.getFunction(database, \"CAST\");\n-                    function.setDataType(new Column(\"X\",\n-                            Value.STRING_IGNORECASE));\n-                    function.setParameter(0, r);\n-                    r = function;\n-                }\n-                r = new ConditionNot(new CompareLike(database, r, readSum(),\n-                        null, true));\n-            } else {\n-                return r;\n-            }\n+                       if (readIf(\"*\")) {\n+                           Function function = Function.getFunction(database, \"CAST\");\n+                           function.setDataType(new Column(\"X\", Value.STRING_IGNORECASE));\n+                           function.setParameter(0, r);\n+                           r = function;\n+                       }\n+                       r = new ConditionNot(new CompareLike(database, r, readSum(), null, true));\n+                   } else {\n+                       return r;\n+                   }\n         }\n     }\n \n@@ -2566,10 +2512,10 @@ public class Parser {\n             } else if (readIf(\"/\")) {\n                 r = new Operation(OpType.DIVIDE, r, readTerm());\n             } else if (readIf(\"%\")) {\n-                r = new Operation(OpType.MODULUS, r, readTerm());\n-            } else {\n-                return r;\n-            }\n+                       r = new Operation(OpType.MODULUS, r, readTerm());\n+                   } else {\n+                       return r;\n+                   }\n         }\n     }\n \n@@ -2581,51 +2527,49 @@ public class Parser {\n         Aggregate r;\n         if (aggregateType == AggregateType.COUNT) {\n             if (readIf(\"*\")) {\n-                r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect,\n-                        false);\n+                r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect, false);\n             } else {\n                 boolean distinct = readIf(\"DISTINCT\");\n                 Expression on = readExpression();\n                 if (on instanceof Wildcard && !distinct) {\n                     // PostgreSQL compatibility: count(t.*)\n-                    r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect,\n-                            false);\n+                    r = new Aggregate(AggregateType.COUNT_ALL, null, currentSelect, false);\n                 } else {\n-                    r = new Aggregate(AggregateType.COUNT, on, currentSelect,\n-                            distinct);\n+                    r = new Aggregate(AggregateType.COUNT, on, currentSelect, distinct);\n                 }\n             }\n         } else if (aggregateType == AggregateType.GROUP_CONCAT) {\n-            boolean distinct = readIf(\"DISTINCT\");\n-\n-            if (equalsToken(\"GROUP_CONCAT\", aggregateName)) {\n-                r = new Aggregate(AggregateType.GROUP_CONCAT,\n-                    readExpression(), currentSelect, distinct);\n-                if (readIf(\"ORDER\")) {\n-                    read(\"BY\");\n-                    r.setGroupConcatOrder(parseSimpleOrderList());\n-                }\n-\n-                if (readIf(\"SEPARATOR\")) {\n-                    r.setGroupConcatSeparator(readExpression());\n-                }\n-            } else if (equalsToken(\"STRING_AGG\", aggregateName)) {\n-                // PostgreSQL compatibility: string_agg(expression, delimiter)\n-                r = new Aggregate(AggregateType.GROUP_CONCAT,\n-                    readExpression(), currentSelect, distinct);\n-                read(\",\");\n+        boolean distinct = readIf(\"DISTINCT\");\n+        if (equalsToken(\"GROUP_CONCAT\", aggregateName)) {\n+            r = new Aggregate(AggregateType.GROUP_CONCAT,\n+                readExpression(),\n+                    currentSelect,\n+                        distinct);\n+            if (readIf(\"ORDER\")) {\n+                read(\"BY\");\n+                r.setGroupConcatOrder(parseSimpleOrderList());\n+            }\n+            if (readIf(\"SEPARATOR\")) {\n                 r.setGroupConcatSeparator(readExpression());\n-                if (readIf(\"ORDER\")) {\n-                    read(\"BY\");\n-                    r.setGroupConcatOrder(parseSimpleOrderList());\n-                }\n-            } else {\n-                r = null;\n             }\n+        } else if (equalsToken(\"STRING_AGG\", aggregateName)) {\n+                // PostgreSQL compatibility: string_agg(expression, delimiter)\n+            r = new Aggregate(AggregateType.GROUP_CONCAT,\n+                readExpression(),\n+                    currentSelect,\n+                        distinct);\n+            read(\",\");\n+            r.setGroupConcatSeparator(readExpression());\n+            if (readIf(\"ORDER\")) {\n+                read(\"BY\");\n+                r.setGroupConcatOrder(parseSimpleOrderList());\n+            }\n+        } else {\n+            r = null;\n+        }\n         } else {\n             boolean distinct = readIf(\"DISTINCT\");\n-            r = new Aggregate(aggregateType, readExpression(), currentSelect,\n-                    distinct);\n+            r = new Aggregate(aggregateType, readExpression(), currentSelect, distinct);\n         }\n         read(\")\");\n         if (r != null && readIf(\"FILTER\")) {\n@@ -2659,8 +2603,7 @@ public class Parser {\n         if (schema != null) {\n             functionAlias = schema.findFunction(functionName);\n         } else {\n-            functionAlias = findFunctionAlias(session.getCurrentSchemaName(),\n-                    functionName);\n+            functionAlias = findFunctionAlias(session.getCurrentSchemaName(), functionName);\n         }\n         if (functionAlias == null) {\n             throw DbException.get(ErrorCode.FUNCTION_NOT_FOUND_1, functionName);\n@@ -2750,8 +2693,7 @@ public class Parser {\n             break;\n         }\n         case Function.EXTRACT: {\n-            function.setParameter(0,\n-                    ValueExpression.get(ValueString.get(currentToken)));\n+            function.setParameter(0, ValueExpression.get(ValueString.get(currentToken)));\n             read();\n             read(\"FROM\");\n             function.setParameter(1, readExpression());\n@@ -2761,8 +2703,7 @@ public class Parser {\n         case Function.DATE_ADD:\n         case Function.DATE_DIFF: {\n             if (Function.isDatePart(currentToken)) {\n-                function.setParameter(0,\n-                        ValueExpression.get(ValueString.get(currentToken)));\n+                function.setParameter(0, ValueExpression.get(ValueString.get(currentToken)));\n                 read();\n             } else {\n                 function.setParameter(0, readExpression());\n@@ -2825,11 +2766,11 @@ public class Parser {\n                     read(\"FROM\");\n                 }\n             } else if (readIf(\"BOTH\")) {\n-                if (!readIf(\"FROM\")) {\n-                    space = readExpression();\n-                    read(\"FROM\");\n-                }\n-            }\n+                       if (!readIf(\"FROM\")) {\n+                           space = readExpression();\n+                           read(\"FROM\");\n+                       }\n+                   }\n             Expression p0 = readExpression();\n             if (readIf(\",\")) {\n                 space = readExpression();\n@@ -2869,8 +2810,7 @@ public class Parser {\n             if (currentSelect == null && currentPrepared == null) {\n                 throw getSyntaxError();\n             }\n-            return new Rownum(currentSelect == null ? currentPrepared\n-                    : currentSelect);\n+            return new Rownum(currentSelect == null ? currentPrepared : currentSelect);\n         default:\n             if (!readIf(\")\")) {\n                 int i = 0;\n@@ -2900,8 +2840,7 @@ public class Parser {\n         return function;\n     }\n \n-    private Expression readWildcardOrSequenceValue(String schema,\n-            String objectName) {\n+    private Expression readWildcardOrSequenceValue(String schema, String objectName) {\n         if (readIf(\"*\")) {\n             return new Wildcard(schema, objectName);\n         }\n@@ -2917,10 +2856,10 @@ public class Parser {\n             Sequence sequence = findSequence(schema, objectName);\n             if (sequence != null) {\n                 Function function = Function.getFunction(database, \"CURRVAL\");\n-                function.setParameter(0, ValueExpression.get(ValueString\n-                        .get(sequence.getSchema().getName())));\n-                function.setParameter(1, ValueExpression.get(ValueString\n-                        .get(sequence.getName())));\n+                function.setParameter(0,\n+ValueExpression.get(ValueString.get(sequence.getSchema().getName())));\n+                function.setParameter(1,\n+ValueExpression.get(ValueString.get(sequence.getName())));\n                 function.doneWithParameters();\n                 return function;\n             }\n@@ -2953,16 +2892,14 @@ public class Parser {\n             if (readIf(\"(\")) {\n                 String databaseName = schema;\n                 if (!equalsToken(database.getShortName(), databaseName)) {\n-                    throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n-                            databaseName);\n+                    throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1, databaseName);\n                 }\n                 schema = objectName;\n                 return readFunction(database.getSchema(schema), name);\n             } else if (readIf(\".\")) {\n                 String databaseName = schema;\n                 if (!equalsToken(database.getShortName(), databaseName)) {\n-                    throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1,\n-                            databaseName);\n+                    throw DbException.get(ErrorCode.DATABASE_NOT_FOUND_1, databaseName);\n                 }\n                 schema = objectName;\n                 objectName = name;\n@@ -2981,7 +2918,6 @@ public class Parser {\n     private Parameter readParameter() {\n         // there must be no space between ? and the number\n         boolean indexed = Character.isDigit(sqlCommandChars[parseIndex]);\n-\n         Parameter p;\n         if (indexed) {\n             readParameterIndex();\n@@ -2991,15 +2927,13 @@ public class Parser {\n                     // example check constraints)\n                     throw getSyntaxError();\n                 } else if (!parameters.isEmpty()) {\n-                    throw DbException\n-                            .get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n+                    throw DbException.get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n                 }\n                 indexedParameterList = New.arrayList();\n             }\n             int index = currentValue.getInt() - 1;\n             if (index < 0 || index >= Constants.MAX_PARAMETER_INDEX) {\n-                throw DbException.getInvalidValueException(\n-                        \"parameter index\", index);\n+                throw DbException.getInvalidValueException(\"parameter index\", index);\n             }\n             if (indexedParameterList.size() <= index) {\n                 indexedParameterList.ensureCapacity(index + 1);\n@@ -3016,8 +2950,7 @@ public class Parser {\n         } else {\n             read();\n             if (indexedParameterList != null) {\n-                throw DbException\n-                        .get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n+                throw DbException.get(ErrorCode.CANNOT_MIX_INDEXED_AND_UNINDEXED_PARAMS);\n             }\n             p = new Parameter(parameters.size());\n         }\n@@ -3071,138 +3004,128 @@ public class Parser {\n                     // not\n                     r = readCase();\n                 } else if (readIf(\"(\")) {\n-                    r = readFunction(null, name);\n-                } else if (equalsToken(\"CURRENT_USER\", name)) {\n-                    r = readFunctionWithoutParameters(\"USER\");\n-                } else if (equalsToken(\"CURRENT_TIMESTAMP\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                } else if (equalsToken(\"SYSDATE\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                } else if (equalsToken(\"SYSTIMESTAMP\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                } else if (equalsToken(\"CURRENT_DATE\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n-                } else if (equalsToken(\"TODAY\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n-                } else if (equalsToken(\"CURRENT_TIME\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n-                } else if (equalsToken(\"SYSTIME\", name)) {\n-                    r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n-                } else if (equalsToken(\"CURRENT\", name)) {\n-                    if (readIf(\"TIMESTAMP\")) {\n-                        r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n-                    } else if (readIf(\"TIME\")) {\n-                        r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n-                    } else if (readIf(\"DATE\")) {\n-                        r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n-                    } else {\n-                        r = new ExpressionColumn(database, null, null, name);\n-                    }\n-                } else if (equalsToken(\"NEXT\", name) && readIf(\"VALUE\")) {\n-                    read(\"FOR\");\n-                    Sequence sequence = readSequence();\n-                    r = new SequenceValue(sequence);\n-                } else if (equalsToken(\"TIME\", name)) {\n-                    boolean without = readIf(\"WITHOUT\");\n-                    if (without) {\n-                        read(\"TIME\");\n-                        read(\"ZONE\");\n-                    }\n-                    if (currentTokenType != VALUE\n-                            || currentValue.getType() != Value.STRING) {\n-                        if (without) {\n-                            throw getSyntaxError();\n-                        }\n-                        r = new ExpressionColumn(database, null, null, name);\n-                    } else {\n-                        String time = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueTime.parse(time));\n-                    }\n-                } else if (equalsToken(\"TIMESTAMP\", name)) {\n-                    if (readIf(\"WITH\")) {\n-                        read(\"TIME\");\n-                        read(\"ZONE\");\n-                        if (currentTokenType != VALUE\n-                                || currentValue.getType() != Value.STRING) {\n-                            throw getSyntaxError();\n-                        }\n-                        String timestamp = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueTimestampTimeZone.parse(timestamp));\n-                    } else {\n-                        boolean without = readIf(\"WITHOUT\");\n-                        if (without) {\n-                            read(\"TIME\");\n-                            read(\"ZONE\");\n-                        }\n-                        if (currentTokenType != VALUE\n-                                || currentValue.getType() != Value.STRING) {\n-                            if (without) {\n-                                throw getSyntaxError();\n-                            }\n-                            r = new ExpressionColumn(database, null, null, name);\n-                        } else {\n-                            String timestamp = currentValue.getString();\n-                            read();\n-                            r = ValueExpression.get(ValueTimestamp.parse(timestamp, database.getMode()));\n-                        }\n-                    }\n-                } else if (currentTokenType == VALUE &&\n-                        currentValue.getType() == Value.STRING) {\n-                    if (equalsToken(\"DATE\", name) ||\n-                            equalsToken(\"D\", name)) {\n-                        String date = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueDate.parse(date));\n-                    } else if (equalsToken(\"T\", name)) {\n-                        String time = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueTime.parse(time));\n-                    } else if (equalsToken(\"TS\", name)) {\n-                        String timestamp = currentValue.getString();\n-                        read();\n-                        r = ValueExpression\n-                                .get(ValueTimestamp.parse(timestamp, database.getMode()));\n-                    } else if (equalsToken(\"X\", name)) {\n-                        read();\n-                        byte[] buffer = StringUtils\n-                                .convertHexToBytes(currentValue.getString());\n-                        r = ValueExpression.get(ValueBytes.getNoCopy(buffer));\n-                    } else if (equalsToken(\"E\", name)) {\n-                        String text = currentValue.getString();\n+                           r = readFunction(null, name);\n+                       } else if (equalsToken(\"CURRENT_USER\", name)) {\n+                           r = readFunctionWithoutParameters(\"USER\");\n+                       } else if (equalsToken(\"CURRENT_TIMESTAMP\", name)) {\n+                                  r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+                              } else if (equalsToken(\"SYSDATE\", name)) {\n+                                  r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+                              } else if (equalsToken(\"SYSTIMESTAMP\", name)) {\n+                                         r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+                                     } else if (equalsToken(\"CURRENT_DATE\", name)) {\n+                                         r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n+                                     } else if (equalsToken(\"TODAY\", name)) {\n+                                                r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n+                                            } else if (equalsToken(\"CURRENT_TIME\", name)) {\n+                                                r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n+                                            } else if (equalsToken(\"SYSTIME\", name)) {\n+                                                       r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n+                                                   } else if (equalsToken(\"CURRENT\", name)) {\n+                                                       if (readIf(\"TIMESTAMP\")) {\n+                                                           r = readFunctionWithoutParameters(\"CURRENT_TIMESTAMP\");\n+                                                       } else if (readIf(\"TIME\")) {\n+                                                           r = readFunctionWithoutParameters(\"CURRENT_TIME\");\n+                                                       } else if (readIf(\"DATE\")) {\n+                                                                  r = readFunctionWithoutParameters(\"CURRENT_DATE\");\n+                                                              } else {\n+                                                                  r = new ExpressionColumn(database, null, null, name);\n+                                                              }\n+                                                   } else if (equalsToken(\"NEXT\", name) && readIf(\"VALUE\")) {\n+                                                              read(\"FOR\");\n+                                                              Sequence sequence = readSequence();\n+                                                              r = new SequenceValue(sequence);\n+                                                          } else if (equalsToken(\"TIME\", name)) {\n+                                                       boolean without = readIf(\"WITHOUT\");\n+                                                       if (without) {\n+                                                           read(\"TIME\");\n+                                                           read(\"ZONE\");\n+                                                       }\n+                                                       if (currentTokenType != VALUE || currentValue.getType() != Value.STRING) {\n+                                                           if (without) {\n+                                                               throw getSyntaxError();\n+                                                           }\n+                                                           r = new ExpressionColumn(database, null, null, name);\n+                                                       } else {\n+                                                           String time = currentValue.getString();\n+                                                           read();\n+                                                           r = ValueExpression.get(ValueTime.parse(time));\n+                                                       }\n+                                                          } else if (equalsToken(\"TIMESTAMP\", name)) {\n+                                                                     if (readIf(\"WITH\")) {\n+                                                                         read(\"TIME\");\n+                                                                         read(\"ZONE\");\n+                                                                         if (currentTokenType != VALUE || currentValue.getType() != Value.STRING) {\n+                                                                             throw getSyntaxError();\n+                                                                         }\n+                                                                         String timestamp = currentValue.getString();\n+                                                                         read();\n+                                                                         r = ValueExpression.get(ValueTimestampTimeZone.parse(timestamp));\n+                                                                     } else {\n+                                                                         boolean without = readIf(\"WITHOUT\");\n+                                                                         if (without) {\n+                                                                             read(\"TIME\");\n+                                                                             read(\"ZONE\");\n+                                                                         }\n+                                                                         if (currentTokenType != VALUE || currentValue.getType() != Value.STRING) {\n+                                                                             if (without) {\n+                                                                                 throw getSyntaxError();\n+                                                                             }\n+                                                                             r = new ExpressionColumn(database, null, null, name);\n+                                                                         } else {\n+                                                                             String timestamp = currentValue.getString();\n+                                                                             read();\n+                                                                             r = ValueExpression.get(ValueTimestamp.parse(timestamp, database.getMode()));\n+                                                                         }\n+                                                                     }\n+                                                                 } else if (currentTokenType == VALUE && currentValue.getType() == Value.STRING) {\n+                                                                     if (equalsToken(\"DATE\", name) || equalsToken(\"D\", name)) {\n+                                                                         String date = currentValue.getString();\n+                                                                         read();\n+                                                                         r = ValueExpression.get(ValueDate.parse(date));\n+                                                                     } else if (equalsToken(\"T\", name)) {\n+                                                                         String time = currentValue.getString();\n+                                                                         read();\n+                                                                         r = ValueExpression.get(ValueTime.parse(time));\n+                                                                     } else if (equalsToken(\"TS\", name)) {\n+                                                                                String timestamp = currentValue.getString();\n+                                                                                read();\n+                                                                                r = ValueExpression.get(ValueTimestamp.parse(timestamp, database.getMode()));\n+                                                                            } else if (equalsToken(\"X\", name)) {\n+                                                                                read();\n+                                                                                byte[] buffer = StringUtils.convertHexToBytes(currentValue.getString());\n+                                                                                r = ValueExpression.get(ValueBytes.getNoCopy(buffer));\n+                                                                            } else if (equalsToken(\"E\", name)) {\n+                                                                                       String text = currentValue.getString();\n                         // the PostgreSQL ODBC driver uses\n                         // LIKE E'PROJECT\\\\_DATA' instead of LIKE\n                         // 'PROJECT\\_DATA'\n                         // N: SQL-92 \"National Language\" strings\n-                        text = StringUtils.replaceAll(text, \"\\\\\\\\\", \"\\\\\");\n-                        read();\n-                        r = ValueExpression.get(ValueString.get(text));\n-                    } else if (equalsToken(\"N\", name)) {\n+                                                                                       text = StringUtils.replaceAll(text, \"\\\\\\\\\", \"\\\\\");\n+                                                                                       read();\n+                                                                                       r = ValueExpression.get(ValueString.get(text));\n+                                                                                   } else if (equalsToken(\"N\", name)) {\n                         // SQL-92 \"National Language\" strings\n-                        String text = currentValue.getString();\n-                        read();\n-                        r = ValueExpression.get(ValueString.get(text));\n-                    } else {\n-                        r = new ExpressionColumn(database, null, null, name);\n-                    }\n-                } else {\n-                    r = new ExpressionColumn(database, null, null, name);\n-                }\n+                                                                                       String text = currentValue.getString();\n+                                                                                       read();\n+                                                                                       r = ValueExpression.get(ValueString.get(text));\n+                                                                                   } else {\n+                                                                                       r = new ExpressionColumn(database, null, null, name);\n+                                                                                   }\n+                                                                 } else {\n+                                                                     r = new ExpressionColumn(database, null, null, name);\n+                                                                 }\n             }\n             break;\n         case MINUS:\n             read();\n             if (currentTokenType == VALUE) {\n                 r = ValueExpression.get(currentValue.negate());\n-                if (r.getType() == Value.LONG &&\n-                        r.getValue(session).getLong() == Integer.MIN_VALUE) {\n+                if (r.getType() == Value.LONG && r.getValue(session).getLong() == Integer.MIN_VALUE) {\n                     // convert Integer.MIN_VALUE to type 'int'\n                     // (Integer.MAX_VALUE+1 is of type 'long')\n                     r = ValueExpression.get(ValueInt.get(Integer.MIN_VALUE));\n-                } else if (r.getType() == Value.DECIMAL &&\n-                        r.getValue(session).getBigDecimal()\n-                                .compareTo(ValueLong.MIN_BD) == 0) {\n+                } else if (r.getType() == Value.DECIMAL && r.getValue(session).getBigDecimal().compareTo(ValueLong.MIN_BD) == 0) {\n                     // convert Long.MIN_VALUE to type 'long'\n                     // (Long.MAX_VALUE+1 is of type 'decimal')\n                     r = ValueExpression.get(ValueLong.MIN);\n@@ -3255,8 +3178,7 @@ public class Parser {\n             if (currentSelect == null && currentPrepared == null) {\n                 throw getSyntaxError();\n             }\n-            r = new Rownum(currentSelect == null ? currentPrepared\n-                    : currentSelect);\n+            r = new Rownum(currentSelect == null ? currentPrepared : currentSelect);\n             break;\n         case NULL:\n             read();\n@@ -3273,8 +3195,7 @@ public class Parser {\n             Function function = Function.getFunction(database, \"ARRAY_GET\");\n             function.setParameter(0, r);\n             r = readExpression();\n-            r = new Operation(OpType.PLUS, r, ValueExpression.get(ValueInt\n-                    .get(1)));\n+            r = new Operation(OpType.PLUS, r, ValueExpression.get(ValueInt.get(1)));\n             function.setParameter(1, r);\n             r = function;\n             read(\"]\");\n@@ -3286,8 +3207,7 @@ public class Parser {\n                 read(\".\");\n             }\n             if (readIf(\"REGCLASS\")) {\n-                FunctionAlias f = findFunctionAlias(Constants.SCHEMA_MAIN,\n-                        \"PG_GET_OID\");\n+                FunctionAlias f = findFunctionAlias(Constants.SCHEMA_MAIN, \"PG_GET_OID\");\n                 if (f == null) {\n                     throw getSyntaxError();\n                 }\n@@ -3415,7 +3335,7 @@ public class Parser {\n         if (readIf(\"TRUE\") || readIf(\"ON\")) {\n             return true;\n         } else if (readIf(\"FALSE\") || readIf(\"OFF\")) {\n-            return false;\n+        return false;\n         } else {\n             throw getSyntaxError();\n         }\n@@ -3432,10 +3352,10 @@ public class Parser {\n \n     // TODO: why does this function allow defaultSchemaName=null - which resets\n     // the parser schemaName for everyone ?\n+\n     private String readIdentifierWithSchema(String defaultSchemaName) {\n         if (currentTokenType != IDENTIFIER) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                    \"identifier\");\n+            throw DbException.getSyntaxError(sqlCommand, parseIndex, \"identifier\");\n         }\n         String s = currentToken;\n         read();\n@@ -3443,8 +3363,7 @@ public class Parser {\n         if (readIf(\".\")) {\n             schemaName = s;\n             if (currentTokenType != IDENTIFIER) {\n-                throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                        \"identifier\");\n+                throw DbException.getSyntaxError(sqlCommand, parseIndex, \"identifier\");\n             }\n             s = currentToken;\n             read();\n@@ -3454,8 +3373,7 @@ public class Parser {\n                 read(\".\");\n                 schemaName = s;\n                 if (currentTokenType != IDENTIFIER) {\n-                    throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                            \"identifier\");\n+                    throw DbException.getSyntaxError(sqlCommand, parseIndex, \"identifier\");\n                 }\n                 s = currentToken;\n                 read();\n@@ -3478,8 +3396,7 @@ public class Parser {\n \n     private String readColumnIdentifier() {\n         if (currentTokenType != IDENTIFIER) {\n-            throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                    \"identifier\");\n+            throw DbException.getSyntaxError(sqlCommand, parseIndex, \"identifier\");\n         }\n         String s = currentToken;\n         read();\n@@ -3507,8 +3424,9 @@ public class Parser {\n      * Reads passed token in list, in order and returns true on first match.\n      * If none of the token matches returns false\n      */\n+\n     private boolean readIfOr(String... tokens) {\n-        for (String token: tokens) {\n+        for (String token : tokens) {\n             if (readIf(token)) {\n                 return true;\n             }\n@@ -3520,10 +3438,11 @@ public class Parser {\n      * Reads every token in list, in order - returns true if all are found.\n      * If any are not found, returns false - AND resets parsing back to state when called.\n      */\n+\n     private boolean readIfAll(String... tokens) {\n         // save parse location in case we have to fail this test\n         int start = lastParseIndex;\n-        for (String token: tokens) {\n+        for (String token : tokens) {\n             if (!currentTokenQuoted && equalsToken(token, currentToken)) {\n                 read();\n             } else {\n@@ -3537,8 +3456,7 @@ public class Parser {\n     }\n \n     private boolean isToken(String token) {\n-        boolean result = equalsToken(token, currentToken) &&\n-                !currentTokenQuoted;\n+        boolean result = equalsToken(token, currentToken) && !currentTokenQuoted;\n         if (result) {\n             return true;\n         }\n@@ -3550,10 +3468,10 @@ public class Parser {\n         if (a == null) {\n             return b == null;\n         } else if (a.equals(b)) {\n-            return true;\n+        return true;\n         } else if (!identifiersToUpper && a.equalsIgnoreCase(b)) {\n-            return true;\n-        }\n+                   return true;\n+               }\n         return false;\n     }\n \n@@ -3561,10 +3479,10 @@ public class Parser {\n         if (a == null) {\n             return b == null;\n         } else if (a.equals(b)) {\n-            return true;\n+        return true;\n         } else if (a.equalsIgnoreCase(b)) {\n-            return true;\n-        }\n+                   return true;\n+               }\n         return false;\n     }\n \n@@ -3604,8 +3522,7 @@ public class Parser {\n                 }\n                 i++;\n             }\n-            currentToken = StringUtils.cache(sqlCommand.substring(\n-                    start, i));\n+            currentToken = StringUtils.cache(sqlCommand.substring(start, i));\n             currentTokenType = getTokenType(currentToken);\n             parseIndex = i;\n             return;\n@@ -3662,8 +3579,7 @@ public class Parser {\n                         parseIndex = i;\n                         return;\n                     }\n-                    number = (number << 4) + c -\n-                            (c >= 'A' ? ('A' - 0xa) : ('0'));\n+                    number = (number << 4) + c - (c >= 'A' ? ('A' - 0xa) : ('0'));\n                     if (number > Integer.MAX_VALUE) {\n                         readHexDecimal(start, i);\n                         return;\n@@ -3724,7 +3640,7 @@ public class Parser {\n             currentToken = \"'\";\n             checkLiterals(true);\n             currentValue = ValueString.get(StringUtils.cache(result),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                           database.getMode().treatEmptyStringsAsNull);\n             parseIndex = i;\n             currentTokenType = VALUE;\n             return;\n@@ -3739,7 +3655,7 @@ public class Parser {\n             currentToken = \"'\";\n             checkLiterals(true);\n             currentValue = ValueString.get(StringUtils.cache(result),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                           database.getMode().treatEmptyStringsAsNull);\n             parseIndex = i;\n             currentTokenType = VALUE;\n             return;\n@@ -3756,7 +3672,6 @@ public class Parser {\n \n     private void readParameterIndex() {\n         int i = parseIndex;\n-\n         char[] chars = sqlCommandChars;\n         char c = chars[i++];\n         long number = c - '0';\n@@ -3771,8 +3686,7 @@ public class Parser {\n             }\n             number = number * 10 + (c - '0');\n             if (number > Integer.MAX_VALUE) {\n-                throw DbException.getInvalidValueException(\n-                        \"parameter index\", number);\n+                throw DbException.getInvalidValueException(\"parameter index\", number);\n             }\n             i++;\n         }\n@@ -3793,7 +3707,8 @@ public class Parser {\n         char c;\n         do {\n             c = chars[++i];\n-        } while ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F'));\n+        } while ((c >= '0' && c <= '9') ||\n+                     (c >= 'A' && c <= 'F'));\n         parseIndex = i;\n         String sub = sqlCommand.substring(start, i);\n         BigDecimal bd = new BigDecimal(new BigInteger(sub, 16));\n@@ -3825,6 +3740,7 @@ public class Parser {\n             }\n             while (types[++i] == CHAR_VALUE) {\n                 // go until the first non-number\n+\n             }\n         }\n         parseIndex = i;\n@@ -3852,6 +3768,7 @@ public class Parser {\n         currentTokenType = VALUE;\n     }\n \n+\n     public Session getSession() {\n         return session;\n     }\n@@ -4039,23 +3956,24 @@ public class Parser {\n                 } else if (c >= 'A' && c <= 'Z') {\n                     type = CHAR_NAME;\n                 } else if (c >= '0' && c <= '9') {\n-                    type = CHAR_VALUE;\n-                } else {\n-                    if (c <= ' ' || Character.isSpaceChar(c)) {\n+                           type = CHAR_VALUE;\n+                       } else {\n+                           if (c <= ' ' || Character.isSpaceChar(c)) {\n                         // whitespace\n-                    } else if (Character.isJavaIdentifierPart(c)) {\n-                        type = CHAR_NAME;\n-                        if (identifiersToUpper) {\n-                            char u = Character.toUpperCase(c);\n-                            if (u != c) {\n-                                command[i] = u;\n-                                changed = true;\n-                            }\n-                        }\n-                    } else {\n-                        type = CHAR_SPECIAL_1;\n-                    }\n-                }\n+\n+                           } else if (Character.isJavaIdentifierPart(c)) {\n+                               type = CHAR_NAME;\n+                               if (identifiersToUpper) {\n+                                   char u = Character.toUpperCase(c);\n+                                   if (u != c) {\n+                                       command[i] = u;\n+                                       changed = true;\n+                                   }\n+                               }\n+                           } else {\n+                               type = CHAR_SPECIAL_1;\n+                           }\n+                       }\n             }\n             types[i] = type;\n             lastType = type;\n@@ -4181,16 +4099,13 @@ public class Parser {\n         return ParserUtil.getSaveTokenType(s, supportOffsetFetch, functionsAsKeywords);\n     }\n \n-    private Column parseColumnForTable(String columnName,\n-            boolean defaultNullable) {\n+    private Column parseColumnForTable(String columnName, boolean defaultNullable) {\n         Column column;\n         boolean isIdentity = readIf(\"IDENTITY\");\n         if (isIdentity || readIf(\"BIGSERIAL\")) {\n             // Check if any of them are disallowed in the current Mode\n-            if (isIdentity && database.getMode().\n-                    disallowedTypes.contains(\"IDENTITY\")) {\n-                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                        currentToken);\n+            if (isIdentity && database.getMode().disallowedTypes.contains(\"IDENTITY\")) {\n+                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, currentToken);\n             }\n             column = new Column(columnName, Value.LONG);\n             column.setOriginalSQL(\"IDENTITY\");\n@@ -4228,8 +4143,7 @@ public class Parser {\n             column.setNullable(defaultNullable & column.isNullable());\n             break;\n         default:\n-            throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n-                    \"Internal Error - unhandled case: \" + nullConstraint.name());\n+            throw DbException.get(ErrorCode.UNKNOWN_MODE_1, \"Internal Error - unhandled case: \" + nullConstraint.name());\n         }\n         if (readIf(\"AS\")) {\n             if (isIdentity) {\n@@ -4241,27 +4155,27 @@ public class Parser {\n             Expression defaultExpression = readExpression();\n             column.setDefaultExpression(session, defaultExpression);\n         } else if (readIf(\"GENERATED\")) {\n-            if (!readIf(\"ALWAYS\")) {\n-                read(\"BY\");\n-                read(\"DEFAULT\");\n-            }\n-            read(\"AS\");\n-            read(\"IDENTITY\");\n-            long start = 1, increment = 1;\n-            if (readIf(\"(\")) {\n-                read(\"START\");\n-                readIf(\"WITH\");\n-                start = readLong();\n-                readIf(\",\");\n-                if (readIf(\"INCREMENT\")) {\n-                    readIf(\"BY\");\n-                    increment = readLong();\n-                }\n-                read(\")\");\n-            }\n-            column.setPrimaryKey(true);\n-            column.setAutoIncrement(true, start, increment);\n-        }\n+                   if (!readIf(\"ALWAYS\")) {\n+                       read(\"BY\");\n+                       read(\"DEFAULT\");\n+                   }\n+                   read(\"AS\");\n+                   read(\"IDENTITY\");\n+                   long start = 1, increment = 1;\n+                   if (readIf(\"(\")) {\n+                       read(\"START\");\n+                       readIf(\"WITH\");\n+                       start = readLong();\n+                       readIf(\",\");\n+                       if (readIf(\"INCREMENT\")) {\n+                           readIf(\"BY\");\n+                           increment = readLong();\n+                       }\n+                       read(\")\");\n+                   }\n+                   column.setPrimaryKey(true);\n+                   column.setAutoIncrement(true, start, increment);\n+               }\n         if (NullConstraintType.NULL_IS_NOT_ALLOWED == parseNotNullConstraint()) {\n             column.setNullable(false);\n         }\n@@ -4323,28 +4237,28 @@ public class Parser {\n                 original += \" PRECISION\";\n             }\n         } else if (readIf(\"CHARACTER\")) {\n-            if (readIf(\"VARYING\")) {\n-                original += \" VARYING\";\n-            }\n-        } else if (readIf(\"TIME\")) {\n-            if (readIf(\"WITHOUT\")) {\n-                read(\"TIME\");\n-                read(\"ZONE\");\n-                original += \" WITHOUT TIME ZONE\";\n-            }\n-        } else if (readIf(\"TIMESTAMP\")) {\n-            if (readIf(\"WITH\")) {\n-                read(\"TIME\");\n-                read(\"ZONE\");\n-                original += \" WITH TIME ZONE\";\n-            } else if (readIf(\"WITHOUT\")) {\n-                read(\"TIME\");\n-                read(\"ZONE\");\n-                original += \" WITHOUT TIME ZONE\";\n-            }\n-        } else {\n-            regular = true;\n-        }\n+                   if (readIf(\"VARYING\")) {\n+                       original += \" VARYING\";\n+                   }\n+               } else if (readIf(\"TIME\")) {\n+                   if (readIf(\"WITHOUT\")) {\n+                       read(\"TIME\");\n+                       read(\"ZONE\");\n+                       original += \" WITHOUT TIME ZONE\";\n+                   }\n+               } else if (readIf(\"TIMESTAMP\")) {\n+                          if (readIf(\"WITH\")) {\n+                              read(\"TIME\");\n+                              read(\"ZONE\");\n+                              original += \" WITH TIME ZONE\";\n+                          } else if (readIf(\"WITHOUT\")) {\n+                              read(\"TIME\");\n+                              read(\"ZONE\");\n+                              original += \" WITHOUT TIME ZONE\";\n+                          }\n+                      } else {\n+                          regular = true;\n+                      }\n         long precision = -1;\n         int displaySize = -1;\n         String[] enumerators = null;\n@@ -4369,12 +4283,10 @@ public class Parser {\n             Mode mode = database.getMode();\n             dataType = DataType.getTypeByName(original, mode);\n             if (dataType == null || mode.disallowedTypes.contains(original)) {\n-                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                        currentToken);\n+                throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1, currentToken);\n             }\n         }\n-        if (database.getIgnoreCase() && dataType.type == Value.STRING &&\n-                !equalsToken(\"VARCHAR_CASESENSITIVE\", original)) {\n+        if (database.getIgnoreCase() && dataType.type == Value.STRING && !equalsToken(\"VARCHAR_CASESENSITIVE\", original)) {\n             original = \"VARCHAR_IGNORECASE\";\n             dataType = DataType.getTypeByName(original, database.getMode());\n         }\n@@ -4382,8 +4294,7 @@ public class Parser {\n             read();\n         }\n         precision = precision == -1 ? dataType.defaultPrecision : precision;\n-        displaySize = displaySize == -1 ? dataType.defaultDisplaySize\n-                : displaySize;\n+        displaySize = displaySize == -1 ? dataType.defaultDisplaySize : displaySize;\n         scale = scale == -1 ? dataType.defaultScale : scale;\n         if (dataType.supportsPrecision || dataType.supportsScale) {\n             if (readIf(\"(\")) {\n@@ -4394,8 +4305,8 @@ public class Parser {\n                     } else if (readIf(\"M\")) {\n                         p *= 1024 * 1024;\n                     } else if (readIf(\"G\")) {\n-                        p *= 1024 * 1024 * 1024;\n-                    }\n+                               p *= 1024 * 1024 * 1024;\n+                           }\n                     if (p > Long.MAX_VALUE) {\n                         p = Long.MAX_VALUE;\n                     }\n@@ -4425,7 +4336,7 @@ public class Parser {\n             }\n         } else if (dataType.type == Value.ENUM) {\n             if (readIf(\"(\")) {\n-                java.util.List<String> enumeratorList = new ArrayList<>();\n+                java.util.List<String> enumeratorList = new ArrayList< >();\n                 original += '(';\n                 String enumerator0 = readString();\n                 enumeratorList.add(enumerator0);\n@@ -4448,9 +4359,9 @@ public class Parser {\n         } else if (readIf(\"(\")) {\n             // Support for MySQL: INT(11), MEDIUMINT(8) and so on.\n             // Just ignore the precision.\n-            readPositiveInt();\n-            read(\")\");\n-        }\n+                   readPositiveInt();\n+                   read(\")\");\n+               }\n         if (readIf(\"FOR\")) {\n             read(\"BIT\");\n             read(\"DATA\");\n@@ -4462,23 +4373,17 @@ public class Parser {\n         readIf(\"UNSIGNED\");\n         int type = dataType.type;\n         if (scale > precision) {\n-            throw DbException.get(ErrorCode.INVALID_VALUE_SCALE_PRECISION,\n-                    Integer.toString(scale), Long.toString(precision));\n+            throw DbException.get(ErrorCode.INVALID_VALUE_SCALE_PRECISION, Integer.toString(scale), Long.toString(precision));\n         }\n-\n-\n-        Column column = new Column(columnName, type, precision, scale,\n-            displaySize, enumerators);\n+        Column column = new Column(columnName, type, precision, scale, displaySize, enumerators);\n         if (templateColumn != null) {\n             column.setNullable(templateColumn.isNullable());\n-            column.setDefaultExpression(session,\n-                    templateColumn.getDefaultExpression());\n+            column.setDefaultExpression(session, templateColumn.getDefaultExpression());\n             int selectivity = templateColumn.getSelectivity();\n             if (selectivity != Constants.SELECTIVITY_DEFAULT) {\n                 column.setSelectivity(selectivity);\n             }\n-            Expression checkConstraint = templateColumn.getCheckConstraint(\n-                    session, columnName);\n+            Expression checkConstraint = templateColumn.getCheckConstraint(session, columnName);\n             column.addCheckConstraint(session, checkConstraint);\n         }\n         column.setComment(comment);\n@@ -4496,30 +4401,30 @@ public class Parser {\n         if (readIf(\"VIEW\")) {\n             return parseCreateView(force, orReplace);\n         } else if (readIf(\"ALIAS\")) {\n-            return parseCreateFunctionAlias(force);\n+        return parseCreateFunctionAlias(force);\n         } else if (readIf(\"SEQUENCE\")) {\n-            return parseCreateSequence();\n-        } else if (readIf(\"USER\")) {\n+                                       return parseCreateSequence();\n+               } else if (readIf(\"USER\")) {\n             return parseCreateUser();\n-        } else if (readIf(\"TRIGGER\")) {\n+               } else if (readIf(\"TRIGGER\")) {\n             return parseCreateTrigger(force);\n-        } else if (readIf(\"ROLE\")) {\n-            return parseCreateRole();\n-        } else if (readIf(\"SCHEMA\")) {\n-            return parseCreateSchema();\n-        } else if (readIf(\"CONSTANT\")) {\n-            return parseCreateConstant();\n-        } else if (readIf(\"DOMAIN\")) {\n-            return parseCreateUserDataType();\n-        } else if (readIf(\"TYPE\")) {\n-            return parseCreateUserDataType();\n-        } else if (readIf(\"DATATYPE\")) {\n-            return parseCreateUserDataType();\n-        } else if (readIf(\"AGGREGATE\")) {\n-            return parseCreateAggregate(force);\n-        } else if (readIf(\"LINKED\")) {\n-            return parseCreateLinkedTable(false, false, force);\n-        }\n+                      } else if (readIf(\"ROLE\")) {\n+                   return parseCreateRole();\n+                      } else if (readIf(\"SCHEMA\")) {\n+                   return parseCreateSchema();\n+                             } else if (readIf(\"CONSTANT\")) {\n+                          return parseCreateConstant();\n+                             } else if (readIf(\"DOMAIN\")) {\n+                          return parseCreateUserDataType();\n+                                    } else if (readIf(\"TYPE\")) {\n+                                 return parseCreateUserDataType();\n+                                    } else if (readIf(\"DATATYPE\")) {\n+                                 return parseCreateUserDataType();\n+                                           } else if (readIf(\"AGGREGATE\")) {\n+                                        return parseCreateAggregate(force);\n+                                           } else if (readIf(\"LINKED\")) {\n+                                                      return parseCreateLinkedTable(false, false, force);\n+                                                  }\n         // tables or linked tables\n         boolean memory = false, cached = false;\n         if (readIf(\"MEMORY\")) {\n@@ -4542,95 +4447,95 @@ public class Parser {\n             read(\"TABLE\");\n             return parseCreateTable(true, true, cached);\n         } else if (readIf(\"TEMP\") || readIf(\"TEMPORARY\")) {\n-            if (readIf(\"LINKED\")) {\n-                return parseCreateLinkedTable(true, true, force);\n-            }\n-            read(\"TABLE\");\n-            return parseCreateTable(true, true, cached);\n-        } else if (readIf(\"TABLE\")) {\n-            if (!cached && !memory) {\n-                cached = database.getDefaultTableType() == Table.TYPE_CACHED;\n-            }\n-            return parseCreateTable(false, false, cached);\n-        } else if (readIf(\"SYNONYM\")) {\n+                   if (readIf(\"LINKED\")) {\n+                       return parseCreateLinkedTable(true, true, force);\n+                   }\n+                   read(\"TABLE\");\n+                   return parseCreateTable(true, true, cached);\n+               } else if (readIf(\"TABLE\")) {\n+                   if (!cached && !memory) {\n+                       cached = database.getDefaultTableType() == Table.TYPE_CACHED;\n+                   }\n+                   return parseCreateTable(false, false, cached);\n+               } else if (readIf(\"SYNONYM\")) {\n             return parseCreateSynonym(orReplace);\n-        } else {\n-            boolean hash = false, primaryKey = false;\n-            boolean unique = false, spatial = false;\n-            String indexName = null;\n-            Schema oldSchema = null;\n-            boolean ifNotExists = false;\n-            if (readIf(\"PRIMARY\")) {\n-                read(\"KEY\");\n-                if (readIf(\"HASH\")) {\n-                    hash = true;\n-                }\n-                primaryKey = true;\n-                if (!isToken(\"ON\")) {\n-                    ifNotExists = readIfNotExists();\n-                    indexName = readIdentifierWithSchema(null);\n-                    oldSchema = getSchema();\n-                }\n-            } else {\n-                if (readIf(\"UNIQUE\")) {\n-                    unique = true;\n-                }\n-                if (readIf(\"HASH\")) {\n-                    hash = true;\n-                }\n-                if (readIf(\"SPATIAL\")) {\n-                    spatial = true;\n-                }\n-                if (readIf(\"INDEX\")) {\n-                    if (!isToken(\"ON\")) {\n-                        ifNotExists = readIfNotExists();\n-                        indexName = readIdentifierWithSchema(null);\n-                        oldSchema = getSchema();\n-                    }\n-                } else {\n-                    throw getSyntaxError();\n-                }\n-            }\n-            read(\"ON\");\n-            String tableName = readIdentifierWithSchema();\n-            checkSchema(oldSchema);\n-            CreateIndex command = new CreateIndex(session, getSchema());\n-            command.setIfNotExists(ifNotExists);\n-            command.setPrimaryKey(primaryKey);\n-            command.setTableName(tableName);\n-            command.setUnique(unique);\n-            command.setIndexName(indexName);\n-            command.setComment(readCommentIf());\n-            read(\"(\");\n-            command.setIndexColumns(parseIndexColumnList());\n-\n-            if (readIf(\"USING\")) {\n-                if (hash) {\n-                    throw getSyntaxError();\n-                }\n-                if (spatial) {\n-                    throw getSyntaxError();\n-                }\n-                if (readIf(\"BTREE\")) {\n+                      } else {\n+                          boolean hash = false, primaryKey = false;\n+                          boolean unique = false, spatial = false;\n+                          String indexName = null;\n+                          Schema oldSchema = null;\n+                          boolean ifNotExists = false;\n+                          if (readIf(\"PRIMARY\")) {\n+                              read(\"KEY\");\n+                              if (readIf(\"HASH\")) {\n+                                  hash = true;\n+                              }\n+                              primaryKey = true;\n+                              if (!isToken(\"ON\")) {\n+                                  ifNotExists = readIfNotExists();\n+                                  indexName = readIdentifierWithSchema(null);\n+                                  oldSchema = getSchema();\n+                              }\n+                          } else {\n+                              if (readIf(\"UNIQUE\")) {\n+                                  unique = true;\n+                              }\n+                              if (readIf(\"HASH\")) {\n+                                  hash = true;\n+                              }\n+                              if (readIf(\"SPATIAL\")) {\n+                                  spatial = true;\n+                              }\n+                              if (readIf(\"INDEX\")) {\n+                                  if (!isToken(\"ON\")) {\n+                                      ifNotExists = readIfNotExists();\n+                                      indexName = readIdentifierWithSchema(null);\n+                                      oldSchema = getSchema();\n+                                  }\n+                              } else {\n+                                  throw getSyntaxError();\n+                              }\n+                          }\n+                          read(\"ON\");\n+                          String tableName = readIdentifierWithSchema();\n+                          checkSchema(oldSchema);\n+                          CreateIndex command = new CreateIndex(session, getSchema());\n+                          command.setIfNotExists(ifNotExists);\n+                          command.setPrimaryKey(primaryKey);\n+                          command.setTableName(tableName);\n+                          command.setUnique(unique);\n+                          command.setIndexName(indexName);\n+                          command.setComment(readCommentIf());\n+                          read(\"(\");\n+                          command.setIndexColumns(parseIndexColumnList());\n+                          if (readIf(\"USING\")) {\n+                              if (hash) {\n+                                  throw getSyntaxError();\n+                              }\n+                              if (spatial) {\n+                                  throw getSyntaxError();\n+                              }\n+                              if (readIf(\"BTREE\")) {\n                     // default\n-                } else if (readIf(\"RTREE\")) {\n-                    spatial = true;\n-                } else if (readIf(\"HASH\")) {\n-                    hash = true;\n-                } else {\n-                    throw getSyntaxError();\n-                }\n \n-            }\n-            command.setHash(hash);\n-            command.setSpatial(spatial);\n-            return command;\n-        }\n+                              } else if (readIf(\"RTREE\")) {\n+                                  spatial = true;\n+                              } else if (readIf(\"HASH\")) {\n+                                         hash = true;\n+                                     } else {\n+                                         throw getSyntaxError();\n+                                     }\n+                          }\n+                          command.setHash(hash);\n+                          command.setSpatial(spatial);\n+                          return command;\n+                      }\n     }\n \n     /**\n      * @return true if we expect to see a TABLE clause\n      */\n+\n     private boolean addRoleOrRight(GrantRevoke command) {\n         if (readIf(\"SELECT\")) {\n             command.addRight(Right.SELECT);\n@@ -4639,30 +4544,30 @@ public class Parser {\n             command.addRight(Right.DELETE);\n             return true;\n         } else if (readIf(\"INSERT\")) {\n-            command.addRight(Right.INSERT);\n-            return true;\n-        } else if (readIf(\"UPDATE\")) {\n-            command.addRight(Right.UPDATE);\n-            return true;\n-        } else if (readIf(\"ALL\")) {\n-            command.addRight(Right.ALL);\n-            return true;\n-        } else if (readIf(\"ALTER\")) {\n-            read(\"ANY\");\n-            read(\"SCHEMA\");\n-            command.addRight(Right.ALTER_ANY_SCHEMA);\n-            command.addTable(null);\n-            return false;\n-        } else if (readIf(\"CONNECT\")) {\n+                   command.addRight(Right.INSERT);\n+                   return true;\n+               } else if (readIf(\"UPDATE\")) {\n+                   command.addRight(Right.UPDATE);\n+                   return true;\n+               } else if (readIf(\"ALL\")) {\n+                          command.addRight(Right.ALL);\n+                          return true;\n+                      } else if (readIf(\"ALTER\")) {\n+                          read(\"ANY\");\n+                          read(\"SCHEMA\");\n+                          command.addRight(Right.ALTER_ANY_SCHEMA);\n+                          command.addTable(null);\n+                          return false;\n+                      } else if (readIf(\"CONNECT\")) {\n             // ignore this right\n-            return true;\n-        } else if (readIf(\"RESOURCE\")) {\n+                   return true;\n+                             } else if (readIf(\"RESOURCE\")) {\n             // ignore this right\n-            return true;\n-        } else {\n-            command.addRoleName(readUniqueIdentifier());\n-            return false;\n-        }\n+                          return true;\n+                             } else {\n+                                 command.addRoleName(readUniqueIdentifier());\n+                                 return false;\n+                             }\n     }\n \n     private GrantRevoke parseGrantRevoke(int operationType) {\n@@ -4672,8 +4577,7 @@ public class Parser {\n         while (readIf(\",\")) {\n             addRoleOrRight(command);\n             if (command.isRightMode() && command.isRoleMode()) {\n-                throw DbException\n-                        .get(ErrorCode.ROLES_AND_RIGHT_CANNOT_BE_MIXED);\n+                throw DbException.get(ErrorCode.ROLES_AND_RIGHT_CANNOT_BE_MIXED);\n             }\n         }\n         if (tableClauseExpected) {\n@@ -4712,8 +4616,7 @@ public class Parser {\n \n     private TableFilter parseValuesTable(int orderInFrom) {\n         Schema mainSchema = database.getSchema(Constants.SCHEMA_MAIN);\n-        TableFunction tf = (TableFunction) Function.getFunction(database,\n-                \"TABLE\");\n+        TableFunction tf = (TableFunction) Function.getFunction(database, \"TABLE\");\n         ArrayList<Column> columns = New.arrayList();\n         ArrayList<ArrayList<Expression>> rows = New.arrayList();\n         do {\n@@ -4736,16 +4639,14 @@ public class Parser {\n                     prec = dt.defaultPrecision;\n                     scale = dt.defaultScale;\n                     displaySize = dt.defaultDisplaySize;\n-                    column = new Column(columnName, type, prec, scale,\n-                            displaySize);\n+                    column = new Column(columnName, type, prec, scale, displaySize);\n                     columns.add(column);\n                 }\n                 prec = expr.getPrecision();\n                 scale = expr.getScale();\n                 displaySize = expr.getDisplaySize();\n                 if (i >= columns.size()) {\n-                    throw DbException\n-                            .get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n+                    throw DbException.get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n                 }\n                 Column c = columns.get(i);\n                 type = Value.getHigherOrder(c.getType(), type);\n@@ -4785,9 +4686,13 @@ public class Parser {\n         tf.setColumns(columns);\n         tf.doneWithParameters();\n         Table table = new FunctionTable(mainSchema, session, tf, tf);\n-        TableFilter filter = new TableFilter(session, table, null,\n-                rightsChecked, currentSelect, orderInFrom,\n-                null);\n+        TableFilter filter = new TableFilter(session,\n+            table,\n+                null,\n+                    rightsChecked,\n+                        currentSelect,\n+                            orderInFrom,\n+                                null);\n         return filter;\n     }\n \n@@ -4842,40 +4747,41 @@ public class Parser {\n                 readIf(\"BY\");\n                 command.setIncrement(readExpression());\n             } else if (readIf(\"MINVALUE\")) {\n-                command.setMinValue(readExpression());\n-            } else if (readIf(\"NOMINVALUE\")) {\n-                command.setMinValue(null);\n-            } else if (readIf(\"MAXVALUE\")) {\n-                command.setMaxValue(readExpression());\n-            } else if (readIf(\"NOMAXVALUE\")) {\n-                command.setMaxValue(null);\n-            } else if (readIf(\"CYCLE\")) {\n-                command.setCycle(true);\n-            } else if (readIf(\"NOCYCLE\")) {\n-                command.setCycle(false);\n-            } else if (readIf(\"NO\")) {\n-                if (readIf(\"MINVALUE\")) {\n-                    command.setMinValue(null);\n-                } else if (readIf(\"MAXVALUE\")) {\n-                    command.setMaxValue(null);\n-                } else if (readIf(\"CYCLE\")) {\n-                    command.setCycle(false);\n-                } else if (readIf(\"CACHE\")) {\n-                    command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-                } else {\n-                    break;\n-                }\n-            } else if (readIf(\"CACHE\")) {\n-                command.setCacheSize(readExpression());\n-            } else if (readIf(\"NOCACHE\")) {\n-                command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-            } else if (readIf(\"BELONGS_TO_TABLE\")) {\n-                command.setBelongsToTable(true);\n-            } else if (readIf(\"ORDER\")) {\n+                       command.setMinValue(readExpression());\n+                   } else if (readIf(\"NOMINVALUE\")) {\n+                       command.setMinValue(null);\n+                   } else if (readIf(\"MAXVALUE\")) {\n+                              command.setMaxValue(readExpression());\n+                          } else if (readIf(\"NOMAXVALUE\")) {\n+                              command.setMaxValue(null);\n+                          } else if (readIf(\"CYCLE\")) {\n+                                     command.setCycle(true);\n+                                 } else if (readIf(\"NOCYCLE\")) {\n+                                     command.setCycle(false);\n+                                 } else if (readIf(\"NO\")) {\n+                                            if (readIf(\"MINVALUE\")) {\n+                                                command.setMinValue(null);\n+                                            } else if (readIf(\"MAXVALUE\")) {\n+                                                command.setMaxValue(null);\n+                                            } else if (readIf(\"CYCLE\")) {\n+                                                       command.setCycle(false);\n+                                                   } else if (readIf(\"CACHE\")) {\n+                                                       command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+                                                   } else {\n+                                                break;\n+                                                   }\n+                                        } else if (readIf(\"CACHE\")) {\n+                                            command.setCacheSize(readExpression());\n+                                        } else if (readIf(\"NOCACHE\")) {\n+                                                   command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+                                               } else if (readIf(\"BELONGS_TO_TABLE\")) {\n+                                                   command.setBelongsToTable(true);\n+                                               } else if (readIf(\"ORDER\")) {\n                 // Oracle compatibility\n-            } else {\n-                break;\n-            }\n+\n+                                                      } else {\n+                                                   break;\n+                                                      }\n         }\n         return command;\n     }\n@@ -4898,8 +4804,7 @@ public class Parser {\n         String constantName = readIdentifierWithSchema();\n         Schema schema = getSchema();\n         if (isKeyword(constantName)) {\n-            throw DbException.get(ErrorCode.CONSTANT_ALREADY_EXISTS_1,\n-                    constantName);\n+            throw DbException.get(ErrorCode.CONSTANT_ALREADY_EXISTS_1, constantName);\n         }\n         read(\"VALUE\");\n         Expression expr = readExpression();\n@@ -4915,10 +4820,8 @@ public class Parser {\n         CreateAggregate command = new CreateAggregate(session);\n         command.setForce(force);\n         String name = readIdentifierWithSchema();\n-        if (isKeyword(name) || Function.getFunction(database, name) != null ||\n-                getAggregateType(name) != null) {\n-            throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1,\n-                    name);\n+        if (isKeyword(name) || Function.getFunction(database, name) != null || getAggregateType(name) != null) {\n+            throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1, name);\n         }\n         command.setName(name);\n         command.setSchema(getSchema());\n@@ -4969,14 +4872,14 @@ public class Parser {\n             } else if (readIf(\"UPDATE\")) {\n                 typeMask |= Trigger.UPDATE;\n             } else if (readIf(\"DELETE\")) {\n-                typeMask |= Trigger.DELETE;\n-            } else if (readIf(\"SELECT\")) {\n-                typeMask |= Trigger.SELECT;\n-            } else if (readIf(\"ROLLBACK\")) {\n-                onRollback = true;\n-            } else {\n-                throw getSyntaxError();\n-            }\n+                       typeMask |= Trigger.DELETE;\n+                   } else if (readIf(\"SELECT\")) {\n+                       typeMask |= Trigger.SELECT;\n+                   } else if (readIf(\"ROLLBACK\")) {\n+                              onRollback = true;\n+                          } else {\n+                              throw getSyntaxError();\n+                          }\n         } while (readIf(\",\"));\n         read(\"ON\");\n         String tableName = readIdentifierWithSchema();\n@@ -5022,13 +4925,12 @@ public class Parser {\n             read(\"HASH\");\n             command.setHash(readExpression());\n         } else if (readIf(\"IDENTIFIED\")) {\n-            read(\"BY\");\n+                   read(\"BY\");\n             // uppercase if not quoted\n-            command.setPassword(ValueExpression.get(ValueString\n-                    .get(readColumnIdentifier())));\n-        } else {\n-            throw getSyntaxError();\n-        }\n+                   command.setPassword(ValueExpression.get(ValueString.get(readColumnIdentifier())));\n+               } else {\n+                   throw getSyntaxError();\n+               }\n         if (readIf(\"ADMIN\")) {\n             command.setAdmin(true);\n         }\n@@ -5048,14 +4950,11 @@ public class Parser {\n         }\n         if (database.isAllowBuiltinAliasOverride() && newAliasSameNameAsBuiltin) {\n             // fine\n-        } else if (isKeyword(aliasName) ||\n-                Function.getFunction(database, aliasName) != null ||\n-                getAggregateType(aliasName) != null) {\n-            throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1,\n-                    aliasName);\n-        }\n-        CreateFunctionAlias command = new CreateFunctionAlias(session,\n-                getSchema());\n+\n+        } else if (isKeyword(aliasName) || Function.getFunction(database, aliasName) != null || getAggregateType(aliasName) != null) {\n+            throw DbException.get(ErrorCode.FUNCTION_ALIAS_ALREADY_EXISTS_1, aliasName);\n+        }\n+        CreateFunctionAlias command = new CreateFunctionAlias(session, getSchema());\n         command.setForce(force);\n         command.setAliasName(aliasName);\n         command.setIfNotExists(ifNotExists);\n@@ -5071,7 +4970,7 @@ public class Parser {\n     }\n \n     private Prepared parseWith() {\n-        List<TableView> viewsCreated = new ArrayList<>();\n+        List<TableView> viewsCreated = new ArrayList< >();\n         readIf(\"RECURSIVE\");\n \n         // this WITH statement might not be a temporary view - allow optional keyword to\n@@ -5083,18 +4982,15 @@ public class Parser {\n         if (session.isParsingCreateView()) {\n             isPersistent = true;\n         }\n-\n         do {\n             viewsCreated.add(parseSingleCommonTableExpression(isPersistent));\n         } while (readIf(\",\"));\n-\n         Prepared p = null;\n         // reverse the order of constructed CTE views - as the destruction order\n         // (since later created view may depend on previously created views -\n         //  we preserve that dependency order in the destruction sequence )\n         // used in setCteCleanups\n         Collections.reverse(viewsCreated);\n-\n         if (isToken(\"SELECT\")) {\n             Query query = parseSelectUnion();\n             query.setPrepareAlways(true);\n@@ -5104,26 +5000,25 @@ public class Parser {\n             p = parseInsert();\n             p.setPrepareAlways(true);\n         } else if (readIf(\"UPDATE\")) {\n-            p = parseUpdate();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"MERGE\")) {\n-            p = parseMerge();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"DELETE\")) {\n-            p = parseDelete();\n-            p.setPrepareAlways(true);\n-        } else if (readIf(\"CREATE\")) {\n-            if (!isToken(\"TABLE\")) {\n-                throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n-                        WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n-\n-            }\n-            p = parseCreate();\n-            p.setPrepareAlways(true);\n-        } else {\n-            throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n-                    WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n-        }\n+                   p = parseUpdate();\n+                   p.setPrepareAlways(true);\n+               } else if (readIf(\"MERGE\")) {\n+                   p = parseMerge();\n+                   p.setPrepareAlways(true);\n+               } else if (readIf(\"DELETE\")) {\n+                          p = parseDelete();\n+                          p.setPrepareAlways(true);\n+                      } else if (readIf(\"CREATE\")) {\n+                          if (!isToken(\"TABLE\")) {\n+                              throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n+                                                    WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n+                          }\n+                          p = parseCreate();\n+                          p.setPrepareAlways(true);\n+                      } else {\n+                          throw DbException.get(ErrorCode.SYNTAX_ERROR_1,\n+                                                WITH_STATEMENT_SUPPORTS_LIMITED_SUB_STATEMENTS);\n+                      }\n \n         // clean up temporary views starting with last to first (in case of\n         // dependencies) - but only if they are not persistent\n@@ -5151,7 +5046,6 @@ public class Parser {\n                 columns.add(new Column(c, Value.STRING));\n             }\n         }\n-\n         Table oldViewFound = null;\n         if (isPersistent) {\n             oldViewFound = getSchema().findTableOrView(session, cteViewName);\n@@ -5161,18 +5055,15 @@ public class Parser {\n         // this persistent check conflicts with check 10 lines down\n         if (oldViewFound != null) {\n             if (!(oldViewFound instanceof TableView)) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1,\n-                        cteViewName);\n+                throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1, cteViewName);\n             }\n             TableView tv = (TableView) oldViewFound;\n             if (!tv.isTableExpression()) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1,\n-                        cteViewName);\n+                throw DbException.get(ErrorCode.TABLE_OR_VIEW_ALREADY_EXISTS_1, cteViewName);\n             }\n             if (isPersistent) {\n                 oldViewFound.lock(session, true, true);\n                 database.removeSchemaObject(session, oldViewFound);\n-\n             } else {\n                 session.removeLocalTempTable(oldViewFound);\n             }\n@@ -5184,10 +5075,9 @@ public class Parser {\n          * work (its removed after creation in this method). Only create table\n          * data and table if we don't have a working CTE already.\n          */\n-        recursiveTable = TableView.createShadowTableForRecursiveTableExpression(\n-                isPersistent, session, cteViewName, schema, columns, db);\n+        recursiveTable = TableView.createShadowTableForRecursiveTableExpression(isPersistent, session, cteViewName, schema, columns, db);\n         List<Column> columnTemplateList;\n-        String[] querySQLOutput = new String[]{null};\n+        String[] querySQLOutput = new String[] { null };\n         try {\n             read(\"AS\");\n             read(\"(\");\n@@ -5197,23 +5087,18 @@ public class Parser {\n             }\n             read(\")\");\n             columnTemplateList = TableView.createQueryColumnTemplateList(cols, withQuery, querySQLOutput);\n-\n         } finally {\n             TableView.destroyShadowTableForRecursiveExpression(isPersistent, session, recursiveTable);\n         }\n-\n         TableView view = createCTEView(cteViewName,\n-                querySQLOutput[0], columnTemplateList,\n-                true/* allowRecursiveQueryDetection */,\n-                true/* add to session */,\n-                isPersistent, session);\n-\n+            querySQLOutput[0],\n+                columnTemplateList, true/* allowRecursiveQueryDetection */, true/* add to session */,\n+                    isPersistent,\n+                        session);\n         return view;\n     }\n \n-    private TableView createCTEView(String cteViewName,  String querySQL,\n-            List<Column> columnTemplateList, boolean allowRecursiveQueryDetection,\n-            boolean addViewToSession, boolean isPersistent, Session targetSession) {\n+    private TableView createCTEView(String cteViewName, String querySQL, List<Column> columnTemplateList, boolean allowRecursiveQueryDetection, boolean addViewToSession, boolean isPersistent, Session targetSession) {\n         Database db = targetSession.getDatabase();\n         Schema schema = getSchemaWithDefault();\n         int id = db.allocateObjectId();\n@@ -5224,10 +5109,7 @@ public class Parser {\n         // then we just compile it again.\n         TableView view;\n         synchronized (targetSession) {\n-            view = new TableView(schema, id, cteViewName, querySQL,\n-                    parameters, columnTemplateArray, targetSession,\n-                    allowRecursiveQueryDetection, false /* literalsChecked */, true /* isTableExpression */,\n-                    isPersistent);\n+            view = new TableView(schema, id, cteViewName, querySQL, parameters, columnTemplateArray, targetSession, allowRecursiveQueryDetection, false /* literalsChecked */, true /* isTableExpression */, isPersistent);\n             if (!view.isRecursiveQueryDetected() && allowRecursiveQueryDetection) {\n                 if (isPersistent) {\n                     db.addSchemaObject(targetSession, view);\n@@ -5236,10 +5118,7 @@ public class Parser {\n                 } else {\n                     session.removeLocalTempTable(view);\n                 }\n-                view = new TableView(schema, id, cteViewName, querySQL, parameters,\n-                        columnTemplateArray, targetSession,\n-                        false/* assume recursive */, false /* literalsChecked */, true /* isTableExpression */,\n-                        isPersistent);\n+                view = new TableView(schema, id, cteViewName, querySQL, parameters, columnTemplateArray, targetSession, false/* assume recursive */, false /* literalsChecked */, true /* isTableExpression */, isPersistent);\n             }\n             // both removeSchemaObject and removeLocalTempTable hold meta locks\n             targetSession.getDatabase().unlockMeta(targetSession);\n@@ -5276,8 +5155,7 @@ public class Parser {\n             String[] cols = parseColumnList();\n             command.setColumnNames(cols);\n         }\n-        String select = StringUtils.cache(sqlCommand\n-                .substring(parseIndex));\n+        String select = StringUtils.cache(sqlCommand.substring(parseIndex));\n         read(\"AS\");\n         try {\n             Query query;\n@@ -5305,11 +5183,9 @@ public class Parser {\n     private TransactionCommand parseCheckpoint() {\n         TransactionCommand command;\n         if (readIf(\"SYNC\")) {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.CHECKPOINT_SYNC);\n+            command = new TransactionCommand(session, CommandInterface.CHECKPOINT_SYNC);\n         } else {\n-            command = new TransactionCommand(session,\n-                    CommandInterface.CHECKPOINT);\n+            command = new TransactionCommand(session, CommandInterface.CHECKPOINT);\n         }\n         return command;\n     }\n@@ -5318,16 +5194,16 @@ public class Parser {\n         if (readIf(\"TABLE\")) {\n             return parseAlterTable();\n         } else if (readIf(\"USER\")) {\n-            return parseAlterUser();\n+        return parseAlterUser();\n         } else if (readIf(\"INDEX\")) {\n-            return parseAlterIndex();\n-        } else if (readIf(\"SCHEMA\")) {\n+                                      return parseAlterIndex();\n+               } else if (readIf(\"SCHEMA\")) {\n             return parseAlterSchema();\n-        } else if (readIf(\"SEQUENCE\")) {\n+               } else if (readIf(\"SEQUENCE\")) {\n             return parseAlterSequence();\n-        } else if (readIf(\"VIEW\")) {\n-            return parseAlterView();\n-        }\n+                      } else if (readIf(\"VIEW\")) {\n+                          return parseAlterView();\n+                      }\n         throw getSyntaxError();\n     }\n \n@@ -5403,36 +5279,36 @@ public class Parser {\n                 read(\"BY\");\n                 command.setIncrement(readExpression());\n             } else if (readIf(\"MINVALUE\")) {\n-                command.setMinValue(readExpression());\n-            } else if (readIf(\"NOMINVALUE\")) {\n-                command.setMinValue(null);\n-            } else if (readIf(\"MAXVALUE\")) {\n-                command.setMaxValue(readExpression());\n-            } else if (readIf(\"NOMAXVALUE\")) {\n-                command.setMaxValue(null);\n-            } else if (readIf(\"CYCLE\")) {\n-                command.setCycle(true);\n-            } else if (readIf(\"NOCYCLE\")) {\n-                command.setCycle(false);\n-            } else if (readIf(\"NO\")) {\n-                if (readIf(\"MINVALUE\")) {\n-                    command.setMinValue(null);\n-                } else if (readIf(\"MAXVALUE\")) {\n-                    command.setMaxValue(null);\n-                } else if (readIf(\"CYCLE\")) {\n-                    command.setCycle(false);\n-                } else if (readIf(\"CACHE\")) {\n-                    command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-                } else {\n-                    break;\n-                }\n-            } else if (readIf(\"CACHE\")) {\n-                command.setCacheSize(readExpression());\n-            } else if (readIf(\"NOCACHE\")) {\n-                command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n-            } else {\n-                break;\n-            }\n+                       command.setMinValue(readExpression());\n+                   } else if (readIf(\"NOMINVALUE\")) {\n+                       command.setMinValue(null);\n+                   } else if (readIf(\"MAXVALUE\")) {\n+                              command.setMaxValue(readExpression());\n+                          } else if (readIf(\"NOMAXVALUE\")) {\n+                              command.setMaxValue(null);\n+                          } else if (readIf(\"CYCLE\")) {\n+                                     command.setCycle(true);\n+                                 } else if (readIf(\"NOCYCLE\")) {\n+                                     command.setCycle(false);\n+                                 } else if (readIf(\"NO\")) {\n+                                            if (readIf(\"MINVALUE\")) {\n+                                                command.setMinValue(null);\n+                                            } else if (readIf(\"MAXVALUE\")) {\n+                                                command.setMaxValue(null);\n+                                            } else if (readIf(\"CYCLE\")) {\n+                                                       command.setCycle(false);\n+                                                   } else if (readIf(\"CACHE\")) {\n+                                                       command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+                                                   } else {\n+                                                break;\n+                                                   }\n+                                        } else if (readIf(\"CACHE\")) {\n+                                            command.setCacheSize(readExpression());\n+                                        } else if (readIf(\"NOCACHE\")) {\n+                                                   command.setCacheSize(ValueExpression.get(ValueLong.get(1)));\n+                                               } else {\n+                                            break;\n+                                               }\n         }\n         return command;\n     }\n@@ -5462,19 +5338,19 @@ public class Parser {\n             command.setNewName(newName);\n             return command;\n         } else if (readIf(\"ADMIN\")) {\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_ADMIN);\n-            User user = database.getUser(userName);\n-            command.setUser(user);\n-            if (readIf(\"TRUE\")) {\n-                command.setAdmin(true);\n-            } else if (readIf(\"FALSE\")) {\n-                command.setAdmin(false);\n-            } else {\n-                throw getSyntaxError();\n-            }\n-            return command;\n-        }\n+                   AlterUser command = new AlterUser(session);\n+                   command.setType(CommandInterface.ALTER_USER_ADMIN);\n+                   User user = database.getUser(userName);\n+                   command.setUser(user);\n+                   if (readIf(\"TRUE\")) {\n+                       command.setAdmin(true);\n+                   } else if (readIf(\"FALSE\")) {\n+                       command.setAdmin(false);\n+                   } else {\n+                       throw getSyntaxError();\n+                   }\n+                   return command;\n+               }\n         throw getSyntaxError();\n     }\n \n@@ -5494,219 +5370,216 @@ public class Parser {\n         } else if (readIf(\"AUTOCOMMIT\")) {\n             readIfEqualOrTo();\n             boolean value = readBooleanSetting();\n-            int setting = value ? CommandInterface.SET_AUTOCOMMIT_TRUE\n-                    : CommandInterface.SET_AUTOCOMMIT_FALSE;\n+            int setting = value ? CommandInterface.SET_AUTOCOMMIT_TRUE : CommandInterface.SET_AUTOCOMMIT_FALSE;\n             return new TransactionCommand(session, setting);\n         } else if (readIf(\"MVCC\")) {\n-            readIfEqualOrTo();\n-            boolean value = readBooleanSetting();\n-            Set command = new Set(session, SetTypes.MVCC);\n-            command.setInt(value ? 1 : 0);\n-            return command;\n-        } else if (readIf(\"EXCLUSIVE\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.EXCLUSIVE);\n-            command.setExpression(readExpression());\n-            return command;\n-        } else if (readIf(\"IGNORECASE\")) {\n-            readIfEqualOrTo();\n-            boolean value = readBooleanSetting();\n-            Set command = new Set(session, SetTypes.IGNORECASE);\n-            command.setInt(value ? 1 : 0);\n-            return command;\n-        } else if (readIf(\"PASSWORD\")) {\n-            readIfEqualOrTo();\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n-            command.setUser(session.getUser());\n-            command.setPassword(readExpression());\n-            return command;\n-        } else if (readIf(\"SALT\")) {\n-            readIfEqualOrTo();\n-            AlterUser command = new AlterUser(session);\n-            command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n-            command.setUser(session.getUser());\n-            command.setSalt(readExpression());\n-            read(\"HASH\");\n-            command.setHash(readExpression());\n-            return command;\n-        } else if (readIf(\"MODE\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.MODE);\n-            command.setString(readAliasIdentifier());\n-            return command;\n-        } else if (readIf(\"COMPRESS_LOB\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.COMPRESS_LOB);\n-            if (currentTokenType == VALUE) {\n-                command.setString(readString());\n-            } else {\n-                command.setString(readUniqueIdentifier());\n-            }\n-            return command;\n-        } else if (readIf(\"DATABASE\")) {\n-            readIfEqualOrTo();\n-            read(\"COLLATION\");\n-            return parseSetCollation();\n-        } else if (readIf(\"COLLATION\")) {\n-            readIfEqualOrTo();\n-            return parseSetCollation();\n-        } else if (readIf(\"BINARY_COLLATION\")) {\n-            readIfEqualOrTo();\n-            return parseSetBinaryCollation();\n-        } else if (readIf(\"CLUSTER\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.CLUSTER);\n-            command.setString(readString());\n-            return command;\n-        } else if (readIf(\"DATABASE_EVENT_LISTENER\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.DATABASE_EVENT_LISTENER);\n-            command.setString(readString());\n-            return command;\n-        } else if (readIf(\"ALLOW_LITERALS\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.ALLOW_LITERALS);\n-            if (readIf(\"NONE\")) {\n-                command.setInt(Constants.ALLOW_LITERALS_NONE);\n-            } else if (readIf(\"ALL\")) {\n-                command.setInt(Constants.ALLOW_LITERALS_ALL);\n-            } else if (readIf(\"NUMBERS\")) {\n-                command.setInt(Constants.ALLOW_LITERALS_NUMBERS);\n-            } else {\n-                command.setInt(readPositiveInt());\n-            }\n-            return command;\n-        } else if (readIf(\"DEFAULT_TABLE_TYPE\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.DEFAULT_TABLE_TYPE);\n-            if (readIf(\"MEMORY\")) {\n-                command.setInt(Table.TYPE_MEMORY);\n-            } else if (readIf(\"CACHED\")) {\n-                command.setInt(Table.TYPE_CACHED);\n-            } else {\n-                command.setInt(readPositiveInt());\n-            }\n-            return command;\n-        } else if (readIf(\"CREATE\")) {\n-            readIfEqualOrTo();\n+                   readIfEqualOrTo();\n+                   boolean value = readBooleanSetting();\n+                   Set command = new Set(session, SetTypes.MVCC);\n+                   command.setInt(value ? 1 : 0);\n+                   return command;\n+               } else if (readIf(\"EXCLUSIVE\")) {\n+                   readIfEqualOrTo();\n+                   Set command = new Set(session, SetTypes.EXCLUSIVE);\n+                   command.setExpression(readExpression());\n+                   return command;\n+               } else if (readIf(\"IGNORECASE\")) {\n+                          readIfEqualOrTo();\n+                          boolean value = readBooleanSetting();\n+                          Set command = new Set(session, SetTypes.IGNORECASE);\n+                          command.setInt(value ? 1 : 0);\n+                          return command;\n+                      } else if (readIf(\"PASSWORD\")) {\n+                          readIfEqualOrTo();\n+                          AlterUser command = new AlterUser(session);\n+                          command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n+                          command.setUser(session.getUser());\n+                          command.setPassword(readExpression());\n+                          return command;\n+                      } else if (readIf(\"SALT\")) {\n+                                 readIfEqualOrTo();\n+                                 AlterUser command = new AlterUser(session);\n+                                 command.setType(CommandInterface.ALTER_USER_SET_PASSWORD);\n+                                 command.setUser(session.getUser());\n+                                 command.setSalt(readExpression());\n+                                 read(\"HASH\");\n+                                 command.setHash(readExpression());\n+                                 return command;\n+                             } else if (readIf(\"MODE\")) {\n+                                 readIfEqualOrTo();\n+                                 Set command = new Set(session, SetTypes.MODE);\n+                                 command.setString(readAliasIdentifier());\n+                                 return command;\n+                             } else if (readIf(\"COMPRESS_LOB\")) {\n+                                        readIfEqualOrTo();\n+                                        Set command = new Set(session, SetTypes.COMPRESS_LOB);\n+                                        if (currentTokenType == VALUE) {\n+                                            command.setString(readString());\n+                                        } else {\n+                                            command.setString(readUniqueIdentifier());\n+                                        }\n+                                        return command;\n+                                    } else if (readIf(\"DATABASE\")) {\n+                                        readIfEqualOrTo();\n+                                        read(\"COLLATION\");\n+                                        return parseSetCollation();\n+                                    } else if (readIf(\"COLLATION\")) {\n+                                               readIfEqualOrTo();\n+                                               return parseSetCollation();\n+                                           } else if (readIf(\"BINARY_COLLATION\")) {\n+                                               readIfEqualOrTo();\n+                                               return parseSetBinaryCollation();\n+                                           } else if (readIf(\"CLUSTER\")) {\n+                                                      readIfEqualOrTo();\n+                                                      Set command = new Set(session, SetTypes.CLUSTER);\n+                                                      command.setString(readString());\n+                                                      return command;\n+                                                  } else if (readIf(\"DATABASE_EVENT_LISTENER\")) {\n+                                                      readIfEqualOrTo();\n+                                                      Set command = new Set(session, SetTypes.DATABASE_EVENT_LISTENER);\n+                                                      command.setString(readString());\n+                                                      return command;\n+                                                  } else if (readIf(\"ALLOW_LITERALS\")) {\n+                                                             readIfEqualOrTo();\n+                                                             Set command = new Set(session, SetTypes.ALLOW_LITERALS);\n+                                                             if (readIf(\"NONE\")) {\n+                                                                 command.setInt(Constants.ALLOW_LITERALS_NONE);\n+                                                             } else if (readIf(\"ALL\")) {\n+                                                                 command.setInt(Constants.ALLOW_LITERALS_ALL);\n+                                                             } else if (readIf(\"NUMBERS\")) {\n+                                                                        command.setInt(Constants.ALLOW_LITERALS_NUMBERS);\n+                                                                    } else {\n+                                                                        command.setInt(readPositiveInt());\n+                                                                    }\n+                                                             return command;\n+                                                         } else if (readIf(\"DEFAULT_TABLE_TYPE\")) {\n+                                                             readIfEqualOrTo();\n+                                                             Set command = new Set(session, SetTypes.DEFAULT_TABLE_TYPE);\n+                                                             if (readIf(\"MEMORY\")) {\n+                                                                 command.setInt(Table.TYPE_MEMORY);\n+                                                             } else if (readIf(\"CACHED\")) {\n+                                                                 command.setInt(Table.TYPE_CACHED);\n+                                                             } else {\n+                                                                 command.setInt(readPositiveInt());\n+                                                             }\n+                                                             return command;\n+                                                         } else if (readIf(\"CREATE\")) {\n+                                                                    readIfEqualOrTo();\n             // Derby compatibility (CREATE=TRUE in the database URL)\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"HSQLDB.DEFAULT_TABLE_TYPE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"PAGE_STORE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"CACHE_TYPE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"FILE_LOCK\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"DB_CLOSE_ON_EXIT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"AUTO_SERVER\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"AUTO_SERVER_PORT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"AUTO_RECONNECT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"ASSERT\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"ACCESS_MODE_DATA\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"OPEN_NEW\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"JMX\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"PAGE_SIZE\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"RECOVER\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"NAMES\")) {\n+                                                                    read();\n+                                                                    return new NoOperation(session);\n+                                                                } else if (readIf(\"HSQLDB.DEFAULT_TABLE_TYPE\")) {\n+                                                                    readIfEqualOrTo();\n+                                                                    read();\n+                                                                    return new NoOperation(session);\n+                                                                } else if (readIf(\"PAGE_STORE\")) {\n+                                                                           readIfEqualOrTo();\n+                                                                           read();\n+                                                                           return new NoOperation(session);\n+                                                                       } else if (readIf(\"CACHE_TYPE\")) {\n+                                                                           readIfEqualOrTo();\n+                                                                           read();\n+                                                                           return new NoOperation(session);\n+                                                                       } else if (readIf(\"FILE_LOCK\")) {\n+                                                                                  readIfEqualOrTo();\n+                                                                                  read();\n+                                                                                  return new NoOperation(session);\n+                                                                              } else if (readIf(\"DB_CLOSE_ON_EXIT\")) {\n+                                                                                  readIfEqualOrTo();\n+                                                                                  read();\n+                                                                                  return new NoOperation(session);\n+                                                                              } else if (readIf(\"AUTO_SERVER\")) {\n+                                                                                         readIfEqualOrTo();\n+                                                                                         read();\n+                                                                                         return new NoOperation(session);\n+                                                                                     } else if (readIf(\"AUTO_SERVER_PORT\")) {\n+                                                                                         readIfEqualOrTo();\n+                                                                                         read();\n+                                                                                         return new NoOperation(session);\n+                                                                                     } else if (readIf(\"AUTO_RECONNECT\")) {\n+                                                                                                readIfEqualOrTo();\n+                                                                                                read();\n+                                                                                                return new NoOperation(session);\n+                                                                                            } else if (readIf(\"ASSERT\")) {\n+                                                                                                readIfEqualOrTo();\n+                                                                                                read();\n+                                                                                                return new NoOperation(session);\n+                                                                                            } else if (readIf(\"ACCESS_MODE_DATA\")) {\n+                                                                                                       readIfEqualOrTo();\n+                                                                                                       read();\n+                                                                                                       return new NoOperation(session);\n+                                                                                                   } else if (readIf(\"OPEN_NEW\")) {\n+                                                                                                       readIfEqualOrTo();\n+                                                                                                       read();\n+                                                                                                       return new NoOperation(session);\n+                                                                                                   } else if (readIf(\"JMX\")) {\n+                                                                                                              readIfEqualOrTo();\n+                                                                                                              read();\n+                                                                                                              return new NoOperation(session);\n+                                                                                                          } else if (readIf(\"PAGE_SIZE\")) {\n+                                                                                                              readIfEqualOrTo();\n+                                                                                                              read();\n+                                                                                                              return new NoOperation(session);\n+                                                                                                          } else if (readIf(\"RECOVER\")) {\n+                                                                                                                     readIfEqualOrTo();\n+                                                                                                                     read();\n+                                                                                                                     return new NoOperation(session);\n+                                                                                                                 } else if (readIf(\"NAMES\")) {\n             // Quercus PHP MySQL driver compatibility\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"SCOPE_GENERATED_KEYS\")) {\n-            readIfEqualOrTo();\n-            read();\n-            return new NoOperation(session);\n-        } else if (readIf(\"SCHEMA\")) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.SCHEMA);\n-            command.setString(readAliasIdentifier());\n-            return command;\n-        } else if (readIf(\"DATESTYLE\")) {\n+                                                                                                                     readIfEqualOrTo();\n+                                                                                                                     read();\n+                                                                                                                     return new NoOperation(session);\n+                                                                                                                 } else if (readIf(\"SCOPE_GENERATED_KEYS\")) {\n+                                                                                                                            readIfEqualOrTo();\n+                                                                                                                            read();\n+                                                                                                                            return new NoOperation(session);\n+                                                                                                                        } else if (readIf(\"SCHEMA\")) {\n+                                                                                                                            readIfEqualOrTo();\n+                                                                                                                            Set command = new Set(session, SetTypes.SCHEMA);\n+                                                                                                                            command.setString(readAliasIdentifier());\n+                                                                                                                            return command;\n+                                                                                                                        } else if (readIf(\"DATESTYLE\")) {\n             // PostgreSQL compatibility\n-            readIfEqualOrTo();\n-            if (!readIf(\"ISO\")) {\n-                String s = readString();\n-                if (!equalsToken(s, \"ISO\")) {\n-                    throw getSyntaxError();\n-                }\n-            }\n-            return new NoOperation(session);\n-        } else if (readIf(\"SEARCH_PATH\") ||\n-                readIf(SetTypes.getTypeName(SetTypes.SCHEMA_SEARCH_PATH))) {\n-            readIfEqualOrTo();\n-            Set command = new Set(session, SetTypes.SCHEMA_SEARCH_PATH);\n-            ArrayList<String> list = New.arrayList();\n-            list.add(readAliasIdentifier());\n-            while (readIf(\",\")) {\n-                list.add(readAliasIdentifier());\n-            }\n-            command.setStringArray(list.toArray(new String[0]));\n-            return command;\n-        } else if (readIf(\"JAVA_OBJECT_SERIALIZER\")) {\n-            readIfEqualOrTo();\n-            return parseSetJavaObjectSerializer();\n-        } else {\n-            if (isToken(\"LOGSIZE\")) {\n+                                                                                                                                   readIfEqualOrTo();\n+                                                                                                                                   if (!readIf(\"ISO\")) {\n+                                                                                                                                       String s = readString();\n+                                                                                                                                       if (!equalsToken(s, \"ISO\")) {\n+                                                                                                                                           throw getSyntaxError();\n+                                                                                                                                       }\n+                                                                                                                                   }\n+                                                                                                                                   return new NoOperation(session);\n+                                                                                                                               } else if (readIf(\"SEARCH_PATH\") || readIf(SetTypes.getTypeName(SetTypes.SCHEMA_SEARCH_PATH))) {\n+                                                                                                                                   readIfEqualOrTo();\n+                                                                                                                                   Set command = new Set(session, SetTypes.SCHEMA_SEARCH_PATH);\n+                                                                                                                                   ArrayList<String> list = New.arrayList();\n+                                                                                                                                   list.add(readAliasIdentifier());\n+                                                                                                                                   while (readIf(\",\")) {\n+                                                                                                                                       list.add(readAliasIdentifier());\n+                                                                                                                                   }\n+                                                                                                                                   command.setStringArray(list.toArray(new String[0]));\n+                                                                                                                                   return command;\n+                                                                                                                               } else if (readIf(\"JAVA_OBJECT_SERIALIZER\")) {\n+                                                                                                                                          readIfEqualOrTo();\n+                                                                                                                                          return parseSetJavaObjectSerializer();\n+                                                                                                                                      } else {\n+                                                                                                                                          if (isToken(\"LOGSIZE\")) {\n                 // HSQLDB compatibility\n-                currentToken = SetTypes.getTypeName(SetTypes.MAX_LOG_SIZE);\n-            }\n-            if (isToken(\"FOREIGN_KEY_CHECKS\")) {\n+                                                                                                                                              currentToken = SetTypes.getTypeName(SetTypes.MAX_LOG_SIZE);\n+                                                                                                                                          }\n+                                                                                                                                          if (isToken(\"FOREIGN_KEY_CHECKS\")) {\n                 // MySQL compatibility\n-                currentToken = SetTypes\n-                        .getTypeName(SetTypes.REFERENTIAL_INTEGRITY);\n-            }\n-            int type = SetTypes.getType(currentToken);\n-            if (type < 0) {\n-                throw getSyntaxError();\n-            }\n-            read();\n-            readIfEqualOrTo();\n-            Set command = new Set(session, type);\n-            command.setExpression(readExpression());\n-            return command;\n-        }\n+                                                                                                                                              currentToken = SetTypes.getTypeName(SetTypes.REFERENTIAL_INTEGRITY);\n+                                                                                                                                          }\n+                                                                                                                                          int type = SetTypes.getType(currentToken);\n+                                                                                                                                          if (type < 0) {\n+                                                                                                                                              throw getSyntaxError();\n+                                                                                                                                          }\n+                                                                                                                                          read();\n+                                                                                                                                          readIfEqualOrTo();\n+                                                                                                                                          Set command = new Set(session, type);\n+                                                                                                                                          command.setExpression(readExpression());\n+                                                                                                                                          return command;\n+                                                                                                                                      }\n     }\n \n     private Prepared parseUse() {\n@@ -5733,10 +5606,10 @@ public class Parser {\n             } else if (readIf(\"SECONDARY\")) {\n                 command.setInt(Collator.SECONDARY);\n             } else if (readIf(\"TERTIARY\")) {\n-                command.setInt(Collator.TERTIARY);\n-            } else if (readIf(\"IDENTICAL\")) {\n-                command.setInt(Collator.IDENTICAL);\n-            }\n+                       command.setInt(Collator.TERTIARY);\n+                   } else if (readIf(\"IDENTICAL\")) {\n+                       command.setInt(Collator.IDENTICAL);\n+                   }\n         } else {\n             command.setInt(coll.getStrength());\n         }\n@@ -5747,8 +5620,7 @@ public class Parser {\n         Set command = new Set(session, SetTypes.BINARY_COLLATION);\n         String name = readAliasIdentifier();\n         command.setString(name);\n-        if (equalsToken(name, CompareMode.UNSIGNED) ||\n-                equalsToken(name, CompareMode.SIGNED)) {\n+        if (equalsToken(name, CompareMode.UNSIGNED) || equalsToken(name, CompareMode.SIGNED)) {\n             return command;\n         }\n         throw DbException.getInvalidValueException(\"BINARY_COLLATION\", name);\n@@ -5824,7 +5696,7 @@ public class Parser {\n             }\n         }\n         if (readIf(\"SCHEMA\")) {\n-            HashSet<String> schemaNames = new HashSet<>();\n+            HashSet<String> schemaNames = new HashSet< >();\n             do {\n                 schemaNames.add(readUniqueIdentifier());\n             } while (readIf(\",\"));\n@@ -5848,8 +5720,7 @@ public class Parser {\n         if (schemaName != null) {\n             return getSchema().getTableOrView(session, tableName);\n         }\n-        Table table = database.getSchema(session.getCurrentSchemaName())\n-                .resolveTableOrView(session, tableName);\n+        Table table = database.getSchema(session.getCurrentSchemaName()).resolveTableOrView(session, tableName);\n         if (table != null) {\n             return table;\n         }\n@@ -5867,8 +5738,7 @@ public class Parser {\n     }\n \n     private FunctionAlias findFunctionAlias(String schema, String aliasName) {\n-        FunctionAlias functionAlias = database.getSchema(schema).findFunction(\n-                aliasName);\n+        FunctionAlias functionAlias = database.getSchema(schema).findFunction(aliasName);\n         if (functionAlias != null) {\n             return functionAlias;\n         }\n@@ -5885,8 +5755,7 @@ public class Parser {\n     }\n \n     private Sequence findSequence(String schema, String sequenceName) {\n-        Sequence sequence = database.getSchema(schema).findSequence(\n-                sequenceName);\n+        Sequence sequence = database.getSchema(schema).findSequence(sequenceName);\n         if (sequence != null) {\n             return sequence;\n         }\n@@ -5908,8 +5777,7 @@ public class Parser {\n         if (schemaName != null) {\n             return getSchema().getSequence(sequenceName);\n         }\n-        Sequence sequence = findSequence(session.getCurrentSchemaName(),\n-                sequenceName);\n+        Sequence sequence = findSequence(session.getCurrentSchemaName(), sequenceName);\n         if (sequence != null) {\n             return sequence;\n         }\n@@ -5921,8 +5789,7 @@ public class Parser {\n         String tableName = readIdentifierWithSchema();\n         Schema schema = getSchema();\n         if (readIf(\"ADD\")) {\n-            Prepared command = parseAlterTableAddConstraintIf(tableName,\n-                    schema, ifTableExists);\n+            Prepared command = parseAlterTableAddConstraintIf(tableName, schema, ifTableExists);\n             if (command != null) {\n                 return command;\n             }\n@@ -5931,8 +5798,7 @@ public class Parser {\n             read(\"REFERENTIAL_INTEGRITY\");\n             int type = CommandInterface.ALTER_TABLE_SET_REFERENTIAL_INTEGRITY;\n             boolean value = readBooleanSetting();\n-            AlterTableSet command = new AlterTableSet(session,\n-                    schema, type, value);\n+            AlterTableSet command = new AlterTableSet(session, schema, type, value);\n             command.setTableName(tableName);\n             command.setIfTableExists(ifTableExists);\n             if (readIf(\"CHECK\")) {\n@@ -5942,263 +5808,244 @@ public class Parser {\n             }\n             return command;\n         } else if (readIf(\"RENAME\")) {\n-            if (readIf(\"COLUMN\")) {\n+                   if (readIf(\"COLUMN\")) {\n                 // PostgreSQL syntax\n-                String columnName = readColumnIdentifier();\n-                read(\"TO\");\n-                AlterTableRenameColumn command = new AlterTableRenameColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumnName(columnName);\n-                String newName = readColumnIdentifier();\n-                command.setNewColumnName(newName);\n-                return command;\n-            } else if (readIf(\"CONSTRAINT\")) {\n-                String constraintName = readIdentifierWithSchema(schema.getName());\n-                checkSchema(schema);\n-                read(\"TO\");\n-                AlterTableRenameConstraint command = new AlterTableRenameConstraint(\n-                        session, schema);\n-                command.setConstraintName(constraintName);\n-                String newName = readColumnIdentifier();\n-                command.setNewConstraintName(newName);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else {\n-                read(\"TO\");\n-                String newName = readIdentifierWithSchema(schema.getName());\n-                checkSchema(schema);\n-                AlterTableRename command = new AlterTableRename(session,\n-                        getSchema());\n-                command.setOldTableName(tableName);\n-                command.setNewTableName(newName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setHidden(readIf(\"HIDDEN\"));\n-                return command;\n-            }\n-        } else if (readIf(\"DROP\")) {\n-            if (readIf(\"CONSTRAINT\")) {\n-                boolean ifExists = readIfExists(false);\n-                String constraintName = readIdentifierWithSchema(schema.getName());\n-                ifExists = readIfExists(ifExists);\n-                checkSchema(schema);\n-                AlterTableDropConstraint command = new AlterTableDropConstraint(\n-                        session, getSchema(), ifExists);\n-                command.setConstraintName(constraintName);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"FOREIGN\")) {\n+                       String columnName = readColumnIdentifier();\n+                       read(\"TO\");\n+                       AlterTableRenameColumn command = new AlterTableRenameColumn(session, schema);\n+                       command.setTableName(tableName);\n+                       command.setIfTableExists(ifTableExists);\n+                       command.setOldColumnName(columnName);\n+                       String newName = readColumnIdentifier();\n+                       command.setNewColumnName(newName);\n+                       return command;\n+                   } else if (readIf(\"CONSTRAINT\")) {\n+                       String constraintName = readIdentifierWithSchema(schema.getName());\n+                       checkSchema(schema);\n+                       read(\"TO\");\n+                       AlterTableRenameConstraint command = new AlterTableRenameConstraint(session, schema);\n+                       command.setConstraintName(constraintName);\n+                       String newName = readColumnIdentifier();\n+                       command.setNewConstraintName(newName);\n+                       return commandIfTableExists(schema, tableName, ifTableExists, command);\n+                   } else {\n+                       read(\"TO\");\n+                       String newName = readIdentifierWithSchema(schema.getName());\n+                       checkSchema(schema);\n+                       AlterTableRename command = new AlterTableRename(session, getSchema());\n+                       command.setOldTableName(tableName);\n+                       command.setNewTableName(newName);\n+                       command.setIfTableExists(ifTableExists);\n+                       command.setHidden(readIf(\"HIDDEN\"));\n+                       return command;\n+                   }\n+               } else if (readIf(\"DROP\")) {\n+                   if (readIf(\"CONSTRAINT\")) {\n+                       boolean ifExists = readIfExists(false);\n+                       String constraintName = readIdentifierWithSchema(schema.getName());\n+                       ifExists = readIfExists(ifExists);\n+                       checkSchema(schema);\n+                       AlterTableDropConstraint command = new AlterTableDropConstraint(session, getSchema(), ifExists);\n+                       command.setConstraintName(constraintName);\n+                       return commandIfTableExists(schema, tableName, ifTableExists, command);\n+                   } else if (readIf(\"FOREIGN\")) {\n                 // MySQL compatibility\n-                read(\"KEY\");\n-                String constraintName = readIdentifierWithSchema(schema.getName());\n-                checkSchema(schema);\n-                AlterTableDropConstraint command = new AlterTableDropConstraint(\n-                        session, getSchema(), false);\n-                command.setConstraintName(constraintName);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"INDEX\")) {\n+                       read(\"KEY\");\n+                       String constraintName = readIdentifierWithSchema(schema.getName());\n+                       checkSchema(schema);\n+                       AlterTableDropConstraint command = new AlterTableDropConstraint(session, getSchema(), false);\n+                       command.setConstraintName(constraintName);\n+                       return commandIfTableExists(schema, tableName, ifTableExists, command);\n+                   } else if (readIf(\"INDEX\")) {\n                 // MySQL compatibility\n-                String indexOrConstraintName = readIdentifierWithSchema();\n-                final SchemaCommand command;\n-                if (schema.findIndex(session, indexOrConstraintName) != null) {\n-                    DropIndex dropIndexCommand = new DropIndex(session, getSchema());\n-                    dropIndexCommand.setIndexName(indexOrConstraintName);\n-                    command = dropIndexCommand;\n-                } else {\n-                    AlterTableDropConstraint dropCommand = new AlterTableDropConstraint(\n-                            session, getSchema(), false/*ifExists*/);\n-                    dropCommand.setConstraintName(indexOrConstraintName);\n-                    command = dropCommand;\n-                }\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"PRIMARY\")) {\n-                read(\"KEY\");\n-                Table table = tableIfTableExists(schema, tableName, ifTableExists);\n-                if (table == null) {\n-                    return new NoOperation(session);\n-                }\n-                Index idx = table.getPrimaryKey();\n-                DropIndex command = new DropIndex(session, schema);\n-                command.setIndexName(idx.getName());\n-                return command;\n-            } else {\n-                readIf(\"COLUMN\");\n-                boolean ifExists = readIfExists(false);\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setType(CommandInterface.ALTER_TABLE_DROP_COLUMN);\n-                ArrayList<Column> columnsToRemove = New.arrayList();\n-                Table table = tableIfTableExists(schema, tableName, ifTableExists);\n+                              String indexOrConstraintName = readIdentifierWithSchema();\n+                              final SchemaCommand command;\n+                              if (schema.findIndex(session, indexOrConstraintName) != null) {\n+                                  DropIndex dropIndexCommand = new DropIndex(session, getSchema());\n+                                  dropIndexCommand.setIndexName(indexOrConstraintName);\n+                                  command = dropIndexCommand;\n+                              } else {\n+                                  AlterTableDropConstraint dropCommand = new AlterTableDropConstraint(session, getSchema(), false/*ifExists*/);\n+                                  dropCommand.setConstraintName(indexOrConstraintName);\n+                                  command = dropCommand;\n+                              }\n+                              return commandIfTableExists(schema, tableName, ifTableExists, command);\n+                          } else if (readIf(\"PRIMARY\")) {\n+                              read(\"KEY\");\n+                              Table table = tableIfTableExists(schema, tableName, ifTableExists);\n+                              if (table == null) {\n+                                  return new NoOperation(session);\n+                              }\n+                              Index idx = table.getPrimaryKey();\n+                              DropIndex command = new DropIndex(session, schema);\n+                              command.setIndexName(idx.getName());\n+                              return command;\n+                          } else {\n+                              readIf(\"COLUMN\");\n+                              boolean ifExists = readIfExists(false);\n+                              AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n+                              command.setType(CommandInterface.ALTER_TABLE_DROP_COLUMN);\n+                              ArrayList<Column> columnsToRemove = New.arrayList();\n+                              Table table = tableIfTableExists(schema, tableName, ifTableExists);\n                 // For Oracle compatibility - open bracket required\n-                boolean openingBracketDetected = readIf(\"(\");\n-                do {\n-                    String columnName = readColumnIdentifier();\n-                    if (table == null) {\n-                        return new NoOperation(session);\n-                    }\n-                    if (ifExists && !table.doesColumnExist(columnName)) {\n-                        return new NoOperation(session);\n-                    }\n-                    Column column = table.getColumn(columnName);\n-                    columnsToRemove.add(column);\n-                } while (readIf(\",\"));\n-                if (openingBracketDetected) {\n+                              boolean openingBracketDetected = readIf(\"(\");\n+                              do {\n+                                  String columnName = readColumnIdentifier();\n+                                  if (table == null) {\n+                                      return new NoOperation(session);\n+                                  }\n+                                  if (ifExists && !table.doesColumnExist(columnName)) {\n+                                      return new NoOperation(session);\n+                                  }\n+                                  Column column = table.getColumn(columnName);\n+                                  columnsToRemove.add(column);\n+                              } while (readIf(\",\"));\n+                              if (openingBracketDetected) {\n                     // For Oracle compatibility - close bracket\n-                    read(\")\");\n-                }\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setColumnsToRemove(columnsToRemove);\n-                return command;\n-            }\n-        } else if (readIf(\"CHANGE\")) {\n+                                  read(\")\");\n+                              }\n+                              command.setTableName(tableName);\n+                              command.setIfTableExists(ifTableExists);\n+                              command.setColumnsToRemove(columnsToRemove);\n+                              return command;\n+                          }\n+               } else if (readIf(\"CHANGE\")) {\n             // MySQL compatibility\n-            readIf(\"COLUMN\");\n-            String columnName = readColumnIdentifier();\n-            String newColumnName = readColumnIdentifier();\n-            Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-            boolean nullable = column == null ? true : column.isNullable();\n+                          readIf(\"COLUMN\");\n+                          String columnName = readColumnIdentifier();\n+                          String newColumnName = readColumnIdentifier();\n+                          Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+                          boolean nullable = column == null ? true : column.isNullable();\n             // new column type ignored. RENAME and MODIFY are\n             // a single command in MySQL but two different commands in H2.\n-            parseColumnForTable(newColumnName, nullable);\n-            AlterTableRenameColumn command = new AlterTableRenameColumn(session, schema);\n-            command.setTableName(tableName);\n-            command.setIfTableExists(ifTableExists);\n-            command.setOldColumnName(columnName);\n-            command.setNewColumnName(newColumnName);\n-            return command;\n-        } else if (readIf(\"MODIFY\")) {\n+                          parseColumnForTable(newColumnName, nullable);\n+                          AlterTableRenameColumn command = new AlterTableRenameColumn(session, schema);\n+                          command.setTableName(tableName);\n+                          command.setIfTableExists(ifTableExists);\n+                          command.setOldColumnName(columnName);\n+                          command.setNewColumnName(newColumnName);\n+                          return command;\n+                      } else if (readIf(\"MODIFY\")) {\n             // MySQL compatibility (optional)\n-            readIf(\"COLUMN\");\n+                          readIf(\"COLUMN\");\n             // Oracle specifies (but will not require) an opening parenthesis\n-            boolean hasOpeningBracket = readIf(\"(\");\n-            String columnName = readColumnIdentifier();\n-            AlterTableAlterColumn command = null;\n-            NullConstraintType nullConstraint = parseNotNullConstraint();\n-            switch (nullConstraint) {\n-            case NULL_IS_ALLOWED:\n-            case NULL_IS_NOT_ALLOWED:\n-                command = new AlterTableAlterColumn(session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-                command.setOldColumn(column);\n-                if (nullConstraint == NullConstraintType.NULL_IS_ALLOWED) {\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n-                } else {\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n-                }\n-                break;\n-            case NO_NULL_CONSTRAINT_FOUND:\n-                command = parseAlterTableAlterColumnType(schema, tableName, columnName, ifTableExists);\n-                break;\n-            default:\n-                throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n-                        \"Internal Error - unhandled case: \" + nullConstraint.name());\n-            }\n-            if(hasOpeningBracket) {\n-                read(\")\");\n-            }\n-            return command;\n-        } else if (readIf(\"ALTER\")) {\n-            readIf(\"COLUMN\");\n-            String columnName = readColumnIdentifier();\n-            Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n-            if (readIf(\"RENAME\")) {\n-                read(\"TO\");\n-                AlterTableRenameColumn command = new AlterTableRenameColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumnName(columnName);\n-                String newName = readColumnIdentifier();\n-                command.setNewColumnName(newName);\n-                return command;\n-            } else if (readIf(\"DROP\")) {\n+                          boolean hasOpeningBracket = readIf(\"(\");\n+                          String columnName = readColumnIdentifier();\n+                          AlterTableAlterColumn command = null;\n+                          NullConstraintType nullConstraint = parseNotNullConstraint();\n+                          switch (nullConstraint) {\n+                          case NULL_IS_ALLOWED:\n+                          case NULL_IS_NOT_ALLOWED:\n+                              command = new AlterTableAlterColumn(session, schema);\n+                              command.setTableName(tableName);\n+                              command.setIfTableExists(ifTableExists);\n+                              Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+                              command.setOldColumn(column);\n+                              if (nullConstraint == NullConstraintType.NULL_IS_ALLOWED) {\n+                                  command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n+                              } else {\n+                                  command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n+                              }\n+                              break;\n+                          case NO_NULL_CONSTRAINT_FOUND:\n+                              command = parseAlterTableAlterColumnType(schema, tableName, columnName, ifTableExists);\n+                              break;\n+                          default:\n+                              throw DbException.get(ErrorCode.UNKNOWN_MODE_1, \"Internal Error - unhandled case: \" + nullConstraint.name());\n+                          }\n+                          if (hasOpeningBracket) {\n+                              read(\")\");\n+                          }\n+                          return command;\n+                      } else if (readIf(\"ALTER\")) {\n+                                 readIf(\"COLUMN\");\n+                                 String columnName = readColumnIdentifier();\n+                                 Column column = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n+                                 if (readIf(\"RENAME\")) {\n+                                     read(\"TO\");\n+                                     AlterTableRenameColumn command = new AlterTableRenameColumn(session, schema);\n+                                     command.setTableName(tableName);\n+                                     command.setIfTableExists(ifTableExists);\n+                                     command.setOldColumnName(columnName);\n+                                     String newName = readColumnIdentifier();\n+                                     command.setNewColumnName(newName);\n+                                     return command;\n+                                 } else if (readIf(\"DROP\")) {\n                 // PostgreSQL compatibility\n-                if (readIf(\"DEFAULT\")) {\n-                    AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                            session, schema);\n-                    command.setTableName(tableName);\n-                    command.setIfTableExists(ifTableExists);\n-                    command.setOldColumn(column);\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n-                    command.setDefaultExpression(null);\n-                    return command;\n-                }\n-                read(\"NOT\");\n-                read(\"NULL\");\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumn(column);\n-                command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n-                return command;\n-            } else if (readIf(\"TYPE\")) {\n+                                     if (readIf(\"DEFAULT\")) {\n+                                         AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n+                                         command.setTableName(tableName);\n+                                         command.setIfTableExists(ifTableExists);\n+                                         command.setOldColumn(column);\n+                                         command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n+                                         command.setDefaultExpression(null);\n+                                         return command;\n+                                     }\n+                                     read(\"NOT\");\n+                                     read(\"NULL\");\n+                                     AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n+                                     command.setTableName(tableName);\n+                                     command.setIfTableExists(ifTableExists);\n+                                     command.setOldColumn(column);\n+                                     command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n+                                     return command;\n+                                 } else if (readIf(\"TYPE\")) {\n                 // PostgreSQL compatibility\n-                return parseAlterTableAlterColumnType(schema, tableName,\n-                        columnName, ifTableExists);\n-            } else if (readIf(\"SET\")) {\n-                if (readIf(\"DATA\")) {\n+                                                      return parseAlterTableAlterColumnType(schema, tableName, columnName, ifTableExists);\n+                                        } else if (readIf(\"SET\")) {\n+                                            if (readIf(\"DATA\")) {\n                     // Derby compatibility\n-                    read(\"TYPE\");\n-                    return parseAlterTableAlterColumnType(schema, tableName, columnName,\n-                            ifTableExists);\n-                }\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setOldColumn(column);\n-                NullConstraintType nullConstraint = parseNotNullConstraint();\n-                switch (nullConstraint) {\n-                case NULL_IS_ALLOWED:\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n-                    break;\n-                case NULL_IS_NOT_ALLOWED:\n-                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n-                    break;\n-                case NO_NULL_CONSTRAINT_FOUND:\n-                    if (readIf(\"DEFAULT\")) {\n-                        Expression defaultExpression = readExpression();\n-                        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n-                        command.setDefaultExpression(defaultExpression);\n-\n-                    } else if (readIf(\"INVISIBLE\")) {\n-                        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n-                        command.setVisible(false);\n-\n-                    } else if (readIf(\"VISIBLE\")) {\n-                        command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n-                        command.setVisible(true);\n-                    }\n-                    break;\n-                default:\n-                    throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n-                            \"Internal Error - unhandled case: \" + nullConstraint.name());\n-                }\n-                return command;\n-            } else if (readIf(\"RESTART\")) {\n-                readIf(\"WITH\");\n-                Expression start = readExpression();\n-                AlterSequence command = new AlterSequence(session, schema);\n-                command.setColumn(column);\n-                command.setStartWith(start);\n-                return commandIfTableExists(schema, tableName, ifTableExists, command);\n-            } else if (readIf(\"SELECTIVITY\")) {\n-                AlterTableAlterColumn command = new AlterTableAlterColumn(\n-                        session, schema);\n-                command.setTableName(tableName);\n-                command.setIfTableExists(ifTableExists);\n-                command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_SELECTIVITY);\n-                command.setOldColumn(column);\n-                command.setSelectivity(readExpression());\n-                return command;\n-            } else {\n-                return parseAlterTableAlterColumnType(schema, tableName,\n-                        columnName, ifTableExists);\n-            }\n-        }\n+                                                read(\"TYPE\");\n+                                                return parseAlterTableAlterColumnType(schema, tableName, columnName, ifTableExists);\n+                                            }\n+                                            AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n+                                            command.setTableName(tableName);\n+                                            command.setIfTableExists(ifTableExists);\n+                                            command.setOldColumn(column);\n+                                            NullConstraintType nullConstraint = parseNotNullConstraint();\n+                                            switch (nullConstraint) {\n+                                            case NULL_IS_ALLOWED:\n+                                                command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NULL);\n+                                                break;\n+                                            case NULL_IS_NOT_ALLOWED:\n+                                                command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_NOT_NULL);\n+                                                break;\n+                                            case NO_NULL_CONSTRAINT_FOUND:\n+                                                if (readIf(\"DEFAULT\")) {\n+                                                    Expression defaultExpression = readExpression();\n+                                                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_DEFAULT);\n+                                                    command.setDefaultExpression(defaultExpression);\n+                                                } else if (readIf(\"INVISIBLE\")) {\n+                                                    command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n+                                                    command.setVisible(false);\n+                                                } else if (readIf(\"VISIBLE\")) {\n+                                                           command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_VISIBILITY);\n+                                                           command.setVisible(true);\n+                                                       }\n+                                                break;\n+                                            default:\n+                                                throw DbException.get(ErrorCode.UNKNOWN_MODE_1, \"Internal Error - unhandled case: \" + nullConstraint.name());\n+                                            }\n+                                            return command;\n+                                        } else if (readIf(\"RESTART\")) {\n+                                                   readIf(\"WITH\");\n+                                                   Expression start = readExpression();\n+                                                   AlterSequence command = new AlterSequence(session, schema);\n+                                                   command.setColumn(column);\n+                                                   command.setStartWith(start);\n+                                                   return commandIfTableExists(schema, tableName, ifTableExists, command);\n+                                               } else if (readIf(\"SELECTIVITY\")) {\n+                                                   AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n+                                                   command.setTableName(tableName);\n+                                                   command.setIfTableExists(ifTableExists);\n+                                                   command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_SELECTIVITY);\n+                                                   command.setOldColumn(column);\n+                                                   command.setSelectivity(readExpression());\n+                                                   return command;\n+                                               } else {\n+                                                   return parseAlterTableAlterColumnType(schema, tableName, columnName, ifTableExists);\n+                                               }\n+                             }\n         throw getSyntaxError();\n     }\n \n@@ -6210,26 +6057,20 @@ public class Parser {\n         return table;\n     }\n \n-    private Column columnIfTableExists(Schema schema, String tableName,\n-            String columnName, boolean ifTableExists) {\n+    private Column columnIfTableExists(Schema schema, String tableName, String columnName, boolean ifTableExists) {\n         Table table = tableIfTableExists(schema, tableName, ifTableExists);\n         return table == null ? null : table.getColumn(columnName);\n     }\n \n-    private Prepared commandIfTableExists(Schema schema, String tableName,\n-            boolean ifTableExists, Prepared commandIfTableExists) {\n-        return tableIfTableExists(schema, tableName, ifTableExists) == null\n-            ? new NoOperation(session)\n-            : commandIfTableExists;\n+    private Prepared commandIfTableExists(Schema schema, String tableName, boolean ifTableExists, Prepared commandIfTableExists) {\n+        return tableIfTableExists(schema, tableName, ifTableExists) == null ? new NoOperation(session) : commandIfTableExists;\n     }\n \n-    private AlterTableAlterColumn parseAlterTableAlterColumnType(Schema schema,\n-            String tableName, String columnName, boolean ifTableExists) {\n+    private AlterTableAlterColumn parseAlterTableAlterColumnType(Schema schema, String tableName, String columnName, boolean ifTableExists) {\n         Column oldColumn = columnIfTableExists(schema, tableName, columnName, ifTableExists);\n         Column newColumn = parseColumnForTable(columnName,\n-                oldColumn == null ? true : oldColumn.isNullable());\n-        AlterTableAlterColumn command = new AlterTableAlterColumn(session,\n-                schema);\n+            oldColumn == null ? true : oldColumn.isNullable());\n+        AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n         command.setTableName(tableName);\n         command.setIfTableExists(ifTableExists);\n         command.setType(CommandInterface.ALTER_TABLE_ALTER_COLUMN_CHANGE_TYPE);\n@@ -6238,11 +6079,9 @@ public class Parser {\n         return command;\n     }\n \n-    private AlterTableAlterColumn parseAlterTableAddColumn(String tableName,\n-            Schema schema, boolean ifTableExists) {\n+    private AlterTableAlterColumn parseAlterTableAddColumn(String tableName, Schema schema, boolean ifTableExists) {\n         readIf(\"COLUMN\");\n-        AlterTableAlterColumn command = new AlterTableAlterColumn(session,\n-                schema);\n+        AlterTableAlterColumn command = new AlterTableAlterColumn(session, schema);\n         command.setType(CommandInterface.ALTER_TABLE_ADD_COLUMN);\n         command.setTableName(tableName);\n         command.setIfTableExists(ifTableExists);\n@@ -6292,14 +6131,13 @@ public class Parser {\n         if (readIf(\"CASCADE\")) {\n             return ConstraintActionType.CASCADE;\n         } else if (readIf(\"RESTRICT\")) {\n-            return ConstraintActionType.RESTRICT;\n+        return ConstraintActionType.RESTRICT;\n         } else {\n             return null;\n         }\n     }\n \n-    private DefineCommand parseAlterTableAddConstraintIf(String tableName,\n-            Schema schema, boolean ifTableExists) {\n+    private DefineCommand parseAlterTableAddConstraintIf(String tableName, Schema schema, boolean ifTableExists) {\n         String constraintName = null, comment = null;\n         boolean ifNotExists = false;\n         boolean allowIndexDefinition = database.getMode().indexDefinitionInCreateTable;\n@@ -6313,8 +6151,7 @@ public class Parser {\n         }\n         if (readIf(\"PRIMARY\")) {\n             read(\"KEY\");\n-            AlterTableAddConstraint command = new AlterTableAddConstraint(\n-                    session, schema, ifNotExists);\n+            AlterTableAddConstraint command = new AlterTableAddConstraint(session, schema, ifNotExists);\n             command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n             command.setComment(comment);\n             command.setConstraintName(constraintName);\n@@ -6356,12 +6193,12 @@ public class Parser {\n             }\n             return command;\n         } else if (allowAffinityKey && readIfAffinity()) {\n-            read(\"KEY\");\n-            read(\"(\");\n-            CreateIndex command = createAffinityIndex(schema, tableName, parseIndexColumnList());\n-            command.setIfTableExists(ifTableExists);\n-            return command;\n-        }\n+                   read(\"KEY\");\n+                   read(\"(\");\n+                   CreateIndex command = createAffinityIndex(schema, tableName, parseIndexColumnList());\n+                   command.setIfTableExists(ifTableExists);\n+                   return command;\n+               }\n         AlterTableAddConstraint command;\n         if (readIf(\"CHECK\")) {\n             command = new AlterTableAddConstraint(session, schema, ifNotExists);\n@@ -6386,23 +6223,23 @@ public class Parser {\n                 read(\"BTREE\");\n             }\n         } else if (readIf(\"FOREIGN\")) {\n-            command = new AlterTableAddConstraint(session, schema, ifNotExists);\n-            command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n-            read(\"KEY\");\n-            read(\"(\");\n-            command.setIndexColumns(parseIndexColumnList());\n-            if (readIf(\"INDEX\")) {\n-                String indexName = readIdentifierWithSchema();\n-                command.setIndex(schema.findIndex(session, indexName));\n-            }\n-            read(\"REFERENCES\");\n-            parseReferences(command, schema, tableName);\n-        } else {\n-            if (constraintName != null) {\n-                throw getSyntaxError();\n-            }\n-            return null;\n-        }\n+                   command = new AlterTableAddConstraint(session, schema, ifNotExists);\n+                   command.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n+                   read(\"KEY\");\n+                   read(\"(\");\n+                   command.setIndexColumns(parseIndexColumnList());\n+                   if (readIf(\"INDEX\")) {\n+                       String indexName = readIdentifierWithSchema();\n+                       command.setIndex(schema.findIndex(session, indexName));\n+                   }\n+                   read(\"REFERENCES\");\n+                   parseReferences(command, schema, tableName);\n+               } else {\n+                   if (constraintName != null) {\n+                       throw getSyntaxError();\n+                   }\n+                   return null;\n+               }\n         if (readIf(\"NOCHECK\")) {\n             command.setCheckExisting(false);\n         } else {\n@@ -6447,8 +6284,7 @@ public class Parser {\n         }\n     }\n \n-    private CreateLinkedTable parseCreateLinkedTable(boolean temp,\n-            boolean globalTemp, boolean force) {\n+    private CreateLinkedTable parseCreateLinkedTable(boolean temp, boolean globalTemp, boolean force) {\n         read(\"TABLE\");\n         boolean ifNotExists = readIfNotExists();\n         String tableName = readIdentifierWithSchema();\n@@ -6484,8 +6320,7 @@ public class Parser {\n         return command;\n     }\n \n-    private CreateTable parseCreateTable(boolean temp, boolean globalTemp,\n-            boolean persistIndexes) {\n+    private CreateTable parseCreateTable(boolean temp, boolean globalTemp, boolean persistIndexes) {\n         boolean ifNotExists = readIfNotExists();\n         String tableName = readIdentifierWithSchema();\n         if (temp && globalTemp && equalsToken(\"SESSION\", schemaName)) {\n@@ -6505,8 +6340,7 @@ public class Parser {\n         if (readIf(\"(\")) {\n             if (!readIf(\")\")) {\n                 do {\n-                    DefineCommand c = parseAlterTableAddConstraintIf(tableName,\n-                            schema, false);\n+                    DefineCommand c = parseAlterTableAddConstraintIf(tableName, schema, false);\n                     if (c != null) {\n                         command.addConstraintCommand(c);\n                     } else {\n@@ -6516,8 +6350,7 @@ public class Parser {\n                             column.setPrimaryKey(false);\n                             IndexColumn[] cols = { new IndexColumn() };\n                             cols[0].columnName = column.getName();\n-                            AlterTableAddConstraint pk = new AlterTableAddConstraint(\n-                                    session, schema, false);\n+                            AlterTableAddConstraint pk = new AlterTableAddConstraint(session, schema, false);\n                             pk.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n                             pk.setTableName(tableName);\n                             pk.setIndexColumns(cols);\n@@ -6536,8 +6369,7 @@ public class Parser {\n                             boolean hash = readIf(\"HASH\");\n                             IndexColumn[] cols = { new IndexColumn() };\n                             cols[0].columnName = column.getName();\n-                            AlterTableAddConstraint pk = new AlterTableAddConstraint(\n-                                    session, schema, false);\n+                            AlterTableAddConstraint pk = new AlterTableAddConstraint(session, schema, false);\n                             pk.setPrimaryKeyHash(hash);\n                             pk.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_PRIMARY_KEY);\n                             pk.setTableName(tableName);\n@@ -6557,16 +6389,15 @@ public class Parser {\n                             CreateIndex idx = createAffinityIndex(schema, tableName, cols);\n                             command.addConstraintCommand(idx);\n                         } else if (readIf(\"UNIQUE\")) {\n-                            AlterTableAddConstraint unique = new AlterTableAddConstraint(\n-                                    session, schema, false);\n-                            unique.setConstraintName(constraintName);\n-                            unique.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_UNIQUE);\n-                            IndexColumn[] cols = { new IndexColumn() };\n-                            cols[0].columnName = columnName;\n-                            unique.setIndexColumns(cols);\n-                            unique.setTableName(tableName);\n-                            command.addConstraintCommand(unique);\n-                        }\n+                                   AlterTableAddConstraint unique = new AlterTableAddConstraint(session, schema, false);\n+                                   unique.setConstraintName(constraintName);\n+                                   unique.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_UNIQUE);\n+                                   IndexColumn[] cols = { new IndexColumn() };\n+                                   cols[0].columnName = columnName;\n+                                   unique.setIndexColumns(cols);\n+                                   unique.setTableName(tableName);\n+                                   command.addConstraintCommand(unique);\n+                               }\n                         if (NullConstraintType.NULL_IS_NOT_ALLOWED == parseNotNullConstraint()) {\n                             column.setNullable(false);\n                         }\n@@ -6575,8 +6406,7 @@ public class Parser {\n                             column.addCheckConstraint(session, expr);\n                         }\n                         if (readIf(\"REFERENCES\")) {\n-                            AlterTableAddConstraint ref = new AlterTableAddConstraint(\n-                                    session, schema, false);\n+                            AlterTableAddConstraint ref = new AlterTableAddConstraint(session, schema, false);\n                             ref.setConstraintName(constraintName);\n                             ref.setType(CommandInterface.ALTER_TABLE_ADD_CONSTRAINT_REFERENTIAL);\n                             IndexColumn[] cols = { new IndexColumn() };\n@@ -6603,6 +6433,7 @@ public class Parser {\n                 String tableEngine = readUniqueIdentifier();\n                 if (\"InnoDb\".equalsIgnoreCase(tableEngine)) {\n                     // ok\n+\n                 } else if (!\"MyISAM\".equalsIgnoreCase(tableEngine)) {\n                     throw DbException.getUnsupportedException(tableEngine);\n                 }\n@@ -6616,10 +6447,8 @@ public class Parser {\n         // MySQL compatibility\n         if (readIf(\"AUTO_INCREMENT\")) {\n             read(\"=\");\n-            if (currentTokenType != VALUE ||\n-                    currentValue.getType() != Value.INT) {\n-                throw DbException.getSyntaxError(sqlCommand, parseIndex,\n-                        \"integer\");\n+            if (currentTokenType != VALUE || currentValue.getType() != Value.INT) {\n+                throw DbException.getSyntaxError(sqlCommand, parseIndex, \"integer\");\n             }\n             read();\n         }\n@@ -6674,8 +6503,11 @@ public class Parser {\n     /**\n      * Enumeration describing null constraints\n      */\n+\n     private enum NullConstraintType {\n-        NULL_IS_ALLOWED, NULL_IS_NOT_ALLOWED, NO_NULL_CONSTRAINT_FOUND\n+        NULL_IS_ALLOWED,\n+        NULL_IS_NOT_ALLOWED,\n+        NO_NULL_CONSTRAINT_FOUND\n     }\n \n     private NullConstraintType parseNotNullConstraint() {\n@@ -6716,7 +6548,6 @@ public class Parser {\n         Schema synonymSchema = getSchema();\n         read(\"FOR\");\n         String tableName = readIdentifierWithSchema();\n-\n         Schema targetSchema = getSchema();\n         CreateSynonym command = new CreateSynonym(session, synonymSchema);\n         command.setName(name);\n@@ -6763,6 +6594,8 @@ public class Parser {\n      * @param s the identifier\n      * @return the quoted identifier\n      */\n+\n+\n     public static String quoteIdentifier(String s) {\n         if (s == null) {\n             return \"\\\"\\\"\";\n@@ -6773,14 +6606,17 @@ public class Parser {\n         return StringUtils.quoteIdentifier(s);\n     }\n \n+\n     public void setLiteralsChecked(boolean literalsChecked) {\n         this.literalsChecked = literalsChecked;\n     }\n \n+\n     public void setRightsChecked(boolean rightsChecked) {\n         this.rightsChecked = rightsChecked;\n     }\n \n+\n     public void setSuppliedParameterList(ArrayList<Parameter> suppliedParameterList) {\n         this.suppliedParameterList = suppliedParameterList;\n     }\n@@ -6791,6 +6627,8 @@ public class Parser {\n      * @param sql the code snippet\n      * @return the expression object\n      */\n+\n+\n     public Expression parseExpression(String sql) {\n         parameters = New.arrayList();\n         initialize(sql);\n@@ -6804,10 +6642,13 @@ public class Parser {\n      * @param sql the code snippet\n      * @return the table object\n      */\n+\n+\n     public Table parseTableName(String sql) {\n         parameters = New.arrayList();\n         initialize(sql);\n         read();\n         return readTableOrView();\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 1772
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/411/Parser.java\nindex 76588612d8..0baf843d59 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/411/Parser.java\n@@ -6095,7 +6095,7 @@ public class Parser {\n                 throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n                         \"Internal Error - unhandled case: \" + nullConstraint.name());\n             }\n-            if(hasOpeningBracket) {\n+            if (hasOpeningBracket) {\n                 read(\")\");\n             }\n             return command;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/411/Parser.java\nindex 76588612d8..0baf843d59 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/411/Parser.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/411/Parser.java\n@@ -6095,7 +6095,7 @@ public class Parser {\n                 throw DbException.get(ErrorCode.UNKNOWN_MODE_1,\n                         \"Internal Error - unhandled case: \" + nullConstraint.name());\n             }\n-            if(hasOpeningBracket) {\n+            if (hasOpeningBracket) {\n                 read(\")\");\n             }\n             return command;\n",
            "diff_size": 1
        }
    ]
}