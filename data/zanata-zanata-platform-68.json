{
    "error_id": "68",
    "information": {
        "errors": [
            {
                "line": "206",
                "column": "50",
                "severity": "error",
                "message": "'=' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "                    doc.getDocId());\n            // right now we only target untranslated. We might target more in the future\n            List<HTextFlow> untranslatedTextFlows=\n                    textFlowDAO\n                            .getAllTextFlowByDocumentIdWithConstraints(\n                                    documentId, targetLocale,",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler/68/MachineTranslationServiceImpl.java\nindex 4366d173c7..ad7fe4504a 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler/68/MachineTranslationServiceImpl.java\n@@ -203,7 +203,7 @@ public class MachineTranslationServiceImpl implements\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n             // right now we only target untranslated. We might target more in the future\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/intellij/68/MachineTranslationServiceImpl.java\nindex 4366d173c7..96bff62864 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/intellij/68/MachineTranslationServiceImpl.java\n@@ -18,6 +18,7 @@\n  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  */\n+\n package org.zanata.service.impl;\n \n import java.net.URI;\n@@ -80,9 +81,9 @@ import com.google.common.collect.Maps;\n  */\n @RequestScoped\n public class MachineTranslationServiceImpl implements\n-        MachineTranslationService {\n+    MachineTranslationService {\n     private static final Logger log =\n-            LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n+        LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n \n     private URI mtServiceURL;\n     private String mtUser;\n@@ -100,15 +101,15 @@ public class MachineTranslationServiceImpl implements\n \n     @Inject\n     public MachineTranslationServiceImpl(@MTServiceURL URI mtServiceURL,\n-            @MTServiceUser String mtUser,\n-            @MTServiceToken String mtToken,\n-            TextFlowsToMTDoc textFlowsToMTDoc,\n-            TextFlowDAO textFlowDAO,\n-            LocaleService localeService,\n-            EntityManager entityManager,\n-            TransactionUtil transactionUtil,\n-            TranslationService translationService,\n-            VersionStateCache versionStateCache) {\n+                                         @MTServiceUser String mtUser,\n+                                         @MTServiceToken String mtToken,\n+                                         TextFlowsToMTDoc textFlowsToMTDoc,\n+                                         TextFlowDAO textFlowDAO,\n+                                         LocaleService localeService,\n+                                         EntityManager entityManager,\n+                                         TransactionUtil transactionUtil,\n+                                         TranslationService translationService,\n+                                         VersionStateCache versionStateCache) {\n         this.mtServiceURL = mtServiceURL;\n         this.mtUser = mtUser;\n         this.mtToken = mtToken;\n@@ -123,8 +124,8 @@ public class MachineTranslationServiceImpl implements\n \n     @Override\n     public List<String> getSuggestion(@Nonnull HTextFlow textFlow,\n-            @Nonnull LocaleId fromLocale,\n-            @Nonnull LocaleId toLocale) {\n+                                      @Nonnull LocaleId fromLocale,\n+                                      @Nonnull LocaleId toLocale) {\n \n         HDocument document = textFlow.getDocument();\n         String docId = document.getDocId();\n@@ -132,12 +133,12 @@ public class MachineTranslationServiceImpl implements\n         String projectSlug = document.getProjectIteration().getProject().getSlug();\n \n         MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug,\n-                versionSlug, docId, fromLocale, textFlow);\n+            versionSlug, docId, fromLocale, textFlow);\n \n         try {\n             MTDocument result = getTranslationFromMT(doc, toLocale);\n             return result.getContents().stream().map(TypeString::getValue)\n-                    .collect(Collectors.toList());\n+                .collect(Collectors.toList());\n         } catch (ZanataServiceException e) {\n             log.error(\"failed to get translations from machine translation\");\n             return Collections.emptyList();\n@@ -146,18 +147,18 @@ public class MachineTranslationServiceImpl implements\n     }\n \n     private MTDocument getTranslationFromMT(MTDocument request,\n-            LocaleId toLocale) throws ZanataServiceException {\n+                                            LocaleId toLocale) throws ZanataServiceException {\n         ResteasyClient client = new ResteasyClientBuilder().build();\n \n         ResteasyWebTarget webTarget = client.target(mtServiceURL).path(\"api\")\n-                .path(\"document\").path(\"translate\")\n-                .queryParam(\"toLocaleCode\", toLocale.getId());\n+            .path(\"document\").path(\"translate\")\n+            .queryParam(\"toLocaleCode\", toLocale.getId());\n         Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE)\n-                .header(\"X-Auth-User\", mtUser)\n-                .header(\"X-Auth-Token\", mtToken)\n-                .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n-                .header(\"Accept\", MediaType.APPLICATION_JSON)\n-                .post(Entity.json(request));\n+            .header(\"X-Auth-User\", mtUser)\n+            .header(\"X-Auth-Token\", mtToken)\n+            .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n+            .header(\"Accept\", MediaType.APPLICATION_JSON)\n+            .post(Entity.json(request));\n \n         if (response.getStatus() == 200) {\n             MTDocument result = response.readEntity(MTDocument.class);\n@@ -167,8 +168,8 @@ public class MachineTranslationServiceImpl implements\n             return result;\n         } else {\n             log.warn(\"Machine translation return status: {}, header: {}, body: {}\",\n-                    response.getStatus(), response.getHeaders(),\n-                    response.readEntity(String.class));\n+                response.getStatus(), response.getHeaders(),\n+                response.readEntity(String.class));\n             throw new ZanataServiceException(\"failed to get translations from machine translation\");\n         }\n     }\n@@ -176,8 +177,8 @@ public class MachineTranslationServiceImpl implements\n     @Async\n     @Override\n     public Future<Void> prefillWithMachineTranslation(\n-            Long versionId, MachineTranslationPrefill prefillRequest,\n-            @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n+        Long versionId, MachineTranslationPrefill prefillRequest,\n+        @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n         // need to reload all entities\n         HProjectIteration version = entityManager.find(HProjectIteration.class, versionId);\n         HLocale targetLocale = localeService.getByLocaleId(prefillRequest.getToLocale());\n@@ -190,7 +191,7 @@ public class MachineTranslationServiceImpl implements\n         // TODO this assumes all documents using same source locale\n         // TODO some document don't have source locale (null)\n         LocaleId fromLocale =\n-                documents.values().iterator().next().getSourceLocaleId();\n+            documents.values().iterator().next().getSourceLocaleId();\n \n         Stopwatch overallStopwatch = Stopwatch.createStarted();\n         Long targetVersionId = version.getId();\n@@ -201,19 +202,19 @@ public class MachineTranslationServiceImpl implements\n         List<MTDocument> mtDocuments = Lists.newArrayList();\n         for (HDocument doc : documents.values()) {\n             DocumentId documentId = new DocumentId(doc.getId(),\n-                    doc.getDocId());\n+                doc.getDocId());\n             // right now we only target untranslated. We might target more in the future\n-            List<HTextFlow> untranslatedTextFlows=\n-                    textFlowDAO\n-                            .getAllTextFlowByDocumentIdWithConstraints(\n-                                    documentId, targetLocale,\n-                                    FilterConstraints.builder()\n-                                            .keepNone().includeNew()\n-                                            .build());\n+            List<HTextFlow> untranslatedTextFlows =\n+                textFlowDAO\n+                    .getAllTextFlowByDocumentIdWithConstraints(\n+                        documentId, targetLocale,\n+                        FilterConstraints.builder()\n+                            .keepNone().includeNew()\n+                            .build());\n             MTDocument mtDocument = textFlowsToMTDoc\n-                    .fromTextFlows(projectSlug, versionSlug,\n-                            doc.getDocId(), fromLocale,\n-                            untranslatedTextFlows);\n+                .fromTextFlows(projectSlug, versionSlug,\n+                    doc.getDocId(), fromLocale,\n+                    untranslatedTextFlows);\n             docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n             mtDocuments.add(mtDocument);\n         }\n@@ -222,9 +223,9 @@ public class MachineTranslationServiceImpl implements\n         log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n \n         List<MTDocument> result = mtDocuments.stream()\n-                .map(mtDoc -> getTranslationFromMT(mtDoc,\n-                        targetLocale.getLocaleId()))\n-                .collect(Collectors.toList());\n+            .map(mtDoc -> getTranslationFromMT(mtDoc,\n+                targetLocale.getLocaleId()))\n+            .collect(Collectors.toList());\n \n         log.info(\"get back result: {}\", result.size());\n \n@@ -237,46 +238,46 @@ public class MachineTranslationServiceImpl implements\n             MTDocument transDoc = result.get(i);\n \n             translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n-                    targetLocale, prefillRequest.getSaveState());\n+                targetLocale, prefillRequest.getSaveState());\n \n             taskHandle.increaseProgress(1);\n         }\n         versionStateCache.clearVersionStatsCache(targetVersionId);\n \n         log.info(\"{} prefill translation with machine translations for version {}, {}\",\n-                cancelled ? \"CANCELLED\" : \"COMPLETED\",\n-                version.userFriendlyToString(), overallStopwatch);\n+            cancelled ? \"CANCELLED\" : \"COMPLETED\",\n+            version.userFriendlyToString(), overallStopwatch);\n         return AsyncTaskResult.completed();\n     }\n \n     private void translateInBatch(List<HTextFlow> textFlows,\n-            MTDocument transDoc,\n-            HLocale targetLocale, ContentState saveState) {\n+                                  MTDocument transDoc,\n+                                  HLocale targetLocale, ContentState saveState) {\n         int index = 0;\n         while (index < textFlows.size()) {\n             int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n             List<HTextFlow> batch = textFlows.subList(index, bound);\n             List<TypeString> transContentBatch =\n-                    transDoc.getContents().subList(index, bound);\n+                transDoc.getContents().subList(index, bound);\n \n             List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n             index += bound;\n             for (int i = 0; i < batch.size(); i++) {\n                 HTextFlow textFlow = batch.get(i);\n                 HTextFlowTarget maybeTarget =\n-                        textFlow.getTargets().get(targetLocale.getId());\n+                    textFlow.getTargets().get(targetLocale.getId());\n                 int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n                 List<String> translation = Lists.newArrayList(\n-                        transContentBatch.get(i).getValue());\n+                    transContentBatch.get(i).getValue());\n                 // TODO TranslationSourceType only says MT but without provider name\n                 TransUnitUpdateRequest updateRequest =\n-                        new TransUnitUpdateRequest(\n-                                new TransUnitId(textFlow.getId()),\n-                                translation,\n-                                saveState,\n-                                baseRevision,\n-                                TranslationSourceType.MACHINE_TRANS\n-                                        .getAbbr());\n+                    new TransUnitUpdateRequest(\n+                        new TransUnitId(textFlow.getId()),\n+                        translation,\n+                        saveState,\n+                        baseRevision,\n+                        TranslationSourceType.MACHINE_TRANS\n+                            .getAbbr());\n                 updateRequest.addRevisionComment(\"Translated by Google\");\n                 updateRequests.add(updateRequest);\n             }\n",
            "diff_size": 58
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/naturalize/68/MachineTranslationServiceImpl.java\nindex 4366d173c7..ed1f2cf282 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/naturalize/68/MachineTranslationServiceImpl.java\n@@ -203,23 +203,21 @@ public class MachineTranslationServiceImpl implements\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n             // right now we only target untranslated. We might target more in the future\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n                                     FilterConstraints.builder()\n                                             .keepNone().includeNew()\n                                             .build());\n-            MTDocument mtDocument = textFlowsToMTDoc\n+MTDocument mtDocument = textFlowsToMTDoc\n                     .fromTextFlows(projectSlug, versionSlug,\n                             doc.getDocId(), fromLocale,\n                             untranslatedTextFlows);\n             docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n             mtDocuments.add(mtDocument);\n         }\n-\n-\n-        log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n+log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n \n         List<MTDocument> result = mtDocuments.stream()\n                 .map(mtDoc -> getTranslationFromMT(mtDoc,\n@@ -229,9 +227,7 @@ public class MachineTranslationServiceImpl implements\n         log.info(\"get back result: {}\", result.size());\n \n         taskHandle.setMaxProgress(mtDocuments.size());\n-\n-\n-        boolean cancelled = false;\n+boolean cancelled = false;\n         for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n             MTDocument sourceDoc = mtDocuments.get(i);\n             MTDocument transDoc = result.get(i);\n@@ -290,4 +286,4 @@ public class MachineTranslationServiceImpl implements\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/codebuff/68/MachineTranslationServiceImpl.java\nindex 4366d173c7..6f9e45470e 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/codebuff/68/MachineTranslationServiceImpl.java\n@@ -26,7 +26,6 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Future;\n import java.util.stream.Collectors;\n-\n import javax.annotation.Nonnull;\n import javax.enterprise.context.RequestScoped;\n import javax.inject.Inject;\n@@ -34,7 +33,6 @@ import javax.persistence.EntityManager;\n import javax.ws.rs.client.Entity;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n-\n import org.jboss.resteasy.client.jaxrs.ResteasyClient;\n import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;\n import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;\n@@ -69,7 +67,6 @@ import org.zanata.webtrans.shared.model.DocumentId;\n import org.zanata.webtrans.shared.model.TransUnitId;\n import org.zanata.webtrans.shared.model.TransUnitUpdateRequest;\n import org.zanata.webtrans.shared.search.FilterConstraints;\n-\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n@@ -78,12 +75,11 @@ import com.google.common.collect.Maps;\n  * @author Patrick Huang\n  * <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n  */\n-@RequestScoped\n-public class MachineTranslationServiceImpl implements\n-        MachineTranslationService {\n-    private static final Logger log =\n-            LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n \n+\n+@RequestScoped\n+public class MachineTranslationServiceImpl implements MachineTranslationService {\n+    private static final Logger log = LoggerFactory.getLogger(MachineTranslationServiceImpl.class);\n     private URI mtServiceURL;\n     private String mtUser;\n     private String mtToken;\n@@ -100,15 +96,14 @@ public class MachineTranslationServiceImpl implements\n \n     @Inject\n     public MachineTranslationServiceImpl(@MTServiceURL URI mtServiceURL,\n-            @MTServiceUser String mtUser,\n+        @MTServiceUser String mtUser,\n             @MTServiceToken String mtToken,\n-            TextFlowsToMTDoc textFlowsToMTDoc,\n-            TextFlowDAO textFlowDAO,\n-            LocaleService localeService,\n-            EntityManager entityManager,\n-            TransactionUtil transactionUtil,\n-            TranslationService translationService,\n-            VersionStateCache versionStateCache) {\n+        TextFlowsToMTDoc textFlowsToMTDoc,\n+        TextFlowDAO textFlowDAO,\n+        LocaleService localeService,\n+        EntityManager entityManager,\n+        TransactionUtil transactionUtil,\n+        TranslationService translationService, VersionStateCache versionStateCache) {\n         this.mtServiceURL = mtServiceURL;\n         this.mtUser = mtUser;\n         this.mtToken = mtToken;\n@@ -122,130 +117,109 @@ public class MachineTranslationServiceImpl implements\n     }\n \n     @Override\n-    public List<String> getSuggestion(@Nonnull HTextFlow textFlow,\n-            @Nonnull LocaleId fromLocale,\n+    public List<String> getSuggestion(\n+        @Nonnull HTextFlow textFlow, @Nonnull LocaleId fromLocale,\n             @Nonnull LocaleId toLocale) {\n-\n         HDocument document = textFlow.getDocument();\n         String docId = document.getDocId();\n         String versionSlug = document.getProjectIteration().getSlug();\n-        String projectSlug = document.getProjectIteration().getProject().getSlug();\n-\n-        MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug,\n-                versionSlug, docId, fromLocale, textFlow);\n-\n+        String projectSlug = document.getProjectIteration().getProject()\n+                                                           .getSlug();\n+        MTDocument doc = textFlowsToMTDoc.fromSingleTextFlow(projectSlug, versionSlug, docId, fromLocale, textFlow);\n         try {\n             MTDocument result = getTranslationFromMT(doc, toLocale);\n-            return result.getContents().stream().map(TypeString::getValue)\n-                    .collect(Collectors.toList());\n+            return result.getContents().stream()\n+                                       .map(TypeString::getValue)\n+                                       .collect(Collectors.toList());\n         } catch (ZanataServiceException e) {\n             log.error(\"failed to get translations from machine translation\");\n             return Collections.emptyList();\n         }\n-\n     }\n \n-    private MTDocument getTranslationFromMT(MTDocument request,\n-            LocaleId toLocale) throws ZanataServiceException {\n+    private MTDocument getTranslationFromMT(MTDocument request, LocaleId toLocale) throws ZanataServiceException {\n         ResteasyClient client = new ResteasyClientBuilder().build();\n-\n         ResteasyWebTarget webTarget = client.target(mtServiceURL).path(\"api\")\n-                .path(\"document\").path(\"translate\")\n-                .queryParam(\"toLocaleCode\", toLocale.getId());\n-        Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE)\n-                .header(\"X-Auth-User\", mtUser)\n-                .header(\"X-Auth-Token\", mtToken)\n-                .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n-                .header(\"Accept\", MediaType.APPLICATION_JSON)\n-                .post(Entity.json(request));\n-\n+                                                                 .path(\"document\")\n+                                                                 .path(\"translate\")\n+                                                                 .queryParam(\"toLocaleCode\", toLocale.getId());\n+        Response response = webTarget.request(MediaType.APPLICATION_JSON_TYPE).header(\"X-Auth-User\", mtUser)\n+                                                                              .header(\"X-Auth-Token\", mtToken)\n+                                                                              .header(\"Content-Type\", MediaType.APPLICATION_JSON)\n+                                                                              .header(\"Accept\", MediaType.APPLICATION_JSON)\n+                                                                              .post(Entity.json(request));\n         if (response.getStatus() == 200) {\n             MTDocument result = response.readEntity(MTDocument.class);\n             if (!result.getWarnings().isEmpty()) {\n-                log.warn(\"Machine translation returns warning: {}\", result.getWarnings());\n+                log.warn(\"Machine translation returns warning: {}\",\n+result.getWarnings());\n             }\n             return result;\n         } else {\n-            log.warn(\"Machine translation return status: {}, header: {}, body: {}\",\n-                    response.getStatus(), response.getHeaders(),\n-                    response.readEntity(String.class));\n+            log.warn(\"Machine translation return status: {}, header: {}, body: {}\", response.getStatus(), response.getHeaders(), response.readEntity(String.class));\n             throw new ZanataServiceException(\"failed to get translations from machine translation\");\n         }\n     }\n \n     @Async\n     @Override\n-    public Future<Void> prefillWithMachineTranslation(\n-            Long versionId, MachineTranslationPrefill prefillRequest,\n-            @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n+    public Future<Void> prefillWithMachineTranslation(Long versionId, MachineTranslationPrefill prefillRequest,\n+        @Nonnull MachineTranslationPrefillTaskHandle taskHandle) {\n         // need to reload all entities\n         HProjectIteration version = entityManager.find(HProjectIteration.class, versionId);\n         HLocale targetLocale = localeService.getByLocaleId(prefillRequest.getToLocale());\n         Map<String, HDocument> documents = version.getDocuments();\n         if (documents.isEmpty()) {\n-            log.warn(\"no document in this version {}\", version.userFriendlyToString());\n+            log.warn(\"no document in this version {}\",\n+version.userFriendlyToString());\n             return AsyncTaskResult.completed();\n         }\n \n         // TODO this assumes all documents using same source locale\n         // TODO some document don't have source locale (null)\n-        LocaleId fromLocale =\n-                documents.values().iterator().next().getSourceLocaleId();\n-\n+        LocaleId fromLocale = documents.values().iterator()\n+                                                .next()\n+                                                .getSourceLocaleId();\n         Stopwatch overallStopwatch = Stopwatch.createStarted();\n         Long targetVersionId = version.getId();\n         String projectSlug = version.getProject().getSlug();\n         String versionSlug = version.getSlug();\n-\n         Map<String, List<HTextFlow>> docUrlToTextFlows = Maps.newHashMap();\n         List<MTDocument> mtDocuments = Lists.newArrayList();\n         for (HDocument doc : documents.values()) {\n-            DocumentId documentId = new DocumentId(doc.getId(),\n-                    doc.getDocId());\n+            DocumentId documentId = new DocumentId(doc.getId(), doc.getDocId());\n             // right now we only target untranslated. We might target more in the future\n-            List<HTextFlow> untranslatedTextFlows=\n-                    textFlowDAO\n-                            .getAllTextFlowByDocumentIdWithConstraints(\n-                                    documentId, targetLocale,\n-                                    FilterConstraints.builder()\n-                                            .keepNone().includeNew()\n-                                            .build());\n-            MTDocument mtDocument = textFlowsToMTDoc\n-                    .fromTextFlows(projectSlug, versionSlug,\n-                            doc.getDocId(), fromLocale,\n-                            untranslatedTextFlows);\n+            List<HTextFlow> untranslatedTextFlows = textFlowDAO.getAllTextFlowByDocumentIdWithConstraints(documentId,\n+                                                                                                          targetLocale,\n+                                                                                                          FilterConstraints.builder().keepNone()\n+                                                                                                                                     .includeNew()\n+                                                                                                                                     .build());\n+            MTDocument mtDocument = textFlowsToMTDoc.fromTextFlows(projectSlug,\n+                                                                   versionSlug,\n+                                                                   doc.getDocId(),\n+                                                                   fromLocale,\n+                                                                   untranslatedTextFlows);\n             docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n             mtDocuments.add(mtDocument);\n         }\n-\n-\n-        log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n-\n-        List<MTDocument> result = mtDocuments.stream()\n-                .map(mtDoc -> getTranslationFromMT(mtDoc,\n-                        targetLocale.getLocaleId()))\n-                .collect(Collectors.toList());\n-\n+        log.info(\"prepare to send {} of documents to MT\",\n+mtDocuments.size());\n+        List<MTDocument> result = mtDocuments.stream().map(mtDoc -> getTranslationFromMT(mtDoc, targetLocale.getLocaleId()))\n+                                                      .collect(Collectors.toList());\n         log.info(\"get back result: {}\", result.size());\n-\n         taskHandle.setMaxProgress(mtDocuments.size());\n-\n-\n         boolean cancelled = false;\n         for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n             MTDocument sourceDoc = mtDocuments.get(i);\n             MTDocument transDoc = result.get(i);\n-\n-            translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n-                    targetLocale, prefillRequest.getSaveState());\n-\n+            translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()),\n+transDoc,\n+targetLocale,\n+prefillRequest.getSaveState());\n             taskHandle.increaseProgress(1);\n         }\n         versionStateCache.clearVersionStatsCache(targetVersionId);\n-\n-        log.info(\"{} prefill translation with machine translations for version {}, {}\",\n-                cancelled ? \"CANCELLED\" : \"COMPLETED\",\n-                version.userFriendlyToString(), overallStopwatch);\n+        log.info(\"{} prefill translation with machine translations for version {}, {}\", cancelled ? \"CANCELLED\" : \"COMPLETED\", version.userFriendlyToString(), overallStopwatch);\n         return AsyncTaskResult.completed();\n     }\n \n@@ -256,27 +230,16 @@ public class MachineTranslationServiceImpl implements\n         while (index < textFlows.size()) {\n             int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n             List<HTextFlow> batch = textFlows.subList(index, bound);\n-            List<TypeString> transContentBatch =\n-                    transDoc.getContents().subList(index, bound);\n-\n+            List<TypeString> transContentBatch = transDoc.getContents().subList(index, bound);\n             List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n             index += bound;\n             for (int i = 0; i < batch.size(); i++) {\n                 HTextFlow textFlow = batch.get(i);\n-                HTextFlowTarget maybeTarget =\n-                        textFlow.getTargets().get(targetLocale.getId());\n+                HTextFlowTarget maybeTarget = textFlow.getTargets().get(targetLocale.getId());\n                 int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n-                List<String> translation = Lists.newArrayList(\n-                        transContentBatch.get(i).getValue());\n+                List<String> translation = Lists.newArrayList(transContentBatch.get(i).getValue());\n                 // TODO TranslationSourceType only says MT but without provider name\n-                TransUnitUpdateRequest updateRequest =\n-                        new TransUnitUpdateRequest(\n-                                new TransUnitId(textFlow.getId()),\n-                                translation,\n-                                saveState,\n-                                baseRevision,\n-                                TranslationSourceType.MACHINE_TRANS\n-                                        .getAbbr());\n+                TransUnitUpdateRequest updateRequest = new TransUnitUpdateRequest(new TransUnitId(textFlow.getId()), translation, saveState, baseRevision, TranslationSourceType.MACHINE_TRANS.getAbbr());\n                 updateRequest.addRevisionComment(\"Translated by Google\");\n                 updateRequests.add(updateRequest);\n             }\n@@ -285,9 +248,9 @@ public class MachineTranslationServiceImpl implements\n                     translationService.translate(targetLocale.getLocaleId(), updateRequests);\n                 });\n             } catch (Exception e) {\n-                log.error(\"error prefilling translation with machine translation\", e);\n+                log.error(\"error prefilling translation with machine translation\",\n+e);\n             }\n         }\n     }\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 110
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_random/68/MachineTranslationServiceImpl.java\nindex 4366d173c7..ad7fe4504a 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_random/68/MachineTranslationServiceImpl.java\n@@ -203,7 +203,7 @@ public class MachineTranslationServiceImpl implements\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n             // right now we only target untranslated. We might target more in the future\n-            List<HTextFlow> untranslatedTextFlows=\n+            List<HTextFlow> untranslatedTextFlows =\n                     textFlowDAO\n                             .getAllTextFlowByDocumentIdWithConstraints(\n                                     documentId, targetLocale,\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "208",
                    "column": "13",
                    "severity": "error",
                    "message": "'=' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_three_grams/68/MachineTranslationServiceImpl.java\nindex 4366d173c7..2029ceeaac 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/68/MachineTranslationServiceImpl.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_three_grams/68/MachineTranslationServiceImpl.java\n@@ -203,91 +203,92 @@ public class MachineTranslationServiceImpl implements\n             DocumentId documentId = new DocumentId(doc.getId(),\n                     doc.getDocId());\n             // right now we only target untranslated. We might target more in the future\n-            List<HTextFlow> untranslatedTextFlows=\n-                    textFlowDAO\n-                            .getAllTextFlowByDocumentIdWithConstraints(\n-                                    documentId, targetLocale,\n-                                    FilterConstraints.builder()\n-                                            .keepNone().includeNew()\n-                                            .build());\n-            MTDocument mtDocument = textFlowsToMTDoc\n-                    .fromTextFlows(projectSlug, versionSlug,\n-                            doc.getDocId(), fromLocale,\n-                            untranslatedTextFlows);\n-            docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n-            mtDocuments.add(mtDocument);\n-        }\n+            List<HTextFlow> untranslatedTextFlows\n+\n+            =textFlowDAO\n+                    .getAllTextFlowByDocumentIdWithConstraints(\n+                            documentId, targetLocale,\n+                            FilterConstraints.builder()\n+                                    .keepNone().includeNew()\n+                                    .build());\n+    MTDocument mtDocument = textFlowsToMTDoc\n+            .fromTextFlows(projectSlug, versionSlug,\n+                    doc.getDocId(), fromLocale,\n+                    untranslatedTextFlows);\n+    docUrlToTextFlows.put(mtDocument.getUrl(), untranslatedTextFlows);\n+    mtDocuments.add(mtDocument);\n+}\n \n \n-        log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n+log.info(\"prepare to send {} of documents to MT\", mtDocuments.size());\n \n-        List<MTDocument> result = mtDocuments.stream()\n-                .map(mtDoc -> getTranslationFromMT(mtDoc,\n-                        targetLocale.getLocaleId()))\n-                .collect(Collectors.toList());\n+List<MTDocument> result = mtDocuments.stream()\n+        .map(mtDoc -> getTranslationFromMT(mtDoc,\n+                targetLocale.getLocaleId()))\n+        .collect(Collectors.toList());\n \n-        log.info(\"get back result: {}\", result.size());\n+log.info(\"get back result: {}\", result.size());\n \n-        taskHandle.setMaxProgress(mtDocuments.size());\n+taskHandle.setMaxProgress(mtDocuments.size());\n \n \n-        boolean cancelled = false;\n-        for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n-            MTDocument sourceDoc = mtDocuments.get(i);\n-            MTDocument transDoc = result.get(i);\n+boolean cancelled = false;\n+for (int i = 0; i < mtDocuments.size() && !(cancelled = taskHandle.isCancelled()); i++) {\n+    MTDocument sourceDoc = mtDocuments.get(i);\n+    MTDocument transDoc = result.get(i);\n \n-            translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n-                    targetLocale, prefillRequest.getSaveState());\n+    translateInBatch(docUrlToTextFlows.get(sourceDoc.getUrl()), transDoc,\n+            targetLocale, prefillRequest.getSaveState());\n \n-            taskHandle.increaseProgress(1);\n-        }\n-        versionStateCache.clearVersionStatsCache(targetVersionId);\n+    taskHandle.increaseProgress(1);\n+}\n+versionStateCache.clearVersionStatsCache(targetVersionId);\n \n-        log.info(\"{} prefill translation with machine translations for version {}, {}\",\n-                cancelled ? \"CANCELLED\" : \"COMPLETED\",\n-                version.userFriendlyToString(), overallStopwatch);\n-        return AsyncTaskResult.completed();\n-    }\n+log.info(\"{} prefill translation with machine translations for version {}, {}\",\n+        cancelled ? \"CANCELLED\" : \"COMPLETED\",\n+        version.userFriendlyToString(), overallStopwatch);\n+return AsyncTaskResult.completed();\n+}\n \n-    private void translateInBatch(List<HTextFlow> textFlows,\n-            MTDocument transDoc,\n-            HLocale targetLocale, ContentState saveState) {\n-        int index = 0;\n-        while (index < textFlows.size()) {\n-            int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n-            List<HTextFlow> batch = textFlows.subList(index, bound);\n-            List<TypeString> transContentBatch =\n-                    transDoc.getContents().subList(index, bound);\n-\n-            List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n-            index += bound;\n-            for (int i = 0; i < batch.size(); i++) {\n-                HTextFlow textFlow = batch.get(i);\n-                HTextFlowTarget maybeTarget =\n-                        textFlow.getTargets().get(targetLocale.getId());\n-                int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n-                List<String> translation = Lists.newArrayList(\n-                        transContentBatch.get(i).getValue());\n-                // TODO TranslationSourceType only says MT but without provider name\n-                TransUnitUpdateRequest updateRequest =\n-                        new TransUnitUpdateRequest(\n-                                new TransUnitId(textFlow.getId()),\n-                                translation,\n-                                saveState,\n-                                baseRevision,\n-                                TranslationSourceType.MACHINE_TRANS\n-                                        .getAbbr());\n-                updateRequest.addRevisionComment(\"Translated by Google\");\n-                updateRequests.add(updateRequest);\n-            }\n-            try {\n-                transactionUtil.run(() -> {\n-                    translationService.translate(targetLocale.getLocaleId(), updateRequests);\n-                });\n-            } catch (Exception e) {\n-                log.error(\"error prefilling translation with machine translation\", e);\n-            }\n+private void translateInBatch(List<HTextFlow> textFlows,\n+        MTDocument transDoc,\n+        HLocale targetLocale, ContentState saveState) {\n+    int index = 0;\n+    while (index < textFlows.size()) {\n+        int bound = Math.min(index + BATCH_SIZE, textFlows.size());\n+        List<HTextFlow> batch = textFlows.subList(index, bound);\n+        List<TypeString> transContentBatch =\n+                transDoc.getContents().subList(index, bound);\n+\n+        List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n+        index += bound;\n+        for (int i = 0; i < batch.size(); i++) {\n+            HTextFlow textFlow = batch.get(i);\n+            HTextFlowTarget maybeTarget =\n+                    textFlow.getTargets().get(targetLocale.getId());\n+            int baseRevision = maybeTarget == null ? 0 : maybeTarget.getVersionNum();\n+            List<String> translation = Lists.newArrayList(\n+                    transContentBatch.get(i).getValue());\n+            // TODO TranslationSourceType only says MT but without provider name\n+            TransUnitUpdateRequest updateRequest =\n+                    new TransUnitUpdateRequest(\n+                            new TransUnitId(textFlow.getId()),\n+                            translation,\n+                            saveState,\n+                            baseRevision,\n+                            TranslationSourceType.MACHINE_TRANS\n+                                    .getAbbr());\n+            updateRequest.addRevisionComment(\"Translated by Google\");\n+            updateRequests.add(updateRequest);\n+        }\n+        try {\n+            transactionUtil.run(() -> {\n+                translationService.translate(targetLocale.getLocaleId(), updateRequests);\n+            });\n+        } catch (Exception e) {\n+            log.error(\"error prefilling translation with machine translation\", e);\n         }\n     }\n+}\n \n }\n",
            "diff_size": 75
        }
    ]
}