{
    "error_id": "36",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/36/SplitFinder.java\nindex 70561b4872..e1791b1d11 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/36/SplitFinder.java\n@@ -36,198 +36,200 @@ import scala.Option;\n \n public class SplitFinder {\n \n-  private static final Logger LOG = LoggerFactory.getLogger(SplitFinder.class);\n-\n-  private final GBDTParam param;\n-\n-  public SplitFinder(GBDTParam param) {\n-    this.param = param;\n-  }\n-\n-  public GBTSplit findBestSplitFP(int featLo,\n-      Histogram[] histograms,\n-      FeatureInfo featureInfo,\n-      GradPair sumGradPair,\n-      float nodeGain) throws Exception {\n-\n-    GBTSplit bestSplit = new GBTSplit();\n-    for (int i = 0; i < histograms.length; i++) {\n-      if (histograms[i] != null) {\n-        Histogram histogram = histograms[i];\n-        int fid = i + featLo;\n-        boolean isCategorical = featureInfo.isCategorical(fid);\n-        float[] splits = featureInfo.getSplits(fid);\n-        int defaultBin = featureInfo.getDefaultBin(fid);\n-        GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n-            splits, defaultBin, histogram, sumGradPair, nodeGain);\n-        bestSplit.update(curSplit);\n-      }\n-    }\n-    return bestSplit;\n-  }\n-\n-\n-  public GBTSplit findBestSplit(int[] sampledFeats, Option<Histogram>[] histograms,\n-      FeatureInfo featureInfo,\n-      GradPair sumGradPair, float nodeGain) throws Exception {\n-    GBTSplit bestSplit;\n-    if (param.numThread > 1) {\n-      bestSplit = new GBTSplit();\n-      ExecutorService threadPool = Executors.newFixedThreadPool(param.numThread);\n-      Future[] futures = new Future[param.numThread];\n-      for (int threadId = 0; threadId < param.numThread; threadId++) {\n-        futures[threadId] = threadPool.submit(new FinderThread(threadId,\n-            sampledFeats, histograms, featureInfo, sumGradPair, nodeGain));\n-      }\n-      threadPool.shutdown();\n-      for (Future<GBTSplit> future : futures) {\n-        bestSplit.update(future.get());\n-      }\n-    } else {\n-      bestSplit = new FinderThread(0, sampledFeats, histograms,\n-          featureInfo, sumGradPair, nodeGain).call();\n+    private static final Logger LOG = LoggerFactory.getLogger(SplitFinder.class);\n+\n+    private final GBDTParam param;\n+\n+    public SplitFinder(GBDTParam param) {\n+        this.param = param;\n     }\n-    return bestSplit;\n-  }\n-\n-  public GBTSplit findBestSplitOfOneFeature(int fid, boolean isCategorical, float[] splits,\n-      int defaultBin,\n-      Histogram histogram, GradPair sumGradPair, float nodeGain) {\n-    if (isCategorical) {\n-      return findBestSplitSet(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n-    } else {\n-      return findBestSplitPoint(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n+\n+    public GBTSplit findBestSplitFP(int featLo,\n+                                    Histogram[] histograms,\n+                                    FeatureInfo featureInfo,\n+                                    GradPair sumGradPair,\n+                                    float nodeGain) throws Exception {\n+\n+        GBTSplit bestSplit = new GBTSplit();\n+        for (int i = 0; i < histograms.length; i++) {\n+            if (histograms[i] != null) {\n+                Histogram histogram = histograms[i];\n+                int fid = i + featLo;\n+                boolean isCategorical = featureInfo.isCategorical(fid);\n+                float[] splits = featureInfo.getSplits(fid);\n+                int defaultBin = featureInfo.getDefaultBin(fid);\n+                GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n+                        splits, defaultBin, histogram, sumGradPair, nodeGain);\n+                bestSplit.update(curSplit);\n+            }\n+        }\n+        return bestSplit;\n     }\n-  }\n-\n-  // TODO: use more schema on default bin\n-  private GBTSplit findBestSplitPoint(int fid, float[] splits, int defaultBin, Histogram histogram,\n-      GradPair sumGradPair, float nodeGain) {\n-    SplitPoint splitPoint = new SplitPoint();\n-    GradPair leftStat = param.numClass == 2 ? new BinaryGradPair()\n-        : new MultiGradPair(param.numClass, param.fullHessian);\n-    GradPair rightStat = sumGradPair.copy();\n-    GradPair bestLeftStat = null, bestRightStat = null;\n-    for (int i = 0; i < histogram.getNumBin() - 1; i++) {\n-      histogram.plusTo(leftStat, i);\n-      histogram.subtractTo(rightStat, i);\n-      if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n-        float lossChg = leftStat.calcGain(param) + rightStat.calcGain(param)\n-            - nodeGain - param.regLambda;\n-        if (splitPoint.needReplace(lossChg)) {\n-          splitPoint.setFid(fid);\n-          splitPoint.setFvalue(splits[i + 1]);\n-          splitPoint.setGain(lossChg);\n-          bestLeftStat = leftStat.copy();\n-          bestRightStat = rightStat.copy();\n+\n+\n+    public GBTSplit findBestSplit(int[] sampledFeats, Option<Histogram>[] histograms,\n+                                  FeatureInfo featureInfo,\n+                                  GradPair sumGradPair, float nodeGain) throws Exception {\n+        GBTSplit bestSplit;\n+        if (param.numThread > 1) {\n+            bestSplit = new GBTSplit();\n+            ExecutorService threadPool = Executors.newFixedThreadPool(param.numThread);\n+            Future[] futures = new Future[param.numThread];\n+            for (int threadId = 0; threadId < param.numThread; threadId++) {\n+                futures[threadId] = threadPool.submit(new FinderThread(threadId,\n+                        sampledFeats, histograms, featureInfo, sumGradPair, nodeGain));\n+            }\n+            threadPool.shutdown();\n+            for (Future<GBTSplit> future : futures) {\n+                bestSplit.update(future.get());\n+            }\n+        } else {\n+            bestSplit = new FinderThread(0, sampledFeats, histograms,\n+                    featureInfo, sumGradPair, nodeGain).call();\n         }\n-      }\n+        return bestSplit;\n     }\n-    return new GBTSplit(splitPoint, bestLeftStat, bestRightStat);\n-  }\n-\n-  private GBTSplit findBestSplitSet(int fid, float[] splits, int defaultBin, Histogram histogram,\n-      GradPair sumGradPair, float nodeGain) {\n-    // 1. set default bin to left child\n-    GradPair leftStat = histogram.get(defaultBin).copy();\n-    GradPair rightStat = null;\n-    // 2. for other bins, find its location\n-    int firstFlow = -1, curFlow = -1, curSplitId = 0;\n-    List<Float> edges = new ArrayList<>();\n-    edges.add(Float.NEGATIVE_INFINITY);\n-    for (int i = 0; i < histogram.getNumBin(); i++) {\n-      if (i == defaultBin) {\n-        continue; // skip default bin\n-      }\n-      GradPair binGradPair = histogram.get(i);\n-      int flowTo = binFlowTo(sumGradPair, leftStat, binGradPair);\n-      if (flowTo == 0) {\n-        leftStat.plusBy(binGradPair);\n-      }\n-      if (firstFlow == -1) {\n-        firstFlow = flowTo;\n-        curFlow = flowTo;\n-      } else if (flowTo != curFlow) {\n-        edges.add(splits[curSplitId]);\n-        curFlow = flowTo;\n-      }\n-      curSplitId++;\n+\n+    public GBTSplit findBestSplitOfOneFeature(int fid, boolean isCategorical, float[] splits,\n+                                              int defaultBin,\n+                                              Histogram histogram, GradPair sumGradPair,\n+                                              float nodeGain) {\n+        if (isCategorical) {\n+            return findBestSplitSet(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n+        } else {\n+            return findBestSplitPoint(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n+        }\n     }\n-    // 3. create split set\n-    if (edges.size() > 1 || curFlow != 0) { // whether all bins go to the same direction\n-      rightStat = sumGradPair.subtract(leftStat);\n-      if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n-        float splitGain = leftStat.calcGain(param) + rightStat.calcGain(param)\n-            - nodeGain - param.regLambda;\n-        if (splitGain > 0.0f) {\n-          SplitSet splitSet = new SplitSet(fid, splitGain, Maths.floatListToArray(edges),\n-              firstFlow, 0);\n-          return new GBTSplit(splitSet, leftStat, rightStat);\n+\n+    // TODO: use more schema on default bin\n+    private GBTSplit findBestSplitPoint(int fid, float[] splits, int defaultBin,\n+                                        Histogram histogram,\n+                                        GradPair sumGradPair, float nodeGain) {\n+        SplitPoint splitPoint = new SplitPoint();\n+        GradPair leftStat = param.numClass == 2 ? new BinaryGradPair()\n+                : new MultiGradPair(param.numClass, param.fullHessian);\n+        GradPair rightStat = sumGradPair.copy();\n+        GradPair bestLeftStat = null, bestRightStat = null;\n+        for (int i = 0; i < histogram.getNumBin() - 1; i++) {\n+            histogram.plusTo(leftStat, i);\n+            histogram.subtractTo(rightStat, i);\n+            if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n+                float lossChg = leftStat.calcGain(param) + rightStat.calcGain(param)\n+                        - nodeGain - param.regLambda;\n+                if (splitPoint.needReplace(lossChg)) {\n+                    splitPoint.setFid(fid);\n+                    splitPoint.setFvalue(splits[i + 1]);\n+                    splitPoint.setGain(lossChg);\n+                    bestLeftStat = leftStat.copy();\n+                    bestRightStat = rightStat.copy();\n+                }\n+            }\n         }\n-      }\n+        return new GBTSplit(splitPoint, bestLeftStat, bestRightStat);\n     }\n-    return new GBTSplit();\n-  }\n-\n-  private int binFlowTo(GradPair sumGradPair, GradPair leftStat, GradPair binGradPair) {\n-    if (param.numClass == 2) {\n-      double sumGrad = ((BinaryGradPair) sumGradPair).getGrad();\n-      double leftGrad = ((BinaryGradPair) leftStat).getGrad();\n-      double binGrad = ((BinaryGradPair) binGradPair).getGrad();\n-      return binGrad * (2 * leftGrad + binGrad - sumGrad) >= 0.0 ? 0 : 1;\n-    } else {\n-      double[] sumGrad = ((MultiGradPair) sumGradPair).getGrad();\n-      double[] leftGrad = ((MultiGradPair) leftStat).getGrad();\n-      double[] binGrad = ((MultiGradPair) binGradPair).getGrad();\n-      double[] tmp = new double[param.numClass];\n-      for (int i = 0; i < param.numClass; i++) {\n-        tmp[i] = 2 * leftGrad[i] + binGrad[i] - sumGrad[i];\n-      }\n-      return Maths.dot(binGrad, tmp) >= 0.0 ? 0 : 1;\n+\n+    private GBTSplit findBestSplitSet(int fid, float[] splits, int defaultBin, Histogram histogram,\n+                                      GradPair sumGradPair, float nodeGain) {\n+        // 1. set default bin to left child\n+        GradPair leftStat = histogram.get(defaultBin).copy();\n+        GradPair rightStat = null;\n+        // 2. for other bins, find its location\n+        int firstFlow = -1, curFlow = -1, curSplitId = 0;\n+        List<Float> edges = new ArrayList<>();\n+        edges.add(Float.NEGATIVE_INFINITY);\n+        for (int i = 0; i < histogram.getNumBin(); i++) {\n+            if (i == defaultBin) {\n+                continue; // skip default bin\n+            }\n+            GradPair binGradPair = histogram.get(i);\n+            int flowTo = binFlowTo(sumGradPair, leftStat, binGradPair);\n+            if (flowTo == 0) {\n+                leftStat.plusBy(binGradPair);\n+            }\n+            if (firstFlow == -1) {\n+                firstFlow = flowTo;\n+                curFlow = flowTo;\n+            } else if (flowTo != curFlow) {\n+                edges.add(splits[curSplitId]);\n+                curFlow = flowTo;\n+            }\n+            curSplitId++;\n+        }\n+        // 3. create split set\n+        if (edges.size() > 1 || curFlow != 0) { // whether all bins go to the same direction\n+            rightStat = sumGradPair.subtract(leftStat);\n+            if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n+                float splitGain = leftStat.calcGain(param) + rightStat.calcGain(param)\n+                        - nodeGain - param.regLambda;\n+                if (splitGain > 0.0f) {\n+                    SplitSet splitSet = new SplitSet(fid, splitGain, Maths.floatListToArray(edges),\n+                            firstFlow, 0);\n+                    return new GBTSplit(splitSet, leftStat, rightStat);\n+                }\n+            }\n+        }\n+        return new GBTSplit();\n     }\n-  }\n-\n-  private class FinderThread implements Callable<GBTSplit> {\n-\n-    private final int threadId;\n-    private final int[] sampledFeats;\n-    private final Option<Histogram>[] histograms;\n-    private final FeatureInfo featureInfo;\n-    private final GradPair sumGradPair;\n-    private final float nodeGain;\n-\n-    FinderThread(int threadId, int[] sampledFeats, Option<Histogram>[] histograms,\n-        FeatureInfo featureInfo, GradPair sumGradPair, float nodeGain) {\n-      this.threadId = threadId;\n-      this.sampledFeats = sampledFeats;\n-      this.histograms = histograms;\n-      this.featureInfo = featureInfo;\n-      this.sumGradPair = sumGradPair;\n-      this.nodeGain = nodeGain;\n+\n+    private int binFlowTo(GradPair sumGradPair, GradPair leftStat, GradPair binGradPair) {\n+        if (param.numClass == 2) {\n+            double sumGrad = ((BinaryGradPair) sumGradPair).getGrad();\n+            double leftGrad = ((BinaryGradPair) leftStat).getGrad();\n+            double binGrad = ((BinaryGradPair) binGradPair).getGrad();\n+            return binGrad * (2 * leftGrad + binGrad - sumGrad) >= 0.0 ? 0 : 1;\n+        } else {\n+            double[] sumGrad = ((MultiGradPair) sumGradPair).getGrad();\n+            double[] leftGrad = ((MultiGradPair) leftStat).getGrad();\n+            double[] binGrad = ((MultiGradPair) binGradPair).getGrad();\n+            double[] tmp = new double[param.numClass];\n+            for (int i = 0; i < param.numClass; i++) {\n+                tmp[i] = 2 * leftGrad[i] + binGrad[i] - sumGrad[i];\n+            }\n+            return Maths.dot(binGrad, tmp) >= 0.0 ? 0 : 1;\n+        }\n     }\n \n-    @Override\n-    public GBTSplit call() throws Exception {\n-      int avg = sampledFeats.length / param.numThread;\n-      int from = threadId * avg;\n-      int to = threadId + 1 == param.numThread ? histograms.length : from + avg;\n-\n-      GBTSplit myBestSplit = new GBTSplit();\n-      for (int i = from; i < to; i++) {\n-        if (histograms[i].isDefined()) {\n-          Histogram histogram = histograms[i].get();\n-          int fid = sampledFeats[i];\n-          boolean isCategorical = featureInfo.isCategorical(fid);\n-          float[] splits = featureInfo.getSplits(fid);\n-          int defaultBin = featureInfo.getDefaultBin(fid);\n-          GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n-              splits, defaultBin, histogram, sumGradPair, nodeGain);\n-          myBestSplit.update(curSplit);\n+    private class FinderThread implements Callable<GBTSplit> {\n+\n+        private final int threadId;\n+        private final int[] sampledFeats;\n+        private final Option<Histogram>[] histograms;\n+        private final FeatureInfo featureInfo;\n+        private final GradPair sumGradPair;\n+        private final float nodeGain;\n+\n+        FinderThread(int threadId, int[] sampledFeats, Option<Histogram>[] histograms,\n+                     FeatureInfo featureInfo, GradPair sumGradPair, float nodeGain) {\n+            this.threadId = threadId;\n+            this.sampledFeats = sampledFeats;\n+            this.histograms = histograms;\n+            this.featureInfo = featureInfo;\n+            this.sumGradPair = sumGradPair;\n+            this.nodeGain = nodeGain;\n         }\n-      }\n \n-      return myBestSplit;\n+        @Override\n+        public GBTSplit call() throws Exception {\n+            int avg = sampledFeats.length / param.numThread;\n+            int from = threadId * avg;\n+            int to = threadId + 1 == param.numThread ? histograms.length : from + avg;\n+\n+            GBTSplit myBestSplit = new GBTSplit();\n+            for (int i = from; i < to; i++) {\n+                if (histograms[i].isDefined()) {\n+                    Histogram histogram = histograms[i].get();\n+                    int fid = sampledFeats[i];\n+                    boolean isCategorical = featureInfo.isCategorical(fid);\n+                    float[] splits = featureInfo.getSplits(fid);\n+                    int defaultBin = featureInfo.getDefaultBin(fid);\n+                    GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n+                            splits, defaultBin, histogram, sumGradPair, nodeGain);\n+                    myBestSplit.update(curSplit);\n+                }\n+            }\n+\n+            return myBestSplit;\n+        }\n     }\n-  }\n \n }\n",
            "diff_size": 250
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "58",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "75",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "82",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "87",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "100",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "107",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "151",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "153",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "211",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/36/SplitFinder.java\nindex 70561b4872..c58a5fcd3b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/36/SplitFinder.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n \n import com.tencent.angel.spark.ml.tree.gbdt.metadata.FeatureInfo;\n@@ -44,11 +43,9 @@ public class SplitFinder {\n     this.param = param;\n   }\n \n-  public GBTSplit findBestSplitFP(int featLo,\n-      Histogram[] histograms,\n+  public GBTSplit findBestSplitFP(int featLo, Histogram[] histograms,\n       FeatureInfo featureInfo,\n-      GradPair sumGradPair,\n-      float nodeGain) throws Exception {\n+      GradPair sumGradPair, float nodeGain) throws Exception {\n \n     GBTSplit bestSplit = new GBTSplit();\n     for (int i = 0; i < histograms.length; i++) {\n@@ -58,8 +55,7 @@ public class SplitFinder {\n         boolean isCategorical = featureInfo.isCategorical(fid);\n         float[] splits = featureInfo.getSplits(fid);\n         int defaultBin = featureInfo.getDefaultBin(fid);\n-        GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n-            splits, defaultBin, histogram, sumGradPair, nodeGain);\n+        GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical, splits, defaultBin, histogram, sumGradPair, nodeGain);\n         bestSplit.update(curSplit);\n       }\n     }\n@@ -76,24 +72,21 @@ public class SplitFinder {\n       ExecutorService threadPool = Executors.newFixedThreadPool(param.numThread);\n       Future[] futures = new Future[param.numThread];\n       for (int threadId = 0; threadId < param.numThread; threadId++) {\n-        futures[threadId] = threadPool.submit(new FinderThread(threadId,\n-            sampledFeats, histograms, featureInfo, sumGradPair, nodeGain));\n-      }\n+        futures[threadId] = threadPool.submit(new FinderThread(threadId, sampledFeats, histograms, featureInfo, sumGradPair, nodeGain));\n+  }\n       threadPool.shutdown();\n       for (Future<GBTSplit> future : futures) {\n         bestSplit.update(future.get());\n       }\n     } else {\n-      bestSplit = new FinderThread(0, sampledFeats, histograms,\n-          featureInfo, sumGradPair, nodeGain).call();\n-    }\n+      bestSplit = new FinderThread(0, sampledFeats, histograms, featureInfo, sumGradPair, nodeGain).call();\n+  }\n     return bestSplit;\n   }\n \n-  public GBTSplit findBestSplitOfOneFeature(int fid, boolean isCategorical, float[] splits,\n-      int defaultBin,\n+  public GBTSplit findBestSplitOfOneFeature(int fid, boolean isCategorical, float[] splits, int defaultBin,\n       Histogram histogram, GradPair sumGradPair, float nodeGain) {\n-    if (isCategorical) {\n+  if (isCategorical) {\n       return findBestSplitSet(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n     } else {\n       return findBestSplitPoint(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n@@ -104,17 +97,15 @@ public class SplitFinder {\n   private GBTSplit findBestSplitPoint(int fid, float[] splits, int defaultBin, Histogram histogram,\n       GradPair sumGradPair, float nodeGain) {\n     SplitPoint splitPoint = new SplitPoint();\n-    GradPair leftStat = param.numClass == 2 ? new BinaryGradPair()\n-        : new MultiGradPair(param.numClass, param.fullHessian);\n+    GradPair leftStat = param.numClass == 2 ? new BinaryGradPair() : new MultiGradPair(param.numClass, param.fullHessian);\n     GradPair rightStat = sumGradPair.copy();\n     GradPair bestLeftStat = null, bestRightStat = null;\n     for (int i = 0; i < histogram.getNumBin() - 1; i++) {\n       histogram.plusTo(leftStat, i);\n       histogram.subtractTo(rightStat, i);\n       if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n-        float lossChg = leftStat.calcGain(param) + rightStat.calcGain(param)\n-            - nodeGain - param.regLambda;\n-        if (splitPoint.needReplace(lossChg)) {\n+        float lossChg = leftStat.calcGain(param) + rightStat.calcGain(param) - nodeGain - param.regLambda;\n+if (splitPoint.needReplace(lossChg)) {\n           splitPoint.setFid(fid);\n           splitPoint.setFvalue(splits[i + 1]);\n           splitPoint.setGain(lossChg);\n@@ -157,11 +148,9 @@ public class SplitFinder {\n     if (edges.size() > 1 || curFlow != 0) { // whether all bins go to the same direction\n       rightStat = sumGradPair.subtract(leftStat);\n       if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n-        float splitGain = leftStat.calcGain(param) + rightStat.calcGain(param)\n-            - nodeGain - param.regLambda;\n-        if (splitGain > 0.0f) {\n-          SplitSet splitSet = new SplitSet(fid, splitGain, Maths.floatListToArray(edges),\n-              firstFlow, 0);\n+        float splitGain = leftStat.calcGain(param) + rightStat.calcGain(param) - nodeGain - param.regLambda;\n+if (splitGain > 0.0f) {\n+          SplitSet splitSet = new SplitSet(fid, splitGain, Maths.floatListToArray(edges), firstFlow, 0);\n           return new GBTSplit(splitSet, leftStat, rightStat);\n         }\n       }\n@@ -188,8 +177,7 @@ public class SplitFinder {\n   }\n \n   private class FinderThread implements Callable<GBTSplit> {\n-\n-    private final int threadId;\n+  private final int threadId;\n     private final int[] sampledFeats;\n     private final Option<Histogram>[] histograms;\n     private final FeatureInfo featureInfo;\n@@ -220,8 +208,7 @@ public class SplitFinder {\n           boolean isCategorical = featureInfo.isCategorical(fid);\n           float[] splits = featureInfo.getSplits(fid);\n           int defaultBin = featureInfo.getDefaultBin(fid);\n-          GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n-              splits, defaultBin, histogram, sumGradPair, nodeGain);\n+          GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical, splits, defaultBin, histogram, sumGradPair, nodeGain);\n           myBestSplit.update(curSplit);\n         }\n       }\n@@ -230,4 +217,4 @@ public class SplitFinder {\n     }\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 31
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "45",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "54",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "71",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "96",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 98.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "98",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "100",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "107",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "120",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "153",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "155",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "189",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "211",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/36/SplitFinder.java\nindex 70561b4872..cfc31fedc9 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/36/SplitFinder.java\n@@ -35,99 +35,89 @@ import org.slf4j.LoggerFactory;\n import scala.Option;\n \n public class SplitFinder {\n+    private static final Logger LOG = LoggerFactory.getLogger(SplitFinder.class);\n+    private final GBDTParam param;\n \n-  private static final Logger LOG = LoggerFactory.getLogger(SplitFinder.class);\n-\n-  private final GBDTParam param;\n-\n-  public SplitFinder(GBDTParam param) {\n+    public SplitFinder(GBDTParam param) {\n     this.param = param;\n-  }\n-\n-  public GBTSplit findBestSplitFP(int featLo,\n-      Histogram[] histograms,\n-      FeatureInfo featureInfo,\n-      GradPair sumGradPair,\n-      float nodeGain) throws Exception {\n+    }\n \n+    public GBTSplit findBestSplitFP(int featLo, Histogram[] histograms, FeatureInfo featureInfo, GradPair sumGradPair, float nodeGain) throws Exception {\n     GBTSplit bestSplit = new GBTSplit();\n     for (int i = 0; i < histograms.length; i++) {\n-      if (histograms[i] != null) {\n+        if (histograms[i] != null) {\n         Histogram histogram = histograms[i];\n         int fid = i + featLo;\n         boolean isCategorical = featureInfo.isCategorical(fid);\n         float[] splits = featureInfo.getSplits(fid);\n         int defaultBin = featureInfo.getDefaultBin(fid);\n-        GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n-            splits, defaultBin, histogram, sumGradPair, nodeGain);\n+        GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical, splits, defaultBin, histogram, sumGradPair, nodeGain);\n         bestSplit.update(curSplit);\n-      }\n+        }\n     }\n     return bestSplit;\n-  }\n-\n+    }\n \n-  public GBTSplit findBestSplit(int[] sampledFeats, Option<Histogram>[] histograms,\n-      FeatureInfo featureInfo,\n-      GradPair sumGradPair, float nodeGain) throws Exception {\n+    public GBTSplit findBestSplit(int[] sampledFeats,\n+    Option<Histogram>[] histograms,\n+    FeatureInfo featureInfo,\n+    GradPair sumGradPair, float nodeGain) throws Exception {\n     GBTSplit bestSplit;\n     if (param.numThread > 1) {\n-      bestSplit = new GBTSplit();\n-      ExecutorService threadPool = Executors.newFixedThreadPool(param.numThread);\n-      Future[] futures = new Future[param.numThread];\n-      for (int threadId = 0; threadId < param.numThread; threadId++) {\n-        futures[threadId] = threadPool.submit(new FinderThread(threadId,\n-            sampledFeats, histograms, featureInfo, sumGradPair, nodeGain));\n-      }\n-      threadPool.shutdown();\n-      for (Future<GBTSplit> future : futures) {\n-        bestSplit.update(future.get());\n-      }\n+        bestSplit = new GBTSplit();\n+        ExecutorService threadPool = Executors.newFixedThreadPool(param.numThread);\n+        Future[] futures = new Future[param.numThread];\n+        for (int threadId = 0; threadId < param.numThread; threadId++) {\n+                                 futures[threadId] = threadPool.submit(new FinderThread(threadId, sampledFeats, histograms, featureInfo, sumGradPair, nodeGain));\n+        }\n+        threadPool.shutdown();\n+        for (Future<GBTSplit> future : futures) {\n+                                 bestSplit.update(future.get());\n+        }\n     } else {\n-      bestSplit = new FinderThread(0, sampledFeats, histograms,\n-          featureInfo, sumGradPair, nodeGain).call();\n+      bestSplit = new FinderThread(0, sampledFeats, histograms, featureInfo, sumGradPair, nodeGain).call();\n     }\n     return bestSplit;\n-  }\n+    }\n \n-  public GBTSplit findBestSplitOfOneFeature(int fid, boolean isCategorical, float[] splits,\n-      int defaultBin,\n-      Histogram histogram, GradPair sumGradPair, float nodeGain) {\n+    public GBTSplit findBestSplitOfOneFeature(int fid,\n+boolean isCategorical,\n+float[] splits,\n+int defaultBin,\n+    Histogram histogram,\n+    GradPair sumGradPair, float nodeGain) {\n     if (isCategorical) {\n-      return findBestSplitSet(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n+        return findBestSplitSet(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n     } else {\n       return findBestSplitPoint(fid, splits, defaultBin, histogram, sumGradPair, nodeGain);\n     }\n-  }\n+    }\n \n   // TODO: use more schema on default bin\n-  private GBTSplit findBestSplitPoint(int fid, float[] splits, int defaultBin, Histogram histogram,\n-      GradPair sumGradPair, float nodeGain) {\n+\n+    private GBTSplit findBestSplitPoint(int fid, float[] splits, int defaultBin, Histogram histogram, GradPair sumGradPair, float nodeGain) {\n     SplitPoint splitPoint = new SplitPoint();\n-    GradPair leftStat = param.numClass == 2 ? new BinaryGradPair()\n-        : new MultiGradPair(param.numClass, param.fullHessian);\n+    GradPair leftStat = param.numClass == 2 ? new BinaryGradPair() : new MultiGradPair(param.numClass, param.fullHessian);\n     GradPair rightStat = sumGradPair.copy();\n     GradPair bestLeftStat = null, bestRightStat = null;\n     for (int i = 0; i < histogram.getNumBin() - 1; i++) {\n-      histogram.plusTo(leftStat, i);\n-      histogram.subtractTo(rightStat, i);\n-      if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n-        float lossChg = leftStat.calcGain(param) + rightStat.calcGain(param)\n-            - nodeGain - param.regLambda;\n+        histogram.plusTo(leftStat, i);\n+        histogram.subtractTo(rightStat, i);\n+        if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n+        float lossChg = leftStat.calcGain(param) + rightStat.calcGain(param) - nodeGain - param.regLambda;\n         if (splitPoint.needReplace(lossChg)) {\n-          splitPoint.setFid(fid);\n-          splitPoint.setFvalue(splits[i + 1]);\n-          splitPoint.setGain(lossChg);\n-          bestLeftStat = leftStat.copy();\n-          bestRightStat = rightStat.copy();\n+            splitPoint.setFid(fid);\n+            splitPoint.setFvalue(splits[i + 1]);\n+            splitPoint.setGain(lossChg);\n+            bestLeftStat = leftStat.copy();\n+            bestRightStat = rightStat.copy();\n+        }\n         }\n-      }\n     }\n     return new GBTSplit(splitPoint, bestLeftStat, bestRightStat);\n-  }\n+    }\n \n-  private GBTSplit findBestSplitSet(int fid, float[] splits, int defaultBin, Histogram histogram,\n-      GradPair sumGradPair, float nodeGain) {\n+    private GBTSplit findBestSplitSet(int fid, float[] splits, int defaultBin, Histogram histogram, GradPair sumGradPair, float nodeGain) {\n     // 1. set default bin to left child\n     GradPair leftStat = histogram.get(defaultBin).copy();\n     GradPair rightStat = null;\n@@ -136,59 +126,59 @@ public class SplitFinder {\n     List<Float> edges = new ArrayList<>();\n     edges.add(Float.NEGATIVE_INFINITY);\n     for (int i = 0; i < histogram.getNumBin(); i++) {\n-      if (i == defaultBin) {\n+        if (i == defaultBin) {\n         continue; // skip default bin\n-      }\n-      GradPair binGradPair = histogram.get(i);\n-      int flowTo = binFlowTo(sumGradPair, leftStat, binGradPair);\n-      if (flowTo == 0) {\n+        }\n+\n+        GradPair binGradPair = histogram.get(i);\n+        int flowTo = binFlowTo(sumGradPair, leftStat, binGradPair);\n+        if (flowTo == 0) {\n         leftStat.plusBy(binGradPair);\n-      }\n-      if (firstFlow == -1) {\n+        }\n+\n+        if (firstFlow == -1) {\n         firstFlow = flowTo;\n         curFlow = flowTo;\n-      } else if (flowTo != curFlow) {\n-        edges.add(splits[curSplitId]);\n-        curFlow = flowTo;\n-      }\n-      curSplitId++;\n+        } else if (flowTo != curFlow) {\n+                                                        edges.add(splits[curSplitId]);\n+                                                        curFlow = flowTo;\n+               }\n+        curSplitId++;\n     }\n     // 3. create split set\n+\n     if (edges.size() > 1 || curFlow != 0) { // whether all bins go to the same direction\n-      rightStat = sumGradPair.subtract(leftStat);\n-      if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n-        float splitGain = leftStat.calcGain(param) + rightStat.calcGain(param)\n-            - nodeGain - param.regLambda;\n+        rightStat = sumGradPair.subtract(leftStat);\n+        if (leftStat.satisfyWeight(param) && rightStat.satisfyWeight(param)) {\n+        float splitGain = leftStat.calcGain(param) + rightStat.calcGain(param) - nodeGain - param.regLambda;\n         if (splitGain > 0.0f) {\n-          SplitSet splitSet = new SplitSet(fid, splitGain, Maths.floatListToArray(edges),\n-              firstFlow, 0);\n-          return new GBTSplit(splitSet, leftStat, rightStat);\n+            SplitSet splitSet = new SplitSet(fid, splitGain, Maths.floatListToArray(edges), firstFlow, 0);\n+            return new GBTSplit(splitSet, leftStat, rightStat);\n+        }\n         }\n-      }\n     }\n     return new GBTSplit();\n-  }\n+    }\n \n-  private int binFlowTo(GradPair sumGradPair, GradPair leftStat, GradPair binGradPair) {\n+    private int binFlowTo(GradPair sumGradPair, GradPair leftStat, GradPair binGradPair) {\n     if (param.numClass == 2) {\n-      double sumGrad = ((BinaryGradPair) sumGradPair).getGrad();\n-      double leftGrad = ((BinaryGradPair) leftStat).getGrad();\n-      double binGrad = ((BinaryGradPair) binGradPair).getGrad();\n-      return binGrad * (2 * leftGrad + binGrad - sumGrad) >= 0.0 ? 0 : 1;\n+        double sumGrad = ((BinaryGradPair) sumGradPair).getGrad();\n+        double leftGrad = ((BinaryGradPair) leftStat).getGrad();\n+        double binGrad = ((BinaryGradPair) binGradPair).getGrad();\n+        return binGrad * (2 * leftGrad + binGrad - sumGrad) >= 0.0 ? 0 : 1;\n     } else {\n       double[] sumGrad = ((MultiGradPair) sumGradPair).getGrad();\n       double[] leftGrad = ((MultiGradPair) leftStat).getGrad();\n       double[] binGrad = ((MultiGradPair) binGradPair).getGrad();\n       double[] tmp = new double[param.numClass];\n       for (int i = 0; i < param.numClass; i++) {\n-        tmp[i] = 2 * leftGrad[i] + binGrad[i] - sumGrad[i];\n+               tmp[i] = 2 * leftGrad[i] + binGrad[i] - sumGrad[i];\n       }\n       return Maths.dot(binGrad, tmp) >= 0.0 ? 0 : 1;\n     }\n-  }\n-\n-  private class FinderThread implements Callable<GBTSplit> {\n+    }\n \n+    private class FinderThread implements Callable<GBTSplit> {\n     private final int threadId;\n     private final int[] sampledFeats;\n     private final Option<Histogram>[] histograms;\n@@ -196,38 +186,33 @@ public class SplitFinder {\n     private final GradPair sumGradPair;\n     private final float nodeGain;\n \n-    FinderThread(int threadId, int[] sampledFeats, Option<Histogram>[] histograms,\n-        FeatureInfo featureInfo, GradPair sumGradPair, float nodeGain) {\n-      this.threadId = threadId;\n-      this.sampledFeats = sampledFeats;\n-      this.histograms = histograms;\n-      this.featureInfo = featureInfo;\n-      this.sumGradPair = sumGradPair;\n-      this.nodeGain = nodeGain;\n+    FinderThread(int threadId, int[] sampledFeats, Option<Histogram>[] histograms, FeatureInfo featureInfo, GradPair sumGradPair, float nodeGain) {\n+        this.threadId = threadId;\n+        this.sampledFeats = sampledFeats;\n+        this.histograms = histograms;\n+        this.featureInfo = featureInfo;\n+        this.sumGradPair = sumGradPair;\n+        this.nodeGain = nodeGain;\n     }\n \n     @Override\n     public GBTSplit call() throws Exception {\n-      int avg = sampledFeats.length / param.numThread;\n-      int from = threadId * avg;\n-      int to = threadId + 1 == param.numThread ? histograms.length : from + avg;\n-\n-      GBTSplit myBestSplit = new GBTSplit();\n-      for (int i = from; i < to; i++) {\n+        int avg = sampledFeats.length / param.numThread;\n+        int from = threadId * avg;\n+        int to = threadId + 1 == param.numThread ? histograms.length : from + avg;\n+        GBTSplit myBestSplit = new GBTSplit();\n+        for (int i = from; i < to; i++) {\n         if (histograms[i].isDefined()) {\n-          Histogram histogram = histograms[i].get();\n-          int fid = sampledFeats[i];\n-          boolean isCategorical = featureInfo.isCategorical(fid);\n-          float[] splits = featureInfo.getSplits(fid);\n-          int defaultBin = featureInfo.getDefaultBin(fid);\n-          GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical,\n-              splits, defaultBin, histogram, sumGradPair, nodeGain);\n-          myBestSplit.update(curSplit);\n+            Histogram histogram = histograms[i].get();\n+            int fid = sampledFeats[i];\n+            boolean isCategorical = featureInfo.isCategorical(fid);\n+            float[] splits = featureInfo.getSplits(fid);\n+            int defaultBin = featureInfo.getDefaultBin(fid);\n+            GBTSplit curSplit = findBestSplitOfOneFeature(fid, isCategorical, splits, defaultBin, histogram, sumGradPair, nodeGain);\n+            myBestSplit.update(curSplit);\n         }\n-      }\n-\n-      return myBestSplit;\n+        }\n+        return myBestSplit;\n     }\n-  }\n-\n-}\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 128
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/36/SplitFinder.java\nindex 70561b4872..5dd1ecdf65 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/36/SplitFinder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/36/SplitFinder.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n \n import com.tencent.angel.spark.ml.tree.gbdt.metadata.FeatureInfo;\n",
            "diff_size": 1
        }
    ]
}