{
    "error_id": "510",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/510/VectorStorageUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/510/VectorStorageUtils.java\nindex 287c283322..0f3cbb1daa 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/510/VectorStorageUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/510/VectorStorageUtils.java\n@@ -49,837 +49,838 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;\n  */\n public class VectorStorageUtils {\n \n-  protected Vector vector;\n+    protected Vector vector;\n \n-  public static boolean useIntKey(Vector vector) {\n-    return vector instanceof IntKeyVector;\n-  }\n+    public static boolean useIntKey(Vector vector) {\n+        return vector instanceof IntKeyVector;\n+    }\n \n-  public static boolean isDense(Vector vector) {\n-    return vector.isDense();\n-  }\n+    public static boolean isDense(Vector vector) {\n+        return vector.isDense();\n+    }\n \n-  public static boolean isSparse(Vector vector) {\n-    return vector.isSparse();\n-  }\n+    public static boolean isSparse(Vector vector) {\n+        return vector.isSparse();\n+    }\n \n-  public static boolean isSorted(Vector vector) {\n-    return vector.isSorted();\n-  }\n+    public static boolean isSorted(Vector vector) {\n+        return vector.isSorted();\n+    }\n \n-  public static BasicType getKeyType(Vector vector) {\n-    if (vector instanceof IntKeyVector) {\n-      return BasicType.INT;\n-    } else {\n-      return BasicType.LONG;\n+    public static BasicType getKeyType(Vector vector) {\n+        if (vector instanceof IntKeyVector) {\n+            return BasicType.INT;\n+        } else {\n+            return BasicType.LONG;\n+        }\n     }\n-  }\n \n-  public static BasicType getValueType(Vector vector) {\n-    if (vector instanceof IntVector) {\n-      return BasicType.INT;\n-    } else if (vector instanceof LongVector) {\n-      return BasicType.LONG;\n-    } else if (vector instanceof FloatVector) {\n-      return BasicType.FLOAT;\n-    } else {\n-      return BasicType.DOUBLE;\n+    public static BasicType getValueType(Vector vector) {\n+        if (vector instanceof IntVector) {\n+            return BasicType.INT;\n+        } else if (vector instanceof LongVector) {\n+            return BasicType.LONG;\n+        } else if (vector instanceof FloatVector) {\n+            return BasicType.FLOAT;\n+        } else {\n+            return BasicType.DOUBLE;\n+        }\n     }\n-  }\n \n-  public static StorageMethod getStorageMethod(Vector vector) {\n-    if (vector.isDense()) {\n-      return StorageMethod.DENSE;\n-    } else if (vector.isSparse()) {\n-      return StorageMethod.SPARSE;\n-    } else if (vector.isSorted()) {\n-      return StorageMethod.SORTED;\n-    } else {\n-      return StorageMethod.SPARSE;\n+    public static StorageMethod getStorageMethod(Vector vector) {\n+        if (vector.isDense()) {\n+            return StorageMethod.DENSE;\n+        } else if (vector.isSparse()) {\n+            return StorageMethod.SPARSE;\n+        } else if (vector.isSorted()) {\n+            return StorageMethod.SORTED;\n+        } else {\n+            return StorageMethod.SPARSE;\n+        }\n     }\n-  }\n \n-  public static void serialize(ByteBuf buf, Vector vector) {\n-    // Row type\n-    buf.writeInt(vector.getType().getNumber());\n+    public static void serialize(ByteBuf buf, Vector vector) {\n+        // Row type\n+        buf.writeInt(vector.getType().getNumber());\n \n-    // Storage method\n-    buf.writeInt(getStorageMethod(vector).getValue());\n-\n-    // Key type\n-    buf.writeInt(getKeyType(vector).getValue());\n-\n-    // Value type\n-    buf.writeInt(getValueType(vector).getValue());\n-\n-    // Vector dim\n-    buf.writeLong(vector.dim());\n-\n-    // Vector length\n-    buf.writeLong(vector.getSize());\n-\n-    // Vector data\n-    serializeVector(buf, vector);\n-  }\n-\n-  public static Vector deserialize(ByteBuf buf) {\n-    // Row type\n-    RowType rowType = RowType.valueOf(buf.readInt());\n-\n-    // Storage method\n-    StorageMethod storageMethod = StorageMethod.valuesOf(buf.readInt());\n-\n-    // Key type\n-    BasicType keyType = BasicType.valuesOf(buf.readInt());\n-\n-    // Value type\n-    BasicType valueType = BasicType.valuesOf(buf.readInt());\n-\n-    // Vector dim\n-    long dim = buf.readLong();\n-\n-    // Vector length\n-    long len = buf.readLong();\n-\n-    // Init the vector\n-    Vector vector = VectorFactory.getVector(rowType, storageMethod, keyType, valueType, dim, len);\n-\n-    // Vector data\n-    deserializeVector(buf, vector);\n-\n-    return vector;\n-  }\n-\n-\n-  public static void serializeVector(ByteBuf buf, Vector vector) {\n-    if (vector instanceof IntVector) {\n-      serializeVector(buf, (IntVector) vector);\n-    } else if (vector instanceof LongVector) {\n-      serializeVector(buf, (LongVector) vector);\n-    } else if (vector instanceof FloatVector) {\n-      serializeVector(buf, (FloatVector) vector);\n-    } else {\n-      serializeVector(buf, (DoubleVector) vector);\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, IntVector vector) {\n-    if (vector instanceof IntIntVector) {\n-      serializeVector(buf, (IntIntVector) vector);\n-    } else {\n-      serializeVector(buf, (LongIntVector) vector);\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, LongVector vector) {\n-    if (vector instanceof IntLongVector) {\n-      serializeVector(buf, (IntLongVector) vector);\n-    } else {\n-      serializeVector(buf, (LongLongVector) vector);\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, FloatVector vector) {\n-    if (vector instanceof IntFloatVector) {\n-      serializeVector(buf, (IntFloatVector) vector);\n-    } else {\n-      serializeVector(buf, (LongFloatVector) vector);\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, DoubleVector vector) {\n-    if (vector instanceof IntDoubleVector) {\n-      serializeVector(buf, (IntDoubleVector) vector);\n-    } else {\n-      serializeVector(buf, (LongDoubleVector) vector);\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, IntIntVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2IntMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeInt(entry.getIntValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      int[] indices = vector.getStorage().getIndices();\n-      int[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeInt(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      int[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeInt(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, IntLongVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Int2LongMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2LongMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeLong(entry.getLongValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      int[] indices = vector.getStorage().getIndices();\n-      long[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeLong(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      long[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeLong(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, IntFloatVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Int2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2FloatMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeFloat(entry.getFloatValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      int[] indices = vector.getStorage().getIndices();\n-      float[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeFloat(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      float[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, IntDoubleVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Int2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2DoubleMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeDouble(entry.getDoubleValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      int[] indices = vector.getStorage().getIndices();\n-      double[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeDouble(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      double[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeDouble(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, LongIntVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2IntMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2IntMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeInt(entry.getIntValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      long[] indices = vector.getStorage().getIndices();\n-      int[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeInt(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      // Impossible now\n-      int[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeInt(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, LongLongVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2LongMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2LongMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeLong(entry.getLongValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      long[] indices = vector.getStorage().getIndices();\n-      long[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeLong(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      // Impossible now\n-      long[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeLong(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void serializeVector(ByteBuf buf, LongFloatVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2FloatMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeFloat(entry.getFloatValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      long[] indices = vector.getStorage().getIndices();\n-      float[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeFloat(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      // Impossible now\n-      float[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeFloat(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-\n-  public static void serializeVector(ByteBuf buf, LongDoubleVector vector) {\n-    StorageMethod method = getStorageMethod(vector);\n-    if (method == StorageMethod.SPARSE) {\n-      // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2DoubleMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeDouble(entry.getDoubleValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n-    } else if (method == StorageMethod.SORTED) {\n-      // Get the array pair\n-      long[] indices = vector.getStorage().getIndices();\n-      double[] values = vector.getStorage().getValues();\n-      buf.writeInt(indices.length);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeDouble(values[i]);\n-      }\n-    } else if (method == StorageMethod.DENSE) {\n-      // Impossible now\n-      double[] values = vector.getStorage().getValues();\n-      buf.writeInt(values.length);\n-      buf.writeInt(SerializeArrangement.VALUE.getValue());\n-      for (int i = 0; i < values.length; i++) {\n-        buf.writeDouble(values[i]);\n-      }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, Vector vector) {\n-    if (vector instanceof IntVector) {\n-      deserializeVector(buf, (IntVector) vector);\n-    } else if (vector instanceof LongVector) {\n-      deserializeVector(buf, (LongVector) vector);\n-    } else if (vector instanceof FloatVector) {\n-      deserializeVector(buf, (FloatVector) vector);\n-    } else {\n-      deserializeVector(buf, (DoubleVector) vector);\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, IntVector vector) {\n-    if (vector instanceof IntIntVector) {\n-      deserializeVector(buf, (IntIntVector) vector);\n-    } else {\n-      deserializeVector(buf, (LongIntVector) vector);\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, LongVector vector) {\n-    if (vector instanceof IntLongVector) {\n-      deserializeVector(buf, (IntLongVector) vector);\n-    } else {\n-      deserializeVector(buf, (LongLongVector) vector);\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, FloatVector vector) {\n-    if (vector instanceof IntFloatVector) {\n-      deserializeVector(buf, (IntFloatVector) vector);\n-    } else {\n-      deserializeVector(buf, (LongFloatVector) vector);\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, DoubleVector vector) {\n-    if (vector instanceof IntDoubleVector) {\n-      deserializeVector(buf, (IntDoubleVector) vector);\n-    } else {\n-      deserializeVector(buf, (LongDoubleVector) vector);\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, IntIntVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readInt();\n-        }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readInt());\n-        }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readInt();\n-        }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readInt());\n-        }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, IntLongVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readLong();\n-        }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readLong());\n-        }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readLong();\n+        // Storage method\n+        buf.writeInt(getStorageMethod(vector).getValue());\n+\n+        // Key type\n+        buf.writeInt(getKeyType(vector).getValue());\n+\n+        // Value type\n+        buf.writeInt(getValueType(vector).getValue());\n+\n+        // Vector dim\n+        buf.writeLong(vector.dim());\n+\n+        // Vector length\n+        buf.writeLong(vector.getSize());\n+\n+        // Vector data\n+        serializeVector(buf, vector);\n+    }\n+\n+    public static Vector deserialize(ByteBuf buf) {\n+        // Row type\n+        RowType rowType = RowType.valueOf(buf.readInt());\n+\n+        // Storage method\n+        StorageMethod storageMethod = StorageMethod.valuesOf(buf.readInt());\n+\n+        // Key type\n+        BasicType keyType = BasicType.valuesOf(buf.readInt());\n+\n+        // Value type\n+        BasicType valueType = BasicType.valuesOf(buf.readInt());\n+\n+        // Vector dim\n+        long dim = buf.readLong();\n+\n+        // Vector length\n+        long len = buf.readLong();\n+\n+        // Init the vector\n+        Vector vector =\n+                VectorFactory.getVector(rowType, storageMethod, keyType, valueType, dim, len);\n+\n+        // Vector data\n+        deserializeVector(buf, vector);\n+\n+        return vector;\n+    }\n+\n+\n+    public static void serializeVector(ByteBuf buf, Vector vector) {\n+        if (vector instanceof IntVector) {\n+            serializeVector(buf, (IntVector) vector);\n+        } else if (vector instanceof LongVector) {\n+            serializeVector(buf, (LongVector) vector);\n+        } else if (vector instanceof FloatVector) {\n+            serializeVector(buf, (FloatVector) vector);\n+        } else {\n+            serializeVector(buf, (DoubleVector) vector);\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readLong());\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, IntVector vector) {\n+        if (vector instanceof IntIntVector) {\n+            serializeVector(buf, (IntIntVector) vector);\n+        } else {\n+            serializeVector(buf, (LongIntVector) vector);\n         }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, IntFloatVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readFloat();\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, LongVector vector) {\n+        if (vector instanceof IntLongVector) {\n+            serializeVector(buf, (IntLongVector) vector);\n+        } else {\n+            serializeVector(buf, (LongLongVector) vector);\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readFloat());\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, FloatVector vector) {\n+        if (vector instanceof IntFloatVector) {\n+            serializeVector(buf, (IntFloatVector) vector);\n+        } else {\n+            serializeVector(buf, (LongFloatVector) vector);\n         }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readFloat();\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, DoubleVector vector) {\n+        if (vector instanceof IntDoubleVector) {\n+            serializeVector(buf, (IntDoubleVector) vector);\n+        } else {\n+            serializeVector(buf, (LongDoubleVector) vector);\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readFloat());\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, IntIntVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Int2IntMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeInt(entry.getIntKey());\n+                buf.writeInt(entry.getIntValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            int[] indices = vector.getStorage().getIndices();\n+            int[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeInt(indices[i]);\n+                buf.writeInt(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            int[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeInt(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, IntDoubleVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readDouble();\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, IntLongVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Int2LongMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Int2LongMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeInt(entry.getIntKey());\n+                buf.writeLong(entry.getLongValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            int[] indices = vector.getStorage().getIndices();\n+            long[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeInt(indices[i]);\n+                buf.writeLong(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            long[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeLong(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readDouble());\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, IntFloatVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Int2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Int2FloatMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeInt(entry.getIntKey());\n+                buf.writeFloat(entry.getFloatValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            int[] indices = vector.getStorage().getIndices();\n+            float[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeInt(indices[i]);\n+                buf.writeFloat(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            float[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeFloat(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readDouble();\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, IntDoubleVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Int2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Int2DoubleMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeInt(entry.getIntKey());\n+                buf.writeDouble(entry.getDoubleValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            int[] indices = vector.getStorage().getIndices();\n+            double[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeInt(indices[i]);\n+                buf.writeDouble(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            double[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeDouble(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readDouble());\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, LongIntVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Long2IntMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Long2IntMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeLong(entry.getLongKey());\n+                buf.writeInt(entry.getIntValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            long[] indices = vector.getStorage().getIndices();\n+            int[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeLong(indices[i]);\n+                buf.writeInt(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            // Impossible now\n+            int[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeInt(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, LongIntVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readInt();\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, LongLongVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Long2LongMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Long2LongMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeLong(entry.getLongKey());\n+                buf.writeLong(entry.getLongValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            long[] indices = vector.getStorage().getIndices();\n+            long[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeLong(indices[i]);\n+                buf.writeLong(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            // Impossible now\n+            long[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeLong(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readInt());\n+    }\n+\n+    public static void serializeVector(ByteBuf buf, LongFloatVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Long2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Long2FloatMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeLong(entry.getLongKey());\n+                buf.writeFloat(entry.getFloatValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            long[] indices = vector.getStorage().getIndices();\n+            float[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeLong(indices[i]);\n+                buf.writeFloat(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            // Impossible now\n+            float[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeFloat(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readInt();\n+    }\n+\n+\n+    public static void serializeVector(ByteBuf buf, LongDoubleVector vector) {\n+        StorageMethod method = getStorageMethod(vector);\n+        if (method == StorageMethod.SPARSE) {\n+            // Sparse storage, use the iterator to avoid array copy\n+            ObjectIterator<Long2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n+            int sizeIndex = buf.writerIndex();\n+            buf.writeInt(0);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            Long2DoubleMap.Entry entry;\n+            int elemNum = 0;\n+            while (iter.hasNext()) {\n+                entry = iter.next();\n+                buf.writeLong(entry.getLongKey());\n+                buf.writeDouble(entry.getDoubleValue());\n+                elemNum++;\n+            }\n+            buf.setInt(sizeIndex, elemNum);\n+        } else if (method == StorageMethod.SORTED) {\n+            // Get the array pair\n+            long[] indices = vector.getStorage().getIndices();\n+            double[] values = vector.getStorage().getValues();\n+            buf.writeInt(indices.length);\n+            buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+            for (int i = 0; i < indices.length; i++) {\n+                buf.writeLong(indices[i]);\n+                buf.writeDouble(values[i]);\n+            }\n+        } else if (method == StorageMethod.DENSE) {\n+            // Impossible now\n+            double[] values = vector.getStorage().getValues();\n+            buf.writeInt(values.length);\n+            buf.writeInt(SerializeArrangement.VALUE.getValue());\n+            for (int i = 0; i < values.length; i++) {\n+                buf.writeDouble(values[i]);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readInt());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, Vector vector) {\n+        if (vector instanceof IntVector) {\n+            deserializeVector(buf, (IntVector) vector);\n+        } else if (vector instanceof LongVector) {\n+            deserializeVector(buf, (LongVector) vector);\n+        } else if (vector instanceof FloatVector) {\n+            deserializeVector(buf, (FloatVector) vector);\n+        } else {\n+            deserializeVector(buf, (DoubleVector) vector);\n         }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, LongLongVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readLong();\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, IntVector vector) {\n+        if (vector instanceof IntIntVector) {\n+            deserializeVector(buf, (IntIntVector) vector);\n+        } else {\n+            deserializeVector(buf, (LongIntVector) vector);\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readLong());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, LongVector vector) {\n+        if (vector instanceof IntLongVector) {\n+            deserializeVector(buf, (IntLongVector) vector);\n+        } else {\n+            deserializeVector(buf, (LongLongVector) vector);\n         }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readLong();\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, FloatVector vector) {\n+        if (vector instanceof IntFloatVector) {\n+            deserializeVector(buf, (IntFloatVector) vector);\n+        } else {\n+            deserializeVector(buf, (LongFloatVector) vector);\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readLong());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, DoubleVector vector) {\n+        if (vector instanceof IntDoubleVector) {\n+            deserializeVector(buf, (IntDoubleVector) vector);\n+        } else {\n+            deserializeVector(buf, (LongDoubleVector) vector);\n         }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, LongFloatVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readFloat();\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, IntIntVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                int[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readInt();\n+                    values[i] = buf.readInt();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readInt(), buf.readInt());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                int[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readInt();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readInt());\n+                }\n+            }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readFloat());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, IntLongVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                long[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readInt();\n+                    values[i] = buf.readLong();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readInt(), buf.readLong());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                long[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readLong();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readLong());\n+                }\n+            }\n         }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readFloat();\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, IntFloatVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                float[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readInt();\n+                    values[i] = buf.readFloat();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readInt(), buf.readFloat());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                float[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readFloat();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readFloat());\n+                }\n+            }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readFloat());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, IntDoubleVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                double[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readInt();\n+                    values[i] = buf.readDouble();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readInt(), buf.readDouble());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                int[] indices = vector.getStorage().getIndices();\n+                double[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readDouble();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readDouble());\n+                }\n+            }\n         }\n-      }\n-    }\n-  }\n-\n-  public static void deserializeVector(ByteBuf buf, LongDoubleVector vector) {\n-    int elemNum = buf.readInt();\n-    StorageMethod method = getStorageMethod(vector);\n-    SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n-    if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readDouble();\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, LongIntVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                int[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readLong();\n+                    values[i] = buf.readInt();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readLong(), buf.readInt());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                int[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readInt();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readInt());\n+                }\n+            }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readDouble());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, LongLongVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                long[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readLong();\n+                    values[i] = buf.readLong();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readLong(), buf.readLong());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                long[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readLong();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readLong());\n+                }\n+            }\n         }\n-      }\n-    } else {\n-      if (method == StorageMethod.SORTED) {\n-        // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readDouble();\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, LongFloatVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                float[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readLong();\n+                    values[i] = buf.readFloat();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readLong(), buf.readFloat());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                float[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readFloat();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readFloat());\n+                }\n+            }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readDouble());\n+    }\n+\n+    public static void deserializeVector(ByteBuf buf, LongDoubleVector vector) {\n+        int elemNum = buf.readInt();\n+        StorageMethod method = getStorageMethod(vector);\n+        SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n+\n+        if (arrangement == SerializeArrangement.KEY_VALUE) {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                double[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = buf.readLong();\n+                    values[i] = buf.readDouble();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(buf.readLong(), buf.readDouble());\n+                }\n+            }\n+        } else {\n+            if (method == StorageMethod.SORTED) {\n+                // If use sorted storage, we should get the array pair first\n+                long[] indices = vector.getStorage().getIndices();\n+                double[] values = vector.getStorage().getValues();\n+                for (int i = 0; i < elemNum; i++) {\n+                    indices[i] = i;\n+                    values[i] = buf.readDouble();\n+                }\n+            } else {\n+                for (int i = 0; i < elemNum; i++) {\n+                    vector.set(i, buf.readDouble());\n+                }\n+            }\n         }\n-      }\n     }\n-  }\n \n \n-  public static int bufferLen(Vector vector) {\n-    int headLen = 4 * 4 + 2 * 8 + 4 * 2;\n-    StorageMethod method = getStorageMethod(vector);\n-    BasicType keyType = getKeyType(vector);\n-    BasicType valueType = getValueType(vector);\n-    int len = (int) vector.getSize();\n+    public static int bufferLen(Vector vector) {\n+        int headLen = 4 * 4 + 2 * 8 + 4 * 2;\n+        StorageMethod method = getStorageMethod(vector);\n+        BasicType keyType = getKeyType(vector);\n+        BasicType valueType = getValueType(vector);\n+        int len = (int) vector.getSize();\n \n-    if (method == StorageMethod.DENSE) {\n-      return headLen + len * sizeOf(valueType);\n-    } else {\n-      return headLen + len * (sizeOf(keyType) + sizeOf(valueType));\n+        if (method == StorageMethod.DENSE) {\n+            return headLen + len * sizeOf(valueType);\n+        } else {\n+            return headLen + len * (sizeOf(keyType) + sizeOf(valueType));\n+        }\n     }\n-  }\n \n-  public static int sizeOf(BasicType type) {\n-    if (type == BasicType.INT || type == BasicType.FLOAT) {\n-      return 4;\n-    } else {\n-      return 8;\n+    public static int sizeOf(BasicType type) {\n+        if (type == BasicType.INT || type == BasicType.FLOAT) {\n+            return 4;\n+        } else {\n+            return 8;\n+        }\n     }\n-  }\n \n-  public static void clear(Vector vector) {\n-    vector.clear();\n-  }\n+    public static void clear(Vector vector) {\n+        vector.clear();\n+    }\n \n-  public static int size(Vector vector) {\n-    return (int) vector.getSize();\n-  }\n+    public static int size(Vector vector) {\n+        return (int) vector.getSize();\n+    }\n }\n",
            "diff_size": 1284
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "233",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "272",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "311",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "350",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "390",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "430",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "470",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "511",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/510/VectorStorageUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/510/VectorStorageUtils.java\nindex 287c283322..f4f2d23505 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/510/VectorStorageUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/510/VectorStorageUtils.java\n@@ -230,8 +230,7 @@ public class VectorStorageUtils {\n         buf.writeInt(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -270,8 +269,7 @@ public class VectorStorageUtils {\n         buf.writeLong(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -310,8 +308,7 @@ public class VectorStorageUtils {\n         buf.writeFloat(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -350,8 +347,7 @@ public class VectorStorageUtils {\n         buf.writeDouble(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -391,8 +387,7 @@ public class VectorStorageUtils {\n         buf.writeInt(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -432,8 +427,7 @@ public class VectorStorageUtils {\n         buf.writeLong(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -473,8 +467,7 @@ public class VectorStorageUtils {\n         buf.writeFloat(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -515,8 +508,7 @@ public class VectorStorageUtils {\n         buf.writeDouble(values[i]);\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n     }\n   }\n \n@@ -882,4 +874,4 @@ public class VectorStorageUtils {\n   public static int size(Vector vector) {\n     return (int) vector.getSize();\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 17
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "157",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "200",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 201.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "232",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "239",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 240.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "271",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "278",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 279.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "310",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "317",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 318.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "349",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "356",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 357.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "389",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "396",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 397.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "429",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "436",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 437.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "469",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "476",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, indentation should be the same level as line 477.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "509",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "517",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "563",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 564.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "564",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "565",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "577",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 578.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "598",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 599.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "599",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "600",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "612",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 613.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "633",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 634.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "634",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "635",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "647",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 648.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "668",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 669.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "669",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "670",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "682",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 683.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "703",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 704.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "704",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "705",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "717",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 718.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "738",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 739.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "739",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "740",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "752",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 753.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "773",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 774.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "774",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "775",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "787",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 788.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "808",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 59, indentation should be the same level as line 809.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "809",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "810",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "822",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 8, expected is 15, indentation should be the same level as line 823.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/510/VectorStorageUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/510/VectorStorageUtils.java\nindex 287c283322..544800bb8d 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/510/VectorStorageUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/510/VectorStorageUtils.java\n@@ -47,59 +47,60 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;\n /**\n  * Vector storage utils\n  */\n+\n public class VectorStorageUtils {\n \n-  protected Vector vector;\n+    protected Vector vector;\n \n-  public static boolean useIntKey(Vector vector) {\n+    public static boolean useIntKey(Vector vector) {\n     return vector instanceof IntKeyVector;\n-  }\n+    }\n \n-  public static boolean isDense(Vector vector) {\n+    public static boolean isDense(Vector vector) {\n     return vector.isDense();\n-  }\n+    }\n \n-  public static boolean isSparse(Vector vector) {\n+    public static boolean isSparse(Vector vector) {\n     return vector.isSparse();\n-  }\n+    }\n \n-  public static boolean isSorted(Vector vector) {\n+    public static boolean isSorted(Vector vector) {\n     return vector.isSorted();\n-  }\n+    }\n \n-  public static BasicType getKeyType(Vector vector) {\n+    public static BasicType getKeyType(Vector vector) {\n     if (vector instanceof IntKeyVector) {\n-      return BasicType.INT;\n+        return BasicType.INT;\n     } else {\n       return BasicType.LONG;\n     }\n-  }\n+    }\n \n-  public static BasicType getValueType(Vector vector) {\n+    public static BasicType getValueType(Vector vector) {\n     if (vector instanceof IntVector) {\n-      return BasicType.INT;\n+        return BasicType.INT;\n     } else if (vector instanceof LongVector) {\n-      return BasicType.LONG;\n+                                                            return BasicType.LONG;\n     } else if (vector instanceof FloatVector) {\n-      return BasicType.FLOAT;\n-    } else {\n-      return BasicType.DOUBLE;\n+        return BasicType.FLOAT;\n+           } else {\n+             return BasicType.DOUBLE;\n+           }\n     }\n-  }\n \n-  public static StorageMethod getStorageMethod(Vector vector) {\n+    public static StorageMethod getStorageMethod(Vector vector) {\n     if (vector.isDense()) {\n-      return StorageMethod.DENSE;\n+        return StorageMethod.DENSE;\n     } else if (vector.isSparse()) {\n-      return StorageMethod.SPARSE;\n+                                                                    return StorageMethod.SPARSE;\n     } else if (vector.isSorted()) {\n-      return StorageMethod.SORTED;\n-    } else {\n-      return StorageMethod.SPARSE;\n+        return StorageMethod.SORTED;\n+           } else {\n+             return StorageMethod.SPARSE;\n+           }\n     }\n-  }\n \n-  public static void serialize(ByteBuf buf, Vector vector) {\n+    public static void serialize(ByteBuf buf, Vector vector) {\n     // Row type\n     buf.writeInt(vector.getType().getNumber());\n \n@@ -120,9 +121,9 @@ public class VectorStorageUtils {\n \n     // Vector data\n     serializeVector(buf, vector);\n-  }\n+    }\n \n-  public static Vector deserialize(ByteBuf buf) {\n+    public static Vector deserialize(ByteBuf buf) {\n     // Row type\n     RowType rowType = RowType.valueOf(buf.readInt());\n \n@@ -146,72 +147,70 @@ public class VectorStorageUtils {\n \n     // Vector data\n     deserializeVector(buf, vector);\n-\n     return vector;\n-  }\n-\n+    }\n \n-  public static void serializeVector(ByteBuf buf, Vector vector) {\n+    public static void serializeVector(ByteBuf buf, Vector vector) {\n     if (vector instanceof IntVector) {\n-      serializeVector(buf, (IntVector) vector);\n+        serializeVector(buf, (IntVector) vector);\n     } else if (vector instanceof LongVector) {\n-      serializeVector(buf, (LongVector) vector);\n+                                                                       serializeVector(buf, (LongVector) vector);\n     } else if (vector instanceof FloatVector) {\n-      serializeVector(buf, (FloatVector) vector);\n-    } else {\n-      serializeVector(buf, (DoubleVector) vector);\n+        serializeVector(buf, (FloatVector) vector);\n+           } else {\n+             serializeVector(buf, (DoubleVector) vector);\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, IntVector vector) {\n+    public static void serializeVector(ByteBuf buf, IntVector vector) {\n     if (vector instanceof IntIntVector) {\n-      serializeVector(buf, (IntIntVector) vector);\n+        serializeVector(buf, (IntIntVector) vector);\n     } else {\n       serializeVector(buf, (LongIntVector) vector);\n     }\n-  }\n+    }\n \n-  public static void serializeVector(ByteBuf buf, LongVector vector) {\n+    public static void serializeVector(ByteBuf buf, LongVector vector) {\n     if (vector instanceof IntLongVector) {\n-      serializeVector(buf, (IntLongVector) vector);\n+        serializeVector(buf, (IntLongVector) vector);\n     } else {\n       serializeVector(buf, (LongLongVector) vector);\n     }\n-  }\n+    }\n \n-  public static void serializeVector(ByteBuf buf, FloatVector vector) {\n+    public static void serializeVector(ByteBuf buf, FloatVector vector) {\n     if (vector instanceof IntFloatVector) {\n-      serializeVector(buf, (IntFloatVector) vector);\n+        serializeVector(buf, (IntFloatVector) vector);\n     } else {\n       serializeVector(buf, (LongFloatVector) vector);\n     }\n-  }\n+    }\n \n-  public static void serializeVector(ByteBuf buf, DoubleVector vector) {\n+    public static void serializeVector(ByteBuf buf, DoubleVector vector) {\n     if (vector instanceof IntDoubleVector) {\n-      serializeVector(buf, (IntDoubleVector) vector);\n+        serializeVector(buf, (IntDoubleVector) vector);\n     } else {\n       serializeVector(buf, (LongDoubleVector) vector);\n     }\n-  }\n+    }\n \n-  public static void serializeVector(ByteBuf buf, IntIntVector vector) {\n+    public static void serializeVector(ByteBuf buf, IntIntVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2IntMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeInt(entry.getIntValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Int2IntMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeInt(entry.getIntKey());\n+                                            buf.writeInt(entry.getIntValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       int[] indices = vector.getStorage().getIndices();\n@@ -219,39 +218,38 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeInt(values[i]);\n+                                                   buf.writeInt(indices[i]);\n+                                                   buf.writeInt(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       int[] values = vector.getStorage().getValues();\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeInt(values[i]);\n+                                                  buf.writeInt(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, IntLongVector vector) {\n+    public static void serializeVector(ByteBuf buf, IntLongVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Int2LongMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2LongMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeLong(entry.getLongValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Int2LongMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Int2LongMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeInt(entry.getIntKey());\n+                                            buf.writeLong(entry.getLongValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       int[] indices = vector.getStorage().getIndices();\n@@ -259,39 +257,38 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeLong(values[i]);\n+                                                   buf.writeInt(indices[i]);\n+                                                   buf.writeLong(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       long[] values = vector.getStorage().getValues();\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeLong(values[i]);\n+                                                  buf.writeLong(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, IntFloatVector vector) {\n+    public static void serializeVector(ByteBuf buf, IntFloatVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Int2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2FloatMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeFloat(entry.getFloatValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Int2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Int2FloatMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeInt(entry.getIntKey());\n+                                            buf.writeFloat(entry.getFloatValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       int[] indices = vector.getStorage().getIndices();\n@@ -299,39 +296,38 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeFloat(values[i]);\n+                                                   buf.writeInt(indices[i]);\n+                                                   buf.writeFloat(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       float[] values = vector.getStorage().getValues();\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeFloat(values[i]);\n+                                                  buf.writeFloat(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, IntDoubleVector vector) {\n+    public static void serializeVector(ByteBuf buf, IntDoubleVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Int2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Int2DoubleMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeInt(entry.getIntKey());\n-        buf.writeDouble(entry.getDoubleValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Int2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Int2DoubleMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeInt(entry.getIntKey());\n+                                            buf.writeDouble(entry.getDoubleValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       int[] indices = vector.getStorage().getIndices();\n@@ -339,39 +335,38 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeInt(indices[i]);\n-        buf.writeDouble(values[i]);\n+                                                   buf.writeInt(indices[i]);\n+                                                   buf.writeDouble(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       double[] values = vector.getStorage().getValues();\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeDouble(values[i]);\n+                                                  buf.writeDouble(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, LongIntVector vector) {\n+    public static void serializeVector(ByteBuf buf, LongIntVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2IntMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2IntMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeInt(entry.getIntValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Long2IntMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Long2IntMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeLong(entry.getLongKey());\n+                                            buf.writeInt(entry.getIntValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       long[] indices = vector.getStorage().getIndices();\n@@ -379,8 +374,8 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeInt(values[i]);\n+                                                   buf.writeLong(indices[i]);\n+                                                   buf.writeInt(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       // Impossible now\n@@ -388,31 +383,30 @@ public class VectorStorageUtils {\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeInt(values[i]);\n+                                                  buf.writeInt(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, LongLongVector vector) {\n+    public static void serializeVector(ByteBuf buf, LongLongVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2LongMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2LongMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeLong(entry.getLongValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Long2LongMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Long2LongMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeLong(entry.getLongKey());\n+                                            buf.writeLong(entry.getLongValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       long[] indices = vector.getStorage().getIndices();\n@@ -420,8 +414,8 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeLong(values[i]);\n+                                                   buf.writeLong(indices[i]);\n+                                                   buf.writeLong(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       // Impossible now\n@@ -429,31 +423,30 @@ public class VectorStorageUtils {\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeLong(values[i]);\n+                                                  buf.writeLong(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void serializeVector(ByteBuf buf, LongFloatVector vector) {\n+    public static void serializeVector(ByteBuf buf, LongFloatVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2FloatMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeFloat(entry.getFloatValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Long2FloatMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Long2FloatMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeLong(entry.getLongKey());\n+                                            buf.writeFloat(entry.getFloatValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       long[] indices = vector.getStorage().getIndices();\n@@ -461,8 +454,8 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeFloat(values[i]);\n+                                                   buf.writeLong(indices[i]);\n+                                                   buf.writeFloat(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       // Impossible now\n@@ -470,32 +463,30 @@ public class VectorStorageUtils {\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeFloat(values[i]);\n+                                                  buf.writeFloat(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-\n-  public static void serializeVector(ByteBuf buf, LongDoubleVector vector) {\n+    public static void serializeVector(ByteBuf buf, LongDoubleVector vector) {\n     StorageMethod method = getStorageMethod(vector);\n     if (method == StorageMethod.SPARSE) {\n       // Sparse storage, use the iterator to avoid array copy\n-      ObjectIterator<Long2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n-      int sizeIndex = buf.writerIndex();\n-      buf.writeInt(0);\n-      buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n-      Long2DoubleMap.Entry entry;\n-      int elemNum = 0;\n-      while (iter.hasNext()) {\n-        entry = iter.next();\n-        buf.writeLong(entry.getLongKey());\n-        buf.writeDouble(entry.getDoubleValue());\n-        elemNum++;\n-      }\n-      buf.setInt(sizeIndex, elemNum);\n+        ObjectIterator<Long2DoubleMap.Entry> iter = vector.getStorage().entryIterator();\n+        int sizeIndex = buf.writerIndex();\n+        buf.writeInt(0);\n+        buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n+        Long2DoubleMap.Entry entry;\n+        int elemNum = 0;\n+        while (iter.hasNext()) {\n+                                            entry = iter.next();\n+                                            buf.writeLong(entry.getLongKey());\n+                                            buf.writeDouble(entry.getDoubleValue());\n+                                            elemNum++;\n+        }\n+        buf.setInt(sizeIndex, elemNum);\n     } else if (method == StorageMethod.SORTED) {\n       // Get the array pair\n       long[] indices = vector.getStorage().getIndices();\n@@ -503,8 +494,8 @@ public class VectorStorageUtils {\n       buf.writeInt(indices.length);\n       buf.writeInt(SerializeArrangement.KEY_VALUE.getValue());\n       for (int i = 0; i < indices.length; i++) {\n-        buf.writeLong(indices[i]);\n-        buf.writeDouble(values[i]);\n+                                                   buf.writeLong(indices[i]);\n+                                                   buf.writeDouble(values[i]);\n       }\n     } else if (method == StorageMethod.DENSE) {\n       // Impossible now\n@@ -512,374 +503,364 @@ public class VectorStorageUtils {\n       buf.writeInt(values.length);\n       buf.writeInt(SerializeArrangement.VALUE.getValue());\n       for (int i = 0; i < values.length; i++) {\n-        buf.writeDouble(values[i]);\n+                                                  buf.writeDouble(values[i]);\n       }\n-    } else {\n-      throw new UnsupportedOperationException(\n-          \"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           } else {\n+             throw new UnsupportedOperationException(\"Unknown vector storage type:\" + vector.getStorage().getClass().getName());\n+           }\n     }\n-  }\n \n-  public static void deserializeVector(ByteBuf buf, Vector vector) {\n+    public static void deserializeVector(ByteBuf buf, Vector vector) {\n     if (vector instanceof IntVector) {\n-      deserializeVector(buf, (IntVector) vector);\n+        deserializeVector(buf, (IntVector) vector);\n     } else if (vector instanceof LongVector) {\n-      deserializeVector(buf, (LongVector) vector);\n+                                                                         deserializeVector(buf, (LongVector) vector);\n     } else if (vector instanceof FloatVector) {\n-      deserializeVector(buf, (FloatVector) vector);\n-    } else {\n-      deserializeVector(buf, (DoubleVector) vector);\n+        deserializeVector(buf, (FloatVector) vector);\n+           } else {\n+             deserializeVector(buf, (DoubleVector) vector);\n+           }\n     }\n-  }\n \n-  public static void deserializeVector(ByteBuf buf, IntVector vector) {\n+    public static void deserializeVector(ByteBuf buf, IntVector vector) {\n     if (vector instanceof IntIntVector) {\n-      deserializeVector(buf, (IntIntVector) vector);\n+        deserializeVector(buf, (IntIntVector) vector);\n     } else {\n       deserializeVector(buf, (LongIntVector) vector);\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, LongVector vector) {\n+    public static void deserializeVector(ByteBuf buf, LongVector vector) {\n     if (vector instanceof IntLongVector) {\n-      deserializeVector(buf, (IntLongVector) vector);\n+        deserializeVector(buf, (IntLongVector) vector);\n     } else {\n       deserializeVector(buf, (LongLongVector) vector);\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, FloatVector vector) {\n+    public static void deserializeVector(ByteBuf buf, FloatVector vector) {\n     if (vector instanceof IntFloatVector) {\n-      deserializeVector(buf, (IntFloatVector) vector);\n+        deserializeVector(buf, (IntFloatVector) vector);\n     } else {\n       deserializeVector(buf, (LongFloatVector) vector);\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, DoubleVector vector) {\n+    public static void deserializeVector(ByteBuf buf, DoubleVector vector) {\n     if (vector instanceof IntDoubleVector) {\n-      deserializeVector(buf, (IntDoubleVector) vector);\n+        deserializeVector(buf, (IntDoubleVector) vector);\n     } else {\n       deserializeVector(buf, (LongDoubleVector) vector);\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, IntIntVector vector) {\n+    public static void deserializeVector(ByteBuf buf, IntIntVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readInt();\n+                                                           int[] indices = vector.getStorage().getIndices();\n+                                                           int[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readInt();\n+                                                values[i] = buf.readInt();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readInt(), buf.readInt());\n+          }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readInt());\n-        }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readInt();\n-        }\n+               int[] indices = vector.getStorage().getIndices();\n+               int[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readInt();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readInt());\n+                 vector.set(i, buf.readInt());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, IntLongVector vector) {\n+    public static void deserializeVector(ByteBuf buf, IntLongVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readLong();\n-        }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readLong());\n+                                                           int[] indices = vector.getStorage().getIndices();\n+                                                           long[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readInt();\n+                                                values[i] = buf.readLong();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readInt(), buf.readLong());\n+          }\n         }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readLong();\n-        }\n+               int[] indices = vector.getStorage().getIndices();\n+               long[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readLong();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readLong());\n+                 vector.set(i, buf.readLong());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, IntFloatVector vector) {\n+    public static void deserializeVector(ByteBuf buf, IntFloatVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readFloat();\n+                                                           int[] indices = vector.getStorage().getIndices();\n+                                                           float[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readInt();\n+                                                values[i] = buf.readFloat();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readInt(), buf.readFloat());\n+          }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readFloat());\n-        }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readFloat();\n-        }\n+               int[] indices = vector.getStorage().getIndices();\n+               float[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readFloat();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readFloat());\n+                 vector.set(i, buf.readFloat());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, IntDoubleVector vector) {\n+    public static void deserializeVector(ByteBuf buf, IntDoubleVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readInt();\n-          values[i] = buf.readDouble();\n+                                                           int[] indices = vector.getStorage().getIndices();\n+                                                           double[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readInt();\n+                                                values[i] = buf.readDouble();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readInt(), buf.readDouble());\n+          }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readInt(), buf.readDouble());\n-        }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        int[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readDouble();\n-        }\n+               int[] indices = vector.getStorage().getIndices();\n+               double[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readDouble();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readDouble());\n+                 vector.set(i, buf.readDouble());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, LongIntVector vector) {\n+    public static void deserializeVector(ByteBuf buf, LongIntVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readInt();\n-        }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readInt());\n+                                                           long[] indices = vector.getStorage().getIndices();\n+                                                           int[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readLong();\n+                                                values[i] = buf.readInt();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readLong(), buf.readInt());\n+          }\n         }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        int[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readInt();\n-        }\n+               long[] indices = vector.getStorage().getIndices();\n+               int[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readInt();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readInt());\n+                 vector.set(i, buf.readInt());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, LongLongVector vector) {\n+    public static void deserializeVector(ByteBuf buf, LongLongVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readLong();\n+                                                           long[] indices = vector.getStorage().getIndices();\n+                                                           long[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readLong();\n+                                                values[i] = buf.readLong();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readLong(), buf.readLong());\n+          }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readLong());\n-        }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        long[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readLong();\n-        }\n+               long[] indices = vector.getStorage().getIndices();\n+               long[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readLong();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readLong());\n+                 vector.set(i, buf.readLong());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, LongFloatVector vector) {\n+    public static void deserializeVector(ByteBuf buf, LongFloatVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readFloat();\n+                                                           long[] indices = vector.getStorage().getIndices();\n+                                                           float[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readLong();\n+                                                values[i] = buf.readFloat();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readLong(), buf.readFloat());\n+          }\n         }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readFloat());\n-        }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        float[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readFloat();\n-        }\n+               long[] indices = vector.getStorage().getIndices();\n+               float[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readFloat();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readFloat());\n+                 vector.set(i, buf.readFloat());\n         }\n       }\n     }\n-  }\n+    }\n \n-  public static void deserializeVector(ByteBuf buf, LongDoubleVector vector) {\n+    public static void deserializeVector(ByteBuf buf, LongDoubleVector vector) {\n     int elemNum = buf.readInt();\n     StorageMethod method = getStorageMethod(vector);\n     SerializeArrangement arrangement = SerializeArrangement.valuesOf(buf.readInt());\n-\n     if (arrangement == SerializeArrangement.KEY_VALUE) {\n-      if (method == StorageMethod.SORTED) {\n+        if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = buf.readLong();\n-          values[i] = buf.readDouble();\n-        }\n-      } else {\n-        for (int i = 0; i < elemNum; i++) {\n-          vector.set(buf.readLong(), buf.readDouble());\n+                                                           long[] indices = vector.getStorage().getIndices();\n+                                                           double[] values = vector.getStorage().getValues();\n+                                                           for (int i = 0; i < elemNum; i++) {\n+                                                indices[i] = buf.readLong();\n+                                                values[i] = buf.readDouble();\n+                                                           }\n+        } else {\n+          for (int i = 0; i < elemNum; i++) {\n+                   vector.set(buf.readLong(), buf.readDouble());\n+          }\n         }\n-      }\n     } else {\n       if (method == StorageMethod.SORTED) {\n         // If use sorted storage, we should get the array pair first\n-        long[] indices = vector.getStorage().getIndices();\n-        double[] values = vector.getStorage().getValues();\n-        for (int i = 0; i < elemNum; i++) {\n-          indices[i] = i;\n-          values[i] = buf.readDouble();\n-        }\n+               long[] indices = vector.getStorage().getIndices();\n+               double[] values = vector.getStorage().getValues();\n+               for (int i = 0; i < elemNum; i++) {\n+                                              indices[i] = i;\n+                                              values[i] = buf.readDouble();\n+               }\n       } else {\n         for (int i = 0; i < elemNum; i++) {\n-          vector.set(i, buf.readDouble());\n+                 vector.set(i, buf.readDouble());\n         }\n       }\n     }\n-  }\n-\n+    }\n \n-  public static int bufferLen(Vector vector) {\n+    public static int bufferLen(Vector vector) {\n     int headLen = 4 * 4 + 2 * 8 + 4 * 2;\n     StorageMethod method = getStorageMethod(vector);\n     BasicType keyType = getKeyType(vector);\n     BasicType valueType = getValueType(vector);\n     int len = (int) vector.getSize();\n-\n     if (method == StorageMethod.DENSE) {\n-      return headLen + len * sizeOf(valueType);\n+        return headLen + len * sizeOf(valueType);\n     } else {\n       return headLen + len * (sizeOf(keyType) + sizeOf(valueType));\n     }\n-  }\n+    }\n \n-  public static int sizeOf(BasicType type) {\n+    public static int sizeOf(BasicType type) {\n     if (type == BasicType.INT || type == BasicType.FLOAT) {\n-      return 4;\n+        return 4;\n     } else {\n       return 8;\n     }\n-  }\n+    }\n \n-  public static void clear(Vector vector) {\n+    public static void clear(Vector vector) {\n     vector.clear();\n-  }\n+    }\n \n-  public static int size(Vector vector) {\n+    public static int size(Vector vector) {\n     return (int) vector.getSize();\n-  }\n-}\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 454
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}