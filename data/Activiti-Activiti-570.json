{
    "error_id": "570",
    "information": {
        "errors": [
            {
                "line": "16",
                "severity": "error",
                "message": "'package' should be separated from previous statement.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
            }
        ]
    },
    "source_code": " * limitations under the License.\n */\npackage org.activiti.runtime.api.impl;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler/570/ExpressionResolver.java\nindex 355448fddd..7f08ba22da 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler/570/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/intellij/570/ExpressionResolver.java\nindex 355448fddd..3d0fa83ff5 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/intellij/570/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n@@ -49,8 +50,8 @@ public class ExpressionResolver {\n     private ExpressionManager expressionManager;\n \n     public ExpressionResolver(ExpressionManager expressionManager,\n-        ObjectMapper mapper,\n-        DelegateInterceptor delegateInterceptor) {\n+                              ObjectMapper mapper,\n+                              DelegateInterceptor delegateInterceptor) {\n         this.expressionManager = expressionManager;\n         this.mapper = mapper;\n         this.delegateInterceptor = delegateInterceptor;\n@@ -60,17 +61,17 @@ public class ExpressionResolver {\n                                       final Object value) {\n         if (value instanceof String) {\n             return resolveExpressionsString(expressionEvaluator,\n-                                            (String) value);\n+                    (String) value);\n         } else if (value instanceof ObjectNode) {\n             return resolveExpressionsMap(expressionEvaluator,\n-                                         mapper.convertValue(value,\n-                                                             MAP_STRING_OBJECT_TYPE));\n+                    mapper.convertValue(value,\n+                            MAP_STRING_OBJECT_TYPE));\n         } else if (value instanceof Map<?, ?>) {\n             return resolveExpressionsMap(expressionEvaluator,\n-                                         (Map<String, ?>) value);\n+                    (Map<String, ?>) value);\n         } else if (value instanceof List<?>) {\n             return resolveExpressionsList(expressionEvaluator,\n-                                          (List<?>) value);\n+                    (List<?>) value);\n         } else {\n             return value;\n         }\n@@ -80,7 +81,7 @@ public class ExpressionResolver {\n                                                 final List<?> sourceList) {\n         final List<Object> result = new LinkedList<>();\n         sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator,\n-                                                                  value)));\n+                value)));\n         return result;\n     }\n \n@@ -89,8 +90,8 @@ public class ExpressionResolver {\n         final Map<String, Object> result = new LinkedHashMap<>();\n         sourceMap.forEach((key,\n                            value) -> result.put(key,\n-                                                resolveExpressions(expressionEvaluator,\n-                                                                   value)));\n+                resolveExpressions(expressionEvaluator,\n+                        value)));\n         return result;\n     }\n \n@@ -101,10 +102,10 @@ public class ExpressionResolver {\n         }\n         if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n             return resolveObjectPlaceHolder(expressionEvaluator,\n-                                            sourceString);\n+                    sourceString);\n         } else {\n             return resolveInStringPlaceHolder(expressionEvaluator,\n-                                              sourceString);\n+                    sourceString);\n         }\n     }\n \n@@ -112,10 +113,10 @@ public class ExpressionResolver {\n                                             String sourceString) {\n         try {\n             return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager,\n-                delegateInterceptor);\n+                    delegateInterceptor);\n         } catch (final Exception e) {\n             logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                        e);\n+                    e);\n             return sourceString;\n         }\n     }\n@@ -129,12 +130,12 @@ public class ExpressionResolver {\n             final Expression expression = expressionManager.createExpression(expressionKey);\n             try {\n                 final Object value = expressionEvaluator.evaluate(expression, expressionManager,\n-                    delegateInterceptor);\n+                        delegateInterceptor);\n                 matcher.appendReplacement(sb,\n-                                          Objects.toString(value));\n+                        Objects.toString(value));\n             } catch (final Exception e) {\n                 logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                            e);\n+                        e);\n             }\n         }\n         matcher.appendTail(sb);\n@@ -148,7 +149,7 @@ public class ExpressionResolver {\n             return containsExpressionString((String) source);\n         } else if (source instanceof ObjectNode) {\n             return containsExpressionMap(mapper.convertValue(source,\n-                                                             MAP_STRING_OBJECT_TYPE));\n+                    MAP_STRING_OBJECT_TYPE));\n         } else if (source instanceof Map<?, ?>) {\n             return containsExpressionMap((Map<String, ?>) source);\n         } else if (source instanceof List<?>) {\n",
            "diff_size": 19
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/naturalize/570/ExpressionResolver.java\nindex 355448fddd..34156bee04 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/naturalize/570/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n@@ -48,94 +49,78 @@ public class ExpressionResolver {\n \n     private ExpressionManager expressionManager;\n \n-    public ExpressionResolver(ExpressionManager expressionManager,\n-        ObjectMapper mapper,\n+    public ExpressionResolver(ExpressionManager expressionManager, ObjectMapper mapper,\n         DelegateInterceptor delegateInterceptor) {\n         this.expressionManager = expressionManager;\n         this.mapper = mapper;\n         this.delegateInterceptor = delegateInterceptor;\n     }\n \n-    private Object resolveExpressions(final ExpressionEvaluator expressionEvaluator,\n-                                      final Object value) {\n-        if (value instanceof String) {\n-            return resolveExpressionsString(expressionEvaluator,\n-                                            (String) value);\n-        } else if (value instanceof ObjectNode) {\n+    private Object resolveExpressions(final ExpressionEvaluator expressionEvaluator, final Object value) {\n+  if (value instanceof String) {\n+            return resolveExpressionsString(expressionEvaluator, (String) value);\n+  } else if (value instanceof ObjectNode) {\n             return resolveExpressionsMap(expressionEvaluator,\n                                          mapper.convertValue(value,\n                                                              MAP_STRING_OBJECT_TYPE));\n         } else if (value instanceof Map<?, ?>) {\n-            return resolveExpressionsMap(expressionEvaluator,\n-                                         (Map<String, ?>) value);\n-        } else if (value instanceof List<?>) {\n-            return resolveExpressionsList(expressionEvaluator,\n-                                          (List<?>) value);\n-        } else {\n+            return resolveExpressionsMap(expressionEvaluator, (Map<String, ?>) value);\n+  } else if (value instanceof List<?>) {\n+            return resolveExpressionsList(expressionEvaluator, (List<?>) value);\n+  } else {\n             return value;\n         }\n     }\n \n-    private List<Object> resolveExpressionsList(final ExpressionEvaluator expressionEvaluator,\n-                                                final List<?> sourceList) {\n-        final List<Object> result = new LinkedList<>();\n-        sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator,\n-                                                                  value)));\n-        return result;\n+    private List<Object> resolveExpressionsList(final ExpressionEvaluator expressionEvaluator, final List<?> sourceList) {\n+  final List<Object> result = new LinkedList<>();\n+        sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator, value)));\n+return result;\n     }\n \n-    public Map<String, Object> resolveExpressionsMap(final ExpressionEvaluator expressionEvaluator,\n-                                                     final Map<String, ?> sourceMap) {\n-        final Map<String, Object> result = new LinkedHashMap<>();\n+    public Map<String, Object> resolveExpressionsMap(final ExpressionEvaluator expressionEvaluator, final Map<String, ?> sourceMap) {\n+  final Map<String, Object> result = new LinkedHashMap<>();\n         sourceMap.forEach((key,\n                            value) -> result.put(key,\n                                                 resolveExpressions(expressionEvaluator,\n                                                                    value)));\n-        return result;\n+return result;\n     }\n \n-    private Object resolveExpressionsString(final ExpressionEvaluator expressionEvaluator,\n-                                            final String sourceString) {\n-        if (StringUtils.isBlank(sourceString)) {\n+    private Object resolveExpressionsString(final ExpressionEvaluator expressionEvaluator, final String sourceString) {\n+  if (StringUtils.isBlank(sourceString)) {\n             return sourceString;\n         }\n         if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n-            return resolveObjectPlaceHolder(expressionEvaluator,\n-                                            sourceString);\n-        } else {\n-            return resolveInStringPlaceHolder(expressionEvaluator,\n-                                              sourceString);\n+            return resolveObjectPlaceHolder(expressionEvaluator, sourceString);\n+  } else {\n+            return resolveInStringPlaceHolder(expressionEvaluator, sourceString);\n         }\n     }\n \n     private Object resolveObjectPlaceHolder(ExpressionEvaluator expressionEvaluator,\n                                             String sourceString) {\n-        try {\n-            return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager,\n-                delegateInterceptor);\n-        } catch (final Exception e) {\n-            logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                        e);\n-            return sourceString;\n+  try {\n+            return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager, delegateInterceptor);\n+  } catch (final Exception e) {\n+            logger.warn(\"Unable to resolve expression in variables, keeping original value\", e);\n+return sourceString;\n         }\n     }\n \n-    private String resolveInStringPlaceHolder(final ExpressionEvaluator expressionEvaluator,\n-                                              final String sourceString) {\n-        final Matcher matcher = EXPRESSION_PATTERN.matcher(sourceString);\n+    private String resolveInStringPlaceHolder(final ExpressionEvaluator expressionEvaluator, final String sourceString) {\n+  final Matcher matcher = EXPRESSION_PATTERN.matcher(sourceString);\n         final StringBuffer sb = new StringBuffer();\n         while (matcher.find()) {\n             final String expressionKey = matcher.group(EXPRESSION_KEY_INDEX);\n             final Expression expression = expressionManager.createExpression(expressionKey);\n             try {\n-                final Object value = expressionEvaluator.evaluate(expression, expressionManager,\n-                    delegateInterceptor);\n+                final Object value = expressionEvaluator.evaluate(expression, expressionManager, delegateInterceptor);\n                 matcher.appendReplacement(sb,\n                                           Objects.toString(value));\n-            } catch (final Exception e) {\n-                logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                            e);\n-            }\n+  } catch (final Exception e) {\n+                logger.warn(\"Unable to resolve expression in variables, keeping original value\", e);\n+    }\n         }\n         matcher.appendTail(sb);\n         return sb.toString();\n@@ -147,8 +132,7 @@ public class ExpressionResolver {\n         } else if (source instanceof String) {\n             return containsExpressionString((String) source);\n         } else if (source instanceof ObjectNode) {\n-            return containsExpressionMap(mapper.convertValue(source,\n-                                                             MAP_STRING_OBJECT_TYPE));\n+            return containsExpressionMap(mapper.convertValue(source, MAP_STRING_OBJECT_TYPE));\n         } else if (source instanceof Map<?, ?>) {\n             return containsExpressionMap((Map<String, ?>) source);\n         } else if (source instanceof List<?>) {\n@@ -179,4 +163,4 @@ public class ExpressionResolver {\n         }\n         return false;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 52
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "16",
                    "severity": "error",
                    "message": "'package' should be separated from previous statement.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "37",
                    "severity": "error",
                    "message": "'CLASS_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/codebuff/570/ExpressionResolver.java\nindex 355448fddd..22ee4087c8 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/codebuff/570/ExpressionResolver.java\n@@ -33,150 +33,138 @@ import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+\n public class ExpressionResolver {\n \n     private static final TypeReference<Map<String, ?>> MAP_STRING_OBJECT_TYPE = new TypeReference<Map<String, ?>>() {\n-    };\n+                                                       };\n+\n     private final Logger logger = LoggerFactory.getLogger(ExpressionResolver.class);\n \n     private static final String EXPRESSION_PATTERN_STRING = \"([\\\\$]\\\\{([^\\\\}]*)\\\\})\";\n+\n     private static final Pattern EXPRESSION_PATTERN = Pattern.compile(EXPRESSION_PATTERN_STRING);\n+\n     private static final int EXPRESSION_KEY_INDEX = 1;\n \n     private ObjectMapper mapper;\n+\n     private final DelegateInterceptor delegateInterceptor;\n \n     private ExpressionManager expressionManager;\n \n-    public ExpressionResolver(ExpressionManager expressionManager,\n-        ObjectMapper mapper,\n-        DelegateInterceptor delegateInterceptor) {\n-        this.expressionManager = expressionManager;\n-        this.mapper = mapper;\n-        this.delegateInterceptor = delegateInterceptor;\n-    }\n-\n-    private Object resolveExpressions(final ExpressionEvaluator expressionEvaluator,\n-                                      final Object value) {\n-        if (value instanceof String) {\n-            return resolveExpressionsString(expressionEvaluator,\n-                                            (String) value);\n-        } else if (value instanceof ObjectNode) {\n-            return resolveExpressionsMap(expressionEvaluator,\n-                                         mapper.convertValue(value,\n-                                                             MAP_STRING_OBJECT_TYPE));\n-        } else if (value instanceof Map<?, ?>) {\n-            return resolveExpressionsMap(expressionEvaluator,\n-                                         (Map<String, ?>) value);\n-        } else if (value instanceof List<?>) {\n-            return resolveExpressionsList(expressionEvaluator,\n-                                          (List<?>) value);\n-        } else {\n-            return value;\n-        }\n+    public ExpressionResolver(ExpressionManager expressionManager, ObjectMapper mapper, DelegateInterceptor delegateInterceptor) {\n+    this.expressionManager = expressionManager;\n+    this.mapper = mapper;\n+    this.delegateInterceptor = delegateInterceptor;\n     }\n \n-    private List<Object> resolveExpressionsList(final ExpressionEvaluator expressionEvaluator,\n-                                                final List<?> sourceList) {\n-        final List<Object> result = new LinkedList<>();\n-        sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator,\n-                                                                  value)));\n-        return result;\n+    private Object resolveExpressions(final ExpressionEvaluator expressionEvaluator, final Object value) {\n+    if (value instanceof String) {\n+        return resolveExpressionsString(expressionEvaluator, (String) value);\n+    } else if (value instanceof ObjectNode) {\n+      return resolveExpressionsMap(expressionEvaluator,\n+                                   mapper.convertValue(value, MAP_STRING_OBJECT_TYPE));\n+    } else if (value instanceof Map<?, ?>) {\n+      return resolveExpressionsMap(expressionEvaluator, (Map<String, ?>) value);\n+           } else if (value instanceof List<?>) {\n+             return resolveExpressionsList(expressionEvaluator, (List<?>) value);\n+           } else {\n+             return value;\n+           }\n     }\n \n-    public Map<String, Object> resolveExpressionsMap(final ExpressionEvaluator expressionEvaluator,\n-                                                     final Map<String, ?> sourceMap) {\n-        final Map<String, Object> result = new LinkedHashMap<>();\n-        sourceMap.forEach((key,\n-                           value) -> result.put(key,\n-                                                resolveExpressions(expressionEvaluator,\n-                                                                   value)));\n-        return result;\n+    private List<Object> resolveExpressionsList(final ExpressionEvaluator expressionEvaluator, final List<?> sourceList) {\n+    final List<Object> result = new LinkedList<>();\n+    sourceList.forEach(value -> result.add(resolveExpressions(expressionEvaluator, value)));\n+    return result;\n     }\n \n-    private Object resolveExpressionsString(final ExpressionEvaluator expressionEvaluator,\n-                                            final String sourceString) {\n-        if (StringUtils.isBlank(sourceString)) {\n-            return sourceString;\n-        }\n-        if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n-            return resolveObjectPlaceHolder(expressionEvaluator,\n-                                            sourceString);\n-        } else {\n-            return resolveInStringPlaceHolder(expressionEvaluator,\n-                                              sourceString);\n-        }\n+    public Map<String, Object> resolveExpressionsMap(final ExpressionEvaluator expressionEvaluator, final Map<String, ?> sourceMap) {\n+    final Map<String, Object> result = new LinkedHashMap<>();\n+    sourceMap.forEach((key,value) -> result.put(key,\n+                                                resolveExpressions(expressionEvaluator, value)));\n+    return result;\n+    }\n+\n+    private Object resolveExpressionsString(final ExpressionEvaluator expressionEvaluator, final String sourceString) {\n+    if (StringUtils.isBlank(sourceString)) {\n+        return sourceString;\n+    }\n+\n+    if (sourceString.matches(EXPRESSION_PATTERN_STRING)) {\n+        return resolveObjectPlaceHolder(expressionEvaluator, sourceString);\n+    } else {\n+      return resolveInStringPlaceHolder(expressionEvaluator, sourceString);\n+    }\n     }\n \n-    private Object resolveObjectPlaceHolder(ExpressionEvaluator expressionEvaluator,\n-                                            String sourceString) {\n+    private Object resolveObjectPlaceHolder(ExpressionEvaluator expressionEvaluator, String sourceString) {\n+    try {\n+        return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager, delegateInterceptor);\n+    } catch (final Exception e) {\n+      logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n+                  e);\n+      return sourceString;\n+    }\n+    }\n+\n+    private String resolveInStringPlaceHolder(final ExpressionEvaluator expressionEvaluator, final String sourceString) {\n+    final Matcher matcher = EXPRESSION_PATTERN.matcher(sourceString);\n+    final StringBuffer sb = new StringBuffer();\n+    while (matcher.find()) {\n+        final String expressionKey = matcher.group(EXPRESSION_KEY_INDEX);\n+        final Expression expression = expressionManager.createExpression(expressionKey);\n         try {\n-            return expressionEvaluator.evaluate(expressionManager.createExpression(sourceString), expressionManager,\n-                delegateInterceptor);\n+                               final Object value = expressionEvaluator.evaluate(expression,\n+                                                                                 expressionManager,\n+                                                                                 delegateInterceptor);\n+                               matcher.appendReplacement(sb, Objects.toString(value));\n         } catch (final Exception e) {\n-            logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                        e);\n-            return sourceString;\n+          logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n+                      e);\n         }\n     }\n-\n-    private String resolveInStringPlaceHolder(final ExpressionEvaluator expressionEvaluator,\n-                                              final String sourceString) {\n-        final Matcher matcher = EXPRESSION_PATTERN.matcher(sourceString);\n-        final StringBuffer sb = new StringBuffer();\n-        while (matcher.find()) {\n-            final String expressionKey = matcher.group(EXPRESSION_KEY_INDEX);\n-            final Expression expression = expressionManager.createExpression(expressionKey);\n-            try {\n-                final Object value = expressionEvaluator.evaluate(expression, expressionManager,\n-                    delegateInterceptor);\n-                matcher.appendReplacement(sb,\n-                                          Objects.toString(value));\n-            } catch (final Exception e) {\n-                logger.warn(\"Unable to resolve expression in variables, keeping original value\",\n-                            e);\n-            }\n-        }\n-        matcher.appendTail(sb);\n-        return sb.toString();\n+    matcher.appendTail(sb);\n+    return sb.toString();\n     }\n \n     public boolean containsExpression(final Object source) {\n-        if (source == null) {\n-            return false;\n-        } else if (source instanceof String) {\n-            return containsExpressionString((String) source);\n-        } else if (source instanceof ObjectNode) {\n-            return containsExpressionMap(mapper.convertValue(source,\n-                                                             MAP_STRING_OBJECT_TYPE));\n-        } else if (source instanceof Map<?, ?>) {\n-            return containsExpressionMap((Map<String, ?>) source);\n-        } else if (source instanceof List<?>) {\n-            return containsExpressionList((List<?>) source);\n-        } else {\n-            return false;\n-        }\n+    if (source == null) {\n+        return false;\n+    } else if (source instanceof String) {\n+      return containsExpressionString((String) source);\n+    } else if (source instanceof ObjectNode) {\n+      return containsExpressionMap(mapper.convertValue(source, MAP_STRING_OBJECT_TYPE));\n+           } else if (source instanceof Map<?, ?>) {\n+             return containsExpressionMap((Map<String, ?>) source);\n+           } else if (source instanceof List<?>) {\n+             return containsExpressionList((List<?>) source);\n+                  } else {\n+                    return false;\n+                  }\n     }\n \n     private boolean containsExpressionString(final String sourceString) {\n-        return EXPRESSION_PATTERN.matcher(sourceString).find();\n+    return EXPRESSION_PATTERN.matcher(sourceString).find();\n     }\n \n     private boolean containsExpressionMap(final Map<String, ?> source) {\n-        for (Entry<String, ?> entry : source.entrySet()) {\n-            if (containsExpression(entry.getValue())) {\n-                return true;\n-            }\n+    for (Entry<String, ?> entry : source.entrySet()) {\n+        if (containsExpression(entry.getValue())) {\n+                                                         return true;\n         }\n-        return false;\n+    }\n+    return false;\n     }\n \n     private boolean containsExpressionList(List<?> source) {\n-        for (Object item : source) {\n-            if (containsExpression(item)) {\n-                return true;\n-            }\n+    for (Object item : source) {\n+        if (containsExpression(item)) {\n+                                   return true;\n         }\n-        return false;\n     }\n-}\n+    return false;\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 143
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_random/570/ExpressionResolver.java\nindex 355448fddd..7f08ba22da 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_random/570/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_three_grams/570/ExpressionResolver.java\nindex 355448fddd..7f08ba22da 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/570/ExpressionResolver.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_three_grams/570/ExpressionResolver.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.activiti.runtime.api.impl;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n",
            "diff_size": 1
        }
    ]
}