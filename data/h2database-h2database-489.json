{
    "error_id": "489",
    "information": {
        "errors": [
            {
                "line": "1157",
                "column": "53",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "            return null;\n        }\n        return StringUtils.convertHexToBytes((String)v);\n    }\n\n    /**",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/489/DataUtils.java\nindex 5479b048de..f0086075c3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/489/DataUtils.java\n@@ -1154,7 +1154,7 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "815",
                    "column": "50",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "848",
                    "column": "50",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "894",
                    "column": "50",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "942",
                    "column": "55",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/489/DataUtils.java\nindex 5479b048de..be3b61fffd 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/489/DataUtils.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore;\n \n import java.io.EOFException;\n@@ -24,1159 +25,1171 @@ import org.h2.util.StringUtils;\n  */\n public final class DataUtils {\n \n-    /**\n-     * An error occurred while reading from the file.\n-     */\n-    public static final int ERROR_READING_FAILED = 1;\n-\n-    /**\n-     * An error occurred when trying to write to the file.\n-     */\n-    public static final int ERROR_WRITING_FAILED = 2;\n-\n-    /**\n-     * An internal error occurred. This could be a bug, or a memory corruption\n-     * (for example caused by out of memory).\n-     */\n-    public static final int ERROR_INTERNAL = 3;\n-\n-    /**\n-     * The object is already closed.\n-     */\n-    public static final int ERROR_CLOSED = 4;\n-\n-    /**\n-     * The file format is not supported.\n-     */\n-    public static final int ERROR_UNSUPPORTED_FORMAT = 5;\n-\n-    /**\n-     * The file is corrupt or (for encrypted files) the encryption key is wrong.\n-     */\n-    public static final int ERROR_FILE_CORRUPT = 6;\n-\n-    /**\n-     * The file is locked.\n-     */\n-    public static final int ERROR_FILE_LOCKED = 7;\n-\n-    /**\n-     * An error occurred when serializing or de-serializing.\n-     */\n-    public static final int ERROR_SERIALIZATION = 8;\n-\n-    /**\n-     * The application was trying to read data from a chunk that is no longer\n-     * available.\n-     */\n-    public static final int ERROR_CHUNK_NOT_FOUND = 9;\n-\n-    /**\n-     * The block in the stream store was not found.\n-     */\n-    public static final int ERROR_BLOCK_NOT_FOUND = 50;\n-\n-    /**\n-     * The transaction store is corrupt.\n-     */\n-    public static final int ERROR_TRANSACTION_CORRUPT = 100;\n-\n-    /**\n-     * An entry is still locked by another transaction.\n-     */\n-    public static final int ERROR_TRANSACTION_LOCKED = 101;\n-\n-    /**\n-     * There are too many open transactions.\n-     */\n-    public static final int ERROR_TOO_MANY_OPEN_TRANSACTIONS = 102;\n-\n-    /**\n-     * The transaction store is in an illegal state (for example, not yet\n-     * initialized).\n-     */\n-    public static final int ERROR_TRANSACTION_ILLEGAL_STATE = 103;\n-\n-    /**\n-     * The transaction contains too many changes.\n-     */\n-    public static final int ERROR_TRANSACTION_TOO_BIG = 104;\n-\n-    /**\n-     * Deadlock discovered and one of transactions involved chosen as victim and rolled back.\n-     */\n-    public static final int ERROR_TRANSACTIONS_DEADLOCK = 105;\n-\n-    /**\n-     * The transaction store can not be initialized because data type\n-     * is not found in type registry.\n-     */\n-    public static final int ERROR_UNKNOWN_DATA_TYPE = 106;\n-\n-    /**\n-     * The type for leaf page.\n-     */\n-    public static final int PAGE_TYPE_LEAF = 0;\n-\n-    /**\n-     * The type for node page.\n-     */\n-    public static final int PAGE_TYPE_NODE = 1;\n-\n-    /**\n-     * The bit mask for compressed pages (compression level fast).\n-     */\n-    public static final int PAGE_COMPRESSED = 2;\n-\n-    /**\n-     * The bit mask for compressed pages (compression level high).\n-     */\n-    public static final int PAGE_COMPRESSED_HIGH = 2 + 4;\n-\n-    /**\n-     * The bit mask for pages with page sequential number.\n-     */\n-    public static final int PAGE_HAS_PAGE_NO = 8;\n-\n-    /**\n-     * The maximum length of a variable size int.\n-     */\n-    public static final int MAX_VAR_INT_LEN = 5;\n-\n-    /**\n-     * The maximum length of a variable size long.\n-     */\n-    public static final int MAX_VAR_LONG_LEN = 10;\n-\n-    /**\n-     * The maximum integer that needs less space when using variable size\n-     * encoding (only 3 bytes instead of 4).\n-     */\n-    public static final int COMPRESSED_VAR_INT_MAX = 0x1fffff;\n-\n-    /**\n-     * The maximum long that needs less space when using variable size\n-     * encoding (only 7 bytes instead of 8).\n-     */\n-    public static final long COMPRESSED_VAR_LONG_MAX = 0x1ffffffffffffL;\n-\n-    /**\n-     * The marker size of a very large page.\n-     */\n-    public static final int PAGE_LARGE = 2 * 1024 * 1024;\n-\n-    // The following are key prefixes used in meta map\n-\n-    /**\n-     * The prefix for chunks (\"chunk.\"). This, plus the chunk id (hex encoded)\n-     * is the key, and the serialized chunk metadata is the value.\n-     */\n-    public static final String META_CHUNK = \"chunk.\";\n-\n-    /**\n-     * The prefix for names (\"name.\"). This, plus the name of the map, is the\n-     * key, and the map id (hex encoded) is the value.\n-     */\n-    public static final String META_NAME = \"name.\";\n-\n-    /**\n-     * The prefix for maps (\"map.\"). This, plus the map id (hex encoded) is the\n-     * key, and the serialized in the map metadata is the value.\n-     */\n-    public static final String META_MAP = \"map.\";\n-\n-    /**\n-     * The prefix for root positions of maps (\"root.\"). This, plus the map id\n-     * (hex encoded) is the key, and the position (hex encoded) is the value.\n-     */\n-    public static final String META_ROOT = \"root.\";\n-\n-    /**\n-     * Get the length of the variable size int.\n-     *\n-     * @param x the value\n-     * @return the length in bytes\n-     */\n-    public static int getVarIntLen(int x) {\n-        if ((x & (-1 << 7)) == 0) {\n-            return 1;\n-        } else if ((x & (-1 << 14)) == 0) {\n-            return 2;\n-        } else if ((x & (-1 << 21)) == 0) {\n-            return 3;\n-        } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n-        return 5;\n+  /**\n+   * An error occurred while reading from the file.\n+   */\n+  public static final int ERROR_READING_FAILED = 1;\n+\n+  /**\n+   * An error occurred when trying to write to the file.\n+   */\n+  public static final int ERROR_WRITING_FAILED = 2;\n+\n+  /**\n+   * An internal error occurred. This could be a bug, or a memory corruption\n+   * (for example caused by out of memory).\n+   */\n+  public static final int ERROR_INTERNAL = 3;\n+\n+  /**\n+   * The object is already closed.\n+   */\n+  public static final int ERROR_CLOSED = 4;\n+\n+  /**\n+   * The file format is not supported.\n+   */\n+  public static final int ERROR_UNSUPPORTED_FORMAT = 5;\n+\n+  /**\n+   * The file is corrupt or (for encrypted files) the encryption key is wrong.\n+   */\n+  public static final int ERROR_FILE_CORRUPT = 6;\n+\n+  /**\n+   * The file is locked.\n+   */\n+  public static final int ERROR_FILE_LOCKED = 7;\n+\n+  /**\n+   * An error occurred when serializing or de-serializing.\n+   */\n+  public static final int ERROR_SERIALIZATION = 8;\n+\n+  /**\n+   * The application was trying to read data from a chunk that is no longer\n+   * available.\n+   */\n+  public static final int ERROR_CHUNK_NOT_FOUND = 9;\n+\n+  /**\n+   * The block in the stream store was not found.\n+   */\n+  public static final int ERROR_BLOCK_NOT_FOUND = 50;\n+\n+  /**\n+   * The transaction store is corrupt.\n+   */\n+  public static final int ERROR_TRANSACTION_CORRUPT = 100;\n+\n+  /**\n+   * An entry is still locked by another transaction.\n+   */\n+  public static final int ERROR_TRANSACTION_LOCKED = 101;\n+\n+  /**\n+   * There are too many open transactions.\n+   */\n+  public static final int ERROR_TOO_MANY_OPEN_TRANSACTIONS = 102;\n+\n+  /**\n+   * The transaction store is in an illegal state (for example, not yet\n+   * initialized).\n+   */\n+  public static final int ERROR_TRANSACTION_ILLEGAL_STATE = 103;\n+\n+  /**\n+   * The transaction contains too many changes.\n+   */\n+  public static final int ERROR_TRANSACTION_TOO_BIG = 104;\n+\n+  /**\n+   * Deadlock discovered and one of transactions involved chosen as victim and rolled back.\n+   */\n+  public static final int ERROR_TRANSACTIONS_DEADLOCK = 105;\n+\n+  /**\n+   * The transaction store can not be initialized because data type\n+   * is not found in type registry.\n+   */\n+  public static final int ERROR_UNKNOWN_DATA_TYPE = 106;\n+\n+  /**\n+   * The type for leaf page.\n+   */\n+  public static final int PAGE_TYPE_LEAF = 0;\n+\n+  /**\n+   * The type for node page.\n+   */\n+  public static final int PAGE_TYPE_NODE = 1;\n+\n+  /**\n+   * The bit mask for compressed pages (compression level fast).\n+   */\n+  public static final int PAGE_COMPRESSED = 2;\n+\n+  /**\n+   * The bit mask for compressed pages (compression level high).\n+   */\n+  public static final int PAGE_COMPRESSED_HIGH = 2 + 4;\n+\n+  /**\n+   * The bit mask for pages with page sequential number.\n+   */\n+  public static final int PAGE_HAS_PAGE_NO = 8;\n+\n+  /**\n+   * The maximum length of a variable size int.\n+   */\n+  public static final int MAX_VAR_INT_LEN = 5;\n+\n+  /**\n+   * The maximum length of a variable size long.\n+   */\n+  public static final int MAX_VAR_LONG_LEN = 10;\n+\n+  /**\n+   * The maximum integer that needs less space when using variable size\n+   * encoding (only 3 bytes instead of 4).\n+   */\n+  public static final int COMPRESSED_VAR_INT_MAX = 0x1fffff;\n+\n+  /**\n+   * The maximum long that needs less space when using variable size\n+   * encoding (only 7 bytes instead of 8).\n+   */\n+  public static final long COMPRESSED_VAR_LONG_MAX = 0x1ffffffffffffL;\n+\n+  /**\n+   * The marker size of a very large page.\n+   */\n+  public static final int PAGE_LARGE = 2 * 1024 * 1024;\n+\n+  // The following are key prefixes used in meta map\n+\n+  /**\n+   * The prefix for chunks (\"chunk.\"). This, plus the chunk id (hex encoded)\n+   * is the key, and the serialized chunk metadata is the value.\n+   */\n+  public static final String META_CHUNK = \"chunk.\";\n+\n+  /**\n+   * The prefix for names (\"name.\"). This, plus the name of the map, is the\n+   * key, and the map id (hex encoded) is the value.\n+   */\n+  public static final String META_NAME = \"name.\";\n+\n+  /**\n+   * The prefix for maps (\"map.\"). This, plus the map id (hex encoded) is the\n+   * key, and the serialized in the map metadata is the value.\n+   */\n+  public static final String META_MAP = \"map.\";\n+\n+  /**\n+   * The prefix for root positions of maps (\"root.\"). This, plus the map id\n+   * (hex encoded) is the key, and the position (hex encoded) is the value.\n+   */\n+  public static final String META_ROOT = \"root.\";\n+\n+  /**\n+   * Get the length of the variable size int.\n+   *\n+   * @param x the value\n+   * @return the length in bytes\n+   */\n+  public static int getVarIntLen(int x) {\n+    if ((x & (-1 << 7)) == 0) {\n+      return 1;\n+    } else if ((x & (-1 << 14)) == 0) {\n+      return 2;\n+    } else if ((x & (-1 << 21)) == 0) {\n+      return 3;\n+    } else if ((x & (-1 << 28)) == 0) {\n+      return 4;\n     }\n-\n-    /**\n-     * Get the length of the variable size long.\n-     *\n-     * @param x the value\n-     * @return the length in bytes\n-     */\n-    public static int getVarLongLen(long x) {\n-        int i = 1;\n-        while (true) {\n-            x >>>= 7;\n-            if (x == 0) {\n-                return i;\n-            }\n-            i++;\n-        }\n+    return 5;\n+  }\n+\n+  /**\n+   * Get the length of the variable size long.\n+   *\n+   * @param x the value\n+   * @return the length in bytes\n+   */\n+  public static int getVarLongLen(long x) {\n+    int i = 1;\n+    while (true) {\n+      x >>>= 7;\n+      if (x == 0) {\n+        return i;\n+      }\n+      i++;\n     }\n-\n-    /**\n-     * Read a variable size int.\n-     *\n-     * @param buff the source buffer\n-     * @return the value\n-     */\n-    public static int readVarInt(ByteBuffer buff) {\n-        int b = buff.get();\n-        if (b >= 0) {\n-            return b;\n-        }\n-        // a separate function so that this one can be inlined\n-        return readVarIntRest(buff, b);\n+  }\n+\n+  /**\n+   * Read a variable size int.\n+   *\n+   * @param buff the source buffer\n+   * @return the value\n+   */\n+  public static int readVarInt(ByteBuffer buff) {\n+    int b = buff.get();\n+    if (b >= 0) {\n+      return b;\n     }\n-\n-    private static int readVarIntRest(ByteBuffer buff, int b) {\n-        int x = b & 0x7f;\n-        b = buff.get();\n-        if (b >= 0) {\n-            return x | (b << 7);\n-        }\n-        x |= (b & 0x7f) << 7;\n-        b = buff.get();\n-        if (b >= 0) {\n-            return x | (b << 14);\n-        }\n-        x |= (b & 0x7f) << 14;\n-        b = buff.get();\n-        if (b >= 0) {\n-            return x | b << 21;\n-        }\n-        x |= ((b & 0x7f) << 21) | (buff.get() << 28);\n-        return x;\n+    // a separate function so that this one can be inlined\n+    return readVarIntRest(buff, b);\n+  }\n+\n+  private static int readVarIntRest(ByteBuffer buff, int b) {\n+    int x = b & 0x7f;\n+    b = buff.get();\n+    if (b >= 0) {\n+      return x | (b << 7);\n     }\n-\n-    /**\n-     * Read a variable size long.\n-     *\n-     * @param buff the source buffer\n-     * @return the value\n-     */\n-    public static long readVarLong(ByteBuffer buff) {\n-        long x = buff.get();\n-        if (x >= 0) {\n-            return x;\n-        }\n-        x &= 0x7f;\n-        for (int s = 7; s < 64; s += 7) {\n-            long b = buff.get();\n-            x |= (b & 0x7f) << s;\n-            if (b >= 0) {\n-                break;\n-            }\n-        }\n-        return x;\n+    x |= (b & 0x7f) << 7;\n+    b = buff.get();\n+    if (b >= 0) {\n+      return x | (b << 14);\n     }\n-\n-    /**\n-     * Write a variable size int.\n-     *\n-     * @param out the output stream\n-     * @param x the value\n-     * @throws IOException if some data could not be written\n-     */\n-    public static void writeVarInt(OutputStream out, int x) throws IOException {\n-        while ((x & ~0x7f) != 0) {\n-            out.write((byte) (x | 0x80));\n-            x >>>= 7;\n-        }\n-        out.write((byte) x);\n+    x |= (b & 0x7f) << 14;\n+    b = buff.get();\n+    if (b >= 0) {\n+      return x | b << 21;\n     }\n-\n-    /**\n-     * Write a variable size int.\n-     *\n-     * @param buff the source buffer\n-     * @param x the value\n-     */\n-    public static void writeVarInt(ByteBuffer buff, int x) {\n-        while ((x & ~0x7f) != 0) {\n-            buff.put((byte) (x | 0x80));\n-            x >>>= 7;\n-        }\n-        buff.put((byte) x);\n+    x |= ((b & 0x7f) << 21) | (buff.get() << 28);\n+    return x;\n+  }\n+\n+  /**\n+   * Read a variable size long.\n+   *\n+   * @param buff the source buffer\n+   * @return the value\n+   */\n+  public static long readVarLong(ByteBuffer buff) {\n+    long x = buff.get();\n+    if (x >= 0) {\n+      return x;\n     }\n-\n-    /**\n-     * Write characters from a string (without the length).\n-     *\n-     * @param buff the target buffer (must be large enough)\n-     * @param s the string\n-     * @param len the number of characters\n-     */\n-    public static void writeStringData(ByteBuffer buff,\n-            String s, int len) {\n-        for (int i = 0; i < len; i++) {\n-            int c = s.charAt(i);\n-            if (c < 0x80) {\n-                buff.put((byte) c);\n-            } else if (c >= 0x800) {\n-                buff.put((byte) (0xe0 | (c >> 12)));\n-                buff.put((byte) (((c >> 6) & 0x3f)));\n-                buff.put((byte) (c & 0x3f));\n-            } else {\n-                buff.put((byte) (0xc0 | (c >> 6)));\n-                buff.put((byte) (c & 0x3f));\n-            }\n-        }\n+    x &= 0x7f;\n+    for (int s = 7; s < 64; s += 7) {\n+      long b = buff.get();\n+      x |= (b & 0x7f) << s;\n+      if (b >= 0) {\n+        break;\n+      }\n     }\n-\n-    /**\n-     * Read a string.\n-     *\n-     * @param buff the source buffer\n-     * @return the value\n-     */\n-    public static String readString(ByteBuffer buff) {\n-        return readString(buff, readVarInt(buff));\n+    return x;\n+  }\n+\n+  /**\n+   * Write a variable size int.\n+   *\n+   * @param out the output stream\n+   * @param x   the value\n+   * @throws IOException if some data could not be written\n+   */\n+  public static void writeVarInt(OutputStream out, int x) throws IOException {\n+    while ((x & ~0x7f) != 0) {\n+      out.write((byte) (x | 0x80));\n+      x >>>= 7;\n     }\n-\n-    /**\n-     * Read a string.\n-     *\n-     * @param buff the source buffer\n-     * @param len the number of characters\n-     * @return the value\n-     */\n-    public static String readString(ByteBuffer buff, int len) {\n-        char[] chars = new char[len];\n-        for (int i = 0; i < len; i++) {\n-            int x = buff.get() & 0xff;\n-            if (x < 0x80) {\n-                chars[i] = (char) x;\n-            } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12)\n-                        + ((buff.get() & 0x3f) << 6) + (buff.get() & 0x3f));\n-            } else {\n-                chars[i] = (char) (((x & 0x1f) << 6) + (buff.get() & 0x3f));\n-            }\n-        }\n-        return new String(chars);\n+    out.write((byte) x);\n+  }\n+\n+  /**\n+   * Write a variable size int.\n+   *\n+   * @param buff the source buffer\n+   * @param x    the value\n+   */\n+  public static void writeVarInt(ByteBuffer buff, int x) {\n+    while ((x & ~0x7f) != 0) {\n+      buff.put((byte) (x | 0x80));\n+      x >>>= 7;\n     }\n-\n-    /**\n-     * Write a variable size long.\n-     *\n-     * @param buff the target buffer\n-     * @param x the value\n-     */\n-    public static void writeVarLong(ByteBuffer buff, long x) {\n-        while ((x & ~0x7f) != 0) {\n-            buff.put((byte) (x | 0x80));\n-            x >>>= 7;\n-        }\n-        buff.put((byte) x);\n+    buff.put((byte) x);\n+  }\n+\n+  /**\n+   * Write characters from a string (without the length).\n+   *\n+   * @param buff the target buffer (must be large enough)\n+   * @param s    the string\n+   * @param len  the number of characters\n+   */\n+  public static void writeStringData(ByteBuffer buff,\n+                                     String s, int len) {\n+    for (int i = 0; i < len; i++) {\n+      int c = s.charAt(i);\n+      if (c < 0x80) {\n+        buff.put((byte) c);\n+      } else if (c >= 0x800) {\n+        buff.put((byte) (0xe0 | (c >> 12)));\n+        buff.put((byte) (((c >> 6) & 0x3f)));\n+        buff.put((byte) (c & 0x3f));\n+      } else {\n+        buff.put((byte) (0xc0 | (c >> 6)));\n+        buff.put((byte) (c & 0x3f));\n+      }\n     }\n-\n-    /**\n-     * Write a variable size long.\n-     *\n-     * @param out the output stream\n-     * @param x the value\n-     * @throws IOException if some data could not be written\n-     */\n-    public static void writeVarLong(OutputStream out, long x)\n-            throws IOException {\n-        while ((x & ~0x7f) != 0) {\n-            out.write((byte) (x | 0x80));\n-            x >>>= 7;\n-        }\n-        out.write((byte) x);\n+  }\n+\n+  /**\n+   * Read a string.\n+   *\n+   * @param buff the source buffer\n+   * @return the value\n+   */\n+  public static String readString(ByteBuffer buff) {\n+    return readString(buff, readVarInt(buff));\n+  }\n+\n+  /**\n+   * Read a string.\n+   *\n+   * @param buff the source buffer\n+   * @param len  the number of characters\n+   * @return the value\n+   */\n+  public static String readString(ByteBuffer buff, int len) {\n+    char[] chars = new char[len];\n+    for (int i = 0; i < len; i++) {\n+      int x = buff.get() & 0xff;\n+      if (x < 0x80) {\n+        chars[i] = (char) x;\n+      } else if (x >= 0xe0) {\n+        chars[i] = (char) (((x & 0xf) << 12)\n+            + ((buff.get() & 0x3f) << 6) + (buff.get() & 0x3f));\n+      } else {\n+        chars[i] = (char) (((x & 0x1f) << 6) + (buff.get() & 0x3f));\n+      }\n     }\n-\n-    /**\n-     * Copy the elements of an array, with a gap.\n-     *\n-     * @param src the source array\n-     * @param dst the target array\n-     * @param oldSize the size of the old array\n-     * @param gapIndex the index of the gap\n-     */\n-    public static void copyWithGap(Object src, Object dst, int oldSize,\n-            int gapIndex) {\n-        if (gapIndex > 0) {\n-            System.arraycopy(src, 0, dst, 0, gapIndex);\n-        }\n-        if (gapIndex < oldSize) {\n-            System.arraycopy(src, gapIndex, dst, gapIndex + 1, oldSize\n-                    - gapIndex);\n-        }\n+    return new String(chars);\n+  }\n+\n+  /**\n+   * Write a variable size long.\n+   *\n+   * @param buff the target buffer\n+   * @param x    the value\n+   */\n+  public static void writeVarLong(ByteBuffer buff, long x) {\n+    while ((x & ~0x7f) != 0) {\n+      buff.put((byte) (x | 0x80));\n+      x >>>= 7;\n     }\n-\n-    /**\n-     * Copy the elements of an array, and remove one element.\n-     *\n-     * @param src the source array\n-     * @param dst the target array\n-     * @param oldSize the size of the old array\n-     * @param removeIndex the index of the entry to remove\n-     */\n-    public static void copyExcept(Object src, Object dst, int oldSize,\n-            int removeIndex) {\n-        if (removeIndex > 0 && oldSize > 0) {\n-            System.arraycopy(src, 0, dst, 0, removeIndex);\n-        }\n-        if (removeIndex < oldSize) {\n-            System.arraycopy(src, removeIndex + 1, dst, removeIndex, oldSize\n-                    - removeIndex - 1);\n-        }\n+    buff.put((byte) x);\n+  }\n+\n+  /**\n+   * Write a variable size long.\n+   *\n+   * @param out the output stream\n+   * @param x   the value\n+   * @throws IOException if some data could not be written\n+   */\n+  public static void writeVarLong(OutputStream out, long x)\n+      throws IOException {\n+    while ((x & ~0x7f) != 0) {\n+      out.write((byte) (x | 0x80));\n+      x >>>= 7;\n     }\n-\n-    /**\n-     * Read from a file channel until the buffer is full.\n-     * The buffer is rewind after reading.\n-     *\n-     * @param file the file channel\n-     * @param pos the absolute position within the file\n-     * @param dst the byte buffer\n-     * @throws IllegalStateException if some data could not be read\n-     */\n-    public static void readFully(FileChannel file, long pos, ByteBuffer dst) {\n-        try {\n-            do {\n-                int len = file.read(dst, pos);\n-                if (len < 0) {\n-                    throw new EOFException();\n-                }\n-                pos += len;\n-            } while (dst.remaining() > 0);\n-            dst.rewind();\n-        } catch (IOException e) {\n-            long size;\n-            try {\n-                size = file.size();\n-            } catch (IOException e2) {\n-                size = -1;\n-            }\n-            throw newIllegalStateException(\n-                    ERROR_READING_FAILED,\n-                    \"Reading from file {0} failed at {1} (length {2}), \" +\n-                    \"read {3}, remaining {4}\",\n-                    file, pos, size, dst.position(), dst.remaining(), e);\n-        }\n+    out.write((byte) x);\n+  }\n+\n+  /**\n+   * Copy the elements of an array, with a gap.\n+   *\n+   * @param src      the source array\n+   * @param dst      the target array\n+   * @param oldSize  the size of the old array\n+   * @param gapIndex the index of the gap\n+   */\n+  public static void copyWithGap(Object src, Object dst, int oldSize,\n+                                 int gapIndex) {\n+    if (gapIndex > 0) {\n+      System.arraycopy(src, 0, dst, 0, gapIndex);\n     }\n-\n-    /**\n-     * Write to a file channel.\n-     *\n-     * @param file the file channel\n-     * @param pos the absolute position within the file\n-     * @param src the source buffer\n-     */\n-    public static void writeFully(FileChannel file, long pos, ByteBuffer src) {\n-        try {\n-            int off = 0;\n-            do {\n-                int len = file.write(src, pos + off);\n-                off += len;\n-            } while (src.remaining() > 0);\n-        } catch (IOException e) {\n-            throw newIllegalStateException(\n-                    ERROR_WRITING_FAILED,\n-                    \"Writing to {0} failed; length {1} at {2}\",\n-                    file, src.remaining(), pos, e);\n-        }\n+    if (gapIndex < oldSize) {\n+      System.arraycopy(src, gapIndex, dst, gapIndex + 1, oldSize\n+          - gapIndex);\n     }\n-\n-    /**\n-     * Convert the length to a length code 0..31. 31 means more than 1 MB.\n-     *\n-     * @param len the length\n-     * @return the length code\n-     */\n-    public static int encodeLength(int len) {\n-        if (len <= 32) {\n-            return 0;\n-        }\n-        int code = Integer.numberOfLeadingZeros(len);\n-        int remaining = len << (code + 1);\n-        code += code;\n-        if ((remaining & (1 << 31)) != 0) {\n-            code--;\n-        }\n-        if ((remaining << 1) != 0) {\n-            code--;\n-        }\n-        code = Math.min(31, 52 - code);\n-        // alternative code (slower):\n-        // int x = len;\n-        // int shift = 0;\n-        // while (x > 3) {\n-        //    shift++;\n-        //    x = (x >>> 1) + (x & 1);\n-        // }\n-        // shift = Math.max(0,  shift - 4);\n-        // int code = (shift << 1) + (x & 1);\n-        // code = Math.min(31, code);\n-        return code;\n+  }\n+\n+  /**\n+   * Copy the elements of an array, and remove one element.\n+   *\n+   * @param src         the source array\n+   * @param dst         the target array\n+   * @param oldSize     the size of the old array\n+   * @param removeIndex the index of the entry to remove\n+   */\n+  public static void copyExcept(Object src, Object dst, int oldSize,\n+                                int removeIndex) {\n+    if (removeIndex > 0 && oldSize > 0) {\n+      System.arraycopy(src, 0, dst, 0, removeIndex);\n     }\n-\n-    /**\n-     * Get the chunk id from the position.\n-     *\n-     * @param pos the position\n-     * @return the chunk id\n-     */\n-    public static int getPageChunkId(long pos) {\n-        return (int) (pos >>> 38);\n-    }\n-\n-    /**\n-     * Get the map id from the chunk's table of content element.\n-     *\n-     * @param tocElement packed table of content element\n-     * @return the map id\n-     */\n-    public static int getPageMapId(long tocElement) {\n-        return (int) (tocElement >>> 38);\n+    if (removeIndex < oldSize) {\n+      System.arraycopy(src, removeIndex + 1, dst, removeIndex, oldSize\n+          - removeIndex - 1);\n     }\n-\n-    /**\n-     * Get the maximum length for the given page position.\n-     *\n-     * @param pos the position\n-     * @return the maximum length\n-     */\n-    public static int getPageMaxLength(long pos) {\n-        int code = (int) ((pos >> 1) & 31);\n-        return decodePageLength(code);\n-    }\n-\n-    /**\n-     * Get the maximum length for the given code.\n-     * For the code 31, PAGE_LARGE is returned.\n-     *\n-     * @param code encoded page length\n-     * @return the maximum length\n-     */\n-    public static int decodePageLength(int code) {\n-        if (code == 31) {\n-            return PAGE_LARGE;\n+  }\n+\n+  /**\n+   * Read from a file channel until the buffer is full.\n+   * The buffer is rewind after reading.\n+   *\n+   * @param file the file channel\n+   * @param pos  the absolute position within the file\n+   * @param dst  the byte buffer\n+   * @throws IllegalStateException if some data could not be read\n+   */\n+  public static void readFully(FileChannel file, long pos, ByteBuffer dst) {\n+    try {\n+      do {\n+        int len = file.read(dst, pos);\n+        if (len < 0) {\n+          throw new EOFException();\n         }\n-        return (2 + (code & 1)) << ((code >> 1) + 4);\n+        pos += len;\n+      } while (dst.remaining() > 0);\n+      dst.rewind();\n+    } catch (IOException e) {\n+      long size;\n+      try {\n+        size = file.size();\n+      } catch (IOException e2) {\n+        size = -1;\n+      }\n+      throw newIllegalStateException(\n+          ERROR_READING_FAILED,\n+          \"Reading from file {0} failed at {1} (length {2}), \" +\n+              \"read {3}, remaining {4}\",\n+          file, pos, size, dst.position(), dst.remaining(), e);\n     }\n-\n-    /**\n-     * Get the offset from the position.\n-     *\n-     * @param tocElement packed table of content element\n-     * @return the offset\n-     */\n-    public static int getPageOffset(long tocElement) {\n-        return (int) (tocElement >> 6);\n+  }\n+\n+  /**\n+   * Write to a file channel.\n+   *\n+   * @param file the file channel\n+   * @param pos  the absolute position within the file\n+   * @param src  the source buffer\n+   */\n+  public static void writeFully(FileChannel file, long pos, ByteBuffer src) {\n+    try {\n+      int off = 0;\n+      do {\n+        int len = file.write(src, pos + off);\n+        off += len;\n+      } while (src.remaining() > 0);\n+    } catch (IOException e) {\n+      throw newIllegalStateException(\n+          ERROR_WRITING_FAILED,\n+          \"Writing to {0} failed; length {1} at {2}\",\n+          file, src.remaining(), pos, e);\n     }\n-\n-    /**\n-     * Get the page type from the position.\n-     *\n-     * @param pos the position\n-     * @return the page type (PAGE_TYPE_NODE or PAGE_TYPE_LEAF)\n-     */\n-    public static int getPageType(long pos) {\n-        return ((int) pos) & 1;\n+  }\n+\n+  /**\n+   * Convert the length to a length code 0..31. 31 means more than 1 MB.\n+   *\n+   * @param len the length\n+   * @return the length code\n+   */\n+  public static int encodeLength(int len) {\n+    if (len <= 32) {\n+      return 0;\n     }\n-\n-    /**\n-     * Determines whether specified file position corresponds to a leaf page\n-     * @param pos the position\n-     * @return true if it is a leaf, false otherwise\n-     */\n-    public static boolean isLeafPosition(long pos) {\n-        return getPageType(pos) == PAGE_TYPE_LEAF;\n+    int code = Integer.numberOfLeadingZeros(len);\n+    int remaining = len << (code + 1);\n+    code += code;\n+    if ((remaining & (1 << 31)) != 0) {\n+      code--;\n     }\n-\n-    /**\n-     * Find out if page was saved.\n-     *\n-     * @param pos the position\n-     * @return true if page has been saved\n-     */\n-    public static boolean isPageSaved(long pos) {\n-        return (pos & ~1L) != 0;\n-    }\n-\n-    /**\n-     * Find out if page was removed.\n-     *\n-     * @param pos the position\n-     * @return true if page has been removed (no longer accessible from the\n-     *         current root of the tree)\n-     */\n-    static boolean isPageRemoved(long pos) {\n-        return pos == 1L;\n-    }\n-\n-    /**\n-     * Get the position of this page. The following information is encoded in\n-     * the position: the chunk id, the page sequential number, the maximum length, and the type\n-     * (node or leaf).\n-     *\n-     * @param chunkId the chunk id\n-     * @param offset the offset\n-     * @param length the length\n-     * @param type the page type (1 for node, 0 for leaf)\n-     * @return the position\n-     */\n-    public static long getPagePos(int chunkId, int offset, int length, int type) {\n-        long pos = (long) chunkId << 38;\n-        pos |= (long) offset << 6;\n-        pos |= encodeLength(length) << 1;\n-        pos |= type;\n-        return pos;\n-    }\n-\n-    /**\n-     * Convert tocElement into pagePos by replacing mapId with chunkId\n-     * @param chunkId\n-     * @param tocElement\n-     * @return\n-     */\n-    public static long getPagePos(int chunkId, long tocElement) {\n-        return (tocElement & 0x3FFFFFFFFFL) | ((long) chunkId << 38);\n+    if ((remaining << 1) != 0) {\n+      code--;\n     }\n-\n-    /**\n-     * Create table of content element. The following information is encoded in it:\n-     * the map id, the page offset, the maximum length, and the type\n-     * (node or leaf).\n-     *\n-     * @param mapId the chunk id\n-     * @param offset the offset\n-     * @param length the length\n-     * @param type the page type (1 for node, 0 for leaf)\n-     * @return the position\n-     */\n-    public static long getTocElement(int mapId, int offset, int length, int type) {\n-        long pos = (long) mapId << 38;\n-        pos |= (long) offset << 6;\n-        pos |= encodeLength(length) << 1;\n-        pos |= type;\n-        return pos;\n+    code = Math.min(31, 52 - code);\n+    // alternative code (slower):\n+    // int x = len;\n+    // int shift = 0;\n+    // while (x > 3) {\n+    //    shift++;\n+    //    x = (x >>> 1) + (x & 1);\n+    // }\n+    // shift = Math.max(0,  shift - 4);\n+    // int code = (shift << 1) + (x & 1);\n+    // code = Math.min(31, code);\n+    return code;\n+  }\n+\n+  /**\n+   * Get the chunk id from the position.\n+   *\n+   * @param pos the position\n+   * @return the chunk id\n+   */\n+  public static int getPageChunkId(long pos) {\n+    return (int) (pos >>> 38);\n+  }\n+\n+  /**\n+   * Get the map id from the chunk's table of content element.\n+   *\n+   * @param tocElement packed table of content element\n+   * @return the map id\n+   */\n+  public static int getPageMapId(long tocElement) {\n+    return (int) (tocElement >>> 38);\n+  }\n+\n+  /**\n+   * Get the maximum length for the given page position.\n+   *\n+   * @param pos the position\n+   * @return the maximum length\n+   */\n+  public static int getPageMaxLength(long pos) {\n+    int code = (int) ((pos >> 1) & 31);\n+    return decodePageLength(code);\n+  }\n+\n+  /**\n+   * Get the maximum length for the given code.\n+   * For the code 31, PAGE_LARGE is returned.\n+   *\n+   * @param code encoded page length\n+   * @return the maximum length\n+   */\n+  public static int decodePageLength(int code) {\n+    if (code == 31) {\n+      return PAGE_LARGE;\n     }\n-\n-    /**\n-     * Calculate a check value for the given integer. A check value is mean to\n-     * verify the data is consistent with a high probability, but not meant to\n-     * protect against media failure or deliberate changes.\n-     *\n-     * @param x the value\n-     * @return the check value\n-     */\n-    public static short getCheckValue(int x) {\n-        return (short) ((x >> 16) ^ x);\n+    return (2 + (code & 1)) << ((code >> 1) + 4);\n+  }\n+\n+  /**\n+   * Get the offset from the position.\n+   *\n+   * @param tocElement packed table of content element\n+   * @return the offset\n+   */\n+  public static int getPageOffset(long tocElement) {\n+    return (int) (tocElement >> 6);\n+  }\n+\n+  /**\n+   * Get the page type from the position.\n+   *\n+   * @param pos the position\n+   * @return the page type (PAGE_TYPE_NODE or PAGE_TYPE_LEAF)\n+   */\n+  public static int getPageType(long pos) {\n+    return ((int) pos) & 1;\n+  }\n+\n+  /**\n+   * Determines whether specified file position corresponds to a leaf page\n+   *\n+   * @param pos the position\n+   * @return true if it is a leaf, false otherwise\n+   */\n+  public static boolean isLeafPosition(long pos) {\n+    return getPageType(pos) == PAGE_TYPE_LEAF;\n+  }\n+\n+  /**\n+   * Find out if page was saved.\n+   *\n+   * @param pos the position\n+   * @return true if page has been saved\n+   */\n+  public static boolean isPageSaved(long pos) {\n+    return (pos & ~1L) != 0;\n+  }\n+\n+  /**\n+   * Find out if page was removed.\n+   *\n+   * @param pos the position\n+   * @return true if page has been removed (no longer accessible from the\n+   * current root of the tree)\n+   */\n+  static boolean isPageRemoved(long pos) {\n+    return pos == 1L;\n+  }\n+\n+  /**\n+   * Get the position of this page. The following information is encoded in\n+   * the position: the chunk id, the page sequential number, the maximum length, and the type\n+   * (node or leaf).\n+   *\n+   * @param chunkId the chunk id\n+   * @param offset  the offset\n+   * @param length  the length\n+   * @param type    the page type (1 for node, 0 for leaf)\n+   * @return the position\n+   */\n+  public static long getPagePos(int chunkId, int offset, int length, int type) {\n+    long pos = (long) chunkId << 38;\n+    pos |= (long) offset << 6;\n+    pos |= encodeLength(length) << 1;\n+    pos |= type;\n+    return pos;\n+  }\n+\n+  /**\n+   * Convert tocElement into pagePos by replacing mapId with chunkId\n+   *\n+   * @param chunkId\n+   * @param tocElement\n+   * @return\n+   */\n+  public static long getPagePos(int chunkId, long tocElement) {\n+    return (tocElement & 0x3FFFFFFFFFL) | ((long) chunkId << 38);\n+  }\n+\n+  /**\n+   * Create table of content element. The following information is encoded in it:\n+   * the map id, the page offset, the maximum length, and the type\n+   * (node or leaf).\n+   *\n+   * @param mapId  the chunk id\n+   * @param offset the offset\n+   * @param length the length\n+   * @param type   the page type (1 for node, 0 for leaf)\n+   * @return the position\n+   */\n+  public static long getTocElement(int mapId, int offset, int length,\n+                                   int type) {\n+    long pos = (long) mapId << 38;\n+    pos |= (long) offset << 6;\n+    pos |= encodeLength(length) << 1;\n+    pos |= type;\n+    return pos;\n+  }\n+\n+  /**\n+   * Calculate a check value for the given integer. A check value is mean to\n+   * verify the data is consistent with a high probability, but not meant to\n+   * protect against media failure or deliberate changes.\n+   *\n+   * @param x the value\n+   * @return the check value\n+   */\n+  public static short getCheckValue(int x) {\n+    return (short) ((x >> 16) ^ x);\n+  }\n+\n+  /**\n+   * Append a map to the string builder, sorted by key.\n+   *\n+   * @param buff the target buffer\n+   * @param map  the map\n+   * @return the string builder\n+   */\n+  public static StringBuilder appendMap(StringBuilder buff,\n+                                        HashMap<String, ?> map) {\n+    Object[] keys = map.keySet().toArray();\n+    Arrays.sort(keys);\n+    for (Object k : keys) {\n+      String key = (String) k;\n+      Object value = map.get(key);\n+      if (value instanceof Long) {\n+        appendMap(buff, key, (long) value);\n+      } else if (value instanceof Integer) {\n+        appendMap(buff, key, (int) value);\n+      } else {\n+        appendMap(buff, key, value.toString());\n+      }\n     }\n+    return buff;\n+  }\n \n-    /**\n-     * Append a map to the string builder, sorted by key.\n-     *\n-     * @param buff the target buffer\n-     * @param map the map\n-     * @return the string builder\n-     */\n-    public static StringBuilder appendMap(StringBuilder buff, HashMap<String, ?> map) {\n-        Object[] keys = map.keySet().toArray();\n-        Arrays.sort(keys);\n-        for (Object k : keys) {\n-            String key = (String) k;\n-            Object value = map.get(key);\n-            if (value instanceof Long) {\n-                appendMap(buff, key, (long) value);\n-            } else if (value instanceof Integer) {\n-                appendMap(buff, key, (int) value);\n-            } else {\n-                appendMap(buff, key, value.toString());\n-            }\n-        }\n-        return buff;\n+  private static StringBuilder appendMapKey(StringBuilder buff, String key) {\n+    if (buff.length() > 0) {\n+      buff.append(',');\n     }\n-\n-    private static StringBuilder appendMapKey(StringBuilder buff, String key) {\n-        if (buff.length() > 0) {\n-            buff.append(',');\n+    return buff.append(key).append(':');\n+  }\n+\n+  /**\n+   * Append a key-value pair to the string builder. Keys may not contain a\n+   * colon. Values that contain a comma or a double quote are enclosed in\n+   * double quotes, with special characters escaped using a backslash.\n+   *\n+   * @param buff  the target buffer\n+   * @param key   the key\n+   * @param value the value\n+   */\n+  public static void appendMap(StringBuilder buff, String key, String value) {\n+    appendMapKey(buff, key);\n+    if (value.indexOf(',') < 0 && value.indexOf('\\\"') < 0) {\n+      buff.append(value);\n+    } else {\n+      buff.append('\\\"');\n+      for (int i = 0, size = value.length(); i < size; i++) {\n+        char c = value.charAt(i);\n+        if (c == '\\\"') {\n+          buff.append('\\\\');\n         }\n-        return buff.append(key).append(':');\n+        buff.append(c);\n+      }\n+      buff.append('\\\"');\n     }\n-\n-    /**\n-     * Append a key-value pair to the string builder. Keys may not contain a\n-     * colon. Values that contain a comma or a double quote are enclosed in\n-     * double quotes, with special characters escaped using a backslash.\n-     *\n-     * @param buff the target buffer\n-     * @param key the key\n-     * @param value the value\n-     */\n-    public static void appendMap(StringBuilder buff, String key, String value) {\n-        appendMapKey(buff, key);\n-        if (value.indexOf(',') < 0 && value.indexOf('\\\"') < 0) {\n-            buff.append(value);\n-        } else {\n-            buff.append('\\\"');\n-            for (int i = 0, size = value.length(); i < size; i++) {\n-                char c = value.charAt(i);\n-                if (c == '\\\"') {\n-                    buff.append('\\\\');\n-                }\n-                buff.append(c);\n+  }\n+\n+  /**\n+   * Append a key-value pair to the string builder. Keys may not contain a\n+   * colon.\n+   *\n+   * @param buff  the target buffer\n+   * @param key   the key\n+   * @param value the value\n+   */\n+  public static void appendMap(StringBuilder buff, String key, long value) {\n+    appendMapKey(buff, key).append(Long.toHexString(value));\n+  }\n+\n+  /**\n+   * Append a key-value pair to the string builder. Keys may not contain a\n+   * colon.\n+   *\n+   * @param buff  the target buffer\n+   * @param key   the key\n+   * @param value the value\n+   */\n+  public static void appendMap(StringBuilder buff, String key, int value) {\n+    appendMapKey(buff, key).append(Integer.toHexString(value));\n+  }\n+\n+  /**\n+   * @param buff output buffer, should be empty\n+   * @param s    parsed string\n+   * @param i    offset to parse from\n+   * @param size stop offset (exclusive)\n+   * @return new offset\n+   */\n+  private static int parseMapValue(StringBuilder buff, String s, int i,\n+                                   int size) {\n+    while (i < size) {\n+      char c = s.charAt(i++);\n+      if (c == ',') {\n+        break;\n+      } else if (c == '\\\"') {\n+        while (i < size) {\n+          c = s.charAt(i++);\n+          if (c == '\\\\') {\n+            if (i == size) {\n+              throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+                  \"Not a map: {0}\", s);\n             }\n-            buff.append('\\\"');\n+            c = s.charAt(i++);\n+          } else if (c == '\\\"') {\n+            break;\n+          }\n+          buff.append(c);\n         }\n+      } else {\n+        buff.append(c);\n+      }\n     }\n-\n-    /**\n-     * Append a key-value pair to the string builder. Keys may not contain a\n-     * colon.\n-     *\n-     * @param buff the target buffer\n-     * @param key the key\n-     * @param value the value\n-     */\n-    public static void appendMap(StringBuilder buff, String key, long value) {\n-        appendMapKey(buff, key).append(Long.toHexString(value));\n-    }\n-\n-    /**\n-     * Append a key-value pair to the string builder. Keys may not contain a\n-     * colon.\n-     *\n-     * @param buff the target buffer\n-     * @param key the key\n-     * @param value the value\n-     */\n-    public static void appendMap(StringBuilder buff, String key, int value) {\n-        appendMapKey(buff, key).append(Integer.toHexString(value));\n+    return i;\n+  }\n+\n+  /**\n+   * Parse a key-value pair list.\n+   *\n+   * @param s the list\n+   * @return the map\n+   * @throws IllegalStateException if parsing failed\n+   */\n+  public static HashMap<String, String> parseMap(String s) {\n+    HashMap<String, String> map = new HashMap<>();\n+    StringBuilder buff = new StringBuilder();\n+    for (int i = 0, size = s.length(); i < size; ) {\n+      int startKey = i;\n+      i = s.indexOf(':', i);\n+      if (i < 0) {\n+        throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n+      }\n+      String key = s.substring(startKey, i++);\n+      i = parseMapValue(buff, s, i, size);\n+      map.put(key, buff.toString());\n+      buff.setLength(0);\n     }\n-\n-    /**\n-     * @param buff output buffer, should be empty\n-     * @param s parsed string\n-     * @param i offset to parse from\n-     * @param size stop offset (exclusive)\n-     * @return new offset\n-     */\n-    private static int parseMapValue(StringBuilder buff, String s, int i, int size) {\n-        while (i < size) {\n-            char c = s.charAt(i++);\n-            if (c == ',') {\n-                break;\n-            } else if (c == '\\\"') {\n-                while (i < size) {\n-                    c = s.charAt(i++);\n-                    if (c == '\\\\') {\n-                        if (i == size) {\n-                            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n-                        }\n-                        c = s.charAt(i++);\n-                    } else if (c == '\\\"') {\n-                        break;\n-                    }\n-                    buff.append(c);\n-                }\n-            } else {\n-                buff.append(c);\n-            }\n-        }\n-        return i;\n+    return map;\n+  }\n+\n+  /**\n+   * Parse a key-value pair list and checks its checksum.\n+   *\n+   * @param bytes encoded map\n+   * @return the map without mapping for {@code \"fletcher\"}, or {@code null} if checksum is wrong\n+   * or parameter do not represent a properly formatted map serialization\n+   */\n+  static HashMap<String, String> parseChecksummedMap(byte[] bytes) {\n+    int start = 0, end = bytes.length;\n+    while (start < end && bytes[start] <= ' ') {\n+      start++;\n     }\n-\n-    /**\n-     * Parse a key-value pair list.\n-     *\n-     * @param s the list\n-     * @return the map\n-     * @throws IllegalStateException if parsing failed\n-     */\n-    public static HashMap<String, String> parseMap(String s) {\n-        HashMap<String, String> map = new HashMap<>();\n-        StringBuilder buff = new StringBuilder();\n-        for (int i = 0, size = s.length(); i < size;) {\n-            int startKey = i;\n-            i = s.indexOf(':', i);\n-            if (i < 0) {\n-                throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n-            }\n-            String key = s.substring(startKey, i++);\n-            i = parseMapValue(buff, s, i, size);\n-            map.put(key, buff.toString());\n-            buff.setLength(0);\n-        }\n-        return map;\n+    while (start < end && bytes[end - 1] <= ' ') {\n+      end--;\n     }\n-\n-    /**\n-     * Parse a key-value pair list and checks its checksum.\n-     *\n-     * @param bytes encoded map\n-     * @return the map without mapping for {@code \"fletcher\"}, or {@code null} if checksum is wrong\n-     *              or parameter do not represent a properly formatted map serialization\n-     */\n-    static HashMap<String, String> parseChecksummedMap(byte[] bytes) {\n-        int start = 0, end = bytes.length;\n-        while (start < end && bytes[start] <= ' ') {\n-            start++;\n-        }\n-        while (start < end && bytes[end - 1] <= ' ') {\n-            end--;\n-        }\n-        String s = new String(bytes, start, end - start, StandardCharsets.ISO_8859_1);\n-        HashMap<String, String> map = new HashMap<>();\n-        StringBuilder buff = new StringBuilder();\n-        for (int i = 0, size = s.length(); i < size;) {\n-            int startKey = i;\n-            i = s.indexOf(':', i);\n-            if (i < 0) {\n-                // Corrupted map\n-                return null;\n-            }\n-            if (i - startKey == 8 && s.regionMatches(startKey, \"fletcher\", 0, 8)) {\n-                parseMapValue(buff, s, i + 1, size);\n-                int check = (int) Long.parseLong(buff.toString(), 16);\n-                if (check == getFletcher32(bytes, start, startKey - 1)) {\n-                    return map;\n-                }\n-                // Corrupted map\n-                return null;\n-            }\n-            String key = s.substring(startKey, i++);\n-            i = parseMapValue(buff, s, i, size);\n-            map.put(key, buff.toString());\n-            buff.setLength(0);\n+    String s =\n+        new String(bytes, start, end - start, StandardCharsets.ISO_8859_1);\n+    HashMap<String, String> map = new HashMap<>();\n+    StringBuilder buff = new StringBuilder();\n+    for (int i = 0, size = s.length(); i < size; ) {\n+      int startKey = i;\n+      i = s.indexOf(':', i);\n+      if (i < 0) {\n+        // Corrupted map\n+        return null;\n+      }\n+      if (i - startKey == 8 && s.regionMatches(startKey, \"fletcher\", 0, 8)) {\n+        parseMapValue(buff, s, i + 1, size);\n+        int check = (int) Long.parseLong(buff.toString(), 16);\n+        if (check == getFletcher32(bytes, start, startKey - 1)) {\n+          return map;\n         }\n         // Corrupted map\n         return null;\n+      }\n+      String key = s.substring(startKey, i++);\n+      i = parseMapValue(buff, s, i, size);\n+      map.put(key, buff.toString());\n+      buff.setLength(0);\n     }\n-\n-    /**\n-     * Parse a name from key-value pair list.\n-     *\n-     * @param s the list\n-     * @return value of name item, or {@code null}\n-     * @throws IllegalStateException if parsing failed\n-     */\n-    public static String getMapName(String s) {\n-        return getFromMap(s, \"name\");\n-    }\n-\n-    /**\n-     * Parse a specified pair from key-value pair list.\n-     *\n-     * @param s the list\n-     * @param key the name of the key\n-     * @return value of the specified item, or {@code null}\n-     * @throws IllegalStateException if parsing failed\n-     */\n-    public static String getFromMap(String s, String key) {\n-        int keyLength = key.length();\n-        for (int i = 0, size = s.length(); i < size;) {\n-            int startKey = i;\n-            i = s.indexOf(':', i);\n-            if (i < 0) {\n-                throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n-            }\n-            if (i++ - startKey == keyLength && s.regionMatches(startKey, key, 0, keyLength)) {\n-                StringBuilder buff = new StringBuilder();\n-                parseMapValue(buff, s, i, size);\n-                return buff.toString();\n-            } else {\n-                while (i < size) {\n-                    char c = s.charAt(i++);\n-                    if (c == ',') {\n-                        break;\n-                    } else if (c == '\\\"') {\n-                        while (i < size) {\n-                            c = s.charAt(i++);\n-                            if (c == '\\\\') {\n-                                if (i++ == size) {\n-                                    throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n-                                }\n-                            } else if (c == '\\\"') {\n-                                break;\n-                            }\n-                        }\n-                    }\n+    // Corrupted map\n+    return null;\n+  }\n+\n+  /**\n+   * Parse a name from key-value pair list.\n+   *\n+   * @param s the list\n+   * @return value of name item, or {@code null}\n+   * @throws IllegalStateException if parsing failed\n+   */\n+  public static String getMapName(String s) {\n+    return getFromMap(s, \"name\");\n+  }\n+\n+  /**\n+   * Parse a specified pair from key-value pair list.\n+   *\n+   * @param s   the list\n+   * @param key the name of the key\n+   * @return value of the specified item, or {@code null}\n+   * @throws IllegalStateException if parsing failed\n+   */\n+  public static String getFromMap(String s, String key) {\n+    int keyLength = key.length();\n+    for (int i = 0, size = s.length(); i < size; ) {\n+      int startKey = i;\n+      i = s.indexOf(':', i);\n+      if (i < 0) {\n+        throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Not a map: {0}\", s);\n+      }\n+      if (i++ - startKey == keyLength &&\n+          s.regionMatches(startKey, key, 0, keyLength)) {\n+        StringBuilder buff = new StringBuilder();\n+        parseMapValue(buff, s, i, size);\n+        return buff.toString();\n+      } else {\n+        while (i < size) {\n+          char c = s.charAt(i++);\n+          if (c == ',') {\n+            break;\n+          } else if (c == '\\\"') {\n+            while (i < size) {\n+              c = s.charAt(i++);\n+              if (c == '\\\\') {\n+                if (i++ == size) {\n+                  throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+                      \"Not a map: {0}\", s);\n                 }\n+              } else if (c == '\\\"') {\n+                break;\n+              }\n             }\n+          }\n         }\n-        return null;\n+      }\n     }\n-\n-    /**\n-     * Calculate the Fletcher32 checksum.\n-     *\n-     * @param bytes the bytes\n-     * @param offset initial offset\n-     * @param length the message length (if odd, 0 is appended)\n-     * @return the checksum\n-     */\n-    public static int getFletcher32(byte[] bytes, int offset, int length) {\n-        int s1 = 0xffff, s2 = 0xffff;\n-        int i = offset, len = offset + (length & ~1);\n-        while (i < len) {\n-            // reduce after 360 words (each word is two bytes)\n-            for (int end = Math.min(i + 720, len); i < end;) {\n-                int x = ((bytes[i++] & 0xff) << 8) | (bytes[i++] & 0xff);\n-                s2 += s1 += x;\n-            }\n-            s1 = (s1 & 0xffff) + (s1 >>> 16);\n-            s2 = (s2 & 0xffff) + (s2 >>> 16);\n-        }\n-        if ((length & 1) != 0) {\n-            // odd length: append 0\n-            int x = (bytes[i] & 0xff) << 8;\n-            s2 += s1 += x;\n-        }\n-        s1 = (s1 & 0xffff) + (s1 >>> 16);\n-        s2 = (s2 & 0xffff) + (s2 >>> 16);\n-        return (s2 << 16) | s1;\n+    return null;\n+  }\n+\n+  /**\n+   * Calculate the Fletcher32 checksum.\n+   *\n+   * @param bytes  the bytes\n+   * @param offset initial offset\n+   * @param length the message length (if odd, 0 is appended)\n+   * @return the checksum\n+   */\n+  public static int getFletcher32(byte[] bytes, int offset, int length) {\n+    int s1 = 0xffff, s2 = 0xffff;\n+    int i = offset, len = offset + (length & ~1);\n+    while (i < len) {\n+      // reduce after 360 words (each word is two bytes)\n+      for (int end = Math.min(i + 720, len); i < end; ) {\n+        int x = ((bytes[i++] & 0xff) << 8) | (bytes[i++] & 0xff);\n+        s2 += s1 += x;\n+      }\n+      s1 = (s1 & 0xffff) + (s1 >>> 16);\n+      s2 = (s2 & 0xffff) + (s2 >>> 16);\n     }\n-\n-    /**\n-     * Throw an IllegalArgumentException if the argument is invalid.\n-     *\n-     * @param test true if the argument is valid\n-     * @param message the message\n-     * @param arguments the arguments\n-     * @throws IllegalArgumentException if the argument is invalid\n-     */\n-    public static void checkArgument(boolean test, String message,\n-            Object... arguments) {\n-        if (!test) {\n-            throw newIllegalArgumentException(message, arguments);\n-        }\n+    if ((length & 1) != 0) {\n+      // odd length: append 0\n+      int x = (bytes[i] & 0xff) << 8;\n+      s2 += s1 += x;\n     }\n-\n-    /**\n-     * Create a new IllegalArgumentException.\n-     *\n-     * @param message the message\n-     * @param arguments the arguments\n-     * @return the exception\n-     */\n-    public static IllegalArgumentException newIllegalArgumentException(\n-            String message, Object... arguments) {\n-        return initCause(new IllegalArgumentException(\n-                formatMessage(0, message, arguments)),\n-                arguments);\n+    s1 = (s1 & 0xffff) + (s1 >>> 16);\n+    s2 = (s2 & 0xffff) + (s2 >>> 16);\n+    return (s2 << 16) | s1;\n+  }\n+\n+  /**\n+   * Throw an IllegalArgumentException if the argument is invalid.\n+   *\n+   * @param test      true if the argument is valid\n+   * @param message   the message\n+   * @param arguments the arguments\n+   * @throws IllegalArgumentException if the argument is invalid\n+   */\n+  public static void checkArgument(boolean test, String message,\n+                                   Object... arguments) {\n+    if (!test) {\n+      throw newIllegalArgumentException(message, arguments);\n     }\n-\n-    /**\n-     * Create a new UnsupportedOperationException.\n-     *\n-     * @param message the message\n-     * @return the exception\n-     */\n-    public static UnsupportedOperationException\n-            newUnsupportedOperationException(String message) {\n-        return new UnsupportedOperationException(formatMessage(0, message));\n+  }\n+\n+  /**\n+   * Create a new IllegalArgumentException.\n+   *\n+   * @param message   the message\n+   * @param arguments the arguments\n+   * @return the exception\n+   */\n+  public static IllegalArgumentException newIllegalArgumentException(\n+      String message, Object... arguments) {\n+    return initCause(new IllegalArgumentException(\n+            formatMessage(0, message, arguments)),\n+        arguments);\n+  }\n+\n+  /**\n+   * Create a new UnsupportedOperationException.\n+   *\n+   * @param message the message\n+   * @return the exception\n+   */\n+  public static UnsupportedOperationException\n+  newUnsupportedOperationException(String message) {\n+    return new UnsupportedOperationException(formatMessage(0, message));\n+  }\n+\n+  /**\n+   * Create a new IllegalStateException.\n+   *\n+   * @param errorCode the error code\n+   * @param message   the message\n+   * @param arguments the arguments\n+   * @return the exception\n+   */\n+  public static IllegalStateException newIllegalStateException(\n+      int errorCode, String message, Object... arguments) {\n+    return initCause(new IllegalStateException(\n+            formatMessage(errorCode, message, arguments)),\n+        arguments);\n+  }\n+\n+  private static <T extends Exception> T initCause(T e, Object... arguments) {\n+    int size = arguments.length;\n+    if (size > 0) {\n+      Object o = arguments[size - 1];\n+      if (o instanceof Throwable) {\n+        e.initCause((Throwable) o);\n+      }\n     }\n-\n-    /**\n-     * Create a new IllegalStateException.\n-     *\n-     * @param errorCode the error code\n-     * @param message the message\n-     * @param arguments the arguments\n-     * @return the exception\n-     */\n-    public static IllegalStateException newIllegalStateException(\n-            int errorCode, String message, Object... arguments) {\n-        return initCause(new IllegalStateException(\n-                formatMessage(errorCode, message, arguments)),\n-                arguments);\n-    }\n-\n-    private static <T extends Exception> T initCause(T e, Object... arguments) {\n-        int size = arguments.length;\n-        if (size > 0) {\n-            Object o = arguments[size - 1];\n-            if (o instanceof Throwable) {\n-                e.initCause((Throwable) o);\n-            }\n-        }\n-        return e;\n-    }\n-\n-    /**\n-     * Format an error message.\n-     *\n-     * @param errorCode the error code\n-     * @param message the message\n-     * @param arguments the arguments\n-     * @return the formatted message\n-     */\n-    public static String formatMessage(int errorCode, String message,\n-            Object... arguments) {\n-        // convert arguments to strings, to avoid locale specific formatting\n-        arguments = arguments.clone();\n-        for (int i = 0; i < arguments.length; i++) {\n-            Object a = arguments[i];\n-            if (!(a instanceof Exception)) {\n-                String s = a == null ? \"null\" : a.toString();\n-                if (s.length() > 1000) {\n-                    s = s.substring(0, 1000) + \"...\";\n-                }\n-                arguments[i] = s;\n-            }\n+    return e;\n+  }\n+\n+  /**\n+   * Format an error message.\n+   *\n+   * @param errorCode the error code\n+   * @param message   the message\n+   * @param arguments the arguments\n+   * @return the formatted message\n+   */\n+  public static String formatMessage(int errorCode, String message,\n+                                     Object... arguments) {\n+    // convert arguments to strings, to avoid locale specific formatting\n+    arguments = arguments.clone();\n+    for (int i = 0; i < arguments.length; i++) {\n+      Object a = arguments[i];\n+      if (!(a instanceof Exception)) {\n+        String s = a == null ? \"null\" : a.toString();\n+        if (s.length() > 1000) {\n+          s = s.substring(0, 1000) + \"...\";\n         }\n-        return MessageFormat.format(message, arguments) +\n-                \" [\" + Constants.VERSION_MAJOR + \".\" +\n-                Constants.VERSION_MINOR + \".\" + Constants.BUILD_ID +\n-                \"/\" + errorCode + \"]\";\n+        arguments[i] = s;\n+      }\n     }\n-\n-    /**\n-     * Get the error code from an exception message.\n-     *\n-     * @param m the message\n-     * @return the error code, or 0 if none\n-     */\n-    public static int getErrorCode(String m) {\n-        if (m != null && m.endsWith(\"]\")) {\n-            int dash = m.lastIndexOf('/');\n-            if (dash >= 0) {\n-                try {\n-                    return StringUtils.parseUInt31(m, dash + 1, m.length() - 1);\n-                } catch (NumberFormatException e) {\n-                    // no error code\n-                }\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Read a hex long value from a map.\n-     *\n-     * @param map the map\n-     * @param key the key\n-     * @param defaultValue if the value is null\n-     * @return the parsed value\n-     * @throws IllegalStateException if parsing fails\n-     */\n-    public static long readHexLong(Map<String, ?> map, String key, long defaultValue) {\n-        Object v = map.get(key);\n-        if (v == null) {\n-            return defaultValue;\n-        } else if (v instanceof Long) {\n-            return (Long) v;\n-        }\n+    return MessageFormat.format(message, arguments) +\n+        \" [\" + Constants.VERSION_MAJOR + \".\" +\n+        Constants.VERSION_MINOR + \".\" + Constants.BUILD_ID +\n+        \"/\" + errorCode + \"]\";\n+  }\n+\n+  /**\n+   * Get the error code from an exception message.\n+   *\n+   * @param m the message\n+   * @return the error code, or 0 if none\n+   */\n+  public static int getErrorCode(String m) {\n+    if (m != null && m.endsWith(\"]\")) {\n+      int dash = m.lastIndexOf('/');\n+      if (dash >= 0) {\n         try {\n-            return parseHexLong((String) v);\n+          return StringUtils.parseUInt31(m, dash + 1, m.length() - 1);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", v, e);\n+          // no error code\n         }\n+      }\n     }\n-\n-    /**\n-     * Parse an unsigned, hex long.\n-     *\n-     * @param x the string\n-     * @return the parsed value\n-     * @throws IllegalStateException if parsing fails\n-     */\n-    public static long parseHexLong(String x) {\n-        try {\n-            if (x.length() == 16) {\n-                // avoid problems with overflow\n-                // in Java 8, this special case is not needed\n-                return (Long.parseLong(x.substring(0, 8), 16) << 32) |\n-                        Long.parseLong(x.substring(8, 16), 16);\n-            }\n-            return Long.parseLong(x, 16);\n-        } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", x, e);\n-        }\n+    return 0;\n+  }\n+\n+  /**\n+   * Read a hex long value from a map.\n+   *\n+   * @param map          the map\n+   * @param key          the key\n+   * @param defaultValue if the value is null\n+   * @return the parsed value\n+   * @throws IllegalStateException if parsing fails\n+   */\n+  public static long readHexLong(Map<String, ?> map, String key,\n+                                 long defaultValue) {\n+    Object v = map.get(key);\n+    if (v == null) {\n+      return defaultValue;\n+    } else if (v instanceof Long) {\n+      return (Long) v;\n     }\n-\n-    /**\n-     * Parse an unsigned, hex long.\n-     *\n-     * @param x the string\n-     * @return the parsed value\n-     * @throws IllegalStateException if parsing fails\n-     */\n-    public static int parseHexInt(String x) {\n-        try {\n-            // avoid problems with overflow\n-            // in Java 8, we can use Integer.parseLong(x, 16);\n-            return (int) Long.parseLong(x, 16);\n-        } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", x, e);\n-        }\n+    try {\n+      return parseHexLong((String) v);\n+    } catch (NumberFormatException e) {\n+      throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+          \"Error parsing the value {0}\", v, e);\n     }\n-\n-    /**\n-     * Read a hex int value from a map.\n-     *\n-     * @param map the map\n-     * @param key the key\n-     * @param defaultValue if the value is null\n-     * @return the parsed value\n-     * @throws IllegalStateException if parsing fails\n-     */\n-    public static int readHexInt(Map<String, ?> map, String key, int defaultValue) {\n-        Object v = map.get(key);\n-        if (v == null) {\n-            return defaultValue;\n-        } else if (v instanceof Integer) {\n-            return (Integer) v;\n-        }\n-        try {\n-            // support unsigned hex value\n-            return (int) Long.parseLong((String) v, 16);\n-        } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", v, e);\n-        }\n+  }\n+\n+  /**\n+   * Parse an unsigned, hex long.\n+   *\n+   * @param x the string\n+   * @return the parsed value\n+   * @throws IllegalStateException if parsing fails\n+   */\n+  public static long parseHexLong(String x) {\n+    try {\n+      if (x.length() == 16) {\n+        // avoid problems with overflow\n+        // in Java 8, this special case is not needed\n+        return (Long.parseLong(x.substring(0, 8), 16) << 32) |\n+            Long.parseLong(x.substring(8, 16), 16);\n+      }\n+      return Long.parseLong(x, 16);\n+    } catch (NumberFormatException e) {\n+      throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+          \"Error parsing the value {0}\", x, e);\n     }\n-\n-    public static byte[] parseHexBytes(Map<String, ?> map, String key) {\n-        Object v = map.get(key);\n-        if (v == null) {\n-            return null;\n-        }\n-        return StringUtils.convertHexToBytes((String)v);\n+  }\n+\n+  /**\n+   * Parse an unsigned, hex long.\n+   *\n+   * @param x the string\n+   * @return the parsed value\n+   * @throws IllegalStateException if parsing fails\n+   */\n+  public static int parseHexInt(String x) {\n+    try {\n+      // avoid problems with overflow\n+      // in Java 8, we can use Integer.parseLong(x, 16);\n+      return (int) Long.parseLong(x, 16);\n+    } catch (NumberFormatException e) {\n+      throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+          \"Error parsing the value {0}\", x, e);\n+    }\n+  }\n+\n+  /**\n+   * Read a hex int value from a map.\n+   *\n+   * @param map          the map\n+   * @param key          the key\n+   * @param defaultValue if the value is null\n+   * @return the parsed value\n+   * @throws IllegalStateException if parsing fails\n+   */\n+  public static int readHexInt(Map<String, ?> map, String key,\n+                               int defaultValue) {\n+    Object v = map.get(key);\n+    if (v == null) {\n+      return defaultValue;\n+    } else if (v instanceof Integer) {\n+      return (Integer) v;\n     }\n+    try {\n+      // support unsigned hex value\n+      return (int) Long.parseLong((String) v, 16);\n+    } catch (NumberFormatException e) {\n+      throw newIllegalStateException(ERROR_FILE_CORRUPT,\n+          \"Error parsing the value {0}\", v, e);\n+    }\n+  }\n \n-    /**\n-     * Get the configuration parameter value, or default.\n-     *\n-     * @param config the configuration\n-     * @param key the key\n-     * @param defaultValue the default\n-     * @return the configured value or default\n-     */\n-    public static int getConfigParam(Map<String, ?> config, String key, int defaultValue) {\n-        Object o = config.get(key);\n-        if (o instanceof Number) {\n-            return ((Number) o).intValue();\n-        } else if (o != null) {\n-            try {\n-                return Integer.decode(o.toString());\n-            } catch (NumberFormatException e) {\n-                // ignore\n-            }\n-        }\n-        return defaultValue;\n+  public static byte[] parseHexBytes(Map<String, ?> map, String key) {\n+    Object v = map.get(key);\n+    if (v == null) {\n+      return null;\n+    }\n+    return StringUtils.convertHexToBytes((String) v);\n+  }\n+\n+  /**\n+   * Get the configuration parameter value, or default.\n+   *\n+   * @param config       the configuration\n+   * @param key          the key\n+   * @param defaultValue the default\n+   * @return the configured value or default\n+   */\n+  public static int getConfigParam(Map<String, ?> config, String key,\n+                                   int defaultValue) {\n+    Object o = config.get(key);\n+    if (o instanceof Number) {\n+      return ((Number) o).intValue();\n+    } else if (o != null) {\n+      try {\n+        return Integer.decode(o.toString());\n+      } catch (NumberFormatException e) {\n+        // ignore\n+      }\n     }\n+    return defaultValue;\n+  }\n \n }\n",
            "diff_size": 1472
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1157",
                    "column": "53",
                    "severity": "warning",
                    "message": "'typecast' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/489/DataUtils.java\nindex 5479b048de..60305e05e6 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/489/DataUtils.java\n@@ -1179,4 +1179,4 @@ public final class DataUtils {\n         return defaultValue;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/489/DataUtils.java\nindex 5479b048de..2613cc4eca 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/489/DataUtils.java\n@@ -15,154 +15,209 @@ import java.text.MessageFormat;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n-\n import org.h2.engine.Constants;\n import org.h2.util.StringUtils;\n \n /**\n  * Utility methods\n  */\n+\n+\n public final class DataUtils {\n \n     /**\n      * An error occurred while reading from the file.\n      */\n+\n+\n     public static final int ERROR_READING_FAILED = 1;\n \n     /**\n      * An error occurred when trying to write to the file.\n      */\n+\n+\n     public static final int ERROR_WRITING_FAILED = 2;\n \n     /**\n      * An internal error occurred. This could be a bug, or a memory corruption\n      * (for example caused by out of memory).\n      */\n+\n+\n     public static final int ERROR_INTERNAL = 3;\n \n     /**\n      * The object is already closed.\n      */\n+\n+\n     public static final int ERROR_CLOSED = 4;\n \n     /**\n      * The file format is not supported.\n      */\n+\n+\n     public static final int ERROR_UNSUPPORTED_FORMAT = 5;\n \n     /**\n      * The file is corrupt or (for encrypted files) the encryption key is wrong.\n      */\n+\n+\n     public static final int ERROR_FILE_CORRUPT = 6;\n \n     /**\n      * The file is locked.\n      */\n+\n+\n     public static final int ERROR_FILE_LOCKED = 7;\n \n     /**\n      * An error occurred when serializing or de-serializing.\n      */\n+\n+\n     public static final int ERROR_SERIALIZATION = 8;\n \n     /**\n      * The application was trying to read data from a chunk that is no longer\n      * available.\n      */\n+\n+\n     public static final int ERROR_CHUNK_NOT_FOUND = 9;\n \n     /**\n      * The block in the stream store was not found.\n      */\n+\n+\n     public static final int ERROR_BLOCK_NOT_FOUND = 50;\n \n     /**\n      * The transaction store is corrupt.\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_CORRUPT = 100;\n \n     /**\n      * An entry is still locked by another transaction.\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_LOCKED = 101;\n \n     /**\n      * There are too many open transactions.\n      */\n+\n+\n     public static final int ERROR_TOO_MANY_OPEN_TRANSACTIONS = 102;\n \n     /**\n      * The transaction store is in an illegal state (for example, not yet\n      * initialized).\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_ILLEGAL_STATE = 103;\n \n     /**\n      * The transaction contains too many changes.\n      */\n+\n+\n     public static final int ERROR_TRANSACTION_TOO_BIG = 104;\n \n     /**\n      * Deadlock discovered and one of transactions involved chosen as victim and rolled back.\n      */\n+\n+\n     public static final int ERROR_TRANSACTIONS_DEADLOCK = 105;\n \n     /**\n      * The transaction store can not be initialized because data type\n      * is not found in type registry.\n      */\n+\n+\n     public static final int ERROR_UNKNOWN_DATA_TYPE = 106;\n \n     /**\n      * The type for leaf page.\n      */\n+\n+\n     public static final int PAGE_TYPE_LEAF = 0;\n \n     /**\n      * The type for node page.\n      */\n+\n+\n     public static final int PAGE_TYPE_NODE = 1;\n \n     /**\n      * The bit mask for compressed pages (compression level fast).\n      */\n+\n+\n     public static final int PAGE_COMPRESSED = 2;\n \n     /**\n      * The bit mask for compressed pages (compression level high).\n      */\n+\n+\n     public static final int PAGE_COMPRESSED_HIGH = 2 + 4;\n \n     /**\n      * The bit mask for pages with page sequential number.\n      */\n+\n+\n     public static final int PAGE_HAS_PAGE_NO = 8;\n \n     /**\n      * The maximum length of a variable size int.\n      */\n+\n+\n     public static final int MAX_VAR_INT_LEN = 5;\n \n     /**\n      * The maximum length of a variable size long.\n      */\n+\n+\n     public static final int MAX_VAR_LONG_LEN = 10;\n \n     /**\n      * The maximum integer that needs less space when using variable size\n      * encoding (only 3 bytes instead of 4).\n      */\n+\n+\n     public static final int COMPRESSED_VAR_INT_MAX = 0x1fffff;\n \n     /**\n      * The maximum long that needs less space when using variable size\n      * encoding (only 7 bytes instead of 8).\n      */\n+\n+\n     public static final long COMPRESSED_VAR_LONG_MAX = 0x1ffffffffffffL;\n \n     /**\n      * The marker size of a very large page.\n      */\n+\n+\n     public static final int PAGE_LARGE = 2 * 1024 * 1024;\n \n     // The following are key prefixes used in meta map\n@@ -171,24 +226,32 @@ public final class DataUtils {\n      * The prefix for chunks (\"chunk.\"). This, plus the chunk id (hex encoded)\n      * is the key, and the serialized chunk metadata is the value.\n      */\n+\n+\n     public static final String META_CHUNK = \"chunk.\";\n \n     /**\n      * The prefix for names (\"name.\"). This, plus the name of the map, is the\n      * key, and the map id (hex encoded) is the value.\n      */\n+\n+\n     public static final String META_NAME = \"name.\";\n \n     /**\n      * The prefix for maps (\"map.\"). This, plus the map id (hex encoded) is the\n      * key, and the serialized in the map metadata is the value.\n      */\n+\n+\n     public static final String META_MAP = \"map.\";\n \n     /**\n      * The prefix for root positions of maps (\"root.\"). This, plus the map id\n      * (hex encoded) is the key, and the position (hex encoded) is the value.\n      */\n+\n+\n     public static final String META_ROOT = \"root.\";\n \n     /**\n@@ -197,16 +260,18 @@ public final class DataUtils {\n      * @param x the value\n      * @return the length in bytes\n      */\n+\n+\n     public static int getVarIntLen(int x) {\n         if ((x & (-1 << 7)) == 0) {\n             return 1;\n         } else if ((x & (-1 << 14)) == 0) {\n-            return 2;\n+        return 2;\n         } else if ((x & (-1 << 21)) == 0) {\n-            return 3;\n-        } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n+                                              return 3;\n+               } else if ((x & (-1 << 28)) == 0) {\n+                   return 4;\n+               }\n         return 5;\n     }\n \n@@ -216,6 +281,8 @@ public final class DataUtils {\n      * @param x the value\n      * @return the length in bytes\n      */\n+\n+\n     public static int getVarLongLen(long x) {\n         int i = 1;\n         while (true) {\n@@ -233,6 +300,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @return the value\n      */\n+\n+\n     public static int readVarInt(ByteBuffer buff) {\n         int b = buff.get();\n         if (b >= 0) {\n@@ -268,6 +337,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @return the value\n      */\n+\n+\n     public static long readVarLong(ByteBuffer buff) {\n         long x = buff.get();\n         if (x >= 0) {\n@@ -291,6 +362,8 @@ public final class DataUtils {\n      * @param x the value\n      * @throws IOException if some data could not be written\n      */\n+\n+\n     public static void writeVarInt(OutputStream out, int x) throws IOException {\n         while ((x & ~0x7f) != 0) {\n             out.write((byte) (x | 0x80));\n@@ -305,6 +378,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @param x the value\n      */\n+\n+\n     public static void writeVarInt(ByteBuffer buff, int x) {\n         while ((x & ~0x7f) != 0) {\n             buff.put((byte) (x | 0x80));\n@@ -320,8 +395,9 @@ public final class DataUtils {\n      * @param s the string\n      * @param len the number of characters\n      */\n-    public static void writeStringData(ByteBuffer buff,\n-            String s, int len) {\n+\n+\n+    public static void writeStringData(ByteBuffer buff, String s, int len) {\n         for (int i = 0; i < len; i++) {\n             int c = s.charAt(i);\n             if (c < 0x80) {\n@@ -343,6 +419,8 @@ public final class DataUtils {\n      * @param buff the source buffer\n      * @return the value\n      */\n+\n+\n     public static String readString(ByteBuffer buff) {\n         return readString(buff, readVarInt(buff));\n     }\n@@ -354,6 +432,8 @@ public final class DataUtils {\n      * @param len the number of characters\n      * @return the value\n      */\n+\n+\n     public static String readString(ByteBuffer buff, int len) {\n         char[] chars = new char[len];\n         for (int i = 0; i < len; i++) {\n@@ -361,8 +441,7 @@ public final class DataUtils {\n             if (x < 0x80) {\n                 chars[i] = (char) x;\n             } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12)\n-                        + ((buff.get() & 0x3f) << 6) + (buff.get() & 0x3f));\n+                chars[i] = (char) (((x & 0xf) << 12) + ((buff.get() & 0x3f) << 6) + (buff.get() & 0x3f));\n             } else {\n                 chars[i] = (char) (((x & 0x1f) << 6) + (buff.get() & 0x3f));\n             }\n@@ -376,6 +455,8 @@ public final class DataUtils {\n      * @param buff the target buffer\n      * @param x the value\n      */\n+\n+\n     public static void writeVarLong(ByteBuffer buff, long x) {\n         while ((x & ~0x7f) != 0) {\n             buff.put((byte) (x | 0x80));\n@@ -391,8 +472,9 @@ public final class DataUtils {\n      * @param x the value\n      * @throws IOException if some data could not be written\n      */\n-    public static void writeVarLong(OutputStream out, long x)\n-            throws IOException {\n+\n+\n+    public static void writeVarLong(OutputStream out, long x) throws IOException {\n         while ((x & ~0x7f) != 0) {\n             out.write((byte) (x | 0x80));\n             x >>>= 7;\n@@ -408,14 +490,14 @@ public final class DataUtils {\n      * @param oldSize the size of the old array\n      * @param gapIndex the index of the gap\n      */\n-    public static void copyWithGap(Object src, Object dst, int oldSize,\n-            int gapIndex) {\n+\n+\n+    public static void copyWithGap(Object src, Object dst, int oldSize, int gapIndex) {\n         if (gapIndex > 0) {\n             System.arraycopy(src, 0, dst, 0, gapIndex);\n         }\n         if (gapIndex < oldSize) {\n-            System.arraycopy(src, gapIndex, dst, gapIndex + 1, oldSize\n-                    - gapIndex);\n+            System.arraycopy(src, gapIndex, dst, gapIndex + 1, oldSize - gapIndex);\n         }\n     }\n \n@@ -427,14 +509,14 @@ public final class DataUtils {\n      * @param oldSize the size of the old array\n      * @param removeIndex the index of the entry to remove\n      */\n-    public static void copyExcept(Object src, Object dst, int oldSize,\n-            int removeIndex) {\n+\n+\n+    public static void copyExcept(Object src, Object dst, int oldSize, int removeIndex) {\n         if (removeIndex > 0 && oldSize > 0) {\n             System.arraycopy(src, 0, dst, 0, removeIndex);\n         }\n         if (removeIndex < oldSize) {\n-            System.arraycopy(src, removeIndex + 1, dst, removeIndex, oldSize\n-                    - removeIndex - 1);\n+            System.arraycopy(src, removeIndex + 1, dst, removeIndex, oldSize - removeIndex - 1);\n         }\n     }\n \n@@ -447,6 +529,8 @@ public final class DataUtils {\n      * @param dst the byte buffer\n      * @throws IllegalStateException if some data could not be read\n      */\n+\n+\n     public static void readFully(FileChannel file, long pos, ByteBuffer dst) {\n         try {\n             do {\n@@ -464,11 +548,7 @@ public final class DataUtils {\n             } catch (IOException e2) {\n                 size = -1;\n             }\n-            throw newIllegalStateException(\n-                    ERROR_READING_FAILED,\n-                    \"Reading from file {0} failed at {1} (length {2}), \" +\n-                    \"read {3}, remaining {4}\",\n-                    file, pos, size, dst.position(), dst.remaining(), e);\n+            throw newIllegalStateException(ERROR_READING_FAILED, \"Reading from file {0} failed at {1} (length {2}), \" + \"read {3}, remaining {4}\", file, pos, size, dst.position(), dst.remaining(), e);\n         }\n     }\n \n@@ -479,6 +559,8 @@ public final class DataUtils {\n      * @param pos the absolute position within the file\n      * @param src the source buffer\n      */\n+\n+\n     public static void writeFully(FileChannel file, long pos, ByteBuffer src) {\n         try {\n             int off = 0;\n@@ -487,10 +569,7 @@ public final class DataUtils {\n                 off += len;\n             } while (src.remaining() > 0);\n         } catch (IOException e) {\n-            throw newIllegalStateException(\n-                    ERROR_WRITING_FAILED,\n-                    \"Writing to {0} failed; length {1} at {2}\",\n-                    file, src.remaining(), pos, e);\n+            throw newIllegalStateException(ERROR_WRITING_FAILED, \"Writing to {0} failed; length {1} at {2}\", file, src.remaining(), pos, e);\n         }\n     }\n \n@@ -500,6 +579,8 @@ public final class DataUtils {\n      * @param len the length\n      * @return the length code\n      */\n+\n+\n     public static int encodeLength(int len) {\n         if (len <= 32) {\n             return 0;\n@@ -533,6 +614,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return the chunk id\n      */\n+\n+\n     public static int getPageChunkId(long pos) {\n         return (int) (pos >>> 38);\n     }\n@@ -543,6 +626,8 @@ public final class DataUtils {\n      * @param tocElement packed table of content element\n      * @return the map id\n      */\n+\n+\n     public static int getPageMapId(long tocElement) {\n         return (int) (tocElement >>> 38);\n     }\n@@ -553,6 +638,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return the maximum length\n      */\n+\n+\n     public static int getPageMaxLength(long pos) {\n         int code = (int) ((pos >> 1) & 31);\n         return decodePageLength(code);\n@@ -565,6 +652,8 @@ public final class DataUtils {\n      * @param code encoded page length\n      * @return the maximum length\n      */\n+\n+\n     public static int decodePageLength(int code) {\n         if (code == 31) {\n             return PAGE_LARGE;\n@@ -578,6 +667,8 @@ public final class DataUtils {\n      * @param tocElement packed table of content element\n      * @return the offset\n      */\n+\n+\n     public static int getPageOffset(long tocElement) {\n         return (int) (tocElement >> 6);\n     }\n@@ -588,6 +679,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return the page type (PAGE_TYPE_NODE or PAGE_TYPE_LEAF)\n      */\n+\n+\n     public static int getPageType(long pos) {\n         return ((int) pos) & 1;\n     }\n@@ -597,6 +690,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return true if it is a leaf, false otherwise\n      */\n+\n+\n     public static boolean isLeafPosition(long pos) {\n         return getPageType(pos) == PAGE_TYPE_LEAF;\n     }\n@@ -607,6 +702,8 @@ public final class DataUtils {\n      * @param pos the position\n      * @return true if page has been saved\n      */\n+\n+\n     public static boolean isPageSaved(long pos) {\n         return (pos & ~1L) != 0;\n     }\n@@ -618,6 +715,8 @@ public final class DataUtils {\n      * @return true if page has been removed (no longer accessible from the\n      *         current root of the tree)\n      */\n+\n+\n     static boolean isPageRemoved(long pos) {\n         return pos == 1L;\n     }\n@@ -633,6 +732,8 @@ public final class DataUtils {\n      * @param type the page type (1 for node, 0 for leaf)\n      * @return the position\n      */\n+\n+\n     public static long getPagePos(int chunkId, int offset, int length, int type) {\n         long pos = (long) chunkId << 38;\n         pos |= (long) offset << 6;\n@@ -647,6 +748,8 @@ public final class DataUtils {\n      * @param tocElement\n      * @return\n      */\n+\n+\n     public static long getPagePos(int chunkId, long tocElement) {\n         return (tocElement & 0x3FFFFFFFFFL) | ((long) chunkId << 38);\n     }\n@@ -662,6 +765,8 @@ public final class DataUtils {\n      * @param type the page type (1 for node, 0 for leaf)\n      * @return the position\n      */\n+\n+\n     public static long getTocElement(int mapId, int offset, int length, int type) {\n         long pos = (long) mapId << 38;\n         pos |= (long) offset << 6;\n@@ -678,6 +783,8 @@ public final class DataUtils {\n      * @param x the value\n      * @return the check value\n      */\n+\n+\n     public static short getCheckValue(int x) {\n         return (short) ((x >> 16) ^ x);\n     }\n@@ -689,6 +796,8 @@ public final class DataUtils {\n      * @param map the map\n      * @return the string builder\n      */\n+\n+\n     public static StringBuilder appendMap(StringBuilder buff, HashMap<String, ?> map) {\n         Object[] keys = map.keySet().toArray();\n         Arrays.sort(keys);\n@@ -722,6 +831,8 @@ public final class DataUtils {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public static void appendMap(StringBuilder buff, String key, String value) {\n         appendMapKey(buff, key);\n         if (value.indexOf(',') < 0 && value.indexOf('\\\"') < 0) {\n@@ -747,6 +858,8 @@ public final class DataUtils {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public static void appendMap(StringBuilder buff, String key, long value) {\n         appendMapKey(buff, key).append(Long.toHexString(value));\n     }\n@@ -759,6 +872,8 @@ public final class DataUtils {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public static void appendMap(StringBuilder buff, String key, int value) {\n         appendMapKey(buff, key).append(Integer.toHexString(value));\n     }\n@@ -770,6 +885,7 @@ public final class DataUtils {\n      * @param size stop offset (exclusive)\n      * @return new offset\n      */\n+\n     private static int parseMapValue(StringBuilder buff, String s, int i, int size) {\n         while (i < size) {\n             char c = s.charAt(i++);\n@@ -802,8 +918,10 @@ public final class DataUtils {\n      * @return the map\n      * @throws IllegalStateException if parsing failed\n      */\n+\n+\n     public static HashMap<String, String> parseMap(String s) {\n-        HashMap<String, String> map = new HashMap<>();\n+        HashMap<String, String> map = new HashMap< >();\n         StringBuilder buff = new StringBuilder();\n         for (int i = 0, size = s.length(); i < size;) {\n             int startKey = i;\n@@ -826,6 +944,8 @@ public final class DataUtils {\n      * @return the map without mapping for {@code \"fletcher\"}, or {@code null} if checksum is wrong\n      *              or parameter do not represent a properly formatted map serialization\n      */\n+\n+\n     static HashMap<String, String> parseChecksummedMap(byte[] bytes) {\n         int start = 0, end = bytes.length;\n         while (start < end && bytes[start] <= ' ') {\n@@ -835,7 +955,7 @@ public final class DataUtils {\n             end--;\n         }\n         String s = new String(bytes, start, end - start, StandardCharsets.ISO_8859_1);\n-        HashMap<String, String> map = new HashMap<>();\n+        HashMap<String, String> map = new HashMap< >();\n         StringBuilder buff = new StringBuilder();\n         for (int i = 0, size = s.length(); i < size;) {\n             int startKey = i;\n@@ -869,6 +989,8 @@ public final class DataUtils {\n      * @return value of name item, or {@code null}\n      * @throws IllegalStateException if parsing failed\n      */\n+\n+\n     public static String getMapName(String s) {\n         return getFromMap(s, \"name\");\n     }\n@@ -881,6 +1003,8 @@ public final class DataUtils {\n      * @return value of the specified item, or {@code null}\n      * @throws IllegalStateException if parsing failed\n      */\n+\n+\n     public static String getFromMap(String s, String key) {\n         int keyLength = key.length();\n         for (int i = 0, size = s.length(); i < size;) {\n@@ -924,6 +1048,8 @@ public final class DataUtils {\n      * @param length the message length (if odd, 0 is appended)\n      * @return the checksum\n      */\n+\n+\n     public static int getFletcher32(byte[] bytes, int offset, int length) {\n         int s1 = 0xffff, s2 = 0xffff;\n         int i = offset, len = offset + (length & ~1);\n@@ -954,8 +1080,9 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @throws IllegalArgumentException if the argument is invalid\n      */\n-    public static void checkArgument(boolean test, String message,\n-            Object... arguments) {\n+\n+\n+    public static void checkArgument(boolean test, String message, Object... arguments) {\n         if (!test) {\n             throw newIllegalArgumentException(message, arguments);\n         }\n@@ -968,10 +1095,11 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @return the exception\n      */\n-    public static IllegalArgumentException newIllegalArgumentException(\n-            String message, Object... arguments) {\n-        return initCause(new IllegalArgumentException(\n-                formatMessage(0, message, arguments)),\n+\n+\n+    public static IllegalArgumentException newIllegalArgumentException(String message, Object... arguments) {\n+        return initCause(\n+            new IllegalArgumentException(formatMessage(0, message, arguments)),\n                 arguments);\n     }\n \n@@ -981,8 +1109,9 @@ public final class DataUtils {\n      * @param message the message\n      * @return the exception\n      */\n-    public static UnsupportedOperationException\n-            newUnsupportedOperationException(String message) {\n+\n+\n+    public static UnsupportedOperationException newUnsupportedOperationException(String message) {\n         return new UnsupportedOperationException(formatMessage(0, message));\n     }\n \n@@ -994,11 +1123,10 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @return the exception\n      */\n-    public static IllegalStateException newIllegalStateException(\n-            int errorCode, String message, Object... arguments) {\n-        return initCause(new IllegalStateException(\n-                formatMessage(errorCode, message, arguments)),\n-                arguments);\n+\n+\n+    public static IllegalStateException newIllegalStateException(int errorCode, String message, Object... arguments) {\n+        return initCause(new IllegalStateException(formatMessage(errorCode, message, arguments)), arguments);\n     }\n \n     private static <T extends Exception> T initCause(T e, Object... arguments) {\n@@ -1020,8 +1148,9 @@ public final class DataUtils {\n      * @param arguments the arguments\n      * @return the formatted message\n      */\n-    public static String formatMessage(int errorCode, String message,\n-            Object... arguments) {\n+\n+\n+    public static String formatMessage(int errorCode, String message, Object... arguments) {\n         // convert arguments to strings, to avoid locale specific formatting\n         arguments = arguments.clone();\n         for (int i = 0; i < arguments.length; i++) {\n@@ -1034,10 +1163,11 @@ public final class DataUtils {\n                 arguments[i] = s;\n             }\n         }\n-        return MessageFormat.format(message, arguments) +\n-                \" [\" + Constants.VERSION_MAJOR + \".\" +\n-                Constants.VERSION_MINOR + \".\" + Constants.BUILD_ID +\n-                \"/\" + errorCode + \"]\";\n+        return MessageFormat.format(message, arguments) + \" [\"\n+        + Constants.VERSION_MAJOR + \".\"\n+        + Constants.VERSION_MINOR + \".\"\n+        + Constants.BUILD_ID + \"/\"\n+        + errorCode + \"]\";\n     }\n \n     /**\n@@ -1046,6 +1176,8 @@ public final class DataUtils {\n      * @param m the message\n      * @return the error code, or 0 if none\n      */\n+\n+\n     public static int getErrorCode(String m) {\n         if (m != null && m.endsWith(\"]\")) {\n             int dash = m.lastIndexOf('/');\n@@ -1054,6 +1186,7 @@ public final class DataUtils {\n                     return StringUtils.parseUInt31(m, dash + 1, m.length() - 1);\n                 } catch (NumberFormatException e) {\n                     // no error code\n+\n                 }\n             }\n         }\n@@ -1069,6 +1202,8 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static long readHexLong(Map<String, ?> map, String key, long defaultValue) {\n         Object v = map.get(key);\n         if (v == null) {\n@@ -1079,8 +1214,7 @@ public final class DataUtils {\n         try {\n             return parseHexLong((String) v);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", v, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", v, e);\n         }\n     }\n \n@@ -1091,18 +1225,18 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static long parseHexLong(String x) {\n         try {\n             if (x.length() == 16) {\n                 // avoid problems with overflow\n                 // in Java 8, this special case is not needed\n-                return (Long.parseLong(x.substring(0, 8), 16) << 32) |\n-                        Long.parseLong(x.substring(8, 16), 16);\n+                return (Long.parseLong(x.substring(0, 8), 16) << 32) | Long.parseLong(x.substring(8, 16), 16);\n             }\n             return Long.parseLong(x, 16);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", x, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", x, e);\n         }\n     }\n \n@@ -1113,14 +1247,15 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static int parseHexInt(String x) {\n         try {\n             // avoid problems with overflow\n             // in Java 8, we can use Integer.parseLong(x, 16);\n             return (int) Long.parseLong(x, 16);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", x, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", x, e);\n         }\n     }\n \n@@ -1133,6 +1268,8 @@ public final class DataUtils {\n      * @return the parsed value\n      * @throws IllegalStateException if parsing fails\n      */\n+\n+\n     public static int readHexInt(Map<String, ?> map, String key, int defaultValue) {\n         Object v = map.get(key);\n         if (v == null) {\n@@ -1144,17 +1281,17 @@ public final class DataUtils {\n             // support unsigned hex value\n             return (int) Long.parseLong((String) v, 16);\n         } catch (NumberFormatException e) {\n-            throw newIllegalStateException(ERROR_FILE_CORRUPT,\n-                    \"Error parsing the value {0}\", v, e);\n+            throw newIllegalStateException(ERROR_FILE_CORRUPT, \"Error parsing the value {0}\", v, e);\n         }\n     }\n \n+\n     public static byte[] parseHexBytes(Map<String, ?> map, String key) {\n         Object v = map.get(key);\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n@@ -1165,6 +1302,8 @@ public final class DataUtils {\n      * @param defaultValue the default\n      * @return the configured value or default\n      */\n+\n+\n     public static int getConfigParam(Map<String, ?> config, String key, int defaultValue) {\n         Object o = config.get(key);\n         if (o instanceof Number) {\n@@ -1174,9 +1313,10 @@ public final class DataUtils {\n                 return Integer.decode(o.toString());\n             } catch (NumberFormatException e) {\n                 // ignore\n+\n             }\n         }\n         return defaultValue;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 219
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/489/DataUtils.java\nindex 5479b048de..f0086075c3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/489/DataUtils.java\n@@ -1154,7 +1154,7 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/489/DataUtils.java\nindex 5479b048de..f0086075c3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/489/DataUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/489/DataUtils.java\n@@ -1154,7 +1154,7 @@ public final class DataUtils {\n         if (v == null) {\n             return null;\n         }\n-        return StringUtils.convertHexToBytes((String)v);\n+        return StringUtils.convertHexToBytes((String) v);\n     }\n \n     /**\n",
            "diff_size": 1
        }
    ]
}