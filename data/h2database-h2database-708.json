{
    "error_id": "708",
    "information": {
        "errors": [
            {
                "line": "315",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                    dataType = r;\n                    return this;\n                } else { // DATE, TIMESTAMP\n                    dataType = Value.TIMESTAMP;\n                    return this;\n                }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "315",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/708/Operation.java\nindex 8281ba1a12..c585fa1959 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/708/Operation.java\n@@ -312,164 +312,164 @@ public class Operation extends Expression {\n                 if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n                     dataType = r;\n                     return this;\n-                } else { // DATE, TIMESTAMP\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                        } else { // DATE, TIMESTAMPdataType=\n+                        Value.TIMESTAMP;\n+                 return this;\n+             }\n+         }\n+         break;\n+     case MINUS:\n+         switch (l) {\n+         case Value.DATE:\n+         case Value.TIMESTAMP:\n+         case Value.TIMESTAMP_TZ:\n+             switch (r) {\n+             case Value.INT: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.DECIMAL:\n+             case Value.FLOAT:\n+             case Value.DOUBLE: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+                 right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                         .get(60 * 60 * 24)), right);\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.TIME:\n+                 dataType = Value.TIMESTAMP;\n+                 return this;\n+             case Value.DATE:\n+             case Value.TIMESTAMP:\n+             case Value.TIMESTAMP_TZ:\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         case Value.TIME:\n+             if (r == Value.TIME) {\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         }\n+         break;\n+     case MULTIPLY:\n+         if (l == Value.TIME) {\n+             dataType = Value.TIME;\n+             convertRight = false;\n+             return this;\n+         } else if (r == Value.TIME) {\n+             swap();\n+             dataType = Value.TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     case DIVIDE:\n+         if (l == Value.TIME) {\n+             dataType = Value.TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     default:\n+     }\n+     throw getUnsupported(l, r);\n+ }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+ private DbException getUnsupported(int l, int r) {\n+     return DbException.getUnsupportedException(\n+             DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+ }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+ private void swap() {\n+     Expression temp = left;\n+     left = right;\n+     right = temp;\n+ }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+ @Override\n+ public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+     left.setEvaluatable(tableFilter, b);\n+     right.setEvaluatable(tableFilter, b);\n+ }\n \n-    @Override\n-    public int getType() {\n-        return dataType;\n-    }\n+ @Override\n+ public int getType() {\n+     return dataType;\n+ }\n \n-    @Override\n-    public long getPrecision() {\n-        switch (opType) {\n-        case CONCAT:\n-            return left.getPrecision() + right.getPrecision();\n-        default:\n-            return Math.max(left.getPrecision(), right.getPrecision());\n-        }\n-    }\n+ @Override\n+ public long getPrecision() {\n+     switch (opType) {\n+     case CONCAT:\n+         return left.getPrecision() + right.getPrecision();\n+     default:\n+         return Math.max(left.getPrecision(), right.getPrecision());\n+     }\n+ }\n \n-    @Override\n-    public int getDisplaySize() {\n-        switch (opType) {\n-        case CONCAT:\n-            return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n-                    (long) right.getDisplaySize());\n-        default:\n-            return Math.max(left.getDisplaySize(), right.getDisplaySize());\n-        }\n-    }\n+ @Override\n+ public int getDisplaySize() {\n+     switch (opType) {\n+     case CONCAT:\n+         return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n+                 (long) right.getDisplaySize());\n+     default:\n+         return Math.max(left.getDisplaySize(), right.getDisplaySize());\n+     }\n+ }\n \n-    @Override\n-    public int getScale() {\n-        return Math.max(left.getScale(), right.getScale());\n-    }\n+ @Override\n+ public int getScale() {\n+     return Math.max(left.getScale(), right.getScale());\n+ }\n \n-    @Override\n-    public void updateAggregate(Session session) {\n-        left.updateAggregate(session);\n-        right.updateAggregate(session);\n-    }\n+ @Override\n+ public void updateAggregate(Session session) {\n+     left.updateAggregate(session);\n+     right.updateAggregate(session);\n+ }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+ @Override\n+ public boolean isEverything(ExpressionVisitor visitor) {\n+     return left.isEverything(visitor) && right.isEverything(visitor);\n+ }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+ @Override\n+ public int getCost() {\n+     return left.getCost() + right.getCost() + 1;\n+ }\n \n-    /**\n+ /**\n      * Get the left sub-expression of this operation.\n      *\n      * @return the left sub-expression\n      */\n-    public Expression getLeftSubExpression() {\n-        return left;\n-    }\n+ public Expression getLeftSubExpression() {\n+     return left;\n+ }\n \n-    /**\n+ /**\n      * Get the right sub-expression of this operation.\n      *\n      * @return the right sub-expression\n      */\n-    public Expression getRightSubExpression() {\n-        return right;\n-    }\n+ public Expression getRightSubExpression() {\n+     return right;\n+ }\n \n }\n",
            "diff_size": 139
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "327",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/708/Operation.java\nindex 8281ba1a12..c19c95f4c3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/708/Operation.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.expression;\n \n import org.h2.engine.Mode;\n@@ -23,453 +24,471 @@ import org.h2.value.ValueString;\n  */\n public class Operation extends Expression {\n \n-    public enum OpType {\n-        /**\n-         * This operation represents a string concatenation as in\n-         * 'Hello' || 'World'.\n-         */\n-        CONCAT,\n+  public enum OpType {\n+    /**\n+     * This operation represents a string concatenation as in\n+     * 'Hello' || 'World'.\n+     */\n+    CONCAT,\n+\n+    /**\n+     * This operation represents an addition as in 1 + 2.\n+     */\n+    PLUS,\n \n-        /**\n-         * This operation represents an addition as in 1 + 2.\n-         */\n-        PLUS,\n+    /**\n+     * This operation represents a subtraction as in 2 - 1.\n+     */\n+    MINUS,\n \n-        /**\n-         * This operation represents a subtraction as in 2 - 1.\n-         */\n-        MINUS,\n+    /**\n+     * This operation represents a multiplication as in 2 * 3.\n+     */\n+    MULTIPLY,\n \n-        /**\n-         * This operation represents a multiplication as in 2 * 3.\n-         */\n-        MULTIPLY,\n+    /**\n+     * This operation represents a division as in 4 * 2.\n+     */\n+    DIVIDE,\n \n-        /**\n-         * This operation represents a division as in 4 * 2.\n-         */\n-        DIVIDE,\n+    /**\n+     * This operation represents a modulus as in 5 % 2.\n+     */\n+    MODULUS\n+  }\n \n-        /**\n-         * This operation represents a modulus as in 5 % 2.\n-         */\n-        MODULUS\n-    }\n+  private OpType opType;\n+  private Expression left, right;\n+  private int dataType;\n+  private boolean convertRight = true;\n \n-    private OpType opType;\n-    private Expression left, right;\n-    private int dataType;\n-    private boolean convertRight = true;\n+  public Operation(OpType opType, Expression left, Expression right) {\n+    this.opType = opType;\n+    this.left = left;\n+    this.right = right;\n+  }\n \n-    public Operation(OpType opType, Expression left, Expression right) {\n-        this.opType = opType;\n-        this.left = left;\n-        this.right = right;\n-    }\n+  @Override\n+  public String getSQL() {\n+    // don't remove the space, otherwise it might end up some thing like\n+    // --1 which is a line remark\n+    return '(' + left.getSQL() + ' ' + getOperationToken() + ' ' +\n+        right.getSQL() + ')';\n+  }\n \n-    @Override\n-    public String getSQL() {\n-        // don't remove the space, otherwise it might end up some thing like\n-        // --1 which is a line remark\n-        return '(' + left.getSQL() + ' ' + getOperationToken() + ' ' + right.getSQL() + ')';\n+  private String getOperationToken() {\n+    switch (opType) {\n+      case CONCAT:\n+        return \"||\";\n+      case PLUS:\n+        return \"+\";\n+      case MINUS:\n+        return \"-\";\n+      case MULTIPLY:\n+        return \"*\";\n+      case DIVIDE:\n+        return \"/\";\n+      case MODULUS:\n+        return \"%\";\n+      default:\n+        throw DbException.throwInternalError(\"opType=\" + opType);\n     }\n+  }\n \n-    private String getOperationToken() {\n-        switch (opType) {\n-        case CONCAT:\n-            return \"||\";\n-        case PLUS:\n-            return \"+\";\n-        case MINUS:\n-            return \"-\";\n-        case MULTIPLY:\n-            return \"*\";\n-        case DIVIDE:\n-            return \"/\";\n-        case MODULUS:\n-            return \"%\";\n-        default:\n-            throw DbException.throwInternalError(\"opType=\" + opType);\n-        }\n+  @Override\n+  public Value getValue(Session session) {\n+    Mode mode = session.getDatabase().getMode();\n+    Value l = left.getValue(session).convertTo(dataType, mode);\n+    Value r = right.getValue(session);\n+    if (convertRight) {\n+      r = r.convertTo(dataType, mode);\n     }\n-\n-    @Override\n-    public Value getValue(Session session) {\n-        Mode mode = session.getDatabase().getMode();\n-        Value l = left.getValue(session).convertTo(dataType, mode);\n-        Value r = right.getValue(session);\n-        if (convertRight) {\n-            r = r.convertTo(dataType, mode);\n+    switch (opType) {\n+      case CONCAT: {\n+        if (l == ValueNull.INSTANCE) {\n+          if (mode.nullConcatIsNull) {\n+            return ValueNull.INSTANCE;\n+          }\n+          return r;\n+        } else if (r == ValueNull.INSTANCE) {\n+          if (mode.nullConcatIsNull) {\n+            return ValueNull.INSTANCE;\n+          }\n+          return l;\n         }\n-        switch (opType) {\n-        case CONCAT: {\n-            if (l == ValueNull.INSTANCE) {\n-                if (mode.nullConcatIsNull) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                return r;\n-            } else if (r == ValueNull.INSTANCE) {\n-                if (mode.nullConcatIsNull) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                return l;\n-            }\n-            String s1 = l.getString(), s2 = r.getString();\n-            StringBuilder buff = new StringBuilder(s1.length() + s2.length());\n-            buff.append(s1).append(s2);\n-            return ValueString.get(buff.toString());\n+        String s1 = l.getString(), s2 = r.getString();\n+        StringBuilder buff = new StringBuilder(s1.length() + s2.length());\n+        buff.append(s1).append(s2);\n+        return ValueString.get(buff.toString());\n+      }\n+      case PLUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        case PLUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.add(r);\n-        case MINUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.subtract(r);\n-        case MULTIPLY:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.multiply(r);\n-        case DIVIDE:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.divide(r);\n-        case MODULUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.modulus(r);\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + opType);\n+        return l.add(r);\n+      case MINUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-    }\n-\n-    @Override\n-    public void mapColumns(ColumnResolver resolver, int level) {\n-        left.mapColumns(resolver, level);\n-        right.mapColumns(resolver, level);\n-    }\n-\n-    @Override\n-    public Expression optimize(Session session) {\n-        left = left.optimize(session);\n-        right = right.optimize(session);\n-        switch (opType) {\n-        case CONCAT:\n-            dataType = Value.STRING;\n-            if (left.isConstant() && right.isConstant()) {\n-                return ValueExpression.get(getValue(session));\n-            }\n-            break;\n-        case PLUS:\n-        case MINUS:\n-        case MULTIPLY:\n-        case DIVIDE:\n-        case MODULUS:\n-            int l = left.getType();\n-            int r = right.getType();\n-            if ((l == Value.NULL && r == Value.NULL) ||\n-                    (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n-                // (? + ?) - use decimal by default (the most safe data type) or\n-                // string when text concatenation with + is enabled\n-                if (opType == OpType.PLUS && session.getDatabase().\n-                        getMode().allowPlusForStringConcat) {\n-                    dataType = Value.STRING;\n-                    opType = OpType.CONCAT;\n-                } else {\n-                    dataType = Value.DECIMAL;\n-                }\n-            } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n-                return optimizeInterval(session, l, r);\n-            } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n-                return optimizeDateTime(session, l, r);\n-            } else {\n-                dataType = Value.getHigherOrder(l, r);\n-                if (dataType == Value.ENUM) {\n-                    dataType = Value.INT;\n-                } else if (DataType.isStringType(dataType) &&\n-                        session.getDatabase().getMode().allowPlusForStringConcat) {\n-                    opType = OpType.CONCAT;\n-                }\n-            }\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + opType);\n+        return l.subtract(r);\n+      case MULTIPLY:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        if (left.isConstant() && right.isConstant()) {\n-            return ValueExpression.get(getValue(session));\n+        return l.multiply(r);\n+      case DIVIDE:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n+        }\n+        return l.divide(r);\n+      case MODULUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        return this;\n+        return l.modulus(r);\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + opType);\n     }\n+  }\n \n-    private Expression optimizeInterval(Session session, int l, int r) {\n-        boolean lInterval = false, lNumeric = false, lDateTime = false;\n-        if (DataType.isIntervalType(l)) {\n-            lInterval = true;\n-        } else if (DataType.isNumericType(l)) {\n-            lNumeric = true;\n-        } else if (DataType.isDateTimeType(l)) {\n-            lDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n+  @Override\n+  public void mapColumns(ColumnResolver resolver, int level) {\n+    left.mapColumns(resolver, level);\n+    right.mapColumns(resolver, level);\n+  }\n+\n+  @Override\n+  public Expression optimize(Session session) {\n+    left = left.optimize(session);\n+    right = right.optimize(session);\n+    switch (opType) {\n+      case CONCAT:\n+        dataType = Value.STRING;\n+        if (left.isConstant() && right.isConstant()) {\n+          return ValueExpression.get(getValue(session));\n         }\n-        boolean rInterval = false, rNumeric = false, rDateTime = false;\n-        if (DataType.isIntervalType(r)) {\n-            rInterval = true;\n-        } else if (DataType.isNumericType(r)) {\n-            rNumeric = true;\n-        } else if (DataType.isDateTimeType(r)) {\n-            rDateTime = true;\n+        break;\n+      case PLUS:\n+      case MINUS:\n+      case MULTIPLY:\n+      case DIVIDE:\n+      case MODULUS:\n+        int l = left.getType();\n+        int r = right.getType();\n+        if ((l == Value.NULL && r == Value.NULL) ||\n+            (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n+          // (? + ?) - use decimal by default (the most safe data type) or\n+          // string when text concatenation with + is enabled\n+          if (opType == OpType.PLUS && session.getDatabase().\n+              getMode().allowPlusForStringConcat) {\n+            dataType = Value.STRING;\n+            opType = OpType.CONCAT;\n+          } else {\n+            dataType = Value.DECIMAL;\n+          }\n+        } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n+          return optimizeInterval(session, l, r);\n+        } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n+          return optimizeDateTime(session, l, r);\n         } else {\n-            throw getUnsupported(l, r);\n+          dataType = Value.getHigherOrder(l, r);\n+          if (dataType == Value.ENUM) {\n+            dataType = Value.INT;\n+          } else if (DataType.isStringType(dataType) &&\n+              session.getDatabase().getMode().allowPlusForStringConcat) {\n+            opType = OpType.CONCAT;\n+          }\n         }\n-        switch (opType) {\n-        case PLUS:\n-            if (lInterval && rInterval) {\n-                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL, left, right);\n-                }\n-            } else if (lInterval && rDateTime) {\n-                if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);\n-            } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n-            }\n-            break;\n-        case MINUS:\n-            if (lInterval && rInterval) {\n-                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL, left, right);\n-                }\n-            } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL, left, right);\n-            }\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + opType);\n+    }\n+    if (left.isConstant() && right.isConstant()) {\n+      return ValueExpression.get(getValue(session));\n+    }\n+    return this;\n+  }\n+\n+  private Expression optimizeInterval(Session session, int l, int r) {\n+    boolean lInterval = false, lNumeric = false, lDateTime = false;\n+    if (DataType.isIntervalType(l)) {\n+      lInterval = true;\n+    } else if (DataType.isNumericType(l)) {\n+      lNumeric = true;\n+    } else if (DataType.isDateTimeType(l)) {\n+      lDateTime = true;\n+    } else {\n+      throw getUnsupported(l, r);\n+    }\n+    boolean rInterval = false, rNumeric = false, rDateTime = false;\n+    if (DataType.isIntervalType(r)) {\n+      rInterval = true;\n+    } else if (DataType.isNumericType(r)) {\n+      rNumeric = true;\n+    } else if (DataType.isDateTimeType(r)) {\n+      rDateTime = true;\n+    } else {\n+      throw getUnsupported(l, r);\n+    }\n+    switch (opType) {\n+      case PLUS:\n+        if (lInterval && rInterval) {\n+          if (DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL,\n+                left, right);\n+          }\n+        } else if (lInterval && rDateTime) {\n+          if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {\n             break;\n-        case MULTIPLY:\n-            if (lInterval && rNumeric) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, left, right);\n-            } else if (lNumeric && rInterval) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, right, left);\n-            }\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL,\n+              right, left);\n+        } else if (lDateTime && rInterval) {\n+          if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n             break;\n-        case DIVIDE:\n-            if (lInterval && rNumeric) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC, left, right);\n-            }\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL,\n+              left, right);\n+        }\n+        break;\n+      case MINUS:\n+        if (lInterval && rInterval) {\n+          if (DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL,\n+                left, right);\n+          }\n+        } else if (lDateTime && rInterval) {\n+          if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n             break;\n-        default:\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL,\n+              left, right);\n         }\n-        throw getUnsupported(l, r);\n+        break;\n+      case MULTIPLY:\n+        if (lInterval && rNumeric) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC,\n+              left, right);\n+        } else if (lNumeric && rInterval) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC,\n+              right, left);\n+        }\n+        break;\n+      case DIVIDE:\n+        if (lInterval && rNumeric) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC,\n+              left, right);\n+        }\n+        break;\n+      default:\n     }\n+    throw getUnsupported(l, r);\n+  }\n \n-    private Expression optimizeDateTime(Session session, int l, int r) {\n-        switch (opType) {\n-        case PLUS:\n-            if (r != Value.getHigherOrder(l, r)) {\n-                // order left and right: INT < TIME < DATE < TIMESTAMP\n-                swap();\n-                int t = l;\n-                l = r;\n-                r = t;\n+  private Expression optimizeDateTime(Session session, int l, int r) {\n+    switch (opType) {\n+      case PLUS:\n+        if (r != Value.getHigherOrder(l, r)) {\n+          // order left and right: INT < TIME < DATE < TIMESTAMP\n+          swap();\n+          int t = l;\n+          l = r;\n+          r = t;\n+        }\n+        switch (l) {\n+          case Value.INT: {\n+            // Oracle date add\n+            Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+            f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+            f.setParameter(1, left);\n+            f.setParameter(2, right);\n+            f.doneWithParameters();\n+            return f.optimize(session);\n+          }\n+          case Value.DECIMAL:\n+          case Value.FLOAT:\n+          case Value.DOUBLE: {\n+            // Oracle date add\n+            Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+            f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+            left = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                .get(60 * 60 * 24)), left);\n+            f.setParameter(1, left);\n+            f.setParameter(2, right);\n+            f.doneWithParameters();\n+            return f.optimize(session);\n+          }\n+          case Value.TIME:\n+            if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n+              dataType = r;\n+              return this;\n+            } else { // DATE, TIMESTAMP\n+              dataType = Value.TIMESTAMP;\n+              return this;\n             }\n-            switch (l) {\n-            case Value.INT: {\n-                // Oracle date add\n-                Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+        }\n+        break;\n+      case MINUS:\n+        switch (l) {\n+          case Value.DATE:\n+          case Value.TIMESTAMP:\n+          case Value.TIMESTAMP_TZ:\n+            switch (r) {\n+              case Value.INT: {\n+                // Oracle date subtract\n+                Function f =\n+                    Function.getFunction(session.getDatabase(), \"DATEADD\");\n                 f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                f.setParameter(1, left);\n-                f.setParameter(2, right);\n+                right = new UnaryOperation(right);\n+                right = right.optimize(session);\n+                f.setParameter(1, right);\n+                f.setParameter(2, left);\n                 f.doneWithParameters();\n                 return f.optimize(session);\n-            }\n-            case Value.DECIMAL:\n-            case Value.FLOAT:\n-            case Value.DOUBLE: {\n-                // Oracle date add\n-                Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                left = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                        .get(60 * 60 * 24)), left);\n-                f.setParameter(1, left);\n-                f.setParameter(2, right);\n+              }\n+              case Value.DECIMAL:\n+              case Value.FLOAT:\n+              case Value.DOUBLE: {\n+                // Oracle date subtract\n+                Function f =\n+                    Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                f.setParameter(0,\n+                    ValueExpression.get(ValueString.get(\"SECOND\")));\n+                right =\n+                    new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                        .get(60 * 60 * 24)), right);\n+                right = new UnaryOperation(right);\n+                right = right.optimize(session);\n+                f.setParameter(1, right);\n+                f.setParameter(2, left);\n                 f.doneWithParameters();\n                 return f.optimize(session);\n-            }\n-            case Value.TIME:\n-                if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n-                    dataType = r;\n-                    return this;\n-                } else { // DATE, TIMESTAMP\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                dataType = Value.TIME;\n-                convertRight = false;\n+              }\n+              case Value.TIME:\n+                dataType = Value.TIMESTAMP;\n                 return this;\n+              case Value.DATE:\n+              case Value.TIMESTAMP:\n+              case Value.TIMESTAMP_TZ:\n+                return new IntervalOperation(\n+                    IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n             }\n             break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n+          case Value.TIME:\n+            if (r == Value.TIME) {\n+              return new IntervalOperation(\n+                  IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n             }\n             break;\n-        default:\n         }\n-        throw getUnsupported(l, r);\n+        break;\n+      case MULTIPLY:\n+        if (l == Value.TIME) {\n+          dataType = Value.TIME;\n+          convertRight = false;\n+          return this;\n+        } else if (r == Value.TIME) {\n+          swap();\n+          dataType = Value.TIME;\n+          convertRight = false;\n+          return this;\n+        }\n+        break;\n+      case DIVIDE:\n+        if (l == Value.TIME) {\n+          dataType = Value.TIME;\n+          convertRight = false;\n+          return this;\n+        }\n+        break;\n+      default:\n     }\n+    throw getUnsupported(l, r);\n+  }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+  private DbException getUnsupported(int l, int r) {\n+    return DbException.getUnsupportedException(\n+        DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' +\n+            DataType.getDataType(r).name);\n+  }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+  private void swap() {\n+    Expression temp = left;\n+    left = right;\n+    right = temp;\n+  }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+  @Override\n+  public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+    left.setEvaluatable(tableFilter, b);\n+    right.setEvaluatable(tableFilter, b);\n+  }\n \n-    @Override\n-    public int getType() {\n-        return dataType;\n-    }\n+  @Override\n+  public int getType() {\n+    return dataType;\n+  }\n \n-    @Override\n-    public long getPrecision() {\n-        switch (opType) {\n-        case CONCAT:\n-            return left.getPrecision() + right.getPrecision();\n-        default:\n-            return Math.max(left.getPrecision(), right.getPrecision());\n-        }\n+  @Override\n+  public long getPrecision() {\n+    switch (opType) {\n+      case CONCAT:\n+        return left.getPrecision() + right.getPrecision();\n+      default:\n+        return Math.max(left.getPrecision(), right.getPrecision());\n     }\n+  }\n \n-    @Override\n-    public int getDisplaySize() {\n-        switch (opType) {\n-        case CONCAT:\n-            return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n-                    (long) right.getDisplaySize());\n-        default:\n-            return Math.max(left.getDisplaySize(), right.getDisplaySize());\n-        }\n+  @Override\n+  public int getDisplaySize() {\n+    switch (opType) {\n+      case CONCAT:\n+        return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n+            (long) right.getDisplaySize());\n+      default:\n+        return Math.max(left.getDisplaySize(), right.getDisplaySize());\n     }\n+  }\n \n-    @Override\n-    public int getScale() {\n-        return Math.max(left.getScale(), right.getScale());\n-    }\n+  @Override\n+  public int getScale() {\n+    return Math.max(left.getScale(), right.getScale());\n+  }\n \n-    @Override\n-    public void updateAggregate(Session session) {\n-        left.updateAggregate(session);\n-        right.updateAggregate(session);\n-    }\n+  @Override\n+  public void updateAggregate(Session session) {\n+    left.updateAggregate(session);\n+    right.updateAggregate(session);\n+  }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+  @Override\n+  public boolean isEverything(ExpressionVisitor visitor) {\n+    return left.isEverything(visitor) && right.isEverything(visitor);\n+  }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+  @Override\n+  public int getCost() {\n+    return left.getCost() + right.getCost() + 1;\n+  }\n \n-    /**\n-     * Get the left sub-expression of this operation.\n-     *\n-     * @return the left sub-expression\n-     */\n-    public Expression getLeftSubExpression() {\n-        return left;\n-    }\n+  /**\n+   * Get the left sub-expression of this operation.\n+   *\n+   * @return the left sub-expression\n+   */\n+  public Expression getLeftSubExpression() {\n+    return left;\n+  }\n \n-    /**\n-     * Get the right sub-expression of this operation.\n-     *\n-     * @return the right sub-expression\n-     */\n-    public Expression getRightSubExpression() {\n-        return right;\n-    }\n+  /**\n+   * Get the right sub-expression of this operation.\n+   *\n+   * @return the right sub-expression\n+   */\n+  public Expression getRightSubExpression() {\n+    return right;\n+  }\n \n }\n",
            "diff_size": 575
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "311",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/708/Operation.java\nindex 8281ba1a12..966f7a731b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/708/Operation.java\n@@ -21,8 +21,11 @@ import org.h2.value.ValueString;\n /**\n  * A mathematical expression, or string concatenation.\n  */\n+\n+\n public class Operation extends Expression {\n \n+\n     public enum OpType {\n         /**\n          * This operation represents a string concatenation as in\n@@ -32,30 +35,23 @@ public class Operation extends Expression {\n \n         /**\n          * This operation represents an addition as in 1 + 2.\n-         */\n-        PLUS,\n+         */ PLUS,\n \n         /**\n          * This operation represents a subtraction as in 2 - 1.\n-         */\n-        MINUS,\n+         */ MINUS,\n \n         /**\n          * This operation represents a multiplication as in 2 * 3.\n-         */\n-        MULTIPLY,\n+         */ MULTIPLY,\n \n         /**\n          * This operation represents a division as in 4 * 2.\n-         */\n-        DIVIDE,\n+         */ DIVIDE,\n \n         /**\n          * This operation represents a modulus as in 5 % 2.\n-         */\n-        MODULUS\n-    }\n-\n+         */ MODULUS }\n     private OpType opType;\n     private Expression left, right;\n     private int dataType;\n@@ -171,32 +167,31 @@ public class Operation extends Expression {\n         case MULTIPLY:\n         case DIVIDE:\n         case MODULUS:\n+\n             int l = left.getType();\n             int r = right.getType();\n             if ((l == Value.NULL && r == Value.NULL) ||\n                     (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n                 // (? + ?) - use decimal by default (the most safe data type) or\n                 // string when text concatenation with + is enabled\n-                if (opType == OpType.PLUS && session.getDatabase().\n-                        getMode().allowPlusForStringConcat) {\n+                if (opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n                     dataType = Value.STRING;\n                     opType = OpType.CONCAT;\n                 } else {\n                     dataType = Value.DECIMAL;\n                 }\n             } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n-                return optimizeInterval(session, l, r);\n+            return optimizeInterval(session, l, r);\n             } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n-                return optimizeDateTime(session, l, r);\n-            } else {\n-                dataType = Value.getHigherOrder(l, r);\n-                if (dataType == Value.ENUM) {\n-                    dataType = Value.INT;\n-                } else if (DataType.isStringType(dataType) &&\n-                        session.getDatabase().getMode().allowPlusForStringConcat) {\n-                    opType = OpType.CONCAT;\n-                }\n-            }\n+            return optimizeDateTime(session, l, r);\n+                   } else {\n+                       dataType = Value.getHigherOrder(l, r);\n+                       if (dataType == Value.ENUM) {\n+                           dataType = Value.INT;\n+                       } else if (DataType.isStringType(dataType) && session.getDatabase().getMode().allowPlusForStringConcat) {\n+                           opType = OpType.CONCAT;\n+                       }\n+                   }\n             break;\n         default:\n             DbException.throwInternalError(\"type=\" + opType);\n@@ -214,20 +209,20 @@ public class Operation extends Expression {\n         } else if (DataType.isNumericType(l)) {\n             lNumeric = true;\n         } else if (DataType.isDateTimeType(l)) {\n-            lDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n+                   lDateTime = true;\n+               } else {\n+                   throw getUnsupported(l, r);\n+               }\n         boolean rInterval = false, rNumeric = false, rDateTime = false;\n         if (DataType.isIntervalType(r)) {\n             rInterval = true;\n         } else if (DataType.isNumericType(r)) {\n             rNumeric = true;\n         } else if (DataType.isDateTimeType(r)) {\n-            rDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n+                   rDateTime = true;\n+               } else {\n+                   throw getUnsupported(l, r);\n+               }\n         switch (opType) {\n         case PLUS:\n             if (lInterval && rInterval) {\n@@ -240,11 +235,11 @@ public class Operation extends Expression {\n                 }\n                 return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);\n             } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n-            }\n+                       if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n+                           break;\n+                       }\n+                       return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n+                   }\n             break;\n         case MINUS:\n             if (lInterval && rInterval) {\n@@ -301,8 +296,9 @@ public class Operation extends Expression {\n                 // Oracle date add\n                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n                 f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                left = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                        .get(60 * 60 * 24)), left);\n+                left = new Operation(OpType.MULTIPLY,\n+                    ValueExpression.get(ValueInt.get(60 * 60 * 24)),\n+                        left);\n                 f.setParameter(1, left);\n                 f.setParameter(2, right);\n                 f.doneWithParameters();\n@@ -341,8 +337,9 @@ public class Operation extends Expression {\n                     // Oracle date subtract\n                     Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n                     f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n+                    right = new Operation(OpType.MULTIPLY,\n+                        ValueExpression.get(ValueInt.get(60 * 60 * 24)),\n+                            right);\n                     right = new UnaryOperation(right);\n                     right = right.optimize(session);\n                     f.setParameter(1, right);\n@@ -391,8 +388,7 @@ public class Operation extends Expression {\n     }\n \n     private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+        return DbException.getUnsupportedException(DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n     }\n \n     private void swap() {\n@@ -426,8 +422,7 @@ public class Operation extends Expression {\n     public int getDisplaySize() {\n         switch (opType) {\n         case CONCAT:\n-            return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n-                    (long) right.getDisplaySize());\n+            return MathUtils.convertLongToInt((long) left.getDisplaySize() + (long) right.getDisplaySize());\n         default:\n             return Math.max(left.getDisplaySize(), right.getDisplaySize());\n         }\n@@ -459,6 +454,8 @@ public class Operation extends Expression {\n      *\n      * @return the left sub-expression\n      */\n+\n+\n     public Expression getLeftSubExpression() {\n         return left;\n     }\n@@ -468,8 +465,10 @@ public class Operation extends Expression {\n      *\n      * @return the right sub-expression\n      */\n+\n+\n     public Expression getRightSubExpression() {\n         return right;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 57
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "315",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/708/Operation.java\nindex 8281ba1a12..c585fa1959 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/708/Operation.java\n@@ -312,164 +312,164 @@ public class Operation extends Expression {\n                 if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n                     dataType = r;\n                     return this;\n-                } else { // DATE, TIMESTAMP\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                        } else { // DATE, TIMESTAMPdataType=\n+                        Value.TIMESTAMP;\n+                 return this;\n+             }\n+         }\n+         break;\n+     case MINUS:\n+         switch (l) {\n+         case Value.DATE:\n+         case Value.TIMESTAMP:\n+         case Value.TIMESTAMP_TZ:\n+             switch (r) {\n+             case Value.INT: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.DECIMAL:\n+             case Value.FLOAT:\n+             case Value.DOUBLE: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+                 right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                         .get(60 * 60 * 24)), right);\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.TIME:\n+                 dataType = Value.TIMESTAMP;\n+                 return this;\n+             case Value.DATE:\n+             case Value.TIMESTAMP:\n+             case Value.TIMESTAMP_TZ:\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         case Value.TIME:\n+             if (r == Value.TIME) {\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         }\n+         break;\n+     case MULTIPLY:\n+         if (l == Value.TIME) {\n+             dataType = Value.TIME;\n+             convertRight = false;\n+             return this;\n+         } else if (r == Value.TIME) {\n+             swap();\n+             dataType = Value.TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     case DIVIDE:\n+         if (l == Value.TIME) {\n+             dataType = Value.TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     default:\n+     }\n+     throw getUnsupported(l, r);\n+ }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+ private DbException getUnsupported(int l, int r) {\n+     return DbException.getUnsupportedException(\n+             DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+ }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+ private void swap() {\n+     Expression temp = left;\n+     left = right;\n+     right = temp;\n+ }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+ @Override\n+ public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+     left.setEvaluatable(tableFilter, b);\n+     right.setEvaluatable(tableFilter, b);\n+ }\n \n-    @Override\n-    public int getType() {\n-        return dataType;\n-    }\n+ @Override\n+ public int getType() {\n+     return dataType;\n+ }\n \n-    @Override\n-    public long getPrecision() {\n-        switch (opType) {\n-        case CONCAT:\n-            return left.getPrecision() + right.getPrecision();\n-        default:\n-            return Math.max(left.getPrecision(), right.getPrecision());\n-        }\n-    }\n+ @Override\n+ public long getPrecision() {\n+     switch (opType) {\n+     case CONCAT:\n+         return left.getPrecision() + right.getPrecision();\n+     default:\n+         return Math.max(left.getPrecision(), right.getPrecision());\n+     }\n+ }\n \n-    @Override\n-    public int getDisplaySize() {\n-        switch (opType) {\n-        case CONCAT:\n-            return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n-                    (long) right.getDisplaySize());\n-        default:\n-            return Math.max(left.getDisplaySize(), right.getDisplaySize());\n-        }\n-    }\n+ @Override\n+ public int getDisplaySize() {\n+     switch (opType) {\n+     case CONCAT:\n+         return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n+                 (long) right.getDisplaySize());\n+     default:\n+         return Math.max(left.getDisplaySize(), right.getDisplaySize());\n+     }\n+ }\n \n-    @Override\n-    public int getScale() {\n-        return Math.max(left.getScale(), right.getScale());\n-    }\n+ @Override\n+ public int getScale() {\n+     return Math.max(left.getScale(), right.getScale());\n+ }\n \n-    @Override\n-    public void updateAggregate(Session session) {\n-        left.updateAggregate(session);\n-        right.updateAggregate(session);\n-    }\n+ @Override\n+ public void updateAggregate(Session session) {\n+     left.updateAggregate(session);\n+     right.updateAggregate(session);\n+ }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+ @Override\n+ public boolean isEverything(ExpressionVisitor visitor) {\n+     return left.isEverything(visitor) && right.isEverything(visitor);\n+ }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+ @Override\n+ public int getCost() {\n+     return left.getCost() + right.getCost() + 1;\n+ }\n \n-    /**\n+ /**\n      * Get the left sub-expression of this operation.\n      *\n      * @return the left sub-expression\n      */\n-    public Expression getLeftSubExpression() {\n-        return left;\n-    }\n+ public Expression getLeftSubExpression() {\n+     return left;\n+ }\n \n-    /**\n+ /**\n      * Get the right sub-expression of this operation.\n      *\n      * @return the right sub-expression\n      */\n-    public Expression getRightSubExpression() {\n-        return right;\n-    }\n+ public Expression getRightSubExpression() {\n+     return right;\n+ }\n \n }\n",
            "diff_size": 139
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "314",
                    "column": "34",
                    "severity": "warning",
                    "message": "'}' at column 34 should have line break before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "315",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/708/Operation.java\nindex 8281ba1a12..daa7cff244 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/708/Operation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/708/Operation.java\n@@ -311,165 +311,166 @@ public class Operation extends Expression {\n             case Value.TIME:\n                 if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n                     dataType = r;\n-                    return this;\n-                } else { // DATE, TIMESTAMP\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    dataType = Value.TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                dataType = Value.TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                    return this; }\n+                            else { // DATE, TIMESTAMP\n+                         dataType = Value.TIMESTAMP;\n+                         return this;\n+                     }\n+                 }\n+                 break;\n+             case MINUS:\n+                 switch (l) {\n+                 case Value.DATE:\n+                 case Value.TIMESTAMP:\n+                 case Value.TIMESTAMP_TZ:\n+                     switch (r) {\n+                     case Value.INT: {\n+                         // Oracle date subtract\n+                         Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                         f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+                         right = new UnaryOperation(right);\n+                         right = right.optimize(session);\n+                         f.setParameter(1, right);\n+                         f.setParameter(2, left);\n+                         f.doneWithParameters();\n+                         return f.optimize(session);\n+                     }\n+                     case Value.DECIMAL:\n+                     case Value.FLOAT:\n+                     case Value.DOUBLE: {\n+                         // Oracle date subtract\n+                         Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                         f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+                         right = new Operation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                                 .get(60 * 60 * 24)), right);\n+                         right = new UnaryOperation(right);\n+                         right = right.optimize(session);\n+                         f.setParameter(1, right);\n+                         f.setParameter(2, left);\n+                         f.doneWithParameters();\n+                         return f.optimize(session);\n+                     }\n+                     case Value.TIME:\n+                         dataType = Value.TIMESTAMP;\n+                         return this;\n+                     case Value.DATE:\n+                     case Value.TIMESTAMP:\n+                     case Value.TIMESTAMP_TZ:\n+                         return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+                     }\n+                     break;\n+                 case Value.TIME:\n+                     if (r == Value.TIME) {\n+                         return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+                     }\n+                     break;\n+                 }\n+                 break;\n+             case MULTIPLY:\n+                 if (l == Value.TIME) {\n+                     dataType = Value.TIME;\n+                     convertRight = false;\n+                     return this;\n+                 } else if (r == Value.TIME) {\n+                     swap();\n+                     dataType = Value.TIME;\n+                     convertRight = false;\n+                     return this;\n+                 }\n+                 break;\n+             case DIVIDE:\n+                 if (l == Value.TIME) {\n+                     dataType = Value.TIME;\n+                     convertRight = false;\n+                     return this;\n+                 }\n+                 break;\n+             default:\n+             }\n+             throw getUnsupported(l, r);\n+         }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+         private DbException getUnsupported(int l, int r) {\n+             return DbException.getUnsupportedException(\n+                     DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+         }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+         private void swap() {\n+             Expression temp = left;\n+             left = right;\n+             right = temp;\n+         }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+         @Override\n+         public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+             left.setEvaluatable(tableFilter, b);\n+             right.setEvaluatable(tableFilter, b);\n+         }\n \n-    @Override\n-    public int getType() {\n-        return dataType;\n-    }\n+         @Override\n+         public int getType() {\n+             return dataType;\n+         }\n \n-    @Override\n-    public long getPrecision() {\n-        switch (opType) {\n-        case CONCAT:\n-            return left.getPrecision() + right.getPrecision();\n-        default:\n-            return Math.max(left.getPrecision(), right.getPrecision());\n-        }\n-    }\n+         @Override\n+         public long getPrecision() {\n+             switch (opType) {\n+             case CONCAT:\n+                 return left.getPrecision() + right.getPrecision();\n+             default:\n+                 return Math.max(left.getPrecision(), right.getPrecision());\n+             }\n+         }\n \n-    @Override\n-    public int getDisplaySize() {\n-        switch (opType) {\n-        case CONCAT:\n-            return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n-                    (long) right.getDisplaySize());\n-        default:\n-            return Math.max(left.getDisplaySize(), right.getDisplaySize());\n-        }\n-    }\n+         @Override\n+         public int getDisplaySize() {\n+             switch (opType) {\n+             case CONCAT:\n+                 return MathUtils.convertLongToInt((long) left.getDisplaySize() +\n+                         (long) right.getDisplaySize());\n+             default:\n+                 return Math.max(left.getDisplaySize(), right.getDisplaySize());\n+             }\n+         }\n \n-    @Override\n-    public int getScale() {\n-        return Math.max(left.getScale(), right.getScale());\n-    }\n+         @Override\n+         public int getScale() {\n+             return Math.max(left.getScale(), right.getScale());\n+         }\n \n-    @Override\n-    public void updateAggregate(Session session) {\n-        left.updateAggregate(session);\n-        right.updateAggregate(session);\n-    }\n+         @Override\n+         public void updateAggregate(Session session) {\n+             left.updateAggregate(session);\n+             right.updateAggregate(session);\n+         }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+         @Override\n+         public boolean isEverything(ExpressionVisitor visitor) {\n+             return left.isEverything(visitor) && right.isEverything(visitor);\n+         }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+         @Override\n+         public int getCost() {\n+             return left.getCost() + right.getCost() + 1;\n+         }\n \n-    /**\n+         /**\n      * Get the left sub-expression of this operation.\n      *\n      * @return the left sub-expression\n      */\n-    public Expression getLeftSubExpression() {\n-        return left;\n-    }\n+         public Expression getLeftSubExpression() {\n+             return left;\n+         }\n \n-    /**\n+         /**\n      * Get the right sub-expression of this operation.\n      *\n      * @return the right sub-expression\n      */\n-    public Expression getRightSubExpression() {\n-        return right;\n-    }\n+         public Expression getRightSubExpression() {\n+             return right;\n+         }\n \n-}\n+     }\n+     \n\\ No newline at end of file\n",
            "diff_size": 142
        }
    ]
}