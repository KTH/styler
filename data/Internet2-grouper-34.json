{
    "error_id": "34",
    "information": {
        "errors": [
            {
                "line": "99",
                "severity": "warning",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": " * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\n * </p>\n * \n * @since 2.0\n * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\n */",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "46",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 0, expected is 4, indentation should be the same level as line 102.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/34/ReflectionToStringBuilder.java\nindex 9ba7082e12..3e9d298750 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/34/ReflectionToStringBuilder.java\n@@ -1,706 +1,705 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.List;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassUtils;\r\n-\r\n-/**\r\n- * <p>\r\n- * Assists in implementing {@link Object#toString()} methods using reflection.\r\n- * </p>\r\n- * <p>\r\n- * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\r\n- * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\r\n- * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\r\n- * set up correctly.\r\n- * </p>\r\n- * <p>\r\n- * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these\r\n- * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use\r\n- * synchronization consistent with the class' lock management around the invocation of the method. Take special care to\r\n- * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if\r\n- * modified while the toString method is executing.\r\n- * </p>\r\n- * <p>\r\n- * A typical invocation for this method would look like:\r\n- * </p>\r\n- * <pre>\r\n- * public String toString() {\r\n- *     return ReflectionToStringBuilder.toString(this);\r\n- * }\r\n- * </pre>\r\n- * <p>\r\n- * You can also use the builder to debug 3rd party objects:\r\n- * </p>\r\n- * <pre>\r\n- * System.out.println(&quot;An object: &quot; + ReflectionToStringBuilder.toString(anObject));\r\n- * </pre>\r\n- * <p>\r\n- * A subclass can control field output by overriding the methods:\r\n- * <ul>\r\n- * <li>{@link #accept(java.lang.reflect.Field)}</li>\r\n- * <li>{@link #getValue(java.lang.reflect.Field)}</li>\r\n- * </ul>\r\n- * </p>\r\n- * <p>\r\n- * For example, this method does <i>not</i> include the <code>password</code> field in the returned <code>String</code>:\r\n- * </p>\r\n- * <pre>\r\n- * public String toString() {\r\n- *     return (new ReflectionToStringBuilder(this) {\r\n- *         protected boolean accept(Field f) {\r\n- *             return super.accept(f) &amp;&amp; !f.getName().equals(&quot;password&quot;);\r\n- *         }\r\n- *     }).toString();\r\n- * }\r\n- * </pre>\r\n- * <p>\r\n- * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\r\n- * </p>\r\n- * \r\n- * @since 2.0\r\n- * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\r\n- */\r\n-public class ReflectionToStringBuilder extends ToStringBuilder {\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object) {\r\n-        return toString(object, null, false, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style) {\r\n-        return toString(object, style, false, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n-        return toString(object, style, outputTransients, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n-        return toString(object, style, outputTransients, outputStatics, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\r\n-     * <code>java.lang.Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static <T> String toString(\r\n-            T object, ToStringStyle style, boolean outputTransients,\r\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n-                .toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude. Null excludes nothing.\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n-        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n-    }\r\n-\r\n-    /**\r\n-     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\r\n-     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\r\n-     * is <code>null</code>.\r\n-     *\r\n-     * @param collection\r\n-     *            The collection to convert\r\n-     * @return A new array of Strings.\r\n-     */\r\n-    static String[] toNoNullStringArray(Collection<String> collection) {\r\n-        if (collection == null) {\r\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\r\n-        }\r\n-        return toNoNullStringArray(collection.toArray());\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\r\n-     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\r\n-     * if an array element is <code>null</code>.\r\n-     *\r\n-     * @param array\r\n-     *            The array to check\r\n-     * @return The given array or a new array without null.\r\n-     */\r\n-    static String[] toNoNullStringArray(Object[] array) {\r\n-        List<String> list = new ArrayList<String>(array.length);\r\n-        for (Object e : array) {\r\n-            if (e != null) {\r\n-                list.add(e.toString());\r\n-            }\r\n-        }\r\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n-    }\r\n-\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n-        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether or not to append static fields.\r\n-     */\r\n-    private boolean appendStatics = false;\r\n-\r\n-    /**\r\n-     * Whether or not to append transient fields.\r\n-     */\r\n-    private boolean appendTransients = false;\r\n-\r\n-    /**\r\n-     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n-     *\r\n-     * @since 3.0 this is protected instead of private\r\n-     */\r\n-    protected String[] excludeFieldNames;\r\n-\r\n-    /**\r\n-     * The last super class to stop appending fields for.\r\n-     */\r\n-    private Class<?> upToClass = null;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object) {\r\n-        super(object);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n-        super(object, style);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the buffer is <code>null</code>, a new one is created.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n-        super(object, style, buffer);\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @since 2.1\r\n-     */\r\n-    public <T> ReflectionToStringBuilder(\r\n-            T object, ToStringStyle style, StringBuffer buffer,\r\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n-        super(object, style, buffer);\r\n-        this.setUpToClass(reflectUpToClass);\r\n-        this.setAppendTransients(outputTransients);\r\n-        this.setAppendStatics(outputStatics);\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns whether or not to append the given <code>Field</code>.\r\n-     * <ul>\r\n-     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\r\n-     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\r\n-     * <li>Inner class fields are not appened.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to test.\r\n-     * @return Whether or not to append the given <code>Field</code>.\r\n-     */\r\n-    protected boolean accept(Field field) {\r\n-        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n-            // Reject field from inner class.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n-            // Reject transient fields.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n-            // Reject static fields.\r\n-            return false;\r\n-        }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n-            // Reject fields from the getExcludeFieldNames list.\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given Class.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\r\n-     * <code>Object.toString()</code> had been called and not implemented by the object.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The class of object parameter\r\n-     */\r\n-    protected void appendFieldsIn(Class<?> clazz) {\r\n-        if (clazz.isArray()) {\r\n-            this.reflectionAppendArray(this.getObject());\r\n-            return;\r\n-        }\r\n-        Field[] fields = clazz.getDeclaredFields();\r\n-        AccessibleObject.setAccessible(fields, true);\r\n-        for (Field field : fields) {\r\n-            String fieldName = field.getName();\r\n-            if (this.accept(field)) {\r\n-                try {\r\n-                    // Warning: Field.get(Object) creates wrappers objects\r\n-                    // for primitive types.\r\n-                    Object fieldValue = this.getValue(field);\r\n-                    this.append(fieldName, fieldValue);\r\n-                } catch (IllegalAccessException ex) {\r\n-                    //this can't happen. Would get a Security exception\r\n-                    // instead\r\n-                    //throw a runtime exception in case the impossible\r\n-                    // happens.\r\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return Returns the excludeFieldNames.\r\n-     */\r\n-    public String[] getExcludeFieldNames() {\r\n-        return this.excludeFieldNames.clone();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @return The last super class to stop appending fields for.\r\n-     */\r\n-    public Class<?> getUpToClass() {\r\n-        return this.upToClass;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to query.\r\n-     * @return The Object from the given Field.\r\n-     *\r\n-     * @throws IllegalArgumentException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     * @throws IllegalAccessException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     *\r\n-     * @see java.lang.reflect.Field#get(Object)\r\n-     */\r\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n-        return field.get(this.getObject());\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public boolean isAppendStatics() {\r\n-        return this.appendStatics;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append transient fields.\r\n-     */\r\n-    public boolean isAppendTransients() {\r\n-        return this.appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append to the <code>toString</code> an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>toString</code>\r\n-     * @return this\r\n-     */\r\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n-        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendStatics\r\n-     *            Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public void setAppendStatics(boolean appendStatics) {\r\n-        this.appendStatics = appendStatics;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendTransients\r\n-     *            Whether or not to append transient fields.\r\n-     */\r\n-    public void setAppendTransients(boolean appendTransients) {\r\n-        this.appendTransients = appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the field names to exclude.\r\n-     *\r\n-     * @param excludeFieldNamesParam\r\n-     *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n-     * @return <code>this</code>\r\n-     */\r\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n-        if (excludeFieldNamesParam == null) {\r\n-            this.excludeFieldNames = null;\r\n-        } else {\r\n-            //clone and remove nulls\r\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n-            Arrays.sort(this.excludeFieldNames);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The last super class to stop appending fields for.\r\n-     */\r\n-    public void setUpToClass(Class<?> clazz) {\r\n-        if (clazz != null) {\r\n-            Object object = getObject();\r\n-            if (object != null && clazz.isInstance(object) == false) {\r\n-                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n-            }\r\n-        }\r\n-        this.upToClass = clazz;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the String built by this builder.\r\n-     * </p>\r\n-     *\r\n-     * @return the built string\r\n-     */\r\n-    @Override\r\n-    public String toString() {\r\n-        if (this.getObject() == null) {\r\n-            return this.getStyle().getNullText();\r\n-        }\r\n-        Class<?> clazz = this.getObject().getClass();\r\n-        this.appendFieldsIn(clazz);\r\n-        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n-            clazz = clazz.getSuperclass();\r\n-            this.appendFieldsIn(clazz);\r\n-        }\r\n-        return super.toString();\r\n-    }\r\n-\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#toString()} methods using reflection.\n+ * </p>\n+ * <p>\n+ * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n+ * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n+ * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n+ * set up correctly.\n+ * </p>\n+ * <p>\n+ * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these\n+ * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use\n+ * synchronization consistent with the class' lock management around the invocation of the method. Take special care to\n+ * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if\n+ * modified while the toString method is executing.\n+ * </p>\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * <pre>\n+ * public String toString() {\n+ *     return ReflectionToStringBuilder.toString(this);\n+ * }\n+ * </pre>\n+ * <p>\n+ * You can also use the builder to debug 3rd party objects:\n+ * </p>\n+ * <pre>\n+ * System.out.println(&quot;An object: &quot; + ReflectionToStringBuilder.toString(anObject));\n+ * </pre>\n+ * <p>\n+ * A subclass can control field output by overriding the methods:\n+ * <ul>\n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * For example, this method does <i>not</i> include the <code>password</code> field in the returned <code>String</code>:\n+ * </p>\n+ * <pre>\n+ * public String toString() {\n+ *     return (new ReflectionToStringBuilder(this) {\n+ *         protected boolean accept(Field f) {\n+ *             return super.accept(f) &amp;&amp; !f.getName().equals(&quot;password&quot;);\n+ *         }\n+ *     }).toString();\n+ * }\n+ * </pre>\n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\n+ * </p>\n+ * \n+ * @since 2.0\n+ * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\n+ */ public class ReflectionToStringBuilder extends ToStringBuilder {\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object, style, outputTransients, outputStatics, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     *\n+     * <p>\n+     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n+     * <code>java.lang.Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param <T>\n+     *            the type of the object\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static <T> String toString(\n+            T object, ToStringStyle style, boolean outputTransients,\n+            boolean outputStatics, Class<? super T> reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n+                .toString();\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     *\n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude. Null excludes nothing.\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n+    }\n+\n+    /**\n+     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n+     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\n+     * is <code>null</code>.\n+     *\n+     * @param collection\n+     *            The collection to convert\n+     * @return A new array of Strings.\n+     */\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n+    }\n+\n+    /**\n+     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n+     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\n+     * if an array element is <code>null</code>.\n+     *\n+     * @param array\n+     *            The array to check\n+     * @return The given array or a new array without null.\n+     */\n+    static String[] toNoNullStringArray(Object[] array) {\n+        List<String> list = new ArrayList<String>(array.length);\n+        for (Object e : array) {\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+    }\n+\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     *\n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, String... excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n+    }\n+\n+    /**\n+     * Whether or not to append static fields.\n+     */\n+    private boolean appendStatics = false;\n+\n+    /**\n+     * Whether or not to append transient fields.\n+     */\n+    private boolean appendTransients = false;\n+\n+    /**\n+     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n+     *\n+     * @since 3.0 this is protected instead of private\n+     */\n+    protected String[] excludeFieldNames;\n+\n+    /**\n+     * The last super class to stop appending fields for.\n+     */\n+    private Class<?> upToClass = null;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+        super(object, style);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     *\n+     * <p>\n+     * If the buffer is <code>null</code>, a new one is created.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super(object, style, buffer);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param <T>\n+     *            the type of the object\n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @since 2.1\n+     */\n+    public <T> ReflectionToStringBuilder(\n+            T object, ToStringStyle style, StringBuffer buffer,\n+            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+        this.setAppendStatics(outputStatics);\n+    }\n+\n+    /**\n+     * Returns whether or not to append the given <code>Field</code>.\n+     * <ul>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n+     * </ul>\n+     *\n+     * @param field\n+     *            The Field to test.\n+     * @return Whether or not to append the given <code>Field</code>.\n+     */\n+    protected boolean accept(Field field) {\n+        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+            // Reject field from inner class.\n+            return false;\n+        }\n+        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n+            // Reject transient fields.\n+            return false;\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n+            // Reject static fields.\n+            return false;\n+        }\n+        if (this.excludeFieldNames != null\n+            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given Class.\n+     * </p>\n+     *\n+     * <p>\n+     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n+     * <code>Object.toString()</code> had been called and not implemented by the object.\n+     * </p>\n+     *\n+     * @param clazz\n+     *            The class of object parameter\n+     */\n+    protected void appendFieldsIn(Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n+            return;\n+        }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (Field field : fields) {\n+            String fieldName = field.getName();\n+            if (this.accept(field)) {\n+                try {\n+                    // Warning: Field.get(Object) creates wrappers objects\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n+                } catch (IllegalAccessException ex) {\n+                    //this can't happen. Would get a Security exception\n+                    // instead\n+                    //throw a runtime exception in case the impossible\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return Returns the excludeFieldNames.\n+     */\n+    public String[] getExcludeFieldNames() {\n+        return this.excludeFieldNames.clone();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the last super class to stop appending fields for.\n+     * </p>\n+     *\n+     * @return The last super class to stop appending fields for.\n+     */\n+    public Class<?> getUpToClass() {\n+        return this.upToClass;\n+    }\n+\n+    /**\n+     * <p>\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n+     * </p>\n+     *\n+     * @param field\n+     *            The Field to query.\n+     * @return The Object from the given Field.\n+     *\n+     * @throws IllegalArgumentException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * @throws IllegalAccessException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     *\n+     * @see java.lang.reflect.Field#get(Object)\n+     */\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append static fields.\n+     * </p>\n+     *\n+     * @return Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append transient fields.\n+     * </p>\n+     *\n+     * @return Whether or not to append transient fields.\n+     */\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append to the <code>toString</code> an <code>Object</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append static fields.\n+     * </p>\n+     *\n+     * @param appendStatics\n+     *            Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append transient fields.\n+     * </p>\n+     *\n+     * @param appendTransients\n+     *            Whether or not to append transient fields.\n+     */\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n+    }\n+\n+    /**\n+     * Sets the field names to exclude.\n+     *\n+     * @param excludeFieldNamesParam\n+     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n+     * @return <code>this</code>\n+     */\n+    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n+        } else {\n+            //clone and remove nulls\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the last super class to stop appending fields for.\n+     * </p>\n+     *\n+     * @param clazz\n+     *            The last super class to stop appending fields for.\n+     */\n+    public void setUpToClass(Class<?> clazz) {\n+        if (clazz != null) {\n+            Object object = getObject();\n+            if (object != null && clazz.isInstance(object) == false) {\n+                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n+            }\n+        }\n+        this.upToClass = clazz;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the String built by this builder.\n+     * </p>\n+     *\n+     * @return the built string\n+     */\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class<?> clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+\n+}\n",
            "diff_size": 706
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/34/ReflectionToStringBuilder.java\nindex 9ba7082e12..f6761444b9 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/34/ReflectionToStringBuilder.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -96,611 +96,611 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassU\n  * <p>\r\n  * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\r\n  * </p>\r\n- * \r\n+ *\r\n  * @since 2.0\r\n  * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\r\n  */\r\n public class ReflectionToStringBuilder extends ToStringBuilder {\r\n \r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object) {\r\n-        return toString(object, null, false, false, null);\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n+   * Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   */\r\n+  public static String toString(Object object) {\r\n+    return toString(object, null, false, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n+   * Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n+   */\r\n+  public static String toString(Object object, ToStringStyle style) {\r\n+    return toString(object, style, false, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be included. Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   */\r\n+  public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n+    return toString(object, style, outputTransients, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n+   * ignored.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be included. Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @param outputStatics\r\n+   *            whether to include transient fields\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @since 2.1\r\n+   */\r\n+  public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n+    return toString(object, style, outputTransients, outputStatics, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n+   * ignored.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\r\n+   * <code>java.lang.Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param <T>\r\n+   *            the type of the object\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @param outputStatics\r\n+   *            whether to include static fields\r\n+   * @param reflectUpToClass\r\n+   *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @since 2.1\r\n+   */\r\n+  public static <T> String toString(\r\n+    T object, ToStringStyle style, boolean outputTransients,\r\n+    boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n+    return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n+      .toString();\r\n+  }\r\n+\r\n+  /**\r\n+   * Builds a String for a toString method excluding the given field names.\r\n+   *\r\n+   * @param object\r\n+   *            The object to \"toString\".\r\n+   * @param excludeFieldNames\r\n+   *            The field names to exclude. Null excludes nothing.\r\n+   * @return The toString value.\r\n+   */\r\n+  public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n+    return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n+  }\r\n+\r\n+  /**\r\n+   * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\r\n+   * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\r\n+   * is <code>null</code>.\r\n+   *\r\n+   * @param collection\r\n+   *            The collection to convert\r\n+   * @return A new array of Strings.\r\n+   */\r\n+  static String[] toNoNullStringArray(Collection<String> collection) {\r\n+    if (collection == null) {\r\n+      return ArrayUtils.EMPTY_STRING_ARRAY;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style) {\r\n-        return toString(object, style, false, false, null);\r\n+    return toNoNullStringArray(collection.toArray());\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\r\n+   * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\r\n+   * if an array element is <code>null</code>.\r\n+   *\r\n+   * @param array\r\n+   *            The array to check\r\n+   * @return The given array or a new array without null.\r\n+   */\r\n+  static String[] toNoNullStringArray(Object[] array) {\r\n+    List<String> list = new ArrayList<String>(array.length);\r\n+    for (Object e : array) {\r\n+      if (e != null) {\r\n+        list.add(e.toString());\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n-        return toString(object, style, outputTransients, false, null);\r\n+    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n+  }\r\n+\r\n+\r\n+  /**\r\n+   * Builds a String for a toString method excluding the given field names.\r\n+   *\r\n+   * @param object\r\n+   *            The object to \"toString\".\r\n+   * @param excludeFieldNames\r\n+   *            The field names to exclude\r\n+   * @return The toString value.\r\n+   */\r\n+  public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n+    return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n+  }\r\n+\r\n+  /**\r\n+   * Whether or not to append static fields.\r\n+   */\r\n+  private boolean appendStatics = false;\r\n+\r\n+  /**\r\n+   * Whether or not to append transient fields.\r\n+   */\r\n+  private boolean appendTransients = false;\r\n+\r\n+  /**\r\n+   * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n+   *\r\n+   * @since 3.0 this is protected instead of private\r\n+   */\r\n+  protected String[] excludeFieldNames;\r\n+\r\n+  /**\r\n+   * The last super class to stop appending fields for.\r\n+   */\r\n+  private Class<?> upToClass = null;\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Constructor.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object passed in is <code>null</code>\r\n+   */\r\n+  public ReflectionToStringBuilder(Object object) {\r\n+    super(object);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Constructor.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default style is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object passed in is <code>null</code>\r\n+   */\r\n+  public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n+    super(object, style);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Constructor.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default style is used.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the buffer is <code>null</code>, a new one is created.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param buffer\r\n+   *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object passed in is <code>null</code>\r\n+   */\r\n+  public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n+    super(object, style, buffer);\r\n+  }\r\n+\r\n+  /**\r\n+   * Constructor.\r\n+   *\r\n+   * @param <T>\r\n+   *            the type of the object\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param buffer\r\n+   *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n+   * @param reflectUpToClass\r\n+   *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @param outputStatics\r\n+   *            whether to include static fields\r\n+   * @since 2.1\r\n+   */\r\n+  public <T> ReflectionToStringBuilder(\r\n+    T object, ToStringStyle style, StringBuffer buffer,\r\n+    Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n+    super(object, style, buffer);\r\n+    this.setUpToClass(reflectUpToClass);\r\n+    this.setAppendTransients(outputTransients);\r\n+    this.setAppendStatics(outputStatics);\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns whether or not to append the given <code>Field</code>.\r\n+   * <ul>\r\n+   * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\r\n+   * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\r\n+   * <li>Inner class fields are not appened.</li>\r\n+   * </ul>\r\n+   *\r\n+   * @param field\r\n+   *            The Field to test.\r\n+   * @return Whether or not to append the given <code>Field</code>.\r\n+   */\r\n+  protected boolean accept(Field field) {\r\n+    if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n+      // Reject field from inner class.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n-        return toString(object, style, outputTransients, outputStatics, null);\r\n+    if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n+      // Reject transient fields.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\r\n-     * <code>java.lang.Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static <T> String toString(\r\n-            T object, ToStringStyle style, boolean outputTransients,\r\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n-                .toString();\r\n+    if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n+      // Reject static fields.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude. Null excludes nothing.\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n-        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n-    }\r\n-\r\n-    /**\r\n-     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\r\n-     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\r\n-     * is <code>null</code>.\r\n-     *\r\n-     * @param collection\r\n-     *            The collection to convert\r\n-     * @return A new array of Strings.\r\n-     */\r\n-    static String[] toNoNullStringArray(Collection<String> collection) {\r\n-        if (collection == null) {\r\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\r\n-        }\r\n-        return toNoNullStringArray(collection.toArray());\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\r\n-     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\r\n-     * if an array element is <code>null</code>.\r\n-     *\r\n-     * @param array\r\n-     *            The array to check\r\n-     * @return The given array or a new array without null.\r\n-     */\r\n-    static String[] toNoNullStringArray(Object[] array) {\r\n-        List<String> list = new ArrayList<String>(array.length);\r\n-        for (Object e : array) {\r\n-            if (e != null) {\r\n-                list.add(e.toString());\r\n-            }\r\n-        }\r\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n-    }\r\n-\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n-        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether or not to append static fields.\r\n-     */\r\n-    private boolean appendStatics = false;\r\n-\r\n-    /**\r\n-     * Whether or not to append transient fields.\r\n-     */\r\n-    private boolean appendTransients = false;\r\n-\r\n-    /**\r\n-     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n-     *\r\n-     * @since 3.0 this is protected instead of private\r\n-     */\r\n-    protected String[] excludeFieldNames;\r\n-\r\n-    /**\r\n-     * The last super class to stop appending fields for.\r\n-     */\r\n-    private Class<?> upToClass = null;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object) {\r\n-        super(object);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n-        super(object, style);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the buffer is <code>null</code>, a new one is created.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n-        super(object, style, buffer);\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @since 2.1\r\n-     */\r\n-    public <T> ReflectionToStringBuilder(\r\n-            T object, ToStringStyle style, StringBuffer buffer,\r\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n-        super(object, style, buffer);\r\n-        this.setUpToClass(reflectUpToClass);\r\n-        this.setAppendTransients(outputTransients);\r\n-        this.setAppendStatics(outputStatics);\r\n+    if (this.excludeFieldNames != null\r\n+      && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n+      // Reject fields from the getExcludeFieldNames list.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * Returns whether or not to append the given <code>Field</code>.\r\n-     * <ul>\r\n-     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\r\n-     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\r\n-     * <li>Inner class fields are not appened.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to test.\r\n-     * @return Whether or not to append the given <code>Field</code>.\r\n-     */\r\n-    protected boolean accept(Field field) {\r\n-        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n-            // Reject field from inner class.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n-            // Reject transient fields.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n-            // Reject static fields.\r\n-            return false;\r\n-        }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n-            // Reject fields from the getExcludeFieldNames list.\r\n-            return false;\r\n-        }\r\n-        return true;\r\n+    return true;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Appends the fields and values defined by the given object of the given Class.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\r\n+   * <code>Object.toString()</code> had been called and not implemented by the object.\r\n+   * </p>\r\n+   *\r\n+   * @param clazz\r\n+   *            The class of object parameter\r\n+   */\r\n+  protected void appendFieldsIn(Class<?> clazz) {\r\n+    if (clazz.isArray()) {\r\n+      this.reflectionAppendArray(this.getObject());\r\n+      return;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given Class.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\r\n-     * <code>Object.toString()</code> had been called and not implemented by the object.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The class of object parameter\r\n-     */\r\n-    protected void appendFieldsIn(Class<?> clazz) {\r\n-        if (clazz.isArray()) {\r\n-            this.reflectionAppendArray(this.getObject());\r\n-            return;\r\n-        }\r\n-        Field[] fields = clazz.getDeclaredFields();\r\n-        AccessibleObject.setAccessible(fields, true);\r\n-        for (Field field : fields) {\r\n-            String fieldName = field.getName();\r\n-            if (this.accept(field)) {\r\n-                try {\r\n-                    // Warning: Field.get(Object) creates wrappers objects\r\n-                    // for primitive types.\r\n-                    Object fieldValue = this.getValue(field);\r\n-                    this.append(fieldName, fieldValue);\r\n-                } catch (IllegalAccessException ex) {\r\n-                    //this can't happen. Would get a Security exception\r\n-                    // instead\r\n-                    //throw a runtime exception in case the impossible\r\n-                    // happens.\r\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n-                }\r\n-            }\r\n+    Field[] fields = clazz.getDeclaredFields();\r\n+    AccessibleObject.setAccessible(fields, true);\r\n+    for (Field field : fields) {\r\n+      String fieldName = field.getName();\r\n+      if (this.accept(field)) {\r\n+        try {\r\n+          // Warning: Field.get(Object) creates wrappers objects\r\n+          // for primitive types.\r\n+          Object fieldValue = this.getValue(field);\r\n+          this.append(fieldName, fieldValue);\r\n+        } catch (IllegalAccessException ex) {\r\n+          //this can't happen. Would get a Security exception\r\n+          // instead\r\n+          //throw a runtime exception in case the impossible\r\n+          // happens.\r\n+          throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n         }\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * @return Returns the excludeFieldNames.\r\n-     */\r\n-    public String[] getExcludeFieldNames() {\r\n-        return this.excludeFieldNames.clone();\r\n+  }\r\n+\r\n+  /**\r\n+   * @return Returns the excludeFieldNames.\r\n+   */\r\n+  public String[] getExcludeFieldNames() {\r\n+    return this.excludeFieldNames.clone();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets the last super class to stop appending fields for.\r\n+   * </p>\r\n+   *\r\n+   * @return The last super class to stop appending fields for.\r\n+   */\r\n+  public Class<?> getUpToClass() {\r\n+    return this.upToClass;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Calls <code>java.lang.reflect.Field.get(Object)</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param field\r\n+   *            The Field to query.\r\n+   * @return The Object from the given Field.\r\n+   *\r\n+   * @throws IllegalArgumentException\r\n+   *             see {@link java.lang.reflect.Field#get(Object)}\r\n+   * @throws IllegalAccessException\r\n+   *             see {@link java.lang.reflect.Field#get(Object)}\r\n+   *\r\n+   * @see java.lang.reflect.Field#get(Object)\r\n+   */\r\n+  protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n+    return field.get(this.getObject());\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets whether or not to append static fields.\r\n+   * </p>\r\n+   *\r\n+   * @return Whether or not to append static fields.\r\n+   * @since 2.1\r\n+   */\r\n+  public boolean isAppendStatics() {\r\n+    return this.appendStatics;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets whether or not to append transient fields.\r\n+   * </p>\r\n+   *\r\n+   * @return Whether or not to append transient fields.\r\n+   */\r\n+  public boolean isAppendTransients() {\r\n+    return this.appendTransients;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append to the <code>toString</code> an <code>Object</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>toString</code>\r\n+   * @return this\r\n+   */\r\n+  public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n+    this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Sets whether or not to append static fields.\r\n+   * </p>\r\n+   *\r\n+   * @param appendStatics\r\n+   *            Whether or not to append static fields.\r\n+   * @since 2.1\r\n+   */\r\n+  public void setAppendStatics(boolean appendStatics) {\r\n+    this.appendStatics = appendStatics;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Sets whether or not to append transient fields.\r\n+   * </p>\r\n+   *\r\n+   * @param appendTransients\r\n+   *            Whether or not to append transient fields.\r\n+   */\r\n+  public void setAppendTransients(boolean appendTransients) {\r\n+    this.appendTransients = appendTransients;\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets the field names to exclude.\r\n+   *\r\n+   * @param excludeFieldNamesParam\r\n+   *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n+   * @return <code>this</code>\r\n+   */\r\n+  public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n+    if (excludeFieldNamesParam == null) {\r\n+      this.excludeFieldNames = null;\r\n+    } else {\r\n+      //clone and remove nulls\r\n+      this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n+      Arrays.sort(this.excludeFieldNames);\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @return The last super class to stop appending fields for.\r\n-     */\r\n-    public Class<?> getUpToClass() {\r\n-        return this.upToClass;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to query.\r\n-     * @return The Object from the given Field.\r\n-     *\r\n-     * @throws IllegalArgumentException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     * @throws IllegalAccessException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     *\r\n-     * @see java.lang.reflect.Field#get(Object)\r\n-     */\r\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n-        return field.get(this.getObject());\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Sets the last super class to stop appending fields for.\r\n+   * </p>\r\n+   *\r\n+   * @param clazz\r\n+   *            The last super class to stop appending fields for.\r\n+   */\r\n+  public void setUpToClass(Class<?> clazz) {\r\n+    if (clazz != null) {\r\n+      Object object = getObject();\r\n+      if (object != null && clazz.isInstance(object) == false) {\r\n+        throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public boolean isAppendStatics() {\r\n-        return this.appendStatics;\r\n+    this.upToClass = clazz;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets the String built by this builder.\r\n+   * </p>\r\n+   *\r\n+   * @return the built string\r\n+   */\r\n+  @Override\r\n+  public String toString() {\r\n+    if (this.getObject() == null) {\r\n+      return this.getStyle().getNullText();\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append transient fields.\r\n-     */\r\n-    public boolean isAppendTransients() {\r\n-        return this.appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append to the <code>toString</code> an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>toString</code>\r\n-     * @return this\r\n-     */\r\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n-        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendStatics\r\n-     *            Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public void setAppendStatics(boolean appendStatics) {\r\n-        this.appendStatics = appendStatics;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendTransients\r\n-     *            Whether or not to append transient fields.\r\n-     */\r\n-    public void setAppendTransients(boolean appendTransients) {\r\n-        this.appendTransients = appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the field names to exclude.\r\n-     *\r\n-     * @param excludeFieldNamesParam\r\n-     *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n-     * @return <code>this</code>\r\n-     */\r\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n-        if (excludeFieldNamesParam == null) {\r\n-            this.excludeFieldNames = null;\r\n-        } else {\r\n-            //clone and remove nulls\r\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n-            Arrays.sort(this.excludeFieldNames);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The last super class to stop appending fields for.\r\n-     */\r\n-    public void setUpToClass(Class<?> clazz) {\r\n-        if (clazz != null) {\r\n-            Object object = getObject();\r\n-            if (object != null && clazz.isInstance(object) == false) {\r\n-                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n-            }\r\n-        }\r\n-        this.upToClass = clazz;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the String built by this builder.\r\n-     * </p>\r\n-     *\r\n-     * @return the built string\r\n-     */\r\n-    @Override\r\n-    public String toString() {\r\n-        if (this.getObject() == null) {\r\n-            return this.getStyle().getNullText();\r\n-        }\r\n-        Class<?> clazz = this.getObject().getClass();\r\n-        this.appendFieldsIn(clazz);\r\n-        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n-            clazz = clazz.getSuperclass();\r\n-            this.appendFieldsIn(clazz);\r\n-        }\r\n-        return super.toString();\r\n+    Class<?> clazz = this.getObject().getClass();\r\n+    this.appendFieldsIn(clazz);\r\n+    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n+      clazz = clazz.getSuperclass();\r\n+      this.appendFieldsIn(clazz);\r\n     }\r\n+    return super.toString();\r\n+  }\r\n \r\n }\r\n",
            "diff_size": 1015
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/34/ReflectionToStringBuilder.java\nindex 9ba7082e12..ef486fecd5 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/34/ReflectionToStringBuilder.java\n@@ -499,8 +499,8 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n             // Reject static fields.\r\n             return false;\r\n         }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n+        if (this.excludeFieldNames != null\n+&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n             // Reject fields from the getExcludeFieldNames list.\r\n             return false;\r\n         }\r\n@@ -703,4 +703,4 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n         return super.toString();\r\n     }\r\n \r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "98",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/34/ReflectionToStringBuilder.java\nindex 9ba7082e12..a5bbfee0ae 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/34/ReflectionToStringBuilder.java\n@@ -30,17 +30,16 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.List;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassUtils;\r\n \r\n /**\r\n@@ -99,7 +98,9 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassU\n  * \r\n  * @since 2.0\r\n  * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\r\n- */\r\n+ */\n+\n+\n public class ReflectionToStringBuilder extends ToStringBuilder {\r\n \r\n     /**\r\n@@ -123,9 +124,9 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @return the String result\r\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object) {\r\n-        return toString(object, null, false, false, null);\r\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n     }\r\n \r\n     /**\r\n@@ -155,9 +156,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @return the String result\r\n      * @throws IllegalArgumentException\r\n      *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style) {\r\n-        return toString(object, style, false, false, null);\r\n+     */\n+\n+\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n     }\r\n \r\n     /**\r\n@@ -193,9 +196,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @return the String result\r\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n-        return toString(object, style, outputTransients, false, null);\r\n+     */\n+\n+\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n     }\r\n \r\n     /**\r\n@@ -239,9 +244,15 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n      * @since 2.1\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n-        return toString(object, style, outputTransients, outputStatics, null);\r\n+     */\n+\n+\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object,\n+                        style,\n+                        outputTransients,\n+                        outputStatics,\n+                        null);\n     }\r\n \r\n     /**\r\n@@ -290,12 +301,14 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n      * @since 2.1\r\n-     */\r\n-    public static <T> String toString(\r\n-            T object, ToStringStyle style, boolean outputTransients,\r\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n-                .toString();\r\n+     */\n+\n+\n+    public static <T> String toString(T object,\n+                                      ToStringStyle style,\n+                                      boolean outputTransients,\n+                                      boolean outputStatics, Class<? super T> reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n     }\r\n \r\n     /**\r\n@@ -306,9 +319,12 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param excludeFieldNames\r\n      *            The field names to exclude. Null excludes nothing.\r\n      * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n-        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n+     */\n+\n+\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+        return toStringExclude(object,\n+                               toNoNullStringArray(excludeFieldNames));\n     }\r\n \r\n     /**\r\n@@ -319,12 +335,14 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param collection\r\n      *            The collection to convert\r\n      * @return A new array of Strings.\r\n-     */\r\n-    static String[] toNoNullStringArray(Collection<String> collection) {\r\n-        if (collection == null) {\r\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\r\n-        }\r\n-        return toNoNullStringArray(collection.toArray());\r\n+     */\n+\n+\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n     }\r\n \r\n     /**\r\n@@ -335,15 +353,17 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param array\r\n      *            The array to check\r\n      * @return The given array or a new array without null.\r\n-     */\r\n-    static String[] toNoNullStringArray(Object[] array) {\r\n-        List<String> list = new ArrayList<String>(array.length);\r\n-        for (Object e : array) {\r\n-            if (e != null) {\r\n-                list.add(e.toString());\r\n-            }\r\n-        }\r\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n+     */\n+\n+\n+    static String[] toNoNullStringArray(Object[] array) {\n+        List<String> list = new ArrayList<String>(array.length);\n+        for (Object e : array) {\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\r\n \r\n \r\n@@ -355,31 +375,35 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param excludeFieldNames\r\n      *            The field names to exclude\r\n      * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n-        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n+     */\n+\n+\n+    public static String toStringExclude(Object object, String... excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n     }\r\n \r\n     /**\r\n      * Whether or not to append static fields.\r\n-     */\r\n+     */\n+\n     private boolean appendStatics = false;\r\n \r\n     /**\r\n      * Whether or not to append transient fields.\r\n-     */\r\n+     */\n     private boolean appendTransients = false;\r\n \r\n     /**\r\n      * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n      *\r\n      * @since 3.0 this is protected instead of private\r\n-     */\r\n+     */\n+\n     protected String[] excludeFieldNames;\r\n \r\n     /**\r\n      * The last super class to stop appending fields for.\r\n-     */\r\n+     */\n     private Class<?> upToClass = null;\r\n \r\n     /**\r\n@@ -395,9 +419,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object) {\r\n-        super(object);\r\n+     */\n+\n+\n+    public ReflectionToStringBuilder(Object object) {\n+    super(object);\n     }\r\n \r\n     /**\r\n@@ -415,9 +441,10 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n-        super(object, style);\r\n+     */\n+\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+    super(object, style);\n     }\r\n \r\n     /**\r\n@@ -441,9 +468,10 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n-        super(object, style, buffer);\r\n+     */\n+\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+    super(object, style, buffer);\n     }\r\n \r\n     /**\r\n@@ -464,14 +492,13 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param outputStatics\r\n      *            whether to include static fields\r\n      * @since 2.1\r\n-     */\r\n-    public <T> ReflectionToStringBuilder(\r\n-            T object, ToStringStyle style, StringBuffer buffer,\r\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n-        super(object, style, buffer);\r\n-        this.setUpToClass(reflectUpToClass);\r\n-        this.setAppendTransients(outputTransients);\r\n-        this.setAppendStatics(outputStatics);\r\n+     */\n+\n+    public <T> ReflectionToStringBuilder(T object, ToStringStyle style, StringBuffer buffer, Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+    super(object, style, buffer);\n+    this.setUpToClass(reflectUpToClass);\n+    this.setAppendTransients(outputTransients);\n+    this.setAppendStatics(outputStatics);\n     }\r\n \r\n     /**\r\n@@ -485,26 +512,29 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param field\r\n      *            The Field to test.\r\n      * @return Whether or not to append the given <code>Field</code>.\r\n-     */\r\n-    protected boolean accept(Field field) {\r\n+     */\n+\n+    protected boolean accept(Field field) {\n         if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n-            // Reject field from inner class.\r\n-            return false;\r\n-        }\r\n+            // Reject field from inner class.\n+            return false;\n+        }\n+\n         if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n-            // Reject transient fields.\r\n-            return false;\r\n-        }\r\n+            // Reject transient fields.\n+            return false;\n+        }\n+\n         if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n-            // Reject static fields.\r\n-            return false;\r\n-        }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n-            // Reject fields from the getExcludeFieldNames list.\r\n-            return false;\r\n-        }\r\n-        return true;\r\n+            // Reject static fields.\n+            return false;\n+        }\n+\n+        if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n     }\r\n \r\n     /**\r\n@@ -519,38 +549,43 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @param clazz\r\n      *            The class of object parameter\r\n-     */\r\n-    protected void appendFieldsIn(Class<?> clazz) {\r\n-        if (clazz.isArray()) {\r\n-            this.reflectionAppendArray(this.getObject());\r\n-            return;\r\n-        }\r\n-        Field[] fields = clazz.getDeclaredFields();\r\n-        AccessibleObject.setAccessible(fields, true);\r\n-        for (Field field : fields) {\r\n-            String fieldName = field.getName();\r\n-            if (this.accept(field)) {\r\n+     */\n+\n+\n+    protected void appendFieldsIn(Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n+            return;\n+        }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+\n+        for (Field field : fields) {\n+            String fieldName = field.getName();\n+            if (this.accept(field)) {\n                 try {\r\n                     // Warning: Field.get(Object) creates wrappers objects\r\n-                    // for primitive types.\r\n-                    Object fieldValue = this.getValue(field);\r\n-                    this.append(fieldName, fieldValue);\r\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n                 } catch (IllegalAccessException ex) {\r\n                     //this can't happen. Would get a Security exception\r\n                     // instead\r\n                     //throw a runtime exception in case the impossible\r\n-                    // happens.\r\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n-                }\r\n-            }\r\n-        }\r\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                }\n+            }\n+        }\n     }\r\n \r\n     /**\r\n      * @return Returns the excludeFieldNames.\r\n-     */\r\n-    public String[] getExcludeFieldNames() {\r\n-        return this.excludeFieldNames.clone();\r\n+     */\n+\n+\n+    public String[] getExcludeFieldNames() {\n+    return this.excludeFieldNames.clone();\n     }\r\n \r\n     /**\r\n@@ -559,9 +594,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * </p>\r\n      *\r\n      * @return The last super class to stop appending fields for.\r\n-     */\r\n-    public Class<?> getUpToClass() {\r\n-        return this.upToClass;\r\n+     */\n+\n+\n+    public Class<?> getUpToClass() {\n+    return this.upToClass;\n     }\r\n \r\n     /**\r\n@@ -579,9 +616,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *             see {@link java.lang.reflect.Field#get(Object)}\r\n      *\r\n      * @see java.lang.reflect.Field#get(Object)\r\n-     */\r\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n-        return field.get(this.getObject());\r\n+     */\n+\n+\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+    return field.get(this.getObject());\n     }\r\n \r\n     /**\r\n@@ -591,9 +630,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @return Whether or not to append static fields.\r\n      * @since 2.1\r\n-     */\r\n-    public boolean isAppendStatics() {\r\n-        return this.appendStatics;\r\n+     */\n+\n+\n+    public boolean isAppendStatics() {\n+    return this.appendStatics;\n     }\r\n \r\n     /**\r\n@@ -602,9 +643,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * </p>\r\n      *\r\n      * @return Whether or not to append transient fields.\r\n-     */\r\n-    public boolean isAppendTransients() {\r\n-        return this.appendTransients;\r\n+     */\n+\n+\n+    public boolean isAppendTransients() {\n+    return this.appendTransients;\n     }\r\n \r\n     /**\r\n@@ -615,10 +658,12 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param array\r\n      *            the array to add to the <code>toString</code>\r\n      * @return this\r\n-     */\r\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n-        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n-        return this;\r\n+     */\n+\n+\n+    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -629,9 +674,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param appendStatics\r\n      *            Whether or not to append static fields.\r\n      * @since 2.1\r\n-     */\r\n-    public void setAppendStatics(boolean appendStatics) {\r\n-        this.appendStatics = appendStatics;\r\n+     */\n+\n+\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n     }\r\n \r\n     /**\r\n@@ -641,9 +688,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @param appendTransients\r\n      *            Whether or not to append transient fields.\r\n-     */\r\n-    public void setAppendTransients(boolean appendTransients) {\r\n-        this.appendTransients = appendTransients;\r\n+     */\n+\n+\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n     }\r\n \r\n     /**\r\n@@ -652,16 +701,18 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param excludeFieldNamesParam\r\n      *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n      * @return <code>this</code>\r\n-     */\r\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n-        if (excludeFieldNamesParam == null) {\r\n-            this.excludeFieldNames = null;\r\n+     */\n+\n+\n+    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n         } else {\r\n-            //clone and remove nulls\r\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n-            Arrays.sort(this.excludeFieldNames);\r\n-        }\r\n-        return this;\r\n+            //clone and remove nulls\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -671,15 +722,17 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @param clazz\r\n      *            The last super class to stop appending fields for.\r\n-     */\r\n-    public void setUpToClass(Class<?> clazz) {\r\n-        if (clazz != null) {\r\n-            Object object = getObject();\r\n-            if (object != null && clazz.isInstance(object) == false) {\r\n-                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n-            }\r\n-        }\r\n-        this.upToClass = clazz;\r\n+     */\n+\n+\n+    public void setUpToClass(Class<?> clazz) {\n+        if (clazz != null) {\n+            Object object = getObject();\n+            if (object != null && clazz.isInstance(object) == false) {\n+                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n+            }\n+        }\n+        this.upToClass = clazz;\n     }\r\n \r\n     /**\r\n@@ -688,19 +741,21 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * </p>\r\n      *\r\n      * @return the built string\r\n-     */\r\n-    @Override\r\n-    public String toString() {\r\n-        if (this.getObject() == null) {\r\n-            return this.getStyle().getNullText();\r\n-        }\r\n-        Class<?> clazz = this.getObject().getClass();\r\n-        this.appendFieldsIn(clazz);\r\n-        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n-            clazz = clazz.getSuperclass();\r\n-            this.appendFieldsIn(clazz);\r\n-        }\r\n-        return super.toString();\r\n-    }\r\n-\r\n-}\r\n+     */\n+\n+\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class<?> clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 224
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "46",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 0, expected is 4, indentation should be the same level as line 102.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/34/ReflectionToStringBuilder.java\nindex 9ba7082e12..3e9d298750 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/34/ReflectionToStringBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/34/ReflectionToStringBuilder.java\n@@ -1,706 +1,705 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.List;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassUtils;\r\n-\r\n-/**\r\n- * <p>\r\n- * Assists in implementing {@link Object#toString()} methods using reflection.\r\n- * </p>\r\n- * <p>\r\n- * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\r\n- * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\r\n- * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\r\n- * set up correctly.\r\n- * </p>\r\n- * <p>\r\n- * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these\r\n- * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use\r\n- * synchronization consistent with the class' lock management around the invocation of the method. Take special care to\r\n- * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if\r\n- * modified while the toString method is executing.\r\n- * </p>\r\n- * <p>\r\n- * A typical invocation for this method would look like:\r\n- * </p>\r\n- * <pre>\r\n- * public String toString() {\r\n- *     return ReflectionToStringBuilder.toString(this);\r\n- * }\r\n- * </pre>\r\n- * <p>\r\n- * You can also use the builder to debug 3rd party objects:\r\n- * </p>\r\n- * <pre>\r\n- * System.out.println(&quot;An object: &quot; + ReflectionToStringBuilder.toString(anObject));\r\n- * </pre>\r\n- * <p>\r\n- * A subclass can control field output by overriding the methods:\r\n- * <ul>\r\n- * <li>{@link #accept(java.lang.reflect.Field)}</li>\r\n- * <li>{@link #getValue(java.lang.reflect.Field)}</li>\r\n- * </ul>\r\n- * </p>\r\n- * <p>\r\n- * For example, this method does <i>not</i> include the <code>password</code> field in the returned <code>String</code>:\r\n- * </p>\r\n- * <pre>\r\n- * public String toString() {\r\n- *     return (new ReflectionToStringBuilder(this) {\r\n- *         protected boolean accept(Field f) {\r\n- *             return super.accept(f) &amp;&amp; !f.getName().equals(&quot;password&quot;);\r\n- *         }\r\n- *     }).toString();\r\n- * }\r\n- * </pre>\r\n- * <p>\r\n- * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\r\n- * </p>\r\n- * \r\n- * @since 2.0\r\n- * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\r\n- */\r\n-public class ReflectionToStringBuilder extends ToStringBuilder {\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object) {\r\n-        return toString(object, null, false, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style) {\r\n-        return toString(object, style, false, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n-        return toString(object, style, outputTransients, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n-        return toString(object, style, outputTransients, outputStatics, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\r\n-     * <code>java.lang.Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static <T> String toString(\r\n-            T object, ToStringStyle style, boolean outputTransients,\r\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n-                .toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude. Null excludes nothing.\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n-        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n-    }\r\n-\r\n-    /**\r\n-     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\r\n-     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\r\n-     * is <code>null</code>.\r\n-     *\r\n-     * @param collection\r\n-     *            The collection to convert\r\n-     * @return A new array of Strings.\r\n-     */\r\n-    static String[] toNoNullStringArray(Collection<String> collection) {\r\n-        if (collection == null) {\r\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\r\n-        }\r\n-        return toNoNullStringArray(collection.toArray());\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\r\n-     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\r\n-     * if an array element is <code>null</code>.\r\n-     *\r\n-     * @param array\r\n-     *            The array to check\r\n-     * @return The given array or a new array without null.\r\n-     */\r\n-    static String[] toNoNullStringArray(Object[] array) {\r\n-        List<String> list = new ArrayList<String>(array.length);\r\n-        for (Object e : array) {\r\n-            if (e != null) {\r\n-                list.add(e.toString());\r\n-            }\r\n-        }\r\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n-    }\r\n-\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n-        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether or not to append static fields.\r\n-     */\r\n-    private boolean appendStatics = false;\r\n-\r\n-    /**\r\n-     * Whether or not to append transient fields.\r\n-     */\r\n-    private boolean appendTransients = false;\r\n-\r\n-    /**\r\n-     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n-     *\r\n-     * @since 3.0 this is protected instead of private\r\n-     */\r\n-    protected String[] excludeFieldNames;\r\n-\r\n-    /**\r\n-     * The last super class to stop appending fields for.\r\n-     */\r\n-    private Class<?> upToClass = null;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object) {\r\n-        super(object);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n-        super(object, style);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the buffer is <code>null</code>, a new one is created.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n-        super(object, style, buffer);\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @since 2.1\r\n-     */\r\n-    public <T> ReflectionToStringBuilder(\r\n-            T object, ToStringStyle style, StringBuffer buffer,\r\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n-        super(object, style, buffer);\r\n-        this.setUpToClass(reflectUpToClass);\r\n-        this.setAppendTransients(outputTransients);\r\n-        this.setAppendStatics(outputStatics);\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns whether or not to append the given <code>Field</code>.\r\n-     * <ul>\r\n-     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\r\n-     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\r\n-     * <li>Inner class fields are not appened.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to test.\r\n-     * @return Whether or not to append the given <code>Field</code>.\r\n-     */\r\n-    protected boolean accept(Field field) {\r\n-        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n-            // Reject field from inner class.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n-            // Reject transient fields.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n-            // Reject static fields.\r\n-            return false;\r\n-        }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n-            // Reject fields from the getExcludeFieldNames list.\r\n-            return false;\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given Class.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\r\n-     * <code>Object.toString()</code> had been called and not implemented by the object.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The class of object parameter\r\n-     */\r\n-    protected void appendFieldsIn(Class<?> clazz) {\r\n-        if (clazz.isArray()) {\r\n-            this.reflectionAppendArray(this.getObject());\r\n-            return;\r\n-        }\r\n-        Field[] fields = clazz.getDeclaredFields();\r\n-        AccessibleObject.setAccessible(fields, true);\r\n-        for (Field field : fields) {\r\n-            String fieldName = field.getName();\r\n-            if (this.accept(field)) {\r\n-                try {\r\n-                    // Warning: Field.get(Object) creates wrappers objects\r\n-                    // for primitive types.\r\n-                    Object fieldValue = this.getValue(field);\r\n-                    this.append(fieldName, fieldValue);\r\n-                } catch (IllegalAccessException ex) {\r\n-                    //this can't happen. Would get a Security exception\r\n-                    // instead\r\n-                    //throw a runtime exception in case the impossible\r\n-                    // happens.\r\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return Returns the excludeFieldNames.\r\n-     */\r\n-    public String[] getExcludeFieldNames() {\r\n-        return this.excludeFieldNames.clone();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @return The last super class to stop appending fields for.\r\n-     */\r\n-    public Class<?> getUpToClass() {\r\n-        return this.upToClass;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to query.\r\n-     * @return The Object from the given Field.\r\n-     *\r\n-     * @throws IllegalArgumentException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     * @throws IllegalAccessException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     *\r\n-     * @see java.lang.reflect.Field#get(Object)\r\n-     */\r\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n-        return field.get(this.getObject());\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public boolean isAppendStatics() {\r\n-        return this.appendStatics;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append transient fields.\r\n-     */\r\n-    public boolean isAppendTransients() {\r\n-        return this.appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append to the <code>toString</code> an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>toString</code>\r\n-     * @return this\r\n-     */\r\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n-        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendStatics\r\n-     *            Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public void setAppendStatics(boolean appendStatics) {\r\n-        this.appendStatics = appendStatics;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendTransients\r\n-     *            Whether or not to append transient fields.\r\n-     */\r\n-    public void setAppendTransients(boolean appendTransients) {\r\n-        this.appendTransients = appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the field names to exclude.\r\n-     *\r\n-     * @param excludeFieldNamesParam\r\n-     *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n-     * @return <code>this</code>\r\n-     */\r\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n-        if (excludeFieldNamesParam == null) {\r\n-            this.excludeFieldNames = null;\r\n-        } else {\r\n-            //clone and remove nulls\r\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n-            Arrays.sort(this.excludeFieldNames);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The last super class to stop appending fields for.\r\n-     */\r\n-    public void setUpToClass(Class<?> clazz) {\r\n-        if (clazz != null) {\r\n-            Object object = getObject();\r\n-            if (object != null && clazz.isInstance(object) == false) {\r\n-                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n-            }\r\n-        }\r\n-        this.upToClass = clazz;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the String built by this builder.\r\n-     * </p>\r\n-     *\r\n-     * @return the built string\r\n-     */\r\n-    @Override\r\n-    public String toString() {\r\n-        if (this.getObject() == null) {\r\n-            return this.getStyle().getNullText();\r\n-        }\r\n-        Class<?> clazz = this.getObject().getClass();\r\n-        this.appendFieldsIn(clazz);\r\n-        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n-            clazz = clazz.getSuperclass();\r\n-            this.appendFieldsIn(clazz);\r\n-        }\r\n-        return super.toString();\r\n-    }\r\n-\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#toString()} methods using reflection.\n+ * </p>\n+ * <p>\n+ * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n+ * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n+ * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n+ * set up correctly.\n+ * </p>\n+ * <p>\n+ * Using reflection to access (private) fields circumvents any synchronization protection guarding access to these\n+ * fields. If a toString method cannot safely read a field, you should exclude it from the toString method, or use\n+ * synchronization consistent with the class' lock management around the invocation of the method. Take special care to\n+ * exclude non-thread-safe collection classes, because these classes may throw ConcurrentModificationException if\n+ * modified while the toString method is executing.\n+ * </p>\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * <pre>\n+ * public String toString() {\n+ *     return ReflectionToStringBuilder.toString(this);\n+ * }\n+ * </pre>\n+ * <p>\n+ * You can also use the builder to debug 3rd party objects:\n+ * </p>\n+ * <pre>\n+ * System.out.println(&quot;An object: &quot; + ReflectionToStringBuilder.toString(anObject));\n+ * </pre>\n+ * <p>\n+ * A subclass can control field output by overriding the methods:\n+ * <ul>\n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * For example, this method does <i>not</i> include the <code>password</code> field in the returned <code>String</code>:\n+ * </p>\n+ * <pre>\n+ * public String toString() {\n+ *     return (new ReflectionToStringBuilder(this) {\n+ *         protected boolean accept(Field f) {\n+ *             return super.accept(f) &amp;&amp; !f.getName().equals(&quot;password&quot;);\n+ *         }\n+ *     }).toString();\n+ * }\n+ * </pre>\n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\n+ * </p>\n+ * \n+ * @since 2.0\n+ * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\n+ */ public class ReflectionToStringBuilder extends ToStringBuilder {\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object, style, outputTransients, outputStatics, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     *\n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     *\n+     * <p>\n+     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n+     * <code>java.lang.Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     *\n+     * @param <T>\n+     *            the type of the object\n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static <T> String toString(\n+            T object, ToStringStyle style, boolean outputTransients,\n+            boolean outputStatics, Class<? super T> reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n+                .toString();\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     *\n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude. Null excludes nothing.\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n+    }\n+\n+    /**\n+     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n+     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\n+     * is <code>null</code>.\n+     *\n+     * @param collection\n+     *            The collection to convert\n+     * @return A new array of Strings.\n+     */\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n+    }\n+\n+    /**\n+     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n+     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\n+     * if an array element is <code>null</code>.\n+     *\n+     * @param array\n+     *            The array to check\n+     * @return The given array or a new array without null.\n+     */\n+    static String[] toNoNullStringArray(Object[] array) {\n+        List<String> list = new ArrayList<String>(array.length);\n+        for (Object e : array) {\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+    }\n+\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     *\n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, String... excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n+    }\n+\n+    /**\n+     * Whether or not to append static fields.\n+     */\n+    private boolean appendStatics = false;\n+\n+    /**\n+     * Whether or not to append transient fields.\n+     */\n+    private boolean appendTransients = false;\n+\n+    /**\n+     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n+     *\n+     * @since 3.0 this is protected instead of private\n+     */\n+    protected String[] excludeFieldNames;\n+\n+    /**\n+     * The last super class to stop appending fields for.\n+     */\n+    private Class<?> upToClass = null;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+        super(object, style);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     *\n+     * <p>\n+     * If the buffer is <code>null</code>, a new one is created.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super(object, style, buffer);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param <T>\n+     *            the type of the object\n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @since 2.1\n+     */\n+    public <T> ReflectionToStringBuilder(\n+            T object, ToStringStyle style, StringBuffer buffer,\n+            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+        this.setAppendStatics(outputStatics);\n+    }\n+\n+    /**\n+     * Returns whether or not to append the given <code>Field</code>.\n+     * <ul>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n+     * </ul>\n+     *\n+     * @param field\n+     *            The Field to test.\n+     * @return Whether or not to append the given <code>Field</code>.\n+     */\n+    protected boolean accept(Field field) {\n+        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+            // Reject field from inner class.\n+            return false;\n+        }\n+        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n+            // Reject transient fields.\n+            return false;\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n+            // Reject static fields.\n+            return false;\n+        }\n+        if (this.excludeFieldNames != null\n+            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given Class.\n+     * </p>\n+     *\n+     * <p>\n+     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n+     * <code>Object.toString()</code> had been called and not implemented by the object.\n+     * </p>\n+     *\n+     * @param clazz\n+     *            The class of object parameter\n+     */\n+    protected void appendFieldsIn(Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n+            return;\n+        }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (Field field : fields) {\n+            String fieldName = field.getName();\n+            if (this.accept(field)) {\n+                try {\n+                    // Warning: Field.get(Object) creates wrappers objects\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n+                } catch (IllegalAccessException ex) {\n+                    //this can't happen. Would get a Security exception\n+                    // instead\n+                    //throw a runtime exception in case the impossible\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return Returns the excludeFieldNames.\n+     */\n+    public String[] getExcludeFieldNames() {\n+        return this.excludeFieldNames.clone();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the last super class to stop appending fields for.\n+     * </p>\n+     *\n+     * @return The last super class to stop appending fields for.\n+     */\n+    public Class<?> getUpToClass() {\n+        return this.upToClass;\n+    }\n+\n+    /**\n+     * <p>\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n+     * </p>\n+     *\n+     * @param field\n+     *            The Field to query.\n+     * @return The Object from the given Field.\n+     *\n+     * @throws IllegalArgumentException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * @throws IllegalAccessException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     *\n+     * @see java.lang.reflect.Field#get(Object)\n+     */\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append static fields.\n+     * </p>\n+     *\n+     * @return Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append transient fields.\n+     * </p>\n+     *\n+     * @return Whether or not to append transient fields.\n+     */\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append to the <code>toString</code> an <code>Object</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append static fields.\n+     * </p>\n+     *\n+     * @param appendStatics\n+     *            Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append transient fields.\n+     * </p>\n+     *\n+     * @param appendTransients\n+     *            Whether or not to append transient fields.\n+     */\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n+    }\n+\n+    /**\n+     * Sets the field names to exclude.\n+     *\n+     * @param excludeFieldNamesParam\n+     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n+     * @return <code>this</code>\n+     */\n+    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n+        } else {\n+            //clone and remove nulls\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the last super class to stop appending fields for.\n+     * </p>\n+     *\n+     * @param clazz\n+     *            The last super class to stop appending fields for.\n+     */\n+    public void setUpToClass(Class<?> clazz) {\n+        if (clazz != null) {\n+            Object object = getObject();\n+            if (object != null && clazz.isInstance(object) == false) {\n+                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n+            }\n+        }\n+        this.upToClass = clazz;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the String built by this builder.\n+     * </p>\n+     *\n+     * @return the built string\n+     */\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class<?> clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+\n+}\n",
            "diff_size": 706
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}