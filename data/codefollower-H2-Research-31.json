{
    "error_id": "31",
    "information": {
        "errors": [
            {
                "line": "923",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                    WeakReference<V> reference = e.reference;\n                    if (reference != null && reference.get() != null) {\n                        break;  // stop trimming if entry holds a value\n                    }\n                }\n                int hash = getHash(e.key);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "923",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "926",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/intellij/31/CacheLongKeyLIRS.java\nindex 466bbf2e82..f7ef02d09c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/intellij/31/CacheLongKeyLIRS.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.cache;\n \n import java.lang.ref.WeakReference;\n@@ -40,8 +41,8 @@ import org.h2.mvstore.DataUtils;\n  * Write access and moving entries to the top of the stack is synchronized per\n  * segment.\n  *\n- * @author Thomas Mueller\n  * @param <V> the value type\n+ * @author Thomas Mueller\n  */\n public class CacheLongKeyLIRS<V> {\n \n@@ -70,8 +71,8 @@ public class CacheLongKeyLIRS<V> {\n         this.nonResidentQueueSize = config.nonResidentQueueSize;\n         this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n         DataUtils.checkArgument(\n-                Integer.bitCount(config.segmentCount) == 1,\n-                \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n+            Integer.bitCount(config.segmentCount) == 1,\n+            \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n         this.segmentCount = config.segmentCount;\n         this.segmentMask = segmentCount - 1;\n         this.stackMoveDistance = config.stackMoveDistance;\n@@ -88,12 +89,13 @@ public class CacheLongKeyLIRS<V> {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n             segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n+                nonResidentQueueSizeHigh);\n         }\n     }\n \n     /**\n      * Determines max size of the data item size to fit into cache\n+     *\n      * @return data items size limit\n      */\n     public long getMaxItemSize() {\n@@ -132,7 +134,7 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Add an entry to the cache using the average memory size.\n      *\n-     * @param key the key (may not be null)\n+     * @param key   the key (may not be null)\n      * @param value the value (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n@@ -145,15 +147,15 @@ public class CacheLongKeyLIRS<V> {\n      * cache yet. This method will usually mark unknown entries as cold and\n      * known entries as hot.\n      *\n-     * @param key the key (may not be null)\n-     * @param value the value (may not be null)\n+     * @param key    the key (may not be null)\n+     * @param value  the value (may not be null)\n      * @param memory the memory used for the given entry\n      * @return the old value, or null if there was no resident entry\n      */\n     public V put(long key, V value, int memory) {\n         if (value == null) {\n             throw DataUtils.newIllegalArgumentException(\n-                    \"The value may not be null\");\n+                \"The value may not be null\");\n         }\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -286,8 +288,8 @@ public class CacheLongKeyLIRS<V> {\n      */\n     public void setMaxMemory(long maxMemory) {\n         DataUtils.checkArgument(\n-                maxMemory > 0,\n-                \"Max memory must be larger than 0, is {0}\", maxMemory);\n+            maxMemory > 0,\n+            \"Max memory must be larger than 0, is {0}\", maxMemory);\n         this.maxMemory = maxMemory;\n         if (segments != null) {\n             long max = 1 + maxMemory / segments.length;\n@@ -417,7 +419,7 @@ public class CacheLongKeyLIRS<V> {\n      * Get the list of keys. This method allows to read the internal state of\n      * the cache.\n      *\n-     * @param cold if true, only keys for the cold entries are returned\n+     * @param cold        if true, only keys for the cold entries are returned\n      * @param nonResident true for non-resident entries\n      * @return the key list\n      */\n@@ -610,12 +612,13 @@ public class CacheLongKeyLIRS<V> {\n \n         /**\n          * Create a new cache segment.\n-         *  @param maxMemory the maximum memory to use\n-         * @param stackMoveDistance the number of other entries to be moved to\n-         *        the top of the stack before moving an entry to the top\n-         * @param len the number of hash table buckets (must be a power of 2)\n-         * @param nonResidentQueueSize the non-resident queue size low watermark factor\n-         * @param nonResidentQueueSizeHigh  the non-resident queue size high watermark factor\n+         *\n+         * @param maxMemory                the maximum memory to use\n+         * @param stackMoveDistance        the number of other entries to be moved to\n+         *                                 the top of the stack before moving an entry to the top\n+         * @param len                      the number of hash table buckets (must be a power of 2)\n+         * @param nonResidentQueueSize     the non-resident queue size low watermark factor\n+         * @param nonResidentQueueSizeHigh the non-resident queue size high watermark factor\n          */\n         Segment(long maxMemory, int stackMoveDistance, int len,\n                 int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n@@ -650,7 +653,7 @@ public class CacheLongKeyLIRS<V> {\n          */\n         Segment(Segment<V> old, int len) {\n             this(old.maxMemory, old.stackMoveDistance, len,\n-                    old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n+                old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n             hits = old.hits;\n             misses = old.misses;\n             Entry<V> s = old.stack.stackPrev;\n@@ -787,9 +790,9 @@ public class CacheLongKeyLIRS<V> {\n          * cache yet. This method will usually mark unknown entries as cold and\n          * known entries as hot.\n          *\n-         * @param key the key (may not be null)\n-         * @param hash the hash\n-         * @param value the value (may not be null)\n+         * @param key    the key (may not be null)\n+         * @param hash   the hash\n+         * @param value  the value (may not be null)\n          * @param memory the memory used for the given entry\n          * @return the old value, or null if there was no resident entry\n          */\n@@ -834,7 +837,7 @@ public class CacheLongKeyLIRS<V> {\n          * Remove an entry. Both resident and non-resident entries can be\n          * removed.\n          *\n-         * @param key the key (may not be null)\n+         * @param key  the key (may not be null)\n          * @param hash the hash\n          * @return the old value, or null if there was no resident entry\n          */\n@@ -964,7 +967,7 @@ public class CacheLongKeyLIRS<V> {\n         /**\n          * Try to find an entry in the map.\n          *\n-         * @param key the key\n+         * @param key  the key\n          * @param hash the hash\n          * @return the entry (might be a non-resident)\n          */\n@@ -1033,7 +1036,7 @@ public class CacheLongKeyLIRS<V> {\n          * Get the list of keys. This method allows to read the internal state\n          * of the cache.\n          *\n-         * @param cold if true, only keys for the cold entries are returned\n+         * @param cold        if true, only keys for the cold entries are returned\n          * @param nonResident true for non-resident entries\n          * @return the key list\n          */\n@@ -1042,12 +1045,12 @@ public class CacheLongKeyLIRS<V> {\n             if (cold) {\n                 Entry<V> start = nonResident ? queue2 : queue;\n                 for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n+                     e = e.queueNext) {\n                     keys.add(e.key);\n                 }\n             } else {\n                 for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n+                     e = e.stackNext) {\n                     keys.add(e.key);\n                 }\n             }\n@@ -1186,7 +1189,7 @@ public class CacheLongKeyLIRS<V> {\n     public static class Config {\n \n         /**\n-         *  The maximum memory to use (1 or larger).\n+         * The maximum memory to use (1 or larger).\n          */\n         public long maxMemory = 1;\n \n",
            "diff_size": 31
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/naturalize/31/CacheLongKeyLIRS.java\nindex 466bbf2e82..bf2a1cbb6a 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/naturalize/31/CacheLongKeyLIRS.java\n@@ -87,9 +87,8 @@ public class CacheLongKeyLIRS<V> {\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n-        }\n+            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize, nonResidentQueueSizeHigh);\n+    }\n     }\n \n     /**\n@@ -920,7 +919,8 @@ public class CacheLongKeyLIRS<V> {\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n                     if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n+                        break;\n+// stop trimming if entry holds a value\n                     }\n                 }\n                 int hash = getHash(e.key);\n@@ -1144,9 +1144,7 @@ public class CacheLongKeyLIRS<V> {\n          * The next entry in the map (the chained entry).\n          */\n         Entry<V> mapNext;\n-\n-\n-        Entry() {\n+Entry() {\n             this(0L, null, 0);\n         }\n \n@@ -1213,4 +1211,4 @@ public class CacheLongKeyLIRS<V> {\n          */\n         public final int nonResidentQueueSizeHigh = 12;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "1007",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/codebuff/31/CacheLongKeyLIRS.java\nindex 466bbf2e82..6f87ebf950 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/codebuff/31/CacheLongKeyLIRS.java\n@@ -43,15 +43,16 @@ import org.h2.mvstore.DataUtils;\n  * @author Thomas Mueller\n  * @param <V> the value type\n  */\n+\n+\n public class CacheLongKeyLIRS<V> {\n \n     /**\n      * The maximum memory this cache should use.\n      */\n-    private long maxMemory;\n \n+    private long maxMemory;\n     private final Segment<V>[] segments;\n-\n     private final int segmentCount;\n     private final int segmentShift;\n     private final int segmentMask;\n@@ -64,14 +65,13 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param config the configuration\n      */\n+\n     @SuppressWarnings(\"unchecked\")\n     public CacheLongKeyLIRS(Config config) {\n         setMaxMemory(config.maxMemory);\n         this.nonResidentQueueSize = config.nonResidentQueueSize;\n         this.nonResidentQueueSizeHigh = config.nonResidentQueueSizeHigh;\n-        DataUtils.checkArgument(\n-                Integer.bitCount(config.segmentCount) == 1,\n-                \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n+        DataUtils.checkArgument(Integer.bitCount(config.segmentCount) == 1, \"The segment count must be a power of 2, is {0}\", config.segmentCount);\n         this.segmentCount = config.segmentCount;\n         this.segmentMask = segmentCount - 1;\n         this.stackMoveDistance = config.stackMoveDistance;\n@@ -84,11 +84,15 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Remove all entries.\n      */\n+\n+\n     public void clear() {\n         long max = getMaxItemSize();\n         for (int i = 0; i < segmentCount; i++) {\n-            segments[i] = new Segment<>(max, stackMoveDistance, 8, nonResidentQueueSize,\n-                                        nonResidentQueueSizeHigh);\n+            segments[i] = new Segment< >(max,\n+                stackMoveDistance, 8,\n+                    nonResidentQueueSize,\n+                        nonResidentQueueSizeHigh);\n         }\n     }\n \n@@ -96,6 +100,8 @@ public class CacheLongKeyLIRS<V> {\n      * Determines max size of the data item size to fit into cache\n      * @return data items size limit\n      */\n+\n+\n     public long getMaxItemSize() {\n         return Math.max(1, maxMemory / segmentCount);\n     }\n@@ -112,6 +118,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return true if there is a resident entry\n      */\n+\n+\n     public boolean containsKey(long key) {\n         Entry<V> e = find(key);\n         return e != null && e.value != null;\n@@ -124,6 +132,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the value, or null if there is no resident entry\n      */\n+\n+\n     public V peek(long key) {\n         Entry<V> e = find(key);\n         return e == null ? null : e.getValue();\n@@ -136,6 +146,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V put(long key, V value) {\n         return put(key, value, sizeOf(value));\n     }\n@@ -150,10 +162,11 @@ public class CacheLongKeyLIRS<V> {\n      * @param memory the memory used for the given entry\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V put(long key, V value, int memory) {\n         if (value == null) {\n-            throw DataUtils.newIllegalArgumentException(\n-                    \"The value may not be null\");\n+            throw DataUtils.newIllegalArgumentException(\"The value may not be null\");\n         }\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -177,7 +190,7 @@ public class CacheLongKeyLIRS<V> {\n         Segment<V> s2 = segments[segmentIndex];\n         if (s == s2) {\n             // no other thread resized, so we do\n-            s = new Segment<>(s, newLen);\n+            s = new Segment< >(s, newLen);\n             segments[segmentIndex] = s;\n         }\n         return s;\n@@ -189,6 +202,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value\n      * @return the size\n      */\n+\n+\n     protected int sizeOf(V value) {\n         return 1;\n     }\n@@ -200,6 +215,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the old value, or null if there was no resident entry\n      */\n+\n+\n     public V remove(long key) {\n         int hash = getHash(key);\n         int segmentIndex = getSegmentIndex(hash);\n@@ -219,6 +236,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the memory, or 0 if there is no resident entry\n      */\n+\n+\n     public int getMemory(long key) {\n         Entry<V> e = find(key);\n         return e == null ? 0 : e.getMemory();\n@@ -232,6 +251,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key (may not be null)\n      * @return the value, or null if there is no resident entry\n      */\n+\n+\n     public V get(long key) {\n         int hash = getHash(key);\n         Segment<V> s = getSegment(hash);\n@@ -254,6 +275,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param key the key\n      * @return the hash code\n      */\n+\n+\n     static int getHash(long key) {\n         int hash = (int) ((key >>> 32) ^ key);\n         // a supplemental secondary hash function\n@@ -269,6 +292,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the used memory\n      */\n+\n+\n     public long getUsedMemory() {\n         long x = 0;\n         for (Segment<V> s : segments) {\n@@ -284,10 +309,12 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param maxMemory the maximum size (1 or larger) in bytes\n      */\n+\n+\n     public void setMaxMemory(long maxMemory) {\n-        DataUtils.checkArgument(\n-                maxMemory > 0,\n-                \"Max memory must be larger than 0, is {0}\", maxMemory);\n+        DataUtils.checkArgument(maxMemory > 0,\n+                                \"Max memory must be larger than 0, is {0}\",\n+                                maxMemory);\n         this.maxMemory = maxMemory;\n         if (segments != null) {\n             long max = 1 + maxMemory / segments.length;\n@@ -302,6 +329,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the maximum memory\n      */\n+\n+\n     public long getMaxMemory() {\n         return maxMemory;\n     }\n@@ -311,8 +340,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the entry set\n      */\n+\n+\n     public synchronized Set<Map.Entry<Long, V>> entrySet() {\n-        HashMap<Long, V> map = new HashMap<>();\n+        HashMap<Long, V> map = new HashMap< >();\n         for (long k : keySet()) {\n             V value = peek(k);\n             if (value != null) {\n@@ -327,8 +358,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the set of keys\n      */\n+\n+\n     public Set<Long> keySet() {\n-        HashSet<Long> set = new HashSet<>();\n+        HashSet<Long> set = new HashSet< >();\n         for (Segment<V> s : segments) {\n             set.addAll(s.keySet());\n         }\n@@ -340,6 +373,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of non-resident entries\n      */\n+\n+\n     public int sizeNonResident() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -353,6 +388,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the size of the array\n      */\n+\n+\n     public int sizeMapArray() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -366,6 +403,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of hot entries\n      */\n+\n+\n     public int sizeHot() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -379,6 +418,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the cache hits\n      */\n+\n+\n     public long getHits() {\n         long x = 0;\n         for (Segment<V> s : segments) {\n@@ -392,6 +433,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the cache misses\n      */\n+\n+\n     public long getMisses() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -405,6 +448,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the number of entries\n      */\n+\n+\n     public int size() {\n         int x = 0;\n         for (Segment<V> s : segments) {\n@@ -421,8 +466,10 @@ public class CacheLongKeyLIRS<V> {\n      * @param nonResident true for non-resident entries\n      * @return the key list\n      */\n+\n+\n     public List<Long> keys(boolean cold, boolean nonResident) {\n-        ArrayList<Long> keys = new ArrayList<>();\n+        ArrayList<Long> keys = new ArrayList< >();\n         for (Segment<V> s : segments) {\n             keys.addAll(s.keys(cold, nonResident));\n         }\n@@ -434,8 +481,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the entry set\n      */\n+\n+\n     public List<V> values() {\n-        ArrayList<V> list = new ArrayList<>();\n+        ArrayList<V> list = new ArrayList< >();\n         for (long k : keySet()) {\n             V value = peek(k);\n             if (value != null) {\n@@ -450,6 +499,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return true if it is empty\n      */\n+\n+\n     public boolean isEmpty() {\n         return size() == 0;\n     }\n@@ -460,6 +511,8 @@ public class CacheLongKeyLIRS<V> {\n      * @param value the value\n      * @return true if it is stored\n      */\n+\n+\n     public boolean containsValue(V value) {\n         return getMap().containsValue(value);\n     }\n@@ -469,8 +522,10 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @return the map\n      */\n+\n+\n     public Map<Long, V> getMap() {\n-        HashMap<Long, V> map = new HashMap<>();\n+        HashMap<Long, V> map = new HashMap< >();\n         for (long k : keySet()) {\n             V x = peek(k);\n             if (x != null) {\n@@ -485,6 +540,8 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param m the map\n      */\n+\n+\n     public void putAll(Map<Long, ? extends V> m) {\n         for (Map.Entry<Long, ? extends V> e : m.entrySet()) {\n             // copy only non-null entries\n@@ -495,6 +552,8 @@ public class CacheLongKeyLIRS<V> {\n     /**\n      * Loop through segments, trimming the non resident queue.\n      */\n+\n+\n     public void trimNonResidentQueue() {\n         for (Segment<V> s : segments) {\n             synchronized (s) {\n@@ -508,41 +567,56 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n+\n     private static class Segment<V> {\n \n         /**\n          * The number of (hot, cold, and non-resident) entries in the map.\n          */\n+\n+\n         int mapSize;\n \n         /**\n          * The size of the LIRS queue for resident cold entries.\n          */\n+\n+\n         int queueSize;\n \n         /**\n          * The size of the LIRS queue for non-resident cold entries.\n          */\n+\n+\n         int queue2Size;\n \n         /**\n          * The number of cache hits.\n          */\n+\n+\n         long hits;\n \n         /**\n          * The number of cache misses.\n          */\n+\n+\n         long misses;\n \n         /**\n          * The map array. The size is always a power of 2.\n          */\n+\n+\n         final Entry<V>[] entries;\n \n         /**\n          * The currently used memory.\n          */\n+\n+\n         long usedMemory;\n \n         /**\n@@ -617,8 +691,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResidentQueueSize the non-resident queue size low watermark factor\n          * @param nonResidentQueueSizeHigh  the non-resident queue size high watermark factor\n          */\n-        Segment(long maxMemory, int stackMoveDistance, int len,\n-                int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n+\n+        Segment(long maxMemory, int stackMoveDistance, int len, int nonResidentQueueSize, int nonResidentQueueSizeHigh) {\n             setMaxMemory(maxMemory);\n             this.stackMoveDistance = stackMoveDistance;\n             this.nonResidentQueueSize = nonResidentQueueSize;\n@@ -628,13 +702,12 @@ public class CacheLongKeyLIRS<V> {\n             mask = len - 1;\n \n             // initialize the stack and queue heads\n-            stack = new Entry<>();\n+            stack = new Entry< >();\n             stack.stackPrev = stack.stackNext = stack;\n-            queue = new Entry<>();\n+            queue = new Entry< >();\n             queue.queuePrev = queue.queueNext = queue;\n-            queue2 = new Entry<>();\n+            queue2 = new Entry< >();\n             queue2.queuePrev = queue2.queueNext = queue2;\n-\n             @SuppressWarnings(\"unchecked\")\n             Entry<V>[] e = new Entry[len];\n             entries = e;\n@@ -648,14 +721,14 @@ public class CacheLongKeyLIRS<V> {\n          * @param old the old segment\n          * @param len the number of hash table buckets (must be a power of 2)\n          */\n+\n         Segment(Segment<V> old, int len) {\n-            this(old.maxMemory, old.stackMoveDistance, len,\n-                    old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n+            this(old.maxMemory, old.stackMoveDistance, len, old.nonResidentQueueSize, old.nonResidentQueueSizeHigh);\n             hits = old.hits;\n             misses = old.misses;\n             Entry<V> s = old.stack.stackPrev;\n             while (s != old.stack) {\n-                Entry<V> e = new Entry<>(s);\n+                Entry<V> e = new Entry< >(s);\n                 addToMap(e);\n                 addToStack(e);\n                 s = s.stackPrev;\n@@ -664,7 +737,7 @@ public class CacheLongKeyLIRS<V> {\n             while (s != old.queue) {\n                 Entry<V> e = find(s.key, getHash(s.key));\n                 if (e == null) {\n-                    e = new Entry<>(s);\n+                    e = new Entry< >(s);\n                     addToMap(e);\n                 }\n                 addToQueue(queue, e);\n@@ -674,7 +747,7 @@ public class CacheLongKeyLIRS<V> {\n             while (s != old.queue2) {\n                 Entry<V> e = find(s.key, getHash(s.key));\n                 if (e == null) {\n-                    e = new Entry<>(s);\n+                    e = new Entry< >(s);\n                     addToMap(e);\n                 }\n                 addToQueue(queue2, e);\n@@ -688,6 +761,8 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return 0 if no resizing is needed, or the new length\n          */\n+\n+\n         int getNewMapLen() {\n             int len = mask + 1;\n             if (len * 3 < mapSize * 4 && len < (1 << 28)) {\n@@ -716,6 +791,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param e the entry\n          * @return the value, or null if there is no resident entry\n          */\n+\n+\n         synchronized V get(Entry<V> e) {\n             V value = e == null ? null : e.getValue();\n             if (value == null) {\n@@ -735,6 +812,7 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param e entry to record access for\n          */\n+\n         private void access(Entry<V> e) {\n             if (e.isHot()) {\n                 if (e != stack.stackNext && e.stackNext != null) {\n@@ -793,6 +871,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param memory the memory used for the given entry\n          * @return the old value, or null if there was no resident entry\n          */\n+\n+\n         synchronized V put(long key, int hash, V value, int memory) {\n             Entry<V> e = find(key, hash);\n             boolean existed = e != null;\n@@ -805,7 +885,7 @@ public class CacheLongKeyLIRS<V> {\n                 // the new entry is too big to fit\n                 return old;\n             }\n-            e = new Entry<>(key, value, memory);\n+            e = new Entry< >(key, value, memory);\n             int index = hash & mask;\n             e.mapNext = entries[index];\n             entries[index] = e;\n@@ -838,6 +918,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param hash the hash\n          * @return the old value, or null if there was no resident entry\n          */\n+\n+\n         synchronized V remove(long key, int hash) {\n             int index = hash & mask;\n             Entry<V> e = entries[index];\n@@ -885,6 +967,7 @@ public class CacheLongKeyLIRS<V> {\n          * is reached. The new entry is added as a cold entry, except if it is\n          * the only entry.\n          */\n+\n         private void evict() {\n             do {\n                 evictBlock();\n@@ -903,7 +986,7 @@ public class CacheLongKeyLIRS<V> {\n                 Entry<V> e = queue.queuePrev;\n                 usedMemory -= e.memory;\n                 removeFromQueue(e);\n-                e.reference = new WeakReference<>(e.value);\n+                e.reference = new WeakReference< >(e.value);\n                 e.value = null;\n                 addToQueue(queue2, e);\n                 // the size of the non-resident-cold entries needs to be limited\n@@ -911,6 +994,7 @@ public class CacheLongKeyLIRS<V> {\n             }\n         }\n \n+\n         void trimNonResidentQueue() {\n             int residentCount = mapSize - queue2Size;\n             int maxQueue2SizeHigh = nonResidentQueueSizeHigh * residentCount;\n@@ -947,6 +1031,7 @@ public class CacheLongKeyLIRS<V> {\n         /**\n          * Ensure the last entry of the stack is cold.\n          */\n+\n         private void pruneStack() {\n             while (true) {\n                 Entry<V> last = stack.stackPrev;\n@@ -968,6 +1053,8 @@ public class CacheLongKeyLIRS<V> {\n          * @param hash the hash\n          * @return the entry (might be a non-resident)\n          */\n+\n+\n         Entry<V> find(long key, int hash) {\n             int index = hash & mask;\n             Entry<V> e = entries[index];\n@@ -999,6 +1086,7 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param e the entry\n          */\n+\n         private void removeFromStack(Entry<V> e) {\n             e.stackPrev.stackNext = e.stackNext;\n             e.stackNext.stackPrev = e.stackPrev;\n@@ -1037,17 +1125,17 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResident true for non-resident entries\n          * @return the key list\n          */\n+\n+\n         synchronized List<Long> keys(boolean cold, boolean nonResident) {\n-            ArrayList<Long> keys = new ArrayList<>();\n+            ArrayList<Long> keys = new ArrayList< >();\n             if (cold) {\n                 Entry<V> start = nonResident ? queue2 : queue;\n-                for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n+                for (Entry<V> e = start.queueNext; e != start; e = e.queueNext) {\n                     keys.add(e.key);\n                 }\n             } else {\n-                for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n+                for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n                     keys.add(e.key);\n                 }\n             }\n@@ -1059,8 +1147,10 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return the set of keys\n          */\n+\n+\n         synchronized Set<Long> keySet() {\n-            HashSet<Long> set = new HashSet<>();\n+            HashSet<Long> set = new HashSet< >();\n             for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n                 set.add(e.key);\n             }\n@@ -1077,6 +1167,8 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @param maxMemory the maximum size (1 or larger) in bytes\n          */\n+\n+\n         void setMaxMemory(long maxMemory) {\n             this.maxMemory = maxMemory;\n         }\n@@ -1092,60 +1184,81 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n+\n+\n     static class Entry<V> {\n \n         /**\n          * The key.\n          */\n+\n+\n         final long key;\n \n         /**\n          * The value. Set to null for non-resident-cold entries.\n          */\n+\n+\n         V value;\n \n         /**\n          * Weak reference to the value. Set to null for resident entries.\n          */\n+\n+\n         WeakReference<V> reference;\n \n         /**\n          * The estimated memory used.\n          */\n+\n+\n         final int memory;\n \n         /**\n          * When the item was last moved to the top of the stack.\n          */\n+\n+\n         int topMove;\n \n         /**\n          * The next entry in the stack.\n          */\n+\n+\n         Entry<V> stackNext;\n \n         /**\n          * The previous entry in the stack.\n          */\n+\n+\n         Entry<V> stackPrev;\n \n         /**\n          * The next entry in the queue (either the resident queue or the\n          * non-resident queue).\n          */\n+\n+\n         Entry<V> queueNext;\n \n         /**\n          * The previous entry in the queue.\n          */\n+\n+\n         Entry<V> queuePrev;\n \n         /**\n          * The next entry in the map (the chained entry).\n          */\n-        Entry<V> mapNext;\n \n \n+        Entry<V> mapNext;\n+\n         Entry() {\n             this(0L, null, 0);\n         }\n@@ -1167,10 +1280,13 @@ public class CacheLongKeyLIRS<V> {\n          *\n          * @return whether the entry is hot\n          */\n+\n+\n         boolean isHot() {\n             return queueNext == null;\n         }\n \n+\n         V getValue() {\n             return value == null ? reference.get() : value;\n         }\n@@ -1178,39 +1294,53 @@ public class CacheLongKeyLIRS<V> {\n         int getMemory() {\n             return value == null ? 0 : memory;\n         }\n+\n     }\n \n     /**\n      * The cache configuration.\n      */\n+\n+\n     public static class Config {\n \n         /**\n          *  The maximum memory to use (1 or larger).\n          */\n+\n+\n         public long maxMemory = 1;\n \n         /**\n          * The number of cache segments (must be a power of 2).\n          */\n+\n+\n         public int segmentCount = 16;\n \n         /**\n          * How many other item are to be moved to the top of the stack before\n          * the current item is moved.\n          */\n+\n+\n         public int stackMoveDistance = 32;\n \n         /**\n          * Low water mark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map.\n          */\n+\n+\n         public final int nonResidentQueueSize = 3;\n \n         /**\n          * High watermark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map\n          */\n+\n+\n         public final int nonResidentQueueSizeHigh = 12;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 179
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "922",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                },
                {
                    "line": "922",
                    "column": "71",
                    "severity": "warning",
                    "message": "'{' at column 71 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "922",
                    "column": "71",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/styler_random/31/CacheLongKeyLIRS.java\nindex 466bbf2e82..20ebf9fd89 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/31/CacheLongKeyLIRS.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/styler_random/31/CacheLongKeyLIRS.java\n@@ -919,117 +919,116 @@ public class CacheLongKeyLIRS<V> {\n                 Entry<V> e = queue2.queuePrev;\n                 if (queue2Size <= maxQueue2SizeHigh) {\n                     WeakReference<V> reference = e.reference;\n-                    if (reference != null && reference.get() != null) {\n-                        break;  // stop trimming if entry holds a value\n-                    }\n+                    if (reference != null && reference.get() != null) {break;  // stop trimming if entry holds a value\n                 }\n-                int hash = getHash(e.key);\n-                remove(e.key, hash);\n             }\n+            int hash = getHash(e.key);\n+            remove(e.key, hash);\n         }\n+    }\n \n-        private void convertOldestHotToCold() {\n-            // the last entry of the stack is known to be hot\n-            Entry<V> last = stack.stackPrev;\n-            if (last == stack) {\n-                // never remove the stack head itself (this would mean the\n-                // internal structure of the cache is corrupt)\n-                throw new IllegalStateException();\n-            }\n-            // remove from stack - which is done anyway in the stack pruning,\n-            // but we can do it here as well\n-            removeFromStack(last);\n-            // adding an entry to the queue will make it cold\n-            addToQueue(queue, last);\n-            pruneStack();\n+    private void convertOldestHotToCold() {\n+        // the last entry of the stack is known to be hot\n+        Entry<V> last = stack.stackPrev;\n+        if (last == stack) {\n+            // never remove the stack head itself (this would mean the\n+            // internal structure of the cache is corrupt)\n+            throw new IllegalStateException();\n         }\n+        // remove from stack - which is done anyway in the stack pruning,\n+        // but we can do it here as well\n+        removeFromStack(last);\n+        // adding an entry to the queue will make it cold\n+        addToQueue(queue, last);\n+        pruneStack();\n+    }\n \n-        /**\n+    /**\n          * Ensure the last entry of the stack is cold.\n          */\n-        private void pruneStack() {\n-            while (true) {\n-                Entry<V> last = stack.stackPrev;\n-                // must stop at a hot entry or the stack head,\n-                // but the stack head itself is also hot, so we\n-                // don't have to test it\n-                if (last.isHot()) {\n-                    break;\n-                }\n-                // the cold entry is still in the queue\n-                removeFromStack(last);\n+    private void pruneStack() {\n+        while (true) {\n+            Entry<V> last = stack.stackPrev;\n+            // must stop at a hot entry or the stack head,\n+            // but the stack head itself is also hot, so we\n+            // don't have to test it\n+            if (last.isHot()) {\n+                break;\n             }\n+            // the cold entry is still in the queue\n+            removeFromStack(last);\n         }\n+    }\n \n-        /**\n+    /**\n          * Try to find an entry in the map.\n          *\n          * @param key the key\n          * @param hash the hash\n          * @return the entry (might be a non-resident)\n          */\n-        Entry<V> find(long key, int hash) {\n-            int index = hash & mask;\n-            Entry<V> e = entries[index];\n-            while (e != null && e.key != key) {\n-                e = e.mapNext;\n-            }\n-            return e;\n+    Entry<V> find(long key, int hash) {\n+        int index = hash & mask;\n+        Entry<V> e = entries[index];\n+        while (e != null && e.key != key) {\n+            e = e.mapNext;\n         }\n+        return e;\n+    }\n \n-        private void addToStack(Entry<V> e) {\n-            e.stackPrev = stack;\n-            e.stackNext = stack.stackNext;\n-            e.stackNext.stackPrev = e;\n-            stack.stackNext = e;\n-            stackSize++;\n-            e.topMove = stackMoveCounter++;\n-        }\n+    private void addToStack(Entry<V> e) {\n+        e.stackPrev = stack;\n+        e.stackNext = stack.stackNext;\n+        e.stackNext.stackPrev = e;\n+        stack.stackNext = e;\n+        stackSize++;\n+        e.topMove = stackMoveCounter++;\n+    }\n \n-        private void addToStackBottom(Entry<V> e) {\n-            e.stackNext = stack;\n-            e.stackPrev = stack.stackPrev;\n-            e.stackPrev.stackNext = e;\n-            stack.stackPrev = e;\n-            stackSize++;\n-        }\n+    private void addToStackBottom(Entry<V> e) {\n+        e.stackNext = stack;\n+        e.stackPrev = stack.stackPrev;\n+        e.stackPrev.stackNext = e;\n+        stack.stackPrev = e;\n+        stackSize++;\n+    }\n \n-        /**\n+    /**\n          * Remove the entry from the stack. The head itself must not be removed.\n          *\n          * @param e the entry\n          */\n-        private void removeFromStack(Entry<V> e) {\n-            e.stackPrev.stackNext = e.stackNext;\n-            e.stackNext.stackPrev = e.stackPrev;\n-            e.stackPrev = e.stackNext = null;\n-            stackSize--;\n-        }\n+    private void removeFromStack(Entry<V> e) {\n+        e.stackPrev.stackNext = e.stackNext;\n+        e.stackNext.stackPrev = e.stackPrev;\n+        e.stackPrev = e.stackNext = null;\n+        stackSize--;\n+    }\n \n-        private void addToQueue(Entry<V> q, Entry<V> e) {\n-            e.queuePrev = q;\n-            e.queueNext = q.queueNext;\n-            e.queueNext.queuePrev = e;\n-            q.queueNext = e;\n-            if (e.value != null) {\n-                queueSize++;\n-            } else {\n-                queue2Size++;\n-            }\n+    private void addToQueue(Entry<V> q, Entry<V> e) {\n+        e.queuePrev = q;\n+        e.queueNext = q.queueNext;\n+        e.queueNext.queuePrev = e;\n+        q.queueNext = e;\n+        if (e.value != null) {\n+            queueSize++;\n+        } else {\n+            queue2Size++;\n         }\n+    }\n \n-        private void removeFromQueue(Entry<V> e) {\n-            e.queuePrev.queueNext = e.queueNext;\n-            e.queueNext.queuePrev = e.queuePrev;\n-            e.queuePrev = e.queueNext = null;\n-            if (e.value != null) {\n-                queueSize--;\n-            } else {\n-                queue2Size--;\n-            }\n+    private void removeFromQueue(Entry<V> e) {\n+        e.queuePrev.queueNext = e.queueNext;\n+        e.queueNext.queuePrev = e.queuePrev;\n+        e.queuePrev = e.queueNext = null;\n+        if (e.value != null) {\n+            queueSize--;\n+        } else {\n+            queue2Size--;\n         }\n+    }\n \n-        /**\n+    /**\n          * Get the list of keys. This method allows to read the internal state\n          * of the cache.\n          *\n@@ -1037,53 +1036,53 @@ public class CacheLongKeyLIRS<V> {\n          * @param nonResident true for non-resident entries\n          * @return the key list\n          */\n-        synchronized List<Long> keys(boolean cold, boolean nonResident) {\n-            ArrayList<Long> keys = new ArrayList<>();\n-            if (cold) {\n-                Entry<V> start = nonResident ? queue2 : queue;\n-                for (Entry<V> e = start.queueNext; e != start;\n-                        e = e.queueNext) {\n-                    keys.add(e.key);\n-                }\n-            } else {\n-                for (Entry<V> e = stack.stackNext; e != stack;\n-                        e = e.stackNext) {\n-                    keys.add(e.key);\n-                }\n+    synchronized List<Long> keys(boolean cold, boolean nonResident) {\n+        ArrayList<Long> keys = new ArrayList<>();\n+        if (cold) {\n+            Entry<V> start = nonResident ? queue2 : queue;\n+            for (Entry<V> e = start.queueNext; e != start;\n+                    e = e.queueNext) {\n+                keys.add(e.key);\n+            }\n+        } else {\n+            for (Entry<V> e = stack.stackNext; e != stack;\n+                    e = e.stackNext) {\n+                keys.add(e.key);\n             }\n-            return keys;\n         }\n+        return keys;\n+    }\n \n-        /**\n+    /**\n          * Get the set of keys for resident entries.\n          *\n          * @return the set of keys\n          */\n-        synchronized Set<Long> keySet() {\n-            HashSet<Long> set = new HashSet<>();\n-            for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n-                set.add(e.key);\n-            }\n-            for (Entry<V> e = queue.queueNext; e != queue; e = e.queueNext) {\n-                set.add(e.key);\n-            }\n-            return set;\n+    synchronized Set<Long> keySet() {\n+        HashSet<Long> set = new HashSet<>();\n+        for (Entry<V> e = stack.stackNext; e != stack; e = e.stackNext) {\n+            set.add(e.key);\n+        }\n+        for (Entry<V> e = queue.queueNext; e != queue; e = e.queueNext) {\n+            set.add(e.key);\n         }\n+        return set;\n+    }\n \n-        /**\n+    /**\n          * Set the maximum memory this cache should use. This will not\n          * immediately cause entries to get removed however; it will only change\n          * the limit. To resize the internal array, call the clear method.\n          *\n          * @param maxMemory the maximum size (1 or larger) in bytes\n          */\n-        void setMaxMemory(long maxMemory) {\n-            this.maxMemory = maxMemory;\n-        }\n-\n+    void setMaxMemory(long maxMemory) {\n+        this.maxMemory = maxMemory;\n     }\n \n-    /**\n+}\n+\n+/**\n      * A cache entry. Each entry is either hot (low inter-reference recency;\n      * LIR), cold (high inter-reference recency; HIR), or non-resident-cold. Hot\n      * entries are in the stack only. Cold entries are in the queue, and may be\n@@ -1092,125 +1091,125 @@ public class CacheLongKeyLIRS<V> {\n      *\n      * @param <V> the value type\n      */\n-    static class Entry<V> {\n+static class Entry<V> {\n \n-        /**\n+    /**\n          * The key.\n          */\n-        final long key;\n+    final long key;\n \n-        /**\n+    /**\n          * The value. Set to null for non-resident-cold entries.\n          */\n-        V value;\n+    V value;\n \n-        /**\n+    /**\n          * Weak reference to the value. Set to null for resident entries.\n          */\n-        WeakReference<V> reference;\n+    WeakReference<V> reference;\n \n-        /**\n+    /**\n          * The estimated memory used.\n          */\n-        final int memory;\n+    final int memory;\n \n-        /**\n+    /**\n          * When the item was last moved to the top of the stack.\n          */\n-        int topMove;\n+    int topMove;\n \n-        /**\n+    /**\n          * The next entry in the stack.\n          */\n-        Entry<V> stackNext;\n+    Entry<V> stackNext;\n \n-        /**\n+    /**\n          * The previous entry in the stack.\n          */\n-        Entry<V> stackPrev;\n+    Entry<V> stackPrev;\n \n-        /**\n+    /**\n          * The next entry in the queue (either the resident queue or the\n          * non-resident queue).\n          */\n-        Entry<V> queueNext;\n+    Entry<V> queueNext;\n \n-        /**\n+    /**\n          * The previous entry in the queue.\n          */\n-        Entry<V> queuePrev;\n+    Entry<V> queuePrev;\n \n-        /**\n+    /**\n          * The next entry in the map (the chained entry).\n          */\n-        Entry<V> mapNext;\n+    Entry<V> mapNext;\n \n \n-        Entry() {\n-            this(0L, null, 0);\n-        }\n+    Entry() {\n+        this(0L, null, 0);\n+    }\n \n-        Entry(long key, V value, int memory) {\n-            this.key = key;\n-            this.memory = memory;\n-            this.value = value;\n-        }\n+    Entry(long key, V value, int memory) {\n+        this.key = key;\n+        this.memory = memory;\n+        this.value = value;\n+    }\n \n-        Entry(Entry<V> old) {\n-            this(old.key, old.value, old.memory);\n-            this.reference = old.reference;\n-            this.topMove = old.topMove;\n-        }\n+    Entry(Entry<V> old) {\n+        this(old.key, old.value, old.memory);\n+        this.reference = old.reference;\n+        this.topMove = old.topMove;\n+    }\n \n-        /**\n+    /**\n          * Whether this entry is hot. Cold entries are in one of the two queues.\n          *\n          * @return whether the entry is hot\n          */\n-        boolean isHot() {\n-            return queueNext == null;\n-        }\n+    boolean isHot() {\n+        return queueNext == null;\n+    }\n \n-        V getValue() {\n-            return value == null ? reference.get() : value;\n-        }\n+    V getValue() {\n+        return value == null ? reference.get() : value;\n+    }\n \n-        int getMemory() {\n-            return value == null ? 0 : memory;\n-        }\n+    int getMemory() {\n+        return value == null ? 0 : memory;\n     }\n+}\n \n-    /**\n+/**\n      * The cache configuration.\n      */\n-    public static class Config {\n+public static class Config {\n \n-        /**\n+    /**\n          *  The maximum memory to use (1 or larger).\n          */\n-        public long maxMemory = 1;\n+    public long maxMemory = 1;\n \n-        /**\n+    /**\n          * The number of cache segments (must be a power of 2).\n          */\n-        public int segmentCount = 16;\n+    public int segmentCount = 16;\n \n-        /**\n+    /**\n          * How many other item are to be moved to the top of the stack before\n          * the current item is moved.\n          */\n-        public int stackMoveDistance = 32;\n+    public int stackMoveDistance = 32;\n \n-        /**\n+    /**\n          * Low water mark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map.\n          */\n-        public final int nonResidentQueueSize = 3;\n+    public final int nonResidentQueueSize = 3;\n \n-        /**\n+    /**\n          * High watermark for the number of entries in the non-resident queue,\n          * as a factor of the number of all other entries in the map\n          */\n-        public final int nonResidentQueueSizeHigh = 12;\n-    }\n+    public final int nonResidentQueueSizeHigh = 12;\n+}\n }\n",
            "diff_size": 192
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "923",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}