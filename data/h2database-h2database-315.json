{
    "error_id": "315",
    "information": {
        "errors": [
            {
                "line": "75",
                "column": "59",
                "severity": "warning",
                "message": "',' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
            }
        ]
    },
    "source_code": "        this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n        if (trace.isDebugEnabled()) {\n            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n        }\n        memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/315/PageBtreeIndex.java\nindex c8d68aa6e7..633a790aff 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/315/PageBtreeIndex.java\n@@ -72,7 +72,7 @@ public class PageBtreeIndex extends PageIndex {\n         }\n         this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n         if (trace.isDebugEnabled()) {\n-            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n+            trace.debug(\"opened {0} rows: {1}\", getName(), rowCount);\n         }\n         memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n     }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/315/PageBtreeIndex.java\nindex c8d68aa6e7..9a02282ef2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/315/PageBtreeIndex.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import org.h2.api.ErrorCode;\n@@ -31,464 +32,465 @@ import org.h2.value.ValueNull;\n  */\n public class PageBtreeIndex extends PageIndex {\n \n-    private static int memoryChangeRequired;\n-\n-    private final PageStore store;\n-    private final RegularTable tableData;\n-    private final boolean needRebuild;\n-    private long rowCount;\n-    private int memoryPerPage;\n-    private int memoryCount;\n-\n-    public PageBtreeIndex(RegularTable table, int id, String indexName,\n-            IndexColumn[] columns,\n-            IndexType indexType, boolean create, Session session) {\n-        initBaseIndex(table, id, indexName, columns, indexType);\n-        if (!database.isStarting() && create) {\n-            checkIndexColumnTypes(columns);\n-        }\n-        // int test;\n-        // trace.setLevel(TraceSystem.DEBUG);\n-        tableData = table;\n-        if (!database.isPersistent() || id < 0) {\n-            throw DbException.throwInternalError(\"\" + indexName);\n-        }\n-        this.store = database.getPageStore();\n-        store.addIndex(this);\n-        if (create) {\n-            // new index\n-            rootPageId = store.allocatePage();\n-            // TODO currently the head position is stored in the log\n-            // it should not for new tables, otherwise redo of other operations\n-            // must ensure this page is not used for other things\n-            store.addMeta(this, session);\n-            PageBtreeLeaf root = PageBtreeLeaf.create(this, rootPageId, PageBtree.ROOT);\n-            store.logUndo(root, null);\n-            store.update(root);\n-        } else {\n-            rootPageId = store.getRootPageId(id);\n-            PageBtree root = getPage(rootPageId);\n-            rowCount = root.getRowCount();\n-        }\n-        this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n-        }\n-        memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n-    }\n-\n-    @Override\n-    public void add(Session session, Row row) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} add {1}\", getName(), row);\n-        }\n-        // safe memory\n-        SearchRow newRow = getSearchRow(row);\n-        try {\n-            addRow(newRow);\n-        } finally {\n-            store.incrementChangeCount();\n-        }\n-    }\n-\n-    private void addRow(SearchRow newRow) {\n-        while (true) {\n-            PageBtree root = getPage(rootPageId);\n-            int splitPoint = root.addRowTry(newRow);\n-            if (splitPoint == -1) {\n-                break;\n-            }\n-            if (trace.isDebugEnabled()) {\n-                trace.debug(\"split {0}\", splitPoint);\n-            }\n-            SearchRow pivot = root.getRow(splitPoint - 1);\n-            store.logUndo(root, root.data);\n-            PageBtree page1 = root;\n-            PageBtree page2 = root.split(splitPoint);\n-            store.logUndo(page2, null);\n-            int id = store.allocatePage();\n-            page1.setPageId(id);\n-            page1.setParentPageId(rootPageId);\n-            page2.setParentPageId(rootPageId);\n-            PageBtreeNode newRoot = PageBtreeNode.create(\n-                    this, rootPageId, PageBtree.ROOT);\n-            store.logUndo(newRoot, null);\n-            newRoot.init(page1, pivot, page2);\n-            store.update(page1);\n-            store.update(page2);\n-            store.update(newRoot);\n-            root = newRoot;\n-        }\n-        invalidateRowCount();\n-        rowCount++;\n-    }\n-\n-    /**\n-     * Create a search row for this row.\n-     *\n-     * @param row the row\n-     * @return the search row\n-     */\n-    private SearchRow getSearchRow(Row row) {\n-        SearchRow r = table.getTemplateSimpleRow(columns.length == 1);\n-        r.setKeyAndVersion(row);\n-        for (Column c : columns) {\n-            int idx = c.getColumnId();\n-            r.setValue(idx, row.getValue(idx));\n-        }\n-        return r;\n-    }\n-\n-    /**\n-     * Read the given page.\n-     *\n-     * @param id the page id\n-     * @return the page\n-     */\n-    PageBtree getPage(int id) {\n-        Page p = store.getPage(id);\n-        if (p == null) {\n-            PageBtreeLeaf empty = PageBtreeLeaf.create(this, id, PageBtree.ROOT);\n-            // could have been created before, but never committed\n-            store.logUndo(empty, null);\n-            store.update(empty);\n-            return empty;\n-        } else if (!(p instanceof PageBtree)) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"\" + p);\n-        }\n-        return (PageBtree) p;\n-    }\n-\n-    @Override\n-    public boolean canGetFirstOrLast() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Cursor findNext(Session session, SearchRow first, SearchRow last) {\n-        return find(session, first, true, last);\n-    }\n-\n-    @Override\n-    public Cursor find(Session session, SearchRow first, SearchRow last) {\n-        return find(session, first, false, last);\n-    }\n-\n-    private Cursor find(Session session, SearchRow first, boolean bigger,\n-            SearchRow last) {\n-        if (SysProperties.CHECK && store == null) {\n-            throw DbException.get(ErrorCode.OBJECT_CLOSED);\n+  private static int memoryChangeRequired;\n+\n+  private final PageStore store;\n+  private final RegularTable tableData;\n+  private final boolean needRebuild;\n+  private long rowCount;\n+  private int memoryPerPage;\n+  private int memoryCount;\n+\n+  public PageBtreeIndex(RegularTable table, int id, String indexName,\n+                        IndexColumn[] columns,\n+                        IndexType indexType, boolean create, Session session) {\n+    initBaseIndex(table, id, indexName, columns, indexType);\n+    if (!database.isStarting() && create) {\n+      checkIndexColumnTypes(columns);\n+    }\n+    // int test;\n+    // trace.setLevel(TraceSystem.DEBUG);\n+    tableData = table;\n+    if (!database.isPersistent() || id < 0) {\n+      throw DbException.throwInternalError(\"\" + indexName);\n+    }\n+    this.store = database.getPageStore();\n+    store.addIndex(this);\n+    if (create) {\n+      // new index\n+      rootPageId = store.allocatePage();\n+      // TODO currently the head position is stored in the log\n+      // it should not for new tables, otherwise redo of other operations\n+      // must ensure this page is not used for other things\n+      store.addMeta(this, session);\n+      PageBtreeLeaf root =\n+          PageBtreeLeaf.create(this, rootPageId, PageBtree.ROOT);\n+      store.logUndo(root, null);\n+      store.update(root);\n+    } else {\n+      rootPageId = store.getRootPageId(id);\n+      PageBtree root = getPage(rootPageId);\n+      rowCount = root.getRowCount();\n+    }\n+    this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"opened {0} rows: {1}\", getName(), rowCount);\n+    }\n+    memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n+  }\n+\n+  @Override\n+  public void add(Session session, Row row) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} add {1}\", getName(), row);\n+    }\n+    // safe memory\n+    SearchRow newRow = getSearchRow(row);\n+    try {\n+      addRow(newRow);\n+    } finally {\n+      store.incrementChangeCount();\n+    }\n+  }\n+\n+  private void addRow(SearchRow newRow) {\n+    while (true) {\n+      PageBtree root = getPage(rootPageId);\n+      int splitPoint = root.addRowTry(newRow);\n+      if (splitPoint == -1) {\n+        break;\n+      }\n+      if (trace.isDebugEnabled()) {\n+        trace.debug(\"split {0}\", splitPoint);\n+      }\n+      SearchRow pivot = root.getRow(splitPoint - 1);\n+      store.logUndo(root, root.data);\n+      PageBtree page1 = root;\n+      PageBtree page2 = root.split(splitPoint);\n+      store.logUndo(page2, null);\n+      int id = store.allocatePage();\n+      page1.setPageId(id);\n+      page1.setParentPageId(rootPageId);\n+      page2.setParentPageId(rootPageId);\n+      PageBtreeNode newRoot = PageBtreeNode.create(\n+          this, rootPageId, PageBtree.ROOT);\n+      store.logUndo(newRoot, null);\n+      newRoot.init(page1, pivot, page2);\n+      store.update(page1);\n+      store.update(page2);\n+      store.update(newRoot);\n+      root = newRoot;\n+    }\n+    invalidateRowCount();\n+    rowCount++;\n+  }\n+\n+  /**\n+   * Create a search row for this row.\n+   *\n+   * @param row the row\n+   * @return the search row\n+   */\n+  private SearchRow getSearchRow(Row row) {\n+    SearchRow r = table.getTemplateSimpleRow(columns.length == 1);\n+    r.setKeyAndVersion(row);\n+    for (Column c : columns) {\n+      int idx = c.getColumnId();\n+      r.setValue(idx, row.getValue(idx));\n+    }\n+    return r;\n+  }\n+\n+  /**\n+   * Read the given page.\n+   *\n+   * @param id the page id\n+   * @return the page\n+   */\n+  PageBtree getPage(int id) {\n+    Page p = store.getPage(id);\n+    if (p == null) {\n+      PageBtreeLeaf empty = PageBtreeLeaf.create(this, id, PageBtree.ROOT);\n+      // could have been created before, but never committed\n+      store.logUndo(empty, null);\n+      store.update(empty);\n+      return empty;\n+    } else if (!(p instanceof PageBtree)) {\n+      throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"\" + p);\n+    }\n+    return (PageBtree) p;\n+  }\n+\n+  @Override\n+  public boolean canGetFirstOrLast() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Cursor findNext(Session session, SearchRow first, SearchRow last) {\n+    return find(session, first, true, last);\n+  }\n+\n+  @Override\n+  public Cursor find(Session session, SearchRow first, SearchRow last) {\n+    return find(session, first, false, last);\n+  }\n+\n+  private Cursor find(Session session, SearchRow first, boolean bigger,\n+                      SearchRow last) {\n+    if (SysProperties.CHECK && store == null) {\n+      throw DbException.get(ErrorCode.OBJECT_CLOSED);\n+    }\n+    PageBtree root = getPage(rootPageId);\n+    PageBtreeCursor cursor = new PageBtreeCursor(session, this, last);\n+    root.find(cursor, first, bigger);\n+    return cursor;\n+  }\n+\n+  @Override\n+  public Cursor findFirstOrLast(Session session, boolean first) {\n+    if (first) {\n+      // TODO optimization: this loops through NULL elements\n+      Cursor cursor = find(session, null, false, null);\n+      while (cursor.next()) {\n+        SearchRow row = cursor.getSearchRow();\n+        Value v = row.getValue(columnIds[0]);\n+        if (v != ValueNull.INSTANCE) {\n+          return cursor;\n         }\n-        PageBtree root = getPage(rootPageId);\n-        PageBtreeCursor cursor = new PageBtreeCursor(session, this, last);\n-        root.find(cursor, first, bigger);\n+      }\n+      return cursor;\n+    }\n+    PageBtree root = getPage(rootPageId);\n+    PageBtreeCursor cursor = new PageBtreeCursor(session, this, null);\n+    root.last(cursor);\n+    cursor.previous();\n+    // TODO optimization: this loops through NULL elements\n+    do {\n+      SearchRow row = cursor.getSearchRow();\n+      if (row == null) {\n+        break;\n+      }\n+      Value v = row.getValue(columnIds[0]);\n+      if (v != ValueNull.INSTANCE) {\n         return cursor;\n-    }\n-\n-    @Override\n-    public Cursor findFirstOrLast(Session session, boolean first) {\n-        if (first) {\n-            // TODO optimization: this loops through NULL elements\n-            Cursor cursor = find(session, null, false, null);\n-            while (cursor.next()) {\n-                SearchRow row = cursor.getSearchRow();\n-                Value v = row.getValue(columnIds[0]);\n-                if (v != ValueNull.INSTANCE) {\n-                    return cursor;\n-                }\n-            }\n-            return cursor;\n-        }\n+      }\n+    } while (cursor.previous());\n+    return cursor;\n+  }\n+\n+  @Override\n+  public double getCost(Session session, int[] masks,\n+                        TableFilter[] filters, int filter, SortOrder sortOrder,\n+                        AllColumnsForPlan allColumnsSet) {\n+    return 10 * getCostRangeIndex(masks, tableData.getRowCount(session),\n+        filters, filter, sortOrder, false, allColumnsSet);\n+  }\n+\n+  @Override\n+  public boolean needRebuild() {\n+    return needRebuild;\n+  }\n+\n+  @Override\n+  public void remove(Session session, Row row) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"{0} remove {1}\", getName(), row);\n+    }\n+    // TODO invalidate row count\n+    // setChanged(session);\n+    if (rowCount == 1) {\n+      removeAllRows();\n+    } else {\n+      try {\n         PageBtree root = getPage(rootPageId);\n-        PageBtreeCursor cursor = new PageBtreeCursor(session, this, null);\n-        root.last(cursor);\n-        cursor.previous();\n-        // TODO optimization: this loops through NULL elements\n-        do {\n-            SearchRow row = cursor.getSearchRow();\n-            if (row == null) {\n-                break;\n-            }\n-            Value v = row.getValue(columnIds[0]);\n-            if (v != ValueNull.INSTANCE) {\n-                return cursor;\n-            }\n-        } while (cursor.previous());\n-        return cursor;\n-    }\n-\n-    @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n-        return 10 * getCostRangeIndex(masks, tableData.getRowCount(session),\n-                filters, filter, sortOrder, false, allColumnsSet);\n-    }\n-\n-    @Override\n-    public boolean needRebuild() {\n-        return needRebuild;\n-    }\n-\n-    @Override\n-    public void remove(Session session, Row row) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"{0} remove {1}\", getName(), row);\n-        }\n-        // TODO invalidate row count\n-        // setChanged(session);\n-        if (rowCount == 1) {\n-            removeAllRows();\n-        } else {\n-            try {\n-                PageBtree root = getPage(rootPageId);\n-                root.remove(row);\n-                invalidateRowCount();\n-                rowCount--;\n-            } finally {\n-                store.incrementChangeCount();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void remove(Session session) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"remove\");\n-        }\n-        removeAllRows();\n-        store.free(rootPageId);\n-        store.removeMeta(this, session);\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"truncate\");\n-        }\n-        removeAllRows();\n-        if (tableData.getContainsLargeObject()) {\n-            database.getLobStorage().removeAllForTable(table.getId());\n-        }\n-        tableData.setRowCount(0);\n-    }\n-\n-    private void removeAllRows() {\n-        try {\n-            PageBtree root = getPage(rootPageId);\n-            root.freeRecursive();\n-            root = PageBtreeLeaf.create(this, rootPageId, PageBtree.ROOT);\n-            store.removeFromCache(rootPageId);\n-            store.update(root);\n-            rowCount = 0;\n-        } finally {\n-            store.incrementChangeCount();\n-        }\n-    }\n-\n-    @Override\n-    public void checkRename() {\n-        // ok\n-    }\n-\n-    /**\n-     * Get a row from the main index.\n-     *\n-     * @param session the session\n-     * @param key the row key\n-     * @return the row\n-     */\n-    @Override\n-    public Row getRow(Session session, long key) {\n-        return tableData.getRow(session, key);\n-    }\n-\n-    PageStore getPageStore() {\n-        return store;\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return tableData.getRowCountApproximation();\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return tableData.getDiskSpaceUsed();\n-    }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        return rowCount;\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        if (trace.isDebugEnabled()) {\n-            trace.debug(\"close\");\n-        }\n-        // can not close the index because it might get used afterwards,\n-        // for example after running recovery\n-        try {\n-            writeRowCount();\n-        } finally {\n-            store.incrementChangeCount();\n-        }\n-    }\n-\n-    /**\n-     * Read a row from the data page at the given offset.\n-     *\n-     * @param data the data\n-     * @param offset the offset\n-     * @param onlyPosition whether only the position of the row is stored\n-     * @param needData whether the row data is required\n-     * @return the row\n-     */\n-    SearchRow readRow(Data data, int offset, boolean onlyPosition,\n-            boolean needData) {\n-        synchronized (data) {\n-            data.setPos(offset);\n-            long key = data.readVarLong();\n-            if (onlyPosition) {\n-                if (needData) {\n-                    return tableData.getRow(null, key);\n-                }\n-                SearchRow row = table.getTemplateSimpleRow(true);\n-                row.setKey(key);\n-                return row;\n-            }\n-            SearchRow row = table.getTemplateSimpleRow(columns.length == 1);\n-            row.setKey(key);\n-            for (Column col : columns) {\n-                int idx = col.getColumnId();\n-                row.setValue(idx, data.readValue());\n-            }\n-            return row;\n-        }\n-    }\n-\n-    /**\n-     * Get the complete row from the data index.\n-     *\n-     * @param key the key\n-     * @return the row\n-     */\n-    SearchRow readRow(long key) {\n-        return tableData.getRow(null, key);\n-    }\n-\n-    /**\n-     * Write a row to the data page at the given offset.\n-     *\n-     * @param data the data\n-     * @param offset the offset\n-     * @param onlyPosition whether only the position of the row is stored\n-     * @param row the row to write\n-     */\n-    void writeRow(Data data, int offset, SearchRow row, boolean onlyPosition) {\n-        data.setPos(offset);\n-        data.writeVarLong(row.getKey());\n-        if (!onlyPosition) {\n-            for (Column col : columns) {\n-                int idx = col.getColumnId();\n-                data.writeValue(row.getValue(idx));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Get the size of a row (only the part that is stored in the index).\n-     *\n-     * @param dummy a dummy data page to calculate the size\n-     * @param row the row\n-     * @param onlyPosition whether only the position of the row is stored\n-     * @return the number of bytes\n-     */\n-    int getRowSize(Data dummy, SearchRow row, boolean onlyPosition) {\n-        int rowsize = Data.getVarLongLen(row.getKey());\n-        if (!onlyPosition) {\n-            for (Column col : columns) {\n-                Value v = row.getValue(col.getColumnId());\n-                rowsize += dummy.getValueLen(v);\n-            }\n-        }\n-        return rowsize;\n-    }\n-\n-    @Override\n-    public boolean canFindNext() {\n-        return true;\n-    }\n-\n-    /**\n-     * The root page has changed.\n-     *\n-     * @param session the session\n-     * @param newPos the new position\n-     */\n-    void setRootPageId(Session session, int newPos) {\n-        store.removeMeta(this, session);\n-        this.rootPageId = newPos;\n-        store.addMeta(this, session);\n-        store.addIndex(this);\n-    }\n-\n-    private void invalidateRowCount() {\n-        PageBtree root = getPage(rootPageId);\n-        root.setRowCountStored(PageData.UNKNOWN_ROWCOUNT);\n-    }\n-\n-    @Override\n-    public void writeRowCount() {\n-        if (SysProperties.MODIFY_ON_WRITE && rootPageId == 0) {\n-            // currently creating the index\n-            return;\n-        }\n-        PageBtree root = getPage(rootPageId);\n-        root.setRowCountStored(MathUtils.convertLongToInt(rowCount));\n-    }\n-\n-    /**\n-     * Check whether the given row contains data.\n-     *\n-     * @param row the row\n-     * @return true if it contains data\n-     */\n-    boolean hasData(SearchRow row) {\n-        return row.getValue(columns[0].getColumnId()) != null;\n-    }\n-\n-    int getMemoryPerPage() {\n-        return memoryPerPage;\n-    }\n-\n-    /**\n-     * The memory usage of a page was changed. The new value is used to adopt\n-     * the average estimated memory size of a page.\n-     *\n-     * @param x the new memory size\n-     */\n-    void memoryChange(int x) {\n-        if (memoryCount < Constants.MEMORY_FACTOR) {\n-            memoryPerPage += (x - memoryPerPage) / ++memoryCount;\n-        } else {\n-            memoryPerPage += (x > memoryPerPage ? 1 : -1) +\n-                    ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n-        }\n-    }\n-\n-    /**\n-     * Check if calculating the memory is required.\n-     *\n-     * @return true if it is\n-     */\n-    static boolean isMemoryChangeRequired() {\n-        if (memoryChangeRequired-- <= 0) {\n-            memoryChangeRequired = 10;\n-            return true;\n+        root.remove(row);\n+        invalidateRowCount();\n+        rowCount--;\n+      } finally {\n+        store.incrementChangeCount();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void remove(Session session) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"remove\");\n+    }\n+    removeAllRows();\n+    store.free(rootPageId);\n+    store.removeMeta(this, session);\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"truncate\");\n+    }\n+    removeAllRows();\n+    if (tableData.getContainsLargeObject()) {\n+      database.getLobStorage().removeAllForTable(table.getId());\n+    }\n+    tableData.setRowCount(0);\n+  }\n+\n+  private void removeAllRows() {\n+    try {\n+      PageBtree root = getPage(rootPageId);\n+      root.freeRecursive();\n+      root = PageBtreeLeaf.create(this, rootPageId, PageBtree.ROOT);\n+      store.removeFromCache(rootPageId);\n+      store.update(root);\n+      rowCount = 0;\n+    } finally {\n+      store.incrementChangeCount();\n+    }\n+  }\n+\n+  @Override\n+  public void checkRename() {\n+    // ok\n+  }\n+\n+  /**\n+   * Get a row from the main index.\n+   *\n+   * @param session the session\n+   * @param key     the row key\n+   * @return the row\n+   */\n+  @Override\n+  public Row getRow(Session session, long key) {\n+    return tableData.getRow(session, key);\n+  }\n+\n+  PageStore getPageStore() {\n+    return store;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return tableData.getRowCountApproximation();\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return tableData.getDiskSpaceUsed();\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    return rowCount;\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    if (trace.isDebugEnabled()) {\n+      trace.debug(\"close\");\n+    }\n+    // can not close the index because it might get used afterwards,\n+    // for example after running recovery\n+    try {\n+      writeRowCount();\n+    } finally {\n+      store.incrementChangeCount();\n+    }\n+  }\n+\n+  /**\n+   * Read a row from the data page at the given offset.\n+   *\n+   * @param data         the data\n+   * @param offset       the offset\n+   * @param onlyPosition whether only the position of the row is stored\n+   * @param needData     whether the row data is required\n+   * @return the row\n+   */\n+  SearchRow readRow(Data data, int offset, boolean onlyPosition,\n+                    boolean needData) {\n+    synchronized (data) {\n+      data.setPos(offset);\n+      long key = data.readVarLong();\n+      if (onlyPosition) {\n+        if (needData) {\n+          return tableData.getRow(null, key);\n         }\n-        return false;\n-    }\n+        SearchRow row = table.getTemplateSimpleRow(true);\n+        row.setKey(key);\n+        return row;\n+      }\n+      SearchRow row = table.getTemplateSimpleRow(columns.length == 1);\n+      row.setKey(key);\n+      for (Column col : columns) {\n+        int idx = col.getColumnId();\n+        row.setValue(idx, data.readValue());\n+      }\n+      return row;\n+    }\n+  }\n+\n+  /**\n+   * Get the complete row from the data index.\n+   *\n+   * @param key the key\n+   * @return the row\n+   */\n+  SearchRow readRow(long key) {\n+    return tableData.getRow(null, key);\n+  }\n+\n+  /**\n+   * Write a row to the data page at the given offset.\n+   *\n+   * @param data         the data\n+   * @param offset       the offset\n+   * @param onlyPosition whether only the position of the row is stored\n+   * @param row          the row to write\n+   */\n+  void writeRow(Data data, int offset, SearchRow row, boolean onlyPosition) {\n+    data.setPos(offset);\n+    data.writeVarLong(row.getKey());\n+    if (!onlyPosition) {\n+      for (Column col : columns) {\n+        int idx = col.getColumnId();\n+        data.writeValue(row.getValue(idx));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get the size of a row (only the part that is stored in the index).\n+   *\n+   * @param dummy        a dummy data page to calculate the size\n+   * @param row          the row\n+   * @param onlyPosition whether only the position of the row is stored\n+   * @return the number of bytes\n+   */\n+  int getRowSize(Data dummy, SearchRow row, boolean onlyPosition) {\n+    int rowsize = Data.getVarLongLen(row.getKey());\n+    if (!onlyPosition) {\n+      for (Column col : columns) {\n+        Value v = row.getValue(col.getColumnId());\n+        rowsize += dummy.getValueLen(v);\n+      }\n+    }\n+    return rowsize;\n+  }\n+\n+  @Override\n+  public boolean canFindNext() {\n+    return true;\n+  }\n+\n+  /**\n+   * The root page has changed.\n+   *\n+   * @param session the session\n+   * @param newPos  the new position\n+   */\n+  void setRootPageId(Session session, int newPos) {\n+    store.removeMeta(this, session);\n+    this.rootPageId = newPos;\n+    store.addMeta(this, session);\n+    store.addIndex(this);\n+  }\n+\n+  private void invalidateRowCount() {\n+    PageBtree root = getPage(rootPageId);\n+    root.setRowCountStored(PageData.UNKNOWN_ROWCOUNT);\n+  }\n+\n+  @Override\n+  public void writeRowCount() {\n+    if (SysProperties.MODIFY_ON_WRITE && rootPageId == 0) {\n+      // currently creating the index\n+      return;\n+    }\n+    PageBtree root = getPage(rootPageId);\n+    root.setRowCountStored(MathUtils.convertLongToInt(rowCount));\n+  }\n+\n+  /**\n+   * Check whether the given row contains data.\n+   *\n+   * @param row the row\n+   * @return true if it contains data\n+   */\n+  boolean hasData(SearchRow row) {\n+    return row.getValue(columns[0].getColumnId()) != null;\n+  }\n+\n+  int getMemoryPerPage() {\n+    return memoryPerPage;\n+  }\n+\n+  /**\n+   * The memory usage of a page was changed. The new value is used to adopt\n+   * the average estimated memory size of a page.\n+   *\n+   * @param x the new memory size\n+   */\n+  void memoryChange(int x) {\n+    if (memoryCount < Constants.MEMORY_FACTOR) {\n+      memoryPerPage += (x - memoryPerPage) / ++memoryCount;\n+    } else {\n+      memoryPerPage += (x > memoryPerPage ? 1 : -1) +\n+          ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n+    }\n+  }\n+\n+  /**\n+   * Check if calculating the memory is required.\n+   *\n+   * @return true if it is\n+   */\n+  static boolean isMemoryChangeRequired() {\n+    if (memoryChangeRequired-- <= 0) {\n+      memoryChangeRequired = 10;\n+      return true;\n+    }\n+    return false;\n+  }\n \n }\n",
            "diff_size": 633
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/315/PageBtreeIndex.java\nindex c8d68aa6e7..54ba57fc5a 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/315/PageBtreeIndex.java\n@@ -72,7 +72,7 @@ public class PageBtreeIndex extends PageIndex {\n         }\n         this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n         if (trace.isDebugEnabled()) {\n-            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n+            trace.debug(\"opened {0} rows: {1}\", getName(), rowCount);\n         }\n         memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n     }\n@@ -491,4 +491,4 @@ public class PageBtreeIndex extends PageIndex {\n         return false;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/315/PageBtreeIndex.java\nindex c8d68aa6e7..9e5b7b3a98 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/315/PageBtreeIndex.java\n@@ -29,10 +29,11 @@ import org.h2.value.ValueNull;\n  * This is the most common type of index, a b tree index.\n  * Only the data of the indexed columns are stored in the index.\n  */\n+\n+\n public class PageBtreeIndex extends PageIndex {\n \n     private static int memoryChangeRequired;\n-\n     private final PageStore store;\n     private final RegularTable tableData;\n     private final boolean needRebuild;\n@@ -40,9 +41,7 @@ public class PageBtreeIndex extends PageIndex {\n     private int memoryPerPage;\n     private int memoryCount;\n \n-    public PageBtreeIndex(RegularTable table, int id, String indexName,\n-            IndexColumn[] columns,\n-            IndexType indexType, boolean create, Session session) {\n+    public PageBtreeIndex(RegularTable table, int id, String indexName, IndexColumn[] columns, IndexType indexType, boolean create, Session session) {\n         initBaseIndex(table, id, indexName, columns, indexType);\n         if (!database.isStarting() && create) {\n             checkIndexColumnTypes(columns);\n@@ -70,9 +69,10 @@ public class PageBtreeIndex extends PageIndex {\n             PageBtree root = getPage(rootPageId);\n             rowCount = root.getRowCount();\n         }\n-        this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n+        this.needRebuild = create ||\n+                               (rowCount == 0 && store.isRecoveryRunning());\n         if (trace.isDebugEnabled()) {\n-            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n+            trace.debug(\"opened {0} rows: {1}\", getName(), rowCount);\n         }\n         memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n     }\n@@ -110,8 +110,7 @@ public class PageBtreeIndex extends PageIndex {\n             page1.setPageId(id);\n             page1.setParentPageId(rootPageId);\n             page2.setParentPageId(rootPageId);\n-            PageBtreeNode newRoot = PageBtreeNode.create(\n-                    this, rootPageId, PageBtree.ROOT);\n+            PageBtreeNode newRoot = PageBtreeNode.create(this, rootPageId, PageBtree.ROOT);\n             store.logUndo(newRoot, null);\n             newRoot.init(page1, pivot, page2);\n             store.update(page1);\n@@ -129,6 +128,7 @@ public class PageBtreeIndex extends PageIndex {\n      * @param row the row\n      * @return the search row\n      */\n+\n     private SearchRow getSearchRow(Row row) {\n         SearchRow r = table.getTemplateSimpleRow(columns.length == 1);\n         r.setKeyAndVersion(row);\n@@ -145,6 +145,8 @@ public class PageBtreeIndex extends PageIndex {\n      * @param id the page id\n      * @return the page\n      */\n+\n+\n     PageBtree getPage(int id) {\n         Page p = store.getPage(id);\n         if (p == null) {\n@@ -174,8 +176,9 @@ public class PageBtreeIndex extends PageIndex {\n         return find(session, first, false, last);\n     }\n \n-    private Cursor find(Session session, SearchRow first, boolean bigger,\n-            SearchRow last) {\n+    private Cursor find(Session session,\n+            SearchRow first,\n+            boolean bigger, SearchRow last) {\n         if (SysProperties.CHECK && store == null) {\n             throw DbException.get(ErrorCode.OBJECT_CLOSED);\n         }\n@@ -218,11 +221,13 @@ public class PageBtreeIndex extends PageIndex {\n     }\n \n     @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n-        return 10 * getCostRangeIndex(masks, tableData.getRowCount(session),\n-                filters, filter, sortOrder, false, allColumnsSet);\n+    public double getCost(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder, AllColumnsForPlan allColumnsSet) {\n+        return 10 * getCostRangeIndex(masks,\n+            tableData.getRowCount(session),\n+                filters,\n+                    filter,\n+                        sortOrder, false,\n+                            allColumnsSet);\n     }\n \n     @Override\n@@ -289,6 +294,7 @@ public class PageBtreeIndex extends PageIndex {\n     @Override\n     public void checkRename() {\n         // ok\n+\n     }\n \n     /**\n@@ -298,11 +304,13 @@ public class PageBtreeIndex extends PageIndex {\n      * @param key the row key\n      * @return the row\n      */\n+\n     @Override\n     public Row getRow(Session session, long key) {\n         return tableData.getRow(session, key);\n     }\n \n+\n     PageStore getPageStore() {\n         return store;\n     }\n@@ -345,8 +353,9 @@ public class PageBtreeIndex extends PageIndex {\n      * @param needData whether the row data is required\n      * @return the row\n      */\n-    SearchRow readRow(Data data, int offset, boolean onlyPosition,\n-            boolean needData) {\n+\n+\n+    SearchRow readRow(Data data, int offset, boolean onlyPosition, boolean needData) {\n         synchronized (data) {\n             data.setPos(offset);\n             long key = data.readVarLong();\n@@ -374,6 +383,8 @@ public class PageBtreeIndex extends PageIndex {\n      * @param key the key\n      * @return the row\n      */\n+\n+\n     SearchRow readRow(long key) {\n         return tableData.getRow(null, key);\n     }\n@@ -386,6 +397,8 @@ public class PageBtreeIndex extends PageIndex {\n      * @param onlyPosition whether only the position of the row is stored\n      * @param row the row to write\n      */\n+\n+\n     void writeRow(Data data, int offset, SearchRow row, boolean onlyPosition) {\n         data.setPos(offset);\n         data.writeVarLong(row.getKey());\n@@ -405,6 +418,7 @@ public class PageBtreeIndex extends PageIndex {\n      * @param onlyPosition whether only the position of the row is stored\n      * @return the number of bytes\n      */\n+\n     int getRowSize(Data dummy, SearchRow row, boolean onlyPosition) {\n         int rowsize = Data.getVarLongLen(row.getKey());\n         if (!onlyPosition) {\n@@ -427,6 +441,8 @@ public class PageBtreeIndex extends PageIndex {\n      * @param session the session\n      * @param newPos the new position\n      */\n+\n+\n     void setRootPageId(Session session, int newPos) {\n         store.removeMeta(this, session);\n         this.rootPageId = newPos;\n@@ -455,6 +471,7 @@ public class PageBtreeIndex extends PageIndex {\n      * @param row the row\n      * @return true if it contains data\n      */\n+\n     boolean hasData(SearchRow row) {\n         return row.getValue(columns[0].getColumnId()) != null;\n     }\n@@ -469,12 +486,13 @@ public class PageBtreeIndex extends PageIndex {\n      *\n      * @param x the new memory size\n      */\n+\n+\n     void memoryChange(int x) {\n         if (memoryCount < Constants.MEMORY_FACTOR) {\n             memoryPerPage += (x - memoryPerPage) / ++memoryCount;\n         } else {\n-            memoryPerPage += (x > memoryPerPage ? 1 : -1) +\n-                    ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n+            memoryPerPage += (x > memoryPerPage ? 1 : -1) + ((x - memoryPerPage) / Constants.MEMORY_FACTOR);\n         }\n     }\n \n@@ -483,6 +501,8 @@ public class PageBtreeIndex extends PageIndex {\n      *\n      * @return true if it is\n      */\n+\n+\n     static boolean isMemoryChangeRequired() {\n         if (memoryChangeRequired-- <= 0) {\n             memoryChangeRequired = 10;\n@@ -491,4 +511,4 @@ public class PageBtreeIndex extends PageIndex {\n         return false;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 45
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/315/PageBtreeIndex.java\nindex c8d68aa6e7..633a790aff 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/315/PageBtreeIndex.java\n@@ -72,7 +72,7 @@ public class PageBtreeIndex extends PageIndex {\n         }\n         this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n         if (trace.isDebugEnabled()) {\n-            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n+            trace.debug(\"opened {0} rows: {1}\", getName(), rowCount);\n         }\n         memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n     }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/315/PageBtreeIndex.java\nindex c8d68aa6e7..633a790aff 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/315/PageBtreeIndex.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/315/PageBtreeIndex.java\n@@ -72,7 +72,7 @@ public class PageBtreeIndex extends PageIndex {\n         }\n         this.needRebuild = create || (rowCount == 0 && store.isRecoveryRunning());\n         if (trace.isDebugEnabled()) {\n-            trace.debug(\"opened {0} rows: {1}\", getName() , rowCount);\n+            trace.debug(\"opened {0} rows: {1}\", getName(), rowCount);\n         }\n         memoryPerPage = (Constants.MEMORY_PAGE_BTREE + store.getPageSize()) >> 2;\n     }\n",
            "diff_size": 1
        }
    ]
}