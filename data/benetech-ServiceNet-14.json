{
    "error_id": "14",
    "information": {
        "errors": [
            {
                "line": "66",
                "severity": "error",
                "message": "'METHOD_DEF' has more than 1 empty lines before.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
            }
        ]
    },
    "source_code": "\n\n    public Optional<ProviderRecordDTO> getFilteredProviderRecord(Organization organization) {\n\n        Map<UUID, ExclusionsConfig> exclusionsMap = exclusionsConfigService.getAllBySystemAccountId();\n",
    "results": [
        {
            "tool": "styler",
            "errors": null,
            "diff": null
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "66",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/errored/1/14/RecordFactory.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/intellij/14/RecordFactory.java\nindex 25151f1e31..77021f2b7d 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/errored/1/14/RecordFactory.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/intellij/14/RecordFactory.java\n@@ -31,148 +31,152 @@ import java.util.stream.Collectors;\n @Slf4j\n public class RecordFactory {\n \n-    @Autowired\n-    private ExclusionsConfigService exclusionsConfigService;\n+  @Autowired\n+  private ExclusionsConfigService exclusionsConfigService;\n \n-    @Autowired\n-    private UserService userService;\n+  @Autowired\n+  private UserService userService;\n \n-    @Autowired\n-    private ConflictService conflictService;\n+  @Autowired\n+  private ConflictService conflictService;\n \n-    @Autowired\n-    private RecordBuilder recordBuilder;\n+  @Autowired\n+  private RecordBuilder recordBuilder;\n \n-    public Optional<ActivityRecordDTO> getFilteredRecord(Organization organization) {\n-        List<ConflictDTO> conflicts = getBaseConflicts(organization.getId());\n+  public Optional<ActivityRecordDTO> getFilteredRecord(Organization organization) {\n+    List<ConflictDTO> conflicts = getBaseConflicts(organization.getId());\n \n-        Map<UUID, ExclusionsConfig> exclusionsMap = exclusionsConfigService.getAllBySystemAccountId();\n+    Map<UUID, ExclusionsConfig> exclusionsMap = exclusionsConfigService.getAllBySystemAccountId();\n \n-        Set<ExclusionsConfig> baseExclusions = getBaseExclusions(organization.getAccount().getId(), exclusionsMap);\n-        Set<FieldExclusion> fieldExclusions = baseExclusions.stream()\n-            .flatMap(e -> e.getExclusions().stream())\n-            .collect(Collectors.toSet());\n+    Set<ExclusionsConfig> baseExclusions = getBaseExclusions(organization.getAccount().getId(), exclusionsMap);\n+    Set<FieldExclusion> fieldExclusions = baseExclusions.stream()\n+        .flatMap(e -> e.getExclusions().stream())\n+        .collect(Collectors.toSet());\n \n-        Set<LocationExclusion> locationExclusions = baseExclusions.stream()\n-            .flatMap(e -> e.getLocationExclusions().stream())\n-            .collect(Collectors.toSet());\n+    Set<LocationExclusion> locationExclusions = baseExclusions.stream()\n+        .flatMap(e -> e.getLocationExclusions().stream())\n+        .collect(Collectors.toSet());\n \n-        List<ConflictDTO> filteredConflicts = filterConflicts(conflicts, fieldExclusions, exclusionsMap);\n+    List<ConflictDTO> filteredConflicts = filterConflicts(conflicts, fieldExclusions, exclusionsMap);\n \n-        return filterRecord(organization, filteredConflicts, fieldExclusions, locationExclusions);\n-    }\n+    return filterRecord(organization, filteredConflicts, fieldExclusions, locationExclusions);\n+  }\n \n \n-    public Optional<ProviderRecordDTO> getFilteredProviderRecord(Organization organization) {\n+  public Optional<ProviderRecordDTO> getFilteredProviderRecord(Organization organization) {\n \n-        Map<UUID, ExclusionsConfig> exclusionsMap = exclusionsConfigService.getAllBySystemAccountId();\n+    Map<UUID, ExclusionsConfig> exclusionsMap = exclusionsConfigService.getAllBySystemAccountId();\n \n-        Set<ExclusionsConfig> baseExclusions = getBaseExclusions(organization.getAccount().getId(), exclusionsMap);\n-        Set<FieldExclusion> fieldExclusions = baseExclusions.stream()\n-            .flatMap(e -> e.getExclusions().stream())\n-            .collect(Collectors.toSet());\n+    Set<ExclusionsConfig> baseExclusions = getBaseExclusions(organization.getAccount().getId(), exclusionsMap);\n+    Set<FieldExclusion> fieldExclusions = baseExclusions.stream()\n+        .flatMap(e -> e.getExclusions().stream())\n+        .collect(Collectors.toSet());\n \n-        Set<LocationExclusion> locationExclusions = baseExclusions.stream()\n-            .flatMap(e -> e.getLocationExclusions().stream())\n-            .collect(Collectors.toSet());\n+    Set<LocationExclusion> locationExclusions = baseExclusions.stream()\n+        .flatMap(e -> e.getLocationExclusions().stream())\n+        .collect(Collectors.toSet());\n \n-        return filterProviderRecord(organization, fieldExclusions, locationExclusions);\n-    }\n+    return filterProviderRecord(organization, fieldExclusions, locationExclusions);\n+  }\n \n-    public ActivityDTO getFilteredResult(ActivityInfo info, Map<UUID, ExclusionsConfig> exclusionsMap) {\n-        Set<FieldExclusion> baseExclusions = Optional.ofNullable(exclusionsMap.get(info.getAccountId()))\n-            .map(ExclusionsConfig::getExclusions).orElse(new HashSet<>());\n-\n-        List<ConflictDTO> conflicts = getBaseConflicts(info.getId());\n-        List<ConflictDTO> filteredConflicts = filterConflicts(conflicts, baseExclusions, exclusionsMap);\n-        List<UUID> matches = info.getOrganizationMatches().stream().map(OrganizationMatch::getId)\n-            .collect(Collectors.toList());\n-        SystemAccount systemAccount = info.getOrganization().getAccount();\n-\n-        return ActivityDTO.builder()\n-            .accountName(systemAccount.getName())\n-            .organizationId(info.getId())\n-            .organizationName(info.getName())\n-            .organizationMatches(matches)\n-            .lastUpdated(info.getRecent())\n-            .conflicts(filteredConflicts)\n-            .build();\n-    }\n+  public ActivityDTO getFilteredResult(ActivityInfo info, Map<UUID, ExclusionsConfig> exclusionsMap) {\n+    Set<FieldExclusion> baseExclusions = Optional.ofNullable(exclusionsMap.get(info.getAccountId()))\n+        .map(ExclusionsConfig::getExclusions).orElse(new HashSet<>());\n \n-    private List<ConflictDTO> getBaseConflicts(UUID resourceId) {\n-        return conflictService.findAllPendingWithResourceId(resourceId);\n-    }\n+    List<ConflictDTO> conflicts = getBaseConflicts(info.getId());\n+    List<ConflictDTO> filteredConflicts = filterConflicts(conflicts, baseExclusions, exclusionsMap);\n+    List<UUID> matches = info.getOrganizationMatches().stream().map(OrganizationMatch::getId)\n+        .collect(Collectors.toList());\n+    SystemAccount systemAccount = info.getOrganization().getAccount();\n \n-    private List<ConflictDTO> filterConflicts(List<ConflictDTO> conflicts, Set<FieldExclusion> baseExclusions,\n-        Map<UUID, ExclusionsConfig> exclusionsMap) {\n+    return ActivityDTO.builder()\n+        .accountName(systemAccount.getName())\n+        .organizationId(info.getId())\n+        .organizationName(info.getName())\n+        .organizationMatches(matches)\n+        .lastUpdated(info.getRecent())\n+        .conflicts(filteredConflicts)\n+        .build();\n+  }\n \n-        return conflicts.stream()\n-            .filter(conf -> isNotExcluded(conf, baseExclusions)\n-                && isNotExcluded(conf, Optional.ofNullable(exclusionsMap.get(conf.getPartnerId()))\n-                .map(ExclusionsConfig::getExclusions).orElse(new HashSet<>())))\n-            .collect(Collectors.toList());\n-    }\n-\n-    private boolean isNotExcluded(ConflictDTO conflict, Set<FieldExclusion> exclusions) {\n-        return exclusions.stream().noneMatch(x ->\n-            x.getEntity().equals(conflict.getEntityPath())\n-                && x.getExcludedFields().contains(conflict.getFieldName()));\n-    }\n+  private List<ConflictDTO> getBaseConflicts(UUID resourceId) {\n+    return conflictService.findAllPendingWithResourceId(resourceId);\n+  }\n \n-    private Set<ExclusionsConfig> getBaseExclusions(UUID accountId, Map<UUID, ExclusionsConfig> exclusionsMap) {\n-        Set<ExclusionsConfig> exclusions = new HashSet<>();\n+  private List<ConflictDTO> filterConflicts(List<ConflictDTO> conflicts, Set<FieldExclusion> baseExclusions,\n+                                            Map<UUID, ExclusionsConfig> exclusionsMap) {\n \n-        userService.getCurrentSystemAccount()\n-            .map(systemAccount -> Optional.ofNullable(exclusionsMap.get(systemAccount.getId())))\n-            .ifPresent(exclusionsConfig -> exclusionsConfig.ifPresent(exclusions::add));\n+    return conflicts.stream()\n+        .filter(conf -> isNotExcluded(conf, baseExclusions)\n+            && isNotExcluded(conf, Optional.ofNullable(exclusionsMap.get(conf.getPartnerId()))\n+            .map(ExclusionsConfig::getExclusions).orElse(new HashSet<>())))\n+        .collect(Collectors.toList());\n+  }\n \n-        Optional.ofNullable(exclusionsMap.get(accountId))\n-            .ifPresent(exclusions::add);\n+  private boolean isNotExcluded(ConflictDTO conflict, Set<FieldExclusion> exclusions) {\n+    return exclusions.stream().noneMatch(x ->\n+        x.getEntity().equals(conflict.getEntityPath())\n+            && x.getExcludedFields().contains(conflict.getFieldName()));\n+  }\n \n-        return exclusions;\n-    }\n+  private Set<ExclusionsConfig> getBaseExclusions(UUID accountId, Map<UUID, ExclusionsConfig> exclusionsMap) {\n+    Set<ExclusionsConfig> exclusions = new HashSet<>();\n \n-    private Optional<ActivityRecordDTO> filterRecord(Organization organization, List<ConflictDTO> conflicts,\n-        Set<FieldExclusion> exclusions, Set<LocationExclusion> locationExclusions) {\n-        try {\n-            return Optional.of(buildRecord(organization, conflicts, exclusions, locationExclusions));\n-        } catch (IllegalAccessException e) {\n-            log.error(\"Unable to filter record.\");\n-            return Optional.empty();\n-        }\n-    }\n+    userService.getCurrentSystemAccount()\n+        .map(systemAccount -> Optional.ofNullable(exclusionsMap.get(systemAccount.getId())))\n+        .ifPresent(exclusionsConfig -> exclusionsConfig.ifPresent(exclusions::add));\n \n-    private Optional<ProviderRecordDTO> filterProviderRecord(Organization organization,\n-        Set<FieldExclusion> exclusions, Set<LocationExclusion> locationExclusions) {\n-        try {\n-            return Optional.of(buildProviderRecord(organization, exclusions, locationExclusions));\n-        } catch (IllegalAccessException e) {\n-            log.error(\"Unable to filter record.\");\n-            return Optional.empty();\n-        }\n-    }\n+    Optional.ofNullable(exclusionsMap.get(accountId))\n+        .ifPresent(exclusions::add);\n \n-    private ActivityRecordDTO buildRecord(Organization organization, List<ConflictDTO> conflictDTOS,\n-        Set<FieldExclusion> exclusions, Set<LocationExclusion> locationExclusions) throws IllegalAccessException {\n+    return exclusions;\n+  }\n \n-        if (exclusions.isEmpty()) {\n-            return recordBuilder.buildBasicRecord(\n-                organization, organization.getUpdatedAt(), conflictDTOS, locationExclusions);\n-        } else {\n-            return recordBuilder.buildFilteredRecord(organization, organization.getUpdatedAt(),\n-                conflictDTOS, exclusions, locationExclusions);\n-        }\n+  private Optional<ActivityRecordDTO> filterRecord(Organization organization, List<ConflictDTO> conflicts,\n+                                                   Set<FieldExclusion> exclusions,\n+                                                   Set<LocationExclusion> locationExclusions) {\n+    try {\n+      return Optional.of(buildRecord(organization, conflicts, exclusions, locationExclusions));\n+    } catch (IllegalAccessException e) {\n+      log.error(\"Unable to filter record.\");\n+      return Optional.empty();\n     }\n-\n-    private ProviderRecordDTO buildProviderRecord(Organization organization,\n-        Set<FieldExclusion> exclusions, Set<LocationExclusion> locationExclusions) throws IllegalAccessException {\n-\n-        if (exclusions.isEmpty()) {\n-            return recordBuilder.buildBasicProviderRecord(\n-                organization, organization.getUpdatedAt(), locationExclusions);\n-        } else {\n-            return recordBuilder.buildFilteredProviderRecord(organization, organization.getUpdatedAt(),\n-                 exclusions, locationExclusions);\n-        }\n+  }\n+\n+  private Optional<ProviderRecordDTO> filterProviderRecord(Organization organization,\n+                                                           Set<FieldExclusion> exclusions,\n+                                                           Set<LocationExclusion> locationExclusions) {\n+    try {\n+      return Optional.of(buildProviderRecord(organization, exclusions, locationExclusions));\n+    } catch (IllegalAccessException e) {\n+      log.error(\"Unable to filter record.\");\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private ActivityRecordDTO buildRecord(Organization organization, List<ConflictDTO> conflictDTOS,\n+                                        Set<FieldExclusion> exclusions, Set<LocationExclusion> locationExclusions)\n+      throws IllegalAccessException {\n+\n+    if (exclusions.isEmpty()) {\n+      return recordBuilder.buildBasicRecord(\n+          organization, organization.getUpdatedAt(), conflictDTOS, locationExclusions);\n+    } else {\n+      return recordBuilder.buildFilteredRecord(organization, organization.getUpdatedAt(),\n+          conflictDTOS, exclusions, locationExclusions);\n+    }\n+  }\n+\n+  private ProviderRecordDTO buildProviderRecord(Organization organization,\n+                                                Set<FieldExclusion> exclusions, Set<LocationExclusion> locationExclusions)\n+      throws IllegalAccessException {\n+\n+    if (exclusions.isEmpty()) {\n+      return recordBuilder.buildBasicProviderRecord(\n+          organization, organization.getUpdatedAt(), locationExclusions);\n+    } else {\n+      return recordBuilder.buildFilteredProviderRecord(organization, organization.getUpdatedAt(),\n+          exclusions, locationExclusions);\n     }\n+  }\n }\n",
            "diff_size": 157
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "173",
                    "severity": "error",
                    "message": "Line is longer than 125 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/errored/1/14/RecordFactory.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/naturalize/14/RecordFactory.java\nindex 25151f1e31..31c4de46c3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/errored/1/14/RecordFactory.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/benetech-ServiceNet/naturalize/14/RecordFactory.java\n@@ -62,8 +62,7 @@ public class RecordFactory {\n         return filterRecord(organization, filteredConflicts, fieldExclusions, locationExclusions);\n     }\n \n-\n-    public Optional<ProviderRecordDTO> getFilteredProviderRecord(Organization organization) {\n+public Optional<ProviderRecordDTO> getFilteredProviderRecord(Organization organization) {\n \n         Map<UUID, ExclusionsConfig> exclusionsMap = exclusionsConfigService.getAllBySystemAccountId();\n \n@@ -171,8 +170,7 @@ public class RecordFactory {\n             return recordBuilder.buildBasicProviderRecord(\n                 organization, organization.getUpdatedAt(), locationExclusions);\n         } else {\n-            return recordBuilder.buildFilteredProviderRecord(organization, organization.getUpdatedAt(),\n-                 exclusions, locationExclusions);\n-        }\n+            return recordBuilder.buildFilteredProviderRecord(organization, organization.getUpdatedAt(), exclusions, locationExclusions);\n+    }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 6
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}