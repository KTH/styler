{
    "error_id": "15",
    "information": {
        "errors": [
            {
                "line": "183",
                "severity": "warning",
                "message": "Comment has incorrect indentation level 0, expected is 4, indentation should be the same level as line 193.",
                "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
            }
        ]
    },
    "source_code": "//**********************************************************************************************************************\n// Other Methods\n//**********************************************************************************************************************\n\n    /**\n     * Registers an event listener.",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/15/EventListenerSupport.java\nindex e717d4ee20..b159717bd0 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/15/EventListenerSupport.java\n@@ -1,331 +1,331 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.event;\r\n-\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.Serializable;\r\n-import java.lang.reflect.Array;\r\n-import java.lang.reflect.InvocationHandler;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Proxy;\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Validate;\r\n-\r\n-/**\r\n- * An EventListenerSupport object can be used to manage a list of event\r\n- * listeners of a particular type. The class provides\r\n- * {@link #addListener(Object)} and {@link #removeListener(Object)} methods\r\n- * for registering listeners, as well as a {@link #fire()} method for firing\r\n- * events to the listeners.\r\n- *\r\n- * <p/>\r\n- * To use this class, suppose you want to support ActionEvents.  You would do:\r\n- * <code><pre>\r\n- * public class MyActionEventSource\r\n- * {\r\n- *   private EventListenerSupport<ActionListener> actionListeners =\r\n- *       EventListenerSupport.create(ActionListener.class);\r\n- *\r\n- *   public void someMethodThatFiresAction()\r\n- *   {\r\n- *     ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"somethingCool\");\r\n- *     actionListeners.fire().actionPerformed(e);\r\n- *   }\r\n- * }\r\n- * </pre></code>\r\n- *\r\n- * Serializing an {@link EventListenerSupport} instance will result in any\r\n- * non-{@link Serializable} listeners being silently dropped.\r\n- *\r\n- * @param <L> the type of event listener that is supported by this proxy.\r\n- *\r\n- * @since 3.0\r\n- * @version $Id: EventListenerSupport.java 1082302 2011-03-16 21:08:27Z oheger $\r\n- */\r\n-public class EventListenerSupport<L> implements Serializable {\r\n-\r\n-    /** Serialization version */\r\n-    private static final long serialVersionUID = 3593265990380473632L;\r\n-\r\n-    /**\r\n-     * The list used to hold the registered listeners. This list is\r\n-     * intentionally a thread-safe copy-on-write-array so that traversals over\r\n-     * the list of listeners will be atomic.\r\n-     */\r\n-    private List<L> listeners = new CopyOnWriteArrayList<L>();\r\n-\r\n-    /**\r\n-     * The proxy representing the collection of listeners. Calls to this proxy\r\n-     * object will sent to all registered listeners.\r\n-     */\r\n-    private transient L proxy;\r\n-\r\n-    /**\r\n-     * Empty typed array for #getListeners().\r\n-     */\r\n-    private transient L[] prototypeArray;\r\n-\r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the specified\r\n-     * listener type.\r\n-     *\r\n-     * @param <T> the type of the listener interface\r\n-     * @param listenerInterface the type of listener interface that will receive\r\n-     *        events posted using this class.\r\n-     *\r\n-     * @return an EventListenerSupport object which supports the specified\r\n-     *         listener type.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> is\r\n-     *         <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\r\n-        return new EventListenerSupport<T>(listenerInterface);\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the provided\r\n-     * listener interface.\r\n-     *\r\n-     * @param listenerInterface the type of listener interface that will receive\r\n-     *        events posted using this class.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> is\r\n-     *         <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface) {\r\n-        this(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the provided\r\n-     * listener interface using the specified class loader to create the JDK\r\n-     * dynamic proxy.\r\n-     *\r\n-     * @param listenerInterface the listener interface.\r\n-     * @param classLoader       the class loader.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> or\r\n-     *         <code>classLoader</code> is <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        this();\r\n-        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\r\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\r\n-        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\r\n-                listenerInterface.getName());\r\n-        initializeTransientFields(listenerInterface, classLoader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new EventListenerSupport instance.\r\n-     * Serialization-friendly constructor.\r\n-     */\r\n-    private EventListenerSupport() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a proxy object which can be used to call listener methods on all\r\n-     * of the registered event listeners. All calls made to this proxy will be\r\n-     * forwarded to all registered listeners.\r\n-     *\r\n-     * @return a proxy object which can be used to call listener methods on all\r\n-     * of the registered event listeners\r\n-     */\r\n-    public L fire() {\r\n-        return proxy;\r\n-    }\r\n-\r\n-//**********************************************************************************************************************\r\n-// Other Methods\r\n-//**********************************************************************************************************************\r\n-\r\n-    /**\r\n-     * Registers an event listener.\r\n-     *\r\n-     * @param listener the event listener (may not be <code>null</code>).\r\n-     *\r\n-     * @throws NullPointerException if <code>listener</code> is\r\n-     *         <code>null</code>.\r\n-     */\r\n-    public void addListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.add(listener);\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the number of registered listeners.\r\n-     *\r\n-     * @return the number of registered listeners.\r\n-     */\r\n-    int getListenerCount() {\r\n-        return listeners.size();\r\n-    }\r\n-\r\n-    /**\r\n-     * Unregisters an event listener.\r\n-     *\r\n-     * @param listener the event listener (may not be <code>null</code>).\r\n-     *\r\n-     * @throws NullPointerException if <code>listener</code> is\r\n-     *         <code>null</code>.\r\n-     */\r\n-    public void removeListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.remove(listener);\r\n-    }\r\n-\r\n-    /**\r\n-     * Get an array containing the currently registered listeners.\r\n-     * Modification to this array's elements will have no effect on the\r\n-     * {@link EventListenerSupport} instance.\r\n-     * @return L[]\r\n-     */\r\n-    public L[] getListeners() {\r\n-        return listeners.toArray(prototypeArray);\r\n-    }\r\n-\r\n-    /**\r\n-     * Serialize.\r\n-     * @param objectOutputStream the output stream\r\n-     * @throws IOException if an IO error occurs\r\n-     */\r\n-    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\r\n-        ArrayList<L> serializableListeners = new ArrayList<L>();\r\n-\r\n-        // don't just rely on instanceof Serializable:\r\n-        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-        for (L listener : listeners) {\r\n-            try {\r\n-                testObjectOutputStream.writeObject(listener);\r\n-                serializableListeners.add(listener);\r\n-            } catch (IOException exception) {\r\n-                //recreate test stream in case of indeterminate state\r\n-                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-            }\r\n-        }\r\n-        /*\r\n-         * we can reconstitute everything we need from an array of our listeners,\r\n-         * which has the additional advantage of typically requiring less storage than a list:\r\n-         */\r\n-        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\r\n-    }\r\n-\r\n-    /**\r\n-     * Deserialize.\r\n-     * @param objectInputStream the input stream\r\n-     * @throws IOException if an IO error occurs\r\n-     * @throws ClassNotFoundException if the class cannot be resolved\r\n-     */\r\n-    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] listeners = (L[]) objectInputStream.readObject();\r\n-\r\n-        this.listeners = new CopyOnWriteArrayList<L>(listeners);\r\n-\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\r\n-\r\n-        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n-\r\n-    /**\r\n-     * Initialize transient fields.\r\n-     * @param listenerInterface the class of the listener interface\r\n-     * @param classLoader the class loader to be used\r\n-     */\r\n-    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n-        this.prototypeArray = array;\r\n-        createProxy(listenerInterface, classLoader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create the proxy object.\r\n-     * @param listenerInterface the class of the listener interface\r\n-     * @param classLoader the class loader to be used\r\n-     */\r\n-    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\r\n-                new Class[] { listenerInterface }, createInvocationHandler()));\r\n-    }\r\n-\r\n-    /**\r\n-     * Create the {@link InvocationHandler} responsible for broadcasting calls\r\n-     * to the managed listeners.  Subclasses can override to provide custom behavior.\r\n-     * @return ProxyInvocationHandler\r\n-     */\r\n-    protected InvocationHandler createInvocationHandler() {\r\n-        return new ProxyInvocationHandler();\r\n-    }\r\n-\r\n-    /**\r\n-     * An invocation handler used to dispatch the event(s) to all the listeners.\r\n-     */\r\n-    protected class ProxyInvocationHandler implements InvocationHandler {\r\n-        /** Serialization version */\r\n-        private static final long serialVersionUID = 1L;\r\n-\r\n-        /**\r\n-         * Propagates the method call to all registered listeners in place of\r\n-         * the proxy listener object.\r\n-         *\r\n-         * @param proxy the proxy object representing a listener on which the\r\n-         *        invocation was called.\r\n-         * @param method the listener method that will be called on all of the\r\n-         *        listeners.\r\n-         * @param args event arguments to propagate to the listeners.\r\n-         * @return the result of the method call\r\n-         * @throws Throwable if an error occurs\r\n-         */\r\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n-            for (L listener : listeners) {\r\n-                method.invoke(listener, args);\r\n-            }\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.event;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Validate;\n+\n+/**\n+ * An EventListenerSupport object can be used to manage a list of event\n+ * listeners of a particular type. The class provides\n+ * {@link #addListener(Object)} and {@link #removeListener(Object)} methods\n+ * for registering listeners, as well as a {@link #fire()} method for firing\n+ * events to the listeners.\n+ *\n+ * <p/>\n+ * To use this class, suppose you want to support ActionEvents.  You would do:\n+ * <code><pre>\n+ * public class MyActionEventSource\n+ * {\n+ *   private EventListenerSupport<ActionListener> actionListeners =\n+ *       EventListenerSupport.create(ActionListener.class);\n+ *\n+ *   public void someMethodThatFiresAction()\n+ *   {\n+ *     ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"somethingCool\");\n+ *     actionListeners.fire().actionPerformed(e);\n+ *   }\n+ * }\n+ * </pre></code>\n+ *\n+ * Serializing an {@link EventListenerSupport} instance will result in any\n+ * non-{@link Serializable} listeners being silently dropped.\n+ *\n+ * @param <L> the type of event listener that is supported by this proxy.\n+ *\n+ * @since 3.0\n+ * @version $Id: EventListenerSupport.java 1082302 2011-03-16 21:08:27Z oheger $\n+ */\n+public class EventListenerSupport<L> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3593265990380473632L;\n+\n+    /**\n+     * The list used to hold the registered listeners. This list is\n+     * intentionally a thread-safe copy-on-write-array so that traversals over\n+     * the list of listeners will be atomic.\n+     */\n+    private List<L> listeners = new CopyOnWriteArrayList<L>();\n+\n+    /**\n+     * The proxy representing the collection of listeners. Calls to this proxy\n+     * object will sent to all registered listeners.\n+     */\n+    private transient L proxy;\n+\n+    /**\n+     * Empty typed array for #getListeners().\n+     */\n+    private transient L[] prototypeArray;\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the specified\n+     * listener type.\n+     *\n+     * @param <T> the type of the listener interface\n+     * @param listenerInterface the type of listener interface that will receive\n+     *        events posted using this class.\n+     *\n+     * @return an EventListenerSupport object which supports the specified\n+     *         listener type.\n+     *\n+     * @throws NullPointerException if <code>listenerInterface</code> is\n+     *         <code>null</code>.\n+     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n+     *         not an interface.\n+     */\n+    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\n+        return new EventListenerSupport<T>(listenerInterface);\n+    }\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the provided\n+     * listener interface.\n+     *\n+     * @param listenerInterface the type of listener interface that will receive\n+     *        events posted using this class.\n+     *\n+     * @throws NullPointerException if <code>listenerInterface</code> is\n+     *         <code>null</code>.\n+     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n+     *         not an interface.\n+     */\n+    public EventListenerSupport(Class<L> listenerInterface) {\n+        this(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the provided\n+     * listener interface using the specified class loader to create the JDK\n+     * dynamic proxy.\n+     *\n+     * @param listenerInterface the listener interface.\n+     * @param classLoader       the class loader.\n+     *\n+     * @throws NullPointerException if <code>listenerInterface</code> or\n+     *         <code>classLoader</code> is <code>null</code>.\n+     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n+     *         not an interface.\n+     */\n+    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n+        this();\n+        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n+        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n+        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n+                listenerInterface.getName());\n+        initializeTransientFields(listenerInterface, classLoader);\n+    }\n+\n+    /**\n+     * Create a new EventListenerSupport instance.\n+     * Serialization-friendly constructor.\n+     */\n+    private EventListenerSupport() {\n+    }\n+\n+    /**\n+     * Returns a proxy object which can be used to call listener methods on all\n+     * of the registered event listeners. All calls made to this proxy will be\n+     * forwarded to all registered listeners.\n+     *\n+     * @return a proxy object which can be used to call listener methods on all\n+     * of the registered event listeners\n+     */\n+    public L fire() {\n+        return proxy;\n+    }\n+\n+//**********************************************************************************************************************\n+// Other Methods\n+//**********************************************************************************************************************\n+/**\n+     * Registers an event listener.\n+     *\n+     * @param listener the event listener (may not be <code>null</code>).\n+     *\n+     * @throws NullPointerException if <code>listener</code> is\n+     *         <code>null</code>.\n+     */\n+\n+public void addListener(L listener) {\n+        Validate.notNull(listener, \"Listener object cannot be null.\");\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Returns the number of registered listeners.\n+     *\n+     * @return the number of registered listeners.\n+     */\n+    int getListenerCount() {\n+        return listeners.size();\n+    }\n+\n+    /**\n+     * Unregisters an event listener.\n+     *\n+     * @param listener the event listener (may not be <code>null</code>).\n+     *\n+     * @throws NullPointerException if <code>listener</code> is\n+     *         <code>null</code>.\n+     */\n+    public void removeListener(L listener) {\n+        Validate.notNull(listener, \"Listener object cannot be null.\");\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Get an array containing the currently registered listeners.\n+     * Modification to this array's elements will have no effect on the\n+     * {@link EventListenerSupport} instance.\n+     * @return L[]\n+     */\n+    public L[] getListeners() {\n+        return listeners.toArray(prototypeArray);\n+    }\n+\n+    /**\n+     * Serialize.\n+     * @param objectOutputStream the output stream\n+     * @throws IOException if an IO error occurs\n+     */\n+    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\n+        ArrayList<L> serializableListeners = new ArrayList<L>();\n+\n+        // don't just rely on instanceof Serializable:\n+        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+        for (L listener : listeners) {\n+            try {\n+                testObjectOutputStream.writeObject(listener);\n+                serializableListeners.add(listener);\n+            } catch (IOException exception) {\n+                //recreate test stream in case of indeterminate state\n+                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+            }\n+        }\n+        /*\n+         * we can reconstitute everything we need from an array of our listeners,\n+         * which has the additional advantage of typically requiring less storage than a list:\n+         */\n+        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\n+    }\n+\n+    /**\n+     * Deserialize.\n+     * @param objectInputStream the input stream\n+     * @throws IOException if an IO error occurs\n+     * @throws ClassNotFoundException if the class cannot be resolved\n+     */\n+    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n+        @SuppressWarnings(\"unchecked\")\n+        L[] listeners = (L[]) objectInputStream.readObject();\n+\n+        this.listeners = new CopyOnWriteArrayList<L>(listeners);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\n+\n+        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    /**\n+     * Initialize transient fields.\n+     * @param listenerInterface the class of the listener interface\n+     * @param classLoader the class loader to be used\n+     */\n+    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\n+        @SuppressWarnings(\"unchecked\")\n+        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n+        this.prototypeArray = array;\n+        createProxy(listenerInterface, classLoader);\n+    }\n+\n+    /**\n+     * Create the proxy object.\n+     * @param listenerInterface the class of the listener interface\n+     * @param classLoader the class loader to be used\n+     */\n+    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n+        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n+                new Class[] { listenerInterface }, createInvocationHandler()));\n+    }\n+\n+    /**\n+     * Create the {@link InvocationHandler} responsible for broadcasting calls\n+     * to the managed listeners.  Subclasses can override to provide custom behavior.\n+     * @return ProxyInvocationHandler\n+     */\n+    protected InvocationHandler createInvocationHandler() {\n+        return new ProxyInvocationHandler();\n+    }\n+\n+    /**\n+     * An invocation handler used to dispatch the event(s) to all the listeners.\n+     */\n+    protected class ProxyInvocationHandler implements InvocationHandler {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * Propagates the method call to all registered listeners in place of\n+         * the proxy listener object.\n+         *\n+         * @param proxy the proxy object representing a listener on which the\n+         *        invocation was called.\n+         * @param method the listener method that will be called on all of the\n+         *        listeners.\n+         * @param args event arguments to propagate to the listeners.\n+         * @return the result of the method call\n+         * @throws Throwable if an error occurs\n+         */\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            for (L listener : listeners) {\n+                method.invoke(listener, args);\n+            }\n+            return null;\n+        }\n+    }\n+}\n",
            "diff_size": 331
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "183",
                    "severity": "warning",
                    "message": "Comment has incorrect indentation level 0, expected is 2, indentation should be the same level as line 193.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/15/EventListenerSupport.java\nindex e717d4ee20..20111396b8 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/15/EventListenerSupport.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -80,252 +80,252 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Valida\n  */\r\n public class EventListenerSupport<L> implements Serializable {\r\n \r\n-    /** Serialization version */\r\n-    private static final long serialVersionUID = 3593265990380473632L;\r\n+  /** Serialization version */\r\n+  private static final long serialVersionUID = 3593265990380473632L;\r\n \r\n-    /**\r\n-     * The list used to hold the registered listeners. This list is\r\n-     * intentionally a thread-safe copy-on-write-array so that traversals over\r\n-     * the list of listeners will be atomic.\r\n-     */\r\n-    private List<L> listeners = new CopyOnWriteArrayList<L>();\r\n+  /**\r\n+   * The list used to hold the registered listeners. This list is\r\n+   * intentionally a thread-safe copy-on-write-array so that traversals over\r\n+   * the list of listeners will be atomic.\r\n+   */\r\n+  private List<L> listeners = new CopyOnWriteArrayList<L>();\r\n \r\n-    /**\r\n-     * The proxy representing the collection of listeners. Calls to this proxy\r\n-     * object will sent to all registered listeners.\r\n-     */\r\n-    private transient L proxy;\r\n+  /**\r\n+   * The proxy representing the collection of listeners. Calls to this proxy\r\n+   * object will sent to all registered listeners.\r\n+   */\r\n+  private transient L proxy;\r\n \r\n-    /**\r\n-     * Empty typed array for #getListeners().\r\n-     */\r\n-    private transient L[] prototypeArray;\r\n+  /**\r\n+   * Empty typed array for #getListeners().\r\n+   */\r\n+  private transient L[] prototypeArray;\r\n \r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the specified\r\n-     * listener type.\r\n-     *\r\n-     * @param <T> the type of the listener interface\r\n-     * @param listenerInterface the type of listener interface that will receive\r\n-     *        events posted using this class.\r\n-     *\r\n-     * @return an EventListenerSupport object which supports the specified\r\n-     *         listener type.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> is\r\n-     *         <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\r\n-        return new EventListenerSupport<T>(listenerInterface);\r\n-    }\r\n+  /**\r\n+   * Creates an EventListenerSupport object which supports the specified\r\n+   * listener type.\r\n+   *\r\n+   * @param <T> the type of the listener interface\r\n+   * @param listenerInterface the type of listener interface that will receive\r\n+   *        events posted using this class.\r\n+   *\r\n+   * @return an EventListenerSupport object which supports the specified\r\n+   *         listener type.\r\n+   *\r\n+   * @throws NullPointerException if <code>listenerInterface</code> is\r\n+   *         <code>null</code>.\r\n+   * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n+   *         not an interface.\r\n+   */\r\n+  public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\r\n+    return new EventListenerSupport<T>(listenerInterface);\r\n+  }\r\n \r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the provided\r\n-     * listener interface.\r\n-     *\r\n-     * @param listenerInterface the type of listener interface that will receive\r\n-     *        events posted using this class.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> is\r\n-     *         <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface) {\r\n-        this(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n+  /**\r\n+   * Creates an EventListenerSupport object which supports the provided\r\n+   * listener interface.\r\n+   *\r\n+   * @param listenerInterface the type of listener interface that will receive\r\n+   *        events posted using this class.\r\n+   *\r\n+   * @throws NullPointerException if <code>listenerInterface</code> is\r\n+   *         <code>null</code>.\r\n+   * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n+   *         not an interface.\r\n+   */\r\n+  public EventListenerSupport(Class<L> listenerInterface) {\r\n+    this(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n+  }\r\n \r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the provided\r\n-     * listener interface using the specified class loader to create the JDK\r\n-     * dynamic proxy.\r\n-     *\r\n-     * @param listenerInterface the listener interface.\r\n-     * @param classLoader       the class loader.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> or\r\n-     *         <code>classLoader</code> is <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        this();\r\n-        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\r\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\r\n-        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\r\n-                listenerInterface.getName());\r\n-        initializeTransientFields(listenerInterface, classLoader);\r\n-    }\r\n+  /**\r\n+   * Creates an EventListenerSupport object which supports the provided\r\n+   * listener interface using the specified class loader to create the JDK\r\n+   * dynamic proxy.\r\n+   *\r\n+   * @param listenerInterface the listener interface.\r\n+   * @param classLoader       the class loader.\r\n+   *\r\n+   * @throws NullPointerException if <code>listenerInterface</code> or\r\n+   *         <code>classLoader</code> is <code>null</code>.\r\n+   * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n+   *         not an interface.\r\n+   */\r\n+  public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\r\n+    this();\r\n+    Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\r\n+    Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\r\n+    Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\r\n+      listenerInterface.getName());\r\n+    initializeTransientFields(listenerInterface, classLoader);\r\n+  }\r\n \r\n-    /**\r\n-     * Create a new EventListenerSupport instance.\r\n-     * Serialization-friendly constructor.\r\n-     */\r\n-    private EventListenerSupport() {\r\n-    }\r\n+  /**\r\n+   * Create a new EventListenerSupport instance.\r\n+   * Serialization-friendly constructor.\r\n+   */\r\n+  private EventListenerSupport() {\r\n+  }\r\n \r\n-    /**\r\n-     * Returns a proxy object which can be used to call listener methods on all\r\n-     * of the registered event listeners. All calls made to this proxy will be\r\n-     * forwarded to all registered listeners.\r\n-     *\r\n-     * @return a proxy object which can be used to call listener methods on all\r\n-     * of the registered event listeners\r\n-     */\r\n-    public L fire() {\r\n-        return proxy;\r\n-    }\r\n+  /**\r\n+   * Returns a proxy object which can be used to call listener methods on all\r\n+   * of the registered event listeners. All calls made to this proxy will be\r\n+   * forwarded to all registered listeners.\r\n+   *\r\n+   * @return a proxy object which can be used to call listener methods on all\r\n+   * of the registered event listeners\r\n+   */\r\n+  public L fire() {\r\n+    return proxy;\r\n+  }\r\n \r\n //**********************************************************************************************************************\r\n // Other Methods\r\n //**********************************************************************************************************************\r\n \r\n-    /**\r\n-     * Registers an event listener.\r\n-     *\r\n-     * @param listener the event listener (may not be <code>null</code>).\r\n-     *\r\n-     * @throws NullPointerException if <code>listener</code> is\r\n-     *         <code>null</code>.\r\n-     */\r\n-    public void addListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.add(listener);\r\n-    }\r\n+  /**\r\n+   * Registers an event listener.\r\n+   *\r\n+   * @param listener the event listener (may not be <code>null</code>).\r\n+   *\r\n+   * @throws NullPointerException if <code>listener</code> is\r\n+   *         <code>null</code>.\r\n+   */\r\n+  public void addListener(L listener) {\r\n+    Validate.notNull(listener, \"Listener object cannot be null.\");\r\n+    listeners.add(listener);\r\n+  }\r\n \r\n-    /**\r\n-     * Returns the number of registered listeners.\r\n-     *\r\n-     * @return the number of registered listeners.\r\n-     */\r\n-    int getListenerCount() {\r\n-        return listeners.size();\r\n-    }\r\n+  /**\r\n+   * Returns the number of registered listeners.\r\n+   *\r\n+   * @return the number of registered listeners.\r\n+   */\r\n+  int getListenerCount() {\r\n+    return listeners.size();\r\n+  }\r\n \r\n-    /**\r\n-     * Unregisters an event listener.\r\n-     *\r\n-     * @param listener the event listener (may not be <code>null</code>).\r\n-     *\r\n-     * @throws NullPointerException if <code>listener</code> is\r\n-     *         <code>null</code>.\r\n-     */\r\n-    public void removeListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.remove(listener);\r\n-    }\r\n+  /**\r\n+   * Unregisters an event listener.\r\n+   *\r\n+   * @param listener the event listener (may not be <code>null</code>).\r\n+   *\r\n+   * @throws NullPointerException if <code>listener</code> is\r\n+   *         <code>null</code>.\r\n+   */\r\n+  public void removeListener(L listener) {\r\n+    Validate.notNull(listener, \"Listener object cannot be null.\");\r\n+    listeners.remove(listener);\r\n+  }\r\n \r\n-    /**\r\n-     * Get an array containing the currently registered listeners.\r\n-     * Modification to this array's elements will have no effect on the\r\n-     * {@link EventListenerSupport} instance.\r\n-     * @return L[]\r\n-     */\r\n-    public L[] getListeners() {\r\n-        return listeners.toArray(prototypeArray);\r\n-    }\r\n+  /**\r\n+   * Get an array containing the currently registered listeners.\r\n+   * Modification to this array's elements will have no effect on the\r\n+   * {@link EventListenerSupport} instance.\r\n+   * @return L[]\r\n+   */\r\n+  public L[] getListeners() {\r\n+    return listeners.toArray(prototypeArray);\r\n+  }\r\n \r\n-    /**\r\n-     * Serialize.\r\n-     * @param objectOutputStream the output stream\r\n-     * @throws IOException if an IO error occurs\r\n-     */\r\n-    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\r\n-        ArrayList<L> serializableListeners = new ArrayList<L>();\r\n+  /**\r\n+   * Serialize.\r\n+   * @param objectOutputStream the output stream\r\n+   * @throws IOException if an IO error occurs\r\n+   */\r\n+  private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\r\n+    ArrayList<L> serializableListeners = new ArrayList<L>();\r\n \r\n-        // don't just rely on instanceof Serializable:\r\n-        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-        for (L listener : listeners) {\r\n-            try {\r\n-                testObjectOutputStream.writeObject(listener);\r\n-                serializableListeners.add(listener);\r\n-            } catch (IOException exception) {\r\n-                //recreate test stream in case of indeterminate state\r\n-                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-            }\r\n-        }\r\n-        /*\r\n-         * we can reconstitute everything we need from an array of our listeners,\r\n-         * which has the additional advantage of typically requiring less storage than a list:\r\n-         */\r\n-        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\r\n+    // don't just rely on instanceof Serializable:\r\n+    ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n+    for (L listener : listeners) {\r\n+      try {\r\n+        testObjectOutputStream.writeObject(listener);\r\n+        serializableListeners.add(listener);\r\n+      } catch (IOException exception) {\r\n+        //recreate test stream in case of indeterminate state\r\n+        testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * Deserialize.\r\n-     * @param objectInputStream the input stream\r\n-     * @throws IOException if an IO error occurs\r\n-     * @throws ClassNotFoundException if the class cannot be resolved\r\n+    /*\r\n+     * we can reconstitute everything we need from an array of our listeners,\r\n+     * which has the additional advantage of typically requiring less storage than a list:\r\n      */\r\n-    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] listeners = (L[]) objectInputStream.readObject();\r\n+    objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\r\n+  }\r\n \r\n-        this.listeners = new CopyOnWriteArrayList<L>(listeners);\r\n+  /**\r\n+   * Deserialize.\r\n+   * @param objectInputStream the input stream\r\n+   * @throws IOException if an IO error occurs\r\n+   * @throws ClassNotFoundException if the class cannot be resolved\r\n+   */\r\n+  private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    L[] listeners = (L[]) objectInputStream.readObject();\r\n \r\n-        @SuppressWarnings(\"unchecked\")\r\n-        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\r\n+    this.listeners = new CopyOnWriteArrayList<L>(listeners);\r\n \r\n-        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\r\n \r\n-    /**\r\n-     * Initialize transient fields.\r\n-     * @param listenerInterface the class of the listener interface\r\n-     * @param classLoader the class loader to be used\r\n-     */\r\n-    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n-        this.prototypeArray = array;\r\n-        createProxy(listenerInterface, classLoader);\r\n-    }\r\n+    initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n+  }\r\n \r\n-    /**\r\n-     * Create the proxy object.\r\n-     * @param listenerInterface the class of the listener interface\r\n-     * @param classLoader the class loader to be used\r\n-     */\r\n-    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\r\n-                new Class[] { listenerInterface }, createInvocationHandler()));\r\n-    }\r\n+  /**\r\n+   * Initialize transient fields.\r\n+   * @param listenerInterface the class of the listener interface\r\n+   * @param classLoader the class loader to be used\r\n+   */\r\n+  private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n+    this.prototypeArray = array;\r\n+    createProxy(listenerInterface, classLoader);\r\n+  }\r\n \r\n-    /**\r\n-     * Create the {@link InvocationHandler} responsible for broadcasting calls\r\n-     * to the managed listeners.  Subclasses can override to provide custom behavior.\r\n-     * @return ProxyInvocationHandler\r\n-     */\r\n-    protected InvocationHandler createInvocationHandler() {\r\n-        return new ProxyInvocationHandler();\r\n-    }\r\n+  /**\r\n+   * Create the proxy object.\r\n+   * @param listenerInterface the class of the listener interface\r\n+   * @param classLoader the class loader to be used\r\n+   */\r\n+  private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\r\n+    proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\r\n+      new Class[] {listenerInterface}, createInvocationHandler()));\r\n+  }\r\n+\r\n+  /**\r\n+   * Create the {@link InvocationHandler} responsible for broadcasting calls\r\n+   * to the managed listeners.  Subclasses can override to provide custom behavior.\r\n+   * @return ProxyInvocationHandler\r\n+   */\r\n+  protected InvocationHandler createInvocationHandler() {\r\n+    return new ProxyInvocationHandler();\r\n+  }\r\n+\r\n+  /**\r\n+   * An invocation handler used to dispatch the event(s) to all the listeners.\r\n+   */\r\n+  protected class ProxyInvocationHandler implements InvocationHandler {\r\n+    /** Serialization version */\r\n+    private static final long serialVersionUID = 1L;\r\n \r\n     /**\r\n-     * An invocation handler used to dispatch the event(s) to all the listeners.\r\n+     * Propagates the method call to all registered listeners in place of\r\n+     * the proxy listener object.\r\n+     *\r\n+     * @param proxy the proxy object representing a listener on which the\r\n+     *        invocation was called.\r\n+     * @param method the listener method that will be called on all of the\r\n+     *        listeners.\r\n+     * @param args event arguments to propagate to the listeners.\r\n+     * @return the result of the method call\r\n+     * @throws Throwable if an error occurs\r\n      */\r\n-    protected class ProxyInvocationHandler implements InvocationHandler {\r\n-        /** Serialization version */\r\n-        private static final long serialVersionUID = 1L;\r\n-\r\n-        /**\r\n-         * Propagates the method call to all registered listeners in place of\r\n-         * the proxy listener object.\r\n-         *\r\n-         * @param proxy the proxy object representing a listener on which the\r\n-         *        invocation was called.\r\n-         * @param method the listener method that will be called on all of the\r\n-         *        listeners.\r\n-         * @param args event arguments to propagate to the listeners.\r\n-         * @return the result of the method call\r\n-         * @throws Throwable if an error occurs\r\n-         */\r\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n-            for (L listener : listeners) {\r\n-                method.invoke(listener, args);\r\n-            }\r\n-            return null;\r\n-        }\r\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n+      for (L listener : listeners) {\r\n+        method.invoke(listener, args);\r\n+      }\r\n+      return null;\r\n     }\r\n+  }\r\n }\r\n",
            "diff_size": 259
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "183",
                    "severity": "warning",
                    "message": "Block comment has incorrect indentation level 0, expected is 4, indentation should be the same level as line 191.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/15/EventListenerSupport.java\nindex e717d4ee20..d2acfe0811 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/15/EventListenerSupport.java\n@@ -176,13 +176,11 @@ public class EventListenerSupport<L> implements Serializable {\n      */\r\n     public L fire() {\r\n         return proxy;\r\n-    }\r\n-\r\n-//**********************************************************************************************************************\r\n-// Other Methods\r\n-//**********************************************************************************************************************\r\n-\r\n-    /**\r\n+    }\n+\n+//***\n+\n+/**\r\n      * Registers an event listener.\r\n      *\r\n      * @param listener the event listener (may not be <code>null</code>).\r\n@@ -260,8 +258,8 @@ public class EventListenerSupport<L> implements Serializable {\n      * @throws ClassNotFoundException if the class cannot be resolved\r\n      */\r\n     private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] listeners = (L[]) objectInputStream.readObject();\r\n+        @SuppressWarnings(\"unchecked\")\n+    L[] listeners = (L[]) objectInputStream.readObject();\r\n \r\n         this.listeners = new CopyOnWriteArrayList<L>(listeners);\r\n \r\n@@ -277,8 +275,8 @@ public class EventListenerSupport<L> implements Serializable {\n      * @param classLoader the class loader to be used\r\n      */\r\n     private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n+        @SuppressWarnings(\"unchecked\")\n+    L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n         this.prototypeArray = array;\r\n         createProxy(listenerInterface, classLoader);\r\n     }\r\n@@ -328,4 +326,4 @@ public class EventListenerSupport<L> implements Serializable {\n             return null;\r\n         }\r\n     }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 12
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "192",
                    "severity": "warning",
                    "message": "Comment has incorrect indentation level 0, expected is 4, indentation should be the same level as line 204.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/15/EventListenerSupport.java\nindex e717d4ee20..bdce291bea 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/15/EventListenerSupport.java\n@@ -30,21 +30,20 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.event;\r\n-\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.Serializable;\r\n-import java.lang.reflect.Array;\r\n-import java.lang.reflect.InvocationHandler;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Proxy;\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.event;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Validate;\r\n \r\n /**\r\n@@ -77,28 +76,31 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Valida\n  *\r\n  * @since 3.0\r\n  * @version $Id: EventListenerSupport.java 1082302 2011-03-16 21:08:27Z oheger $\r\n- */\r\n+ */\n+\n+\n public class EventListenerSupport<L> implements Serializable {\r\n \r\n-    /** Serialization version */\r\n+    /** Serialization version */\n+\n     private static final long serialVersionUID = 3593265990380473632L;\r\n \r\n     /**\r\n      * The list used to hold the registered listeners. This list is\r\n      * intentionally a thread-safe copy-on-write-array so that traversals over\r\n      * the list of listeners will be atomic.\r\n-     */\r\n+     */\n     private List<L> listeners = new CopyOnWriteArrayList<L>();\r\n \r\n     /**\r\n      * The proxy representing the collection of listeners. Calls to this proxy\r\n      * object will sent to all registered listeners.\r\n-     */\r\n+     */\n     private transient L proxy;\r\n \r\n     /**\r\n      * Empty typed array for #getListeners().\r\n-     */\r\n+     */\n     private transient L[] prototypeArray;\r\n \r\n     /**\r\n@@ -116,9 +118,11 @@ public class EventListenerSupport<L> implements Serializable {\n      *         <code>null</code>.\r\n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n      *         not an interface.\r\n-     */\r\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\r\n-        return new EventListenerSupport<T>(listenerInterface);\r\n+     */\n+\n+\n+    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\n+        return new EventListenerSupport<T>(listenerInterface);\n     }\r\n \r\n     /**\r\n@@ -132,9 +136,11 @@ public class EventListenerSupport<L> implements Serializable {\n      *         <code>null</code>.\r\n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n      *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface) {\r\n-        this(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n+     */\n+\n+\n+    public EventListenerSupport(Class<L> listenerInterface) {\n+        this(listenerInterface, Thread.currentThread().getContextClassLoader());\n     }\r\n \r\n     /**\r\n@@ -149,22 +155,23 @@ public class EventListenerSupport<L> implements Serializable {\n      *         <code>classLoader</code> is <code>null</code>.\r\n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n      *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        this();\r\n-        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\r\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\r\n-        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\r\n-                listenerInterface.getName());\r\n-        initializeTransientFields(listenerInterface, classLoader);\r\n+     */\n+\n+    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n+        this();\n+        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n+        Validate.notNull(classLoader,\n+                         \"ClassLoader cannot be null.\");\n+        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\", listenerInterface.getName());\n+        initializeTransientFields(listenerInterface, classLoader);\n     }\r\n \r\n     /**\r\n      * Create a new EventListenerSupport instance.\r\n      * Serialization-friendly constructor.\r\n-     */\r\n-    private EventListenerSupport() {\r\n-    }\r\n+     */\n+\n+    private EventListenerSupport() {}\r\n \r\n     /**\r\n      * Returns a proxy object which can be used to call listener methods on all\r\n@@ -173,9 +180,11 @@ public class EventListenerSupport<L> implements Serializable {\n      *\r\n      * @return a proxy object which can be used to call listener methods on all\r\n      * of the registered event listeners\r\n-     */\r\n-    public L fire() {\r\n-        return proxy;\r\n+     */\n+\n+\n+    public L fire() {\n+    return proxy;\n     }\r\n \r\n //**********************************************************************************************************************\r\n@@ -189,19 +198,23 @@ public class EventListenerSupport<L> implements Serializable {\n      *\r\n      * @throws NullPointerException if <code>listener</code> is\r\n      *         <code>null</code>.\r\n-     */\r\n-    public void addListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.add(listener);\r\n+     */\n+\n+\n+    public void addListener(L listener) {\n+        Validate.notNull(listener,\n+                         \"Listener object cannot be null.\");\n+        listeners.add(listener);\n     }\r\n \r\n     /**\r\n      * Returns the number of registered listeners.\r\n      *\r\n      * @return the number of registered listeners.\r\n-     */\r\n-    int getListenerCount() {\r\n-        return listeners.size();\r\n+     */\n+\n+    int getListenerCount() {\n+        return listeners.size();\n     }\r\n \r\n     /**\r\n@@ -211,10 +224,13 @@ public class EventListenerSupport<L> implements Serializable {\n      *\r\n      * @throws NullPointerException if <code>listener</code> is\r\n      *         <code>null</code>.\r\n-     */\r\n-    public void removeListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.remove(listener);\r\n+     */\n+\n+\n+    public void removeListener(L listener) {\n+        Validate.notNull(listener,\n+                         \"Listener object cannot be null.\");\n+        listeners.remove(listener);\n     }\r\n \r\n     /**\r\n@@ -222,35 +238,39 @@ public class EventListenerSupport<L> implements Serializable {\n      * Modification to this array's elements will have no effect on the\r\n      * {@link EventListenerSupport} instance.\r\n      * @return L[]\r\n-     */\r\n-    public L[] getListeners() {\r\n-        return listeners.toArray(prototypeArray);\r\n+     */\n+\n+\n+    public L[] getListeners() {\n+    return listeners.toArray(prototypeArray);\n     }\r\n \r\n     /**\r\n      * Serialize.\r\n      * @param objectOutputStream the output stream\r\n      * @throws IOException if an IO error occurs\r\n-     */\r\n-    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\r\n+     */\n+\n+    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\n         ArrayList<L> serializableListeners = new ArrayList<L>();\r\n \r\n-        // don't just rely on instanceof Serializable:\r\n-        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-        for (L listener : listeners) {\r\n-            try {\r\n-                testObjectOutputStream.writeObject(listener);\r\n-                serializableListeners.add(listener);\r\n+        // don't just rely on instanceof Serializable:\n+        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+        for (L listener : listeners) {\n+            try {\n+                testObjectOutputStream.writeObject(listener);\n+                serializableListeners.add(listener);\n             } catch (IOException exception) {\r\n-                //recreate test stream in case of indeterminate state\r\n-                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-            }\r\n+                //recreate test stream in case of indeterminate state\n+                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+            }\n         }\r\n         /*\r\n          * we can reconstitute everything we need from an array of our listeners,\r\n          * which has the additional advantage of typically requiring less storage than a list:\r\n-         */\r\n-        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\r\n+         */\n+\n+        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\n     }\r\n \r\n     /**\r\n@@ -258,55 +278,63 @@ public class EventListenerSupport<L> implements Serializable {\n      * @param objectInputStream the input stream\r\n      * @throws IOException if an IO error occurs\r\n      * @throws ClassNotFoundException if the class cannot be resolved\r\n-     */\r\n-    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] listeners = (L[]) objectInputStream.readObject();\r\n-\r\n-        this.listeners = new CopyOnWriteArrayList<L>(listeners);\r\n-\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\r\n-\r\n-        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n+     */\n+\n+    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n+        @SuppressWarnings(\"unchecked\")\n+\n+        L[] listeners = (L[]) objectInputStream.readObject();\n+        this.listeners = new CopyOnWriteArrayList<L>(listeners);\n+\n+        @SuppressWarnings(\"unchecked\")\n+\n+        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\n+        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n     }\r\n \r\n     /**\r\n      * Initialize transient fields.\r\n      * @param listenerInterface the class of the listener interface\r\n      * @param classLoader the class loader to be used\r\n-     */\r\n-    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n-        this.prototypeArray = array;\r\n-        createProxy(listenerInterface, classLoader);\r\n+     */\n+\n+    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\n+        @SuppressWarnings(\"unchecked\")\n+\n+        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n+        this.prototypeArray = array;\n+        createProxy(listenerInterface, classLoader);\n     }\r\n \r\n     /**\r\n      * Create the proxy object.\r\n      * @param listenerInterface the class of the listener interface\r\n      * @param classLoader the class loader to be used\r\n-     */\r\n-    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\r\n-                new Class[] { listenerInterface }, createInvocationHandler()));\r\n+     */\n+\n+    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n+        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler()));\n     }\r\n \r\n     /**\r\n      * Create the {@link InvocationHandler} responsible for broadcasting calls\r\n      * to the managed listeners.  Subclasses can override to provide custom behavior.\r\n      * @return ProxyInvocationHandler\r\n-     */\r\n-    protected InvocationHandler createInvocationHandler() {\r\n-        return new ProxyInvocationHandler();\r\n+     */\n+\n+\n+    protected InvocationHandler createInvocationHandler() {\n+    return new ProxyInvocationHandler();\n     }\r\n \r\n     /**\r\n      * An invocation handler used to dispatch the event(s) to all the listeners.\r\n-     */\r\n+     */\n+\n+\n     protected class ProxyInvocationHandler implements InvocationHandler {\r\n-        /** Serialization version */\r\n+        /** Serialization version */\n+\n         private static final long serialVersionUID = 1L;\r\n \r\n         /**\r\n@@ -320,12 +348,14 @@ public class EventListenerSupport<L> implements Serializable {\n          * @param args event arguments to propagate to the listeners.\r\n          * @return the result of the method call\r\n          * @throws Throwable if an error occurs\r\n-         */\r\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n-            for (L listener : listeners) {\r\n-                method.invoke(listener, args);\r\n-            }\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+         */\n+\n+\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            for (L listener : listeners) {\n+                method.invoke(listener, args);\n+            }\n+            return null;\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 133
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/15/EventListenerSupport.java\nindex e717d4ee20..b159717bd0 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/15/EventListenerSupport.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/15/EventListenerSupport.java\n@@ -1,331 +1,331 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.event;\r\n-\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.Serializable;\r\n-import java.lang.reflect.Array;\r\n-import java.lang.reflect.InvocationHandler;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Proxy;\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Validate;\r\n-\r\n-/**\r\n- * An EventListenerSupport object can be used to manage a list of event\r\n- * listeners of a particular type. The class provides\r\n- * {@link #addListener(Object)} and {@link #removeListener(Object)} methods\r\n- * for registering listeners, as well as a {@link #fire()} method for firing\r\n- * events to the listeners.\r\n- *\r\n- * <p/>\r\n- * To use this class, suppose you want to support ActionEvents.  You would do:\r\n- * <code><pre>\r\n- * public class MyActionEventSource\r\n- * {\r\n- *   private EventListenerSupport<ActionListener> actionListeners =\r\n- *       EventListenerSupport.create(ActionListener.class);\r\n- *\r\n- *   public void someMethodThatFiresAction()\r\n- *   {\r\n- *     ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"somethingCool\");\r\n- *     actionListeners.fire().actionPerformed(e);\r\n- *   }\r\n- * }\r\n- * </pre></code>\r\n- *\r\n- * Serializing an {@link EventListenerSupport} instance will result in any\r\n- * non-{@link Serializable} listeners being silently dropped.\r\n- *\r\n- * @param <L> the type of event listener that is supported by this proxy.\r\n- *\r\n- * @since 3.0\r\n- * @version $Id: EventListenerSupport.java 1082302 2011-03-16 21:08:27Z oheger $\r\n- */\r\n-public class EventListenerSupport<L> implements Serializable {\r\n-\r\n-    /** Serialization version */\r\n-    private static final long serialVersionUID = 3593265990380473632L;\r\n-\r\n-    /**\r\n-     * The list used to hold the registered listeners. This list is\r\n-     * intentionally a thread-safe copy-on-write-array so that traversals over\r\n-     * the list of listeners will be atomic.\r\n-     */\r\n-    private List<L> listeners = new CopyOnWriteArrayList<L>();\r\n-\r\n-    /**\r\n-     * The proxy representing the collection of listeners. Calls to this proxy\r\n-     * object will sent to all registered listeners.\r\n-     */\r\n-    private transient L proxy;\r\n-\r\n-    /**\r\n-     * Empty typed array for #getListeners().\r\n-     */\r\n-    private transient L[] prototypeArray;\r\n-\r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the specified\r\n-     * listener type.\r\n-     *\r\n-     * @param <T> the type of the listener interface\r\n-     * @param listenerInterface the type of listener interface that will receive\r\n-     *        events posted using this class.\r\n-     *\r\n-     * @return an EventListenerSupport object which supports the specified\r\n-     *         listener type.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> is\r\n-     *         <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\r\n-        return new EventListenerSupport<T>(listenerInterface);\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the provided\r\n-     * listener interface.\r\n-     *\r\n-     * @param listenerInterface the type of listener interface that will receive\r\n-     *        events posted using this class.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> is\r\n-     *         <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface) {\r\n-        this(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates an EventListenerSupport object which supports the provided\r\n-     * listener interface using the specified class loader to create the JDK\r\n-     * dynamic proxy.\r\n-     *\r\n-     * @param listenerInterface the listener interface.\r\n-     * @param classLoader       the class loader.\r\n-     *\r\n-     * @throws NullPointerException if <code>listenerInterface</code> or\r\n-     *         <code>classLoader</code> is <code>null</code>.\r\n-     * @throws IllegalArgumentException if <code>listenerInterface</code> is\r\n-     *         not an interface.\r\n-     */\r\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        this();\r\n-        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\r\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\r\n-        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\r\n-                listenerInterface.getName());\r\n-        initializeTransientFields(listenerInterface, classLoader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new EventListenerSupport instance.\r\n-     * Serialization-friendly constructor.\r\n-     */\r\n-    private EventListenerSupport() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a proxy object which can be used to call listener methods on all\r\n-     * of the registered event listeners. All calls made to this proxy will be\r\n-     * forwarded to all registered listeners.\r\n-     *\r\n-     * @return a proxy object which can be used to call listener methods on all\r\n-     * of the registered event listeners\r\n-     */\r\n-    public L fire() {\r\n-        return proxy;\r\n-    }\r\n-\r\n-//**********************************************************************************************************************\r\n-// Other Methods\r\n-//**********************************************************************************************************************\r\n-\r\n-    /**\r\n-     * Registers an event listener.\r\n-     *\r\n-     * @param listener the event listener (may not be <code>null</code>).\r\n-     *\r\n-     * @throws NullPointerException if <code>listener</code> is\r\n-     *         <code>null</code>.\r\n-     */\r\n-    public void addListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.add(listener);\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the number of registered listeners.\r\n-     *\r\n-     * @return the number of registered listeners.\r\n-     */\r\n-    int getListenerCount() {\r\n-        return listeners.size();\r\n-    }\r\n-\r\n-    /**\r\n-     * Unregisters an event listener.\r\n-     *\r\n-     * @param listener the event listener (may not be <code>null</code>).\r\n-     *\r\n-     * @throws NullPointerException if <code>listener</code> is\r\n-     *         <code>null</code>.\r\n-     */\r\n-    public void removeListener(L listener) {\r\n-        Validate.notNull(listener, \"Listener object cannot be null.\");\r\n-        listeners.remove(listener);\r\n-    }\r\n-\r\n-    /**\r\n-     * Get an array containing the currently registered listeners.\r\n-     * Modification to this array's elements will have no effect on the\r\n-     * {@link EventListenerSupport} instance.\r\n-     * @return L[]\r\n-     */\r\n-    public L[] getListeners() {\r\n-        return listeners.toArray(prototypeArray);\r\n-    }\r\n-\r\n-    /**\r\n-     * Serialize.\r\n-     * @param objectOutputStream the output stream\r\n-     * @throws IOException if an IO error occurs\r\n-     */\r\n-    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\r\n-        ArrayList<L> serializableListeners = new ArrayList<L>();\r\n-\r\n-        // don't just rely on instanceof Serializable:\r\n-        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-        for (L listener : listeners) {\r\n-            try {\r\n-                testObjectOutputStream.writeObject(listener);\r\n-                serializableListeners.add(listener);\r\n-            } catch (IOException exception) {\r\n-                //recreate test stream in case of indeterminate state\r\n-                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\r\n-            }\r\n-        }\r\n-        /*\r\n-         * we can reconstitute everything we need from an array of our listeners,\r\n-         * which has the additional advantage of typically requiring less storage than a list:\r\n-         */\r\n-        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\r\n-    }\r\n-\r\n-    /**\r\n-     * Deserialize.\r\n-     * @param objectInputStream the input stream\r\n-     * @throws IOException if an IO error occurs\r\n-     * @throws ClassNotFoundException if the class cannot be resolved\r\n-     */\r\n-    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] listeners = (L[]) objectInputStream.readObject();\r\n-\r\n-        this.listeners = new CopyOnWriteArrayList<L>(listeners);\r\n-\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\r\n-\r\n-        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n-\r\n-    /**\r\n-     * Initialize transient fields.\r\n-     * @param listenerInterface the class of the listener interface\r\n-     * @param classLoader the class loader to be used\r\n-     */\r\n-    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        @SuppressWarnings(\"unchecked\")\r\n-        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\r\n-        this.prototypeArray = array;\r\n-        createProxy(listenerInterface, classLoader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create the proxy object.\r\n-     * @param listenerInterface the class of the listener interface\r\n-     * @param classLoader the class loader to be used\r\n-     */\r\n-    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\r\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\r\n-                new Class[] { listenerInterface }, createInvocationHandler()));\r\n-    }\r\n-\r\n-    /**\r\n-     * Create the {@link InvocationHandler} responsible for broadcasting calls\r\n-     * to the managed listeners.  Subclasses can override to provide custom behavior.\r\n-     * @return ProxyInvocationHandler\r\n-     */\r\n-    protected InvocationHandler createInvocationHandler() {\r\n-        return new ProxyInvocationHandler();\r\n-    }\r\n-\r\n-    /**\r\n-     * An invocation handler used to dispatch the event(s) to all the listeners.\r\n-     */\r\n-    protected class ProxyInvocationHandler implements InvocationHandler {\r\n-        /** Serialization version */\r\n-        private static final long serialVersionUID = 1L;\r\n-\r\n-        /**\r\n-         * Propagates the method call to all registered listeners in place of\r\n-         * the proxy listener object.\r\n-         *\r\n-         * @param proxy the proxy object representing a listener on which the\r\n-         *        invocation was called.\r\n-         * @param method the listener method that will be called on all of the\r\n-         *        listeners.\r\n-         * @param args event arguments to propagate to the listeners.\r\n-         * @return the result of the method call\r\n-         * @throws Throwable if an error occurs\r\n-         */\r\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n-            for (L listener : listeners) {\r\n-                method.invoke(listener, args);\r\n-            }\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.event;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.Validate;\n+\n+/**\n+ * An EventListenerSupport object can be used to manage a list of event\n+ * listeners of a particular type. The class provides\n+ * {@link #addListener(Object)} and {@link #removeListener(Object)} methods\n+ * for registering listeners, as well as a {@link #fire()} method for firing\n+ * events to the listeners.\n+ *\n+ * <p/>\n+ * To use this class, suppose you want to support ActionEvents.  You would do:\n+ * <code><pre>\n+ * public class MyActionEventSource\n+ * {\n+ *   private EventListenerSupport<ActionListener> actionListeners =\n+ *       EventListenerSupport.create(ActionListener.class);\n+ *\n+ *   public void someMethodThatFiresAction()\n+ *   {\n+ *     ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"somethingCool\");\n+ *     actionListeners.fire().actionPerformed(e);\n+ *   }\n+ * }\n+ * </pre></code>\n+ *\n+ * Serializing an {@link EventListenerSupport} instance will result in any\n+ * non-{@link Serializable} listeners being silently dropped.\n+ *\n+ * @param <L> the type of event listener that is supported by this proxy.\n+ *\n+ * @since 3.0\n+ * @version $Id: EventListenerSupport.java 1082302 2011-03-16 21:08:27Z oheger $\n+ */\n+public class EventListenerSupport<L> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3593265990380473632L;\n+\n+    /**\n+     * The list used to hold the registered listeners. This list is\n+     * intentionally a thread-safe copy-on-write-array so that traversals over\n+     * the list of listeners will be atomic.\n+     */\n+    private List<L> listeners = new CopyOnWriteArrayList<L>();\n+\n+    /**\n+     * The proxy representing the collection of listeners. Calls to this proxy\n+     * object will sent to all registered listeners.\n+     */\n+    private transient L proxy;\n+\n+    /**\n+     * Empty typed array for #getListeners().\n+     */\n+    private transient L[] prototypeArray;\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the specified\n+     * listener type.\n+     *\n+     * @param <T> the type of the listener interface\n+     * @param listenerInterface the type of listener interface that will receive\n+     *        events posted using this class.\n+     *\n+     * @return an EventListenerSupport object which supports the specified\n+     *         listener type.\n+     *\n+     * @throws NullPointerException if <code>listenerInterface</code> is\n+     *         <code>null</code>.\n+     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n+     *         not an interface.\n+     */\n+    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\n+        return new EventListenerSupport<T>(listenerInterface);\n+    }\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the provided\n+     * listener interface.\n+     *\n+     * @param listenerInterface the type of listener interface that will receive\n+     *        events posted using this class.\n+     *\n+     * @throws NullPointerException if <code>listenerInterface</code> is\n+     *         <code>null</code>.\n+     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n+     *         not an interface.\n+     */\n+    public EventListenerSupport(Class<L> listenerInterface) {\n+        this(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the provided\n+     * listener interface using the specified class loader to create the JDK\n+     * dynamic proxy.\n+     *\n+     * @param listenerInterface the listener interface.\n+     * @param classLoader       the class loader.\n+     *\n+     * @throws NullPointerException if <code>listenerInterface</code> or\n+     *         <code>classLoader</code> is <code>null</code>.\n+     * @throws IllegalArgumentException if <code>listenerInterface</code> is\n+     *         not an interface.\n+     */\n+    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n+        this();\n+        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n+        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n+        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n+                listenerInterface.getName());\n+        initializeTransientFields(listenerInterface, classLoader);\n+    }\n+\n+    /**\n+     * Create a new EventListenerSupport instance.\n+     * Serialization-friendly constructor.\n+     */\n+    private EventListenerSupport() {\n+    }\n+\n+    /**\n+     * Returns a proxy object which can be used to call listener methods on all\n+     * of the registered event listeners. All calls made to this proxy will be\n+     * forwarded to all registered listeners.\n+     *\n+     * @return a proxy object which can be used to call listener methods on all\n+     * of the registered event listeners\n+     */\n+    public L fire() {\n+        return proxy;\n+    }\n+\n+//**********************************************************************************************************************\n+// Other Methods\n+//**********************************************************************************************************************\n+/**\n+     * Registers an event listener.\n+     *\n+     * @param listener the event listener (may not be <code>null</code>).\n+     *\n+     * @throws NullPointerException if <code>listener</code> is\n+     *         <code>null</code>.\n+     */\n+\n+public void addListener(L listener) {\n+        Validate.notNull(listener, \"Listener object cannot be null.\");\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Returns the number of registered listeners.\n+     *\n+     * @return the number of registered listeners.\n+     */\n+    int getListenerCount() {\n+        return listeners.size();\n+    }\n+\n+    /**\n+     * Unregisters an event listener.\n+     *\n+     * @param listener the event listener (may not be <code>null</code>).\n+     *\n+     * @throws NullPointerException if <code>listener</code> is\n+     *         <code>null</code>.\n+     */\n+    public void removeListener(L listener) {\n+        Validate.notNull(listener, \"Listener object cannot be null.\");\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Get an array containing the currently registered listeners.\n+     * Modification to this array's elements will have no effect on the\n+     * {@link EventListenerSupport} instance.\n+     * @return L[]\n+     */\n+    public L[] getListeners() {\n+        return listeners.toArray(prototypeArray);\n+    }\n+\n+    /**\n+     * Serialize.\n+     * @param objectOutputStream the output stream\n+     * @throws IOException if an IO error occurs\n+     */\n+    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\n+        ArrayList<L> serializableListeners = new ArrayList<L>();\n+\n+        // don't just rely on instanceof Serializable:\n+        ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+        for (L listener : listeners) {\n+            try {\n+                testObjectOutputStream.writeObject(listener);\n+                serializableListeners.add(listener);\n+            } catch (IOException exception) {\n+                //recreate test stream in case of indeterminate state\n+                testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n+            }\n+        }\n+        /*\n+         * we can reconstitute everything we need from an array of our listeners,\n+         * which has the additional advantage of typically requiring less storage than a list:\n+         */\n+        objectOutputStream.writeObject(serializableListeners.toArray(prototypeArray));\n+    }\n+\n+    /**\n+     * Deserialize.\n+     * @param objectInputStream the input stream\n+     * @throws IOException if an IO error occurs\n+     * @throws ClassNotFoundException if the class cannot be resolved\n+     */\n+    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n+        @SuppressWarnings(\"unchecked\")\n+        L[] listeners = (L[]) objectInputStream.readObject();\n+\n+        this.listeners = new CopyOnWriteArrayList<L>(listeners);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\n+\n+        initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    /**\n+     * Initialize transient fields.\n+     * @param listenerInterface the class of the listener interface\n+     * @param classLoader the class loader to be used\n+     */\n+    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\n+        @SuppressWarnings(\"unchecked\")\n+        L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n+        this.prototypeArray = array;\n+        createProxy(listenerInterface, classLoader);\n+    }\n+\n+    /**\n+     * Create the proxy object.\n+     * @param listenerInterface the class of the listener interface\n+     * @param classLoader the class loader to be used\n+     */\n+    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n+        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n+                new Class[] { listenerInterface }, createInvocationHandler()));\n+    }\n+\n+    /**\n+     * Create the {@link InvocationHandler} responsible for broadcasting calls\n+     * to the managed listeners.  Subclasses can override to provide custom behavior.\n+     * @return ProxyInvocationHandler\n+     */\n+    protected InvocationHandler createInvocationHandler() {\n+        return new ProxyInvocationHandler();\n+    }\n+\n+    /**\n+     * An invocation handler used to dispatch the event(s) to all the listeners.\n+     */\n+    protected class ProxyInvocationHandler implements InvocationHandler {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * Propagates the method call to all registered listeners in place of\n+         * the proxy listener object.\n+         *\n+         * @param proxy the proxy object representing a listener on which the\n+         *        invocation was called.\n+         * @param method the listener method that will be called on all of the\n+         *        listeners.\n+         * @param args event arguments to propagate to the listeners.\n+         * @return the result of the method call\n+         * @throws Throwable if an error occurs\n+         */\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            for (L listener : listeners) {\n+                method.invoke(listener, args);\n+            }\n+            return null;\n+        }\n+    }\n+}\n",
            "diff_size": 331
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}