{
    "error_id": "330",
    "information": {
        "errors": [
            {
                "line": "926",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        }\n        case ARRAY:\n        case ROW: // Special storage type for ValueRow\n        {\n            int len = readVarInt();\n            Value[] list = new Value[len];",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "926",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/330/Data.java\nindex c99a141540..b80258ef84 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/330/Data.java\n@@ -923,7 +923,7 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n+            case ROW: // Special storage type for ValueRow\n         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "942",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/330/Data.java\nindex c99a141540..b9afe6e01f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/330/Data.java\n@@ -6,6 +6,7 @@\n  * The variable size number format code is a port from SQLite,\n  * but stored in reverse order (least significant bits in the first byte).\n  */\n+\n package org.h2.store;\n \n import java.io.IOException;\n@@ -70,1433 +71,1459 @@ import org.h2.value.ValueVarcharIgnoreCase;\n  */\n public class Data {\n \n-    /**\n-     * The length of an integer value.\n-     */\n-    public static final int LENGTH_INT = 4;\n+  /**\n+   * The length of an integer value.\n+   */\n+  public static final int LENGTH_INT = 4;\n \n-    /**\n-     * The length of a long value.\n-     */\n-    public static final int LENGTH_LONG = 8;\n+  /**\n+   * The length of a long value.\n+   */\n+  public static final int LENGTH_LONG = 8;\n \n-    private static final byte NULL = 0;\n-    private static final byte TINYINT = 2;\n-    private static final byte SMALLINT = 3;\n-    private static final byte INTEGER = 4;\n-    private static final byte BIGINT = 5;\n-    private static final byte NUMERIC = 6;\n-    private static final byte DOUBLE = 7;\n-    private static final byte REAL = 8;\n-    private static final byte TIME = 9;\n-    private static final byte DATE = 10;\n-    private static final byte TIMESTAMP = 11;\n-    private static final byte VARBINARY = 12;\n-    private static final byte VARCHAR = 13;\n-    private static final byte VARCHAR_IGNORECASE = 14;\n-    private static final byte BLOB = 15;\n-    private static final byte CLOB = 16;\n-    private static final byte ARRAY = 17;\n-    private static final byte RESULT_SET = 18;\n-    private static final byte JAVA_OBJECT = 19;\n-    private static final byte UUID = 20;\n-    private static final byte CHAR = 21;\n-    private static final byte GEOMETRY = 22;\n-    private static final byte TIMESTAMP_TZ = 24;\n-    private static final byte ENUM = 25;\n-    private static final byte INTERVAL = 26;\n-    private static final byte ROW = 27;\n-    private static final byte INT_0_15 = 32;\n-    private static final byte BIGINT_0_7 = 48;\n-    private static final byte NUMERIC_0_1 = 56;\n-    private static final byte NUMERIC_SMALL_0 = 58;\n-    private static final byte NUMERIC_SMALL = 59;\n-    private static final byte DOUBLE_0_1 = 60;\n-    private static final byte REAL_0_1 = 62;\n-    private static final byte BOOLEAN_FALSE = 64;\n-    private static final byte BOOLEAN_TRUE = 65;\n-    private static final byte INT_NEG = 66;\n-    private static final byte BIGINT_NEG = 67;\n-    private static final byte VARCHAR_0_31 = 68;\n-    private static final int VARBINARY_0_31 = 100;\n-    private static final int LOCAL_TIME = 132;\n-    private static final int LOCAL_DATE = 133;\n-    private static final int LOCAL_TIMESTAMP = 134;\n-    // 135 was used for CUSTOM_DATA_TYPE\n-    private static final int JSON = 136;\n-    private static final int TIMESTAMP_TZ_2 = 137;\n-    private static final int TIME_TZ = 138;\n-    private static final int BINARY = 139;\n+  private static final byte NULL = 0;\n+  private static final byte TINYINT = 2;\n+  private static final byte SMALLINT = 3;\n+  private static final byte INTEGER = 4;\n+  private static final byte BIGINT = 5;\n+  private static final byte NUMERIC = 6;\n+  private static final byte DOUBLE = 7;\n+  private static final byte REAL = 8;\n+  private static final byte TIME = 9;\n+  private static final byte DATE = 10;\n+  private static final byte TIMESTAMP = 11;\n+  private static final byte VARBINARY = 12;\n+  private static final byte VARCHAR = 13;\n+  private static final byte VARCHAR_IGNORECASE = 14;\n+  private static final byte BLOB = 15;\n+  private static final byte CLOB = 16;\n+  private static final byte ARRAY = 17;\n+  private static final byte RESULT_SET = 18;\n+  private static final byte JAVA_OBJECT = 19;\n+  private static final byte UUID = 20;\n+  private static final byte CHAR = 21;\n+  private static final byte GEOMETRY = 22;\n+  private static final byte TIMESTAMP_TZ = 24;\n+  private static final byte ENUM = 25;\n+  private static final byte INTERVAL = 26;\n+  private static final byte ROW = 27;\n+  private static final byte INT_0_15 = 32;\n+  private static final byte BIGINT_0_7 = 48;\n+  private static final byte NUMERIC_0_1 = 56;\n+  private static final byte NUMERIC_SMALL_0 = 58;\n+  private static final byte NUMERIC_SMALL = 59;\n+  private static final byte DOUBLE_0_1 = 60;\n+  private static final byte REAL_0_1 = 62;\n+  private static final byte BOOLEAN_FALSE = 64;\n+  private static final byte BOOLEAN_TRUE = 65;\n+  private static final byte INT_NEG = 66;\n+  private static final byte BIGINT_NEG = 67;\n+  private static final byte VARCHAR_0_31 = 68;\n+  private static final int VARBINARY_0_31 = 100;\n+  private static final int LOCAL_TIME = 132;\n+  private static final int LOCAL_DATE = 133;\n+  private static final int LOCAL_TIMESTAMP = 134;\n+  // 135 was used for CUSTOM_DATA_TYPE\n+  private static final int JSON = 136;\n+  private static final int TIMESTAMP_TZ_2 = 137;\n+  private static final int TIME_TZ = 138;\n+  private static final int BINARY = 139;\n \n-    private static final long MILLIS_PER_MINUTE = 1000 * 60;\n+  private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n-    /**\n-     * Raw offset doesn't change during DST transitions, but changes during\n-     * other transitions that some time zones have. H2 1.4.193 and later\n-     * versions use zone offset that is valid for startup time for performance\n-     * reasons. Datetime storage code of PageStore has issues with all time zone\n-     * transitions, so this buggy logic is preserved as is too.\n-     */\n-    private static int zoneOffsetMillis = new GregorianCalendar().get(Calendar.ZONE_OFFSET);\n+  /**\n+   * Raw offset doesn't change during DST transitions, but changes during\n+   * other transitions that some time zones have. H2 1.4.193 and later\n+   * versions use zone offset that is valid for startup time for performance\n+   * reasons. Datetime storage code of PageStore has issues with all time zone\n+   * transitions, so this buggy logic is preserved as is too.\n+   */\n+  private static int zoneOffsetMillis =\n+      new GregorianCalendar().get(Calendar.ZONE_OFFSET);\n \n-    /**\n-     * The data itself.\n-     */\n-    private byte[] data;\n+  /**\n+   * The data itself.\n+   */\n+  private byte[] data;\n \n-    /**\n-     * The current write or read position.\n-     */\n-    private int pos;\n+  /**\n+   * The current write or read position.\n+   */\n+  private int pos;\n \n-    /**\n-     * The data handler responsible for lob objects.\n-     */\n-    private final DataHandler handler;\n+  /**\n+   * The data handler responsible for lob objects.\n+   */\n+  private final DataHandler handler;\n \n-    private final boolean storeLocalTime;\n+  private final boolean storeLocalTime;\n \n-    private Data(DataHandler handler, byte[] data, boolean storeLocalTime) {\n-        this.handler = handler;\n-        this.data = data;\n-        this.storeLocalTime = storeLocalTime;\n-    }\n+  private Data(DataHandler handler, byte[] data, boolean storeLocalTime) {\n+    this.handler = handler;\n+    this.data = data;\n+    this.storeLocalTime = storeLocalTime;\n+  }\n \n-    /**\n-     * Update an integer at the given position.\n-     * The current position is not change.\n-     *\n-     * @param pos the position\n-     * @param x the value\n-     */\n-    public void setInt(int pos, int x) {\n-        Bits.writeInt(data, pos, x);\n-    }\n+  /**\n+   * Update an integer at the given position.\n+   * The current position is not change.\n+   *\n+   * @param pos the position\n+   * @param x   the value\n+   */\n+  public void setInt(int pos, int x) {\n+    Bits.writeInt(data, pos, x);\n+  }\n \n-    /**\n-     * Write an integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @param x the value\n-     */\n-    public void writeInt(int x) {\n-        Bits.writeInt(data, pos, x);\n-        pos += 4;\n-    }\n+  /**\n+   * Write an integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @param x the value\n+   */\n+  public void writeInt(int x) {\n+    Bits.writeInt(data, pos, x);\n+    pos += 4;\n+  }\n \n-    /**\n-     * Read an integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public int readInt() {\n-        int x = Bits.readInt(data, pos);\n-        pos += 4;\n-        return x;\n-    }\n+  /**\n+   * Read an integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public int readInt() {\n+    int x = Bits.readInt(data, pos);\n+    pos += 4;\n+    return x;\n+  }\n \n-    /**\n-     * Get the length of a String. This includes the bytes required to encode\n-     * the length.\n-     *\n-     * @param s the string\n-     * @return the number of bytes required\n-     */\n-    public static int getStringLen(String s) {\n-        int len = s.length();\n-        return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n-    }\n+  /**\n+   * Get the length of a String. This includes the bytes required to encode\n+   * the length.\n+   *\n+   * @param s the string\n+   * @return the number of bytes required\n+   */\n+  public static int getStringLen(String s) {\n+    int len = s.length();\n+    return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n+  }\n \n-    /**\n-     * Calculate the length of String, excluding the bytes required to encode\n-     * the length.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param s the string\n-     * @param len the length of the string\n-     * @return the number of bytes required\n-     */\n-    private static int getStringWithoutLengthLen(String s, int len) {\n-        int plus = 0;\n-        for (int i = 0; i < len; i++) {\n-            char c = s.charAt(i);\n-            if (c >= 0x800) {\n-                plus += 2;\n-            } else if (c >= 0x80) {\n-                plus++;\n-            }\n-        }\n-        return len + plus;\n+  /**\n+   * Calculate the length of String, excluding the bytes required to encode\n+   * the length.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param s   the string\n+   * @param len the length of the string\n+   * @return the number of bytes required\n+   */\n+  private static int getStringWithoutLengthLen(String s, int len) {\n+    int plus = 0;\n+    for (int i = 0; i < len; i++) {\n+      char c = s.charAt(i);\n+      if (c >= 0x800) {\n+        plus += 2;\n+      } else if (c >= 0x80) {\n+        plus++;\n+      }\n     }\n+    return len + plus;\n+  }\n \n-    /**\n-     * Read a String value.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public String readString() {\n-        int len = readVarInt();\n-        return readString(len);\n-    }\n+  /**\n+   * Read a String value.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public String readString() {\n+    int len = readVarInt();\n+    return readString(len);\n+  }\n \n-    /**\n-     * Read a String from the byte array.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param len the length of the resulting string\n-     * @return the String\n-     */\n-    private String readString(int len) {\n-        byte[] buff = data;\n-        int p = pos;\n-        char[] chars = new char[len];\n-        for (int i = 0; i < len; i++) {\n-            int x = buff[p++] & 0xff;\n-            if (x < 0x80) {\n-                chars[i] = (char) x;\n-            } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12) +\n-                        ((buff[p++] & 0x3f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            } else {\n-                chars[i] = (char) (((x & 0x1f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            }\n-        }\n-        pos = p;\n-        return new String(chars);\n+  /**\n+   * Read a String from the byte array.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param len the length of the resulting string\n+   * @return the String\n+   */\n+  private String readString(int len) {\n+    byte[] buff = data;\n+    int p = pos;\n+    char[] chars = new char[len];\n+    for (int i = 0; i < len; i++) {\n+      int x = buff[p++] & 0xff;\n+      if (x < 0x80) {\n+        chars[i] = (char) x;\n+      } else if (x >= 0xe0) {\n+        chars[i] = (char) (((x & 0xf) << 12) +\n+            ((buff[p++] & 0x3f) << 6) +\n+            (buff[p++] & 0x3f));\n+      } else {\n+        chars[i] = (char) (((x & 0x1f) << 6) +\n+            (buff[p++] & 0x3f));\n+      }\n     }\n+    pos = p;\n+    return new String(chars);\n+  }\n \n-    /**\n-     * Write a String.\n-     * The current position is incremented.\n-     *\n-     * @param s the value\n-     */\n-    public void writeString(String s) {\n-        int len = s.length();\n-        writeVarInt(len);\n-        writeStringWithoutLength(s, len);\n-    }\n+  /**\n+   * Write a String.\n+   * The current position is incremented.\n+   *\n+   * @param s the value\n+   */\n+  public void writeString(String s) {\n+    int len = s.length();\n+    writeVarInt(len);\n+    writeStringWithoutLength(s, len);\n+  }\n \n-    /**\n-     * Write a String.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param s the string\n-     * @param len the number of characters to write\n-     */\n-    private void writeStringWithoutLength(String s, int len) {\n-        int p = pos;\n-        byte[] buff = data;\n-        for (int i = 0; i < len; i++) {\n-            int c = s.charAt(i);\n-            if (c < 0x80) {\n-                buff[p++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                buff[p++] = (byte) (0xe0 | (c >> 12));\n-                buff[p++] = (byte) (((c >> 6) & 0x3f));\n-                buff[p++] = (byte) (c & 0x3f);\n-            } else {\n-                buff[p++] = (byte) (0xc0 | (c >> 6));\n-                buff[p++] = (byte) (c & 0x3f);\n-            }\n-        }\n-        pos = p;\n+  /**\n+   * Write a String.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param s   the string\n+   * @param len the number of characters to write\n+   */\n+  private void writeStringWithoutLength(String s, int len) {\n+    int p = pos;\n+    byte[] buff = data;\n+    for (int i = 0; i < len; i++) {\n+      int c = s.charAt(i);\n+      if (c < 0x80) {\n+        buff[p++] = (byte) c;\n+      } else if (c >= 0x800) {\n+        buff[p++] = (byte) (0xe0 | (c >> 12));\n+        buff[p++] = (byte) (((c >> 6) & 0x3f));\n+        buff[p++] = (byte) (c & 0x3f);\n+      } else {\n+        buff[p++] = (byte) (0xc0 | (c >> 6));\n+        buff[p++] = (byte) (c & 0x3f);\n+      }\n     }\n+    pos = p;\n+  }\n \n-    private void writeStringWithoutLength(char[] chars, int len) {\n-        int p = pos;\n-        byte[] buff = data;\n-        for (int i = 0; i < len; i++) {\n-            int c = chars[i];\n-            if (c < 0x80) {\n-                buff[p++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                buff[p++] = (byte) (0xe0 | (c >> 12));\n-                buff[p++] = (byte) (((c >> 6) & 0x3f));\n-                buff[p++] = (byte) (c & 0x3f);\n-            } else {\n-                buff[p++] = (byte) (0xc0 | (c >> 6));\n-                buff[p++] = (byte) (c & 0x3f);\n-            }\n-        }\n-        pos = p;\n+  private void writeStringWithoutLength(char[] chars, int len) {\n+    int p = pos;\n+    byte[] buff = data;\n+    for (int i = 0; i < len; i++) {\n+      int c = chars[i];\n+      if (c < 0x80) {\n+        buff[p++] = (byte) c;\n+      } else if (c >= 0x800) {\n+        buff[p++] = (byte) (0xe0 | (c >> 12));\n+        buff[p++] = (byte) (((c >> 6) & 0x3f));\n+        buff[p++] = (byte) (c & 0x3f);\n+      } else {\n+        buff[p++] = (byte) (0xc0 | (c >> 6));\n+        buff[p++] = (byte) (c & 0x3f);\n+      }\n     }\n+    pos = p;\n+  }\n \n-    /**\n-     * Create a new buffer for the given handler. The\n-     * handler will decide what type of buffer is created.\n-     *\n-     * @param handler the data handler\n-     * @param capacity the initial capacity of the buffer\n-     * @param storeLocalTime\n-     *            store DATE, TIME, and TIMESTAMP values with local time storage\n-     *            format\n-     * @return the buffer\n-     */\n-    public static Data create(DataHandler handler, int capacity, boolean storeLocalTime) {\n-        return new Data(handler, new byte[capacity], storeLocalTime);\n-    }\n+  /**\n+   * Create a new buffer for the given handler. The\n+   * handler will decide what type of buffer is created.\n+   *\n+   * @param handler        the data handler\n+   * @param capacity       the initial capacity of the buffer\n+   * @param storeLocalTime store DATE, TIME, and TIMESTAMP values with local time storage\n+   *                       format\n+   * @return the buffer\n+   */\n+  public static Data create(DataHandler handler, int capacity,\n+                            boolean storeLocalTime) {\n+    return new Data(handler, new byte[capacity], storeLocalTime);\n+  }\n \n-    /**\n-     * Create a new buffer using the given data for the given handler. The\n-     * handler will decide what type of buffer is created.\n-     *\n-     * @param handler the data handler\n-     * @param buff the data\n-     * @param storeLocalTime\n-     *            store DATE, TIME, and TIMESTAMP values with local time storage\n-     *            format\n-     * @return the buffer\n-     */\n-    public static Data create(DataHandler handler, byte[] buff, boolean storeLocalTime) {\n-        return new Data(handler, buff, storeLocalTime);\n-    }\n+  /**\n+   * Create a new buffer using the given data for the given handler. The\n+   * handler will decide what type of buffer is created.\n+   *\n+   * @param handler        the data handler\n+   * @param buff           the data\n+   * @param storeLocalTime store DATE, TIME, and TIMESTAMP values with local time storage\n+   *                       format\n+   * @return the buffer\n+   */\n+  public static Data create(DataHandler handler, byte[] buff,\n+                            boolean storeLocalTime) {\n+    return new Data(handler, buff, storeLocalTime);\n+  }\n \n-    /**\n-     * Get the current write position of this buffer, which is the current\n-     * length.\n-     *\n-     * @return the length\n-     */\n-    public int length() {\n-        return pos;\n-    }\n+  /**\n+   * Get the current write position of this buffer, which is the current\n+   * length.\n+   *\n+   * @return the length\n+   */\n+  public int length() {\n+    return pos;\n+  }\n \n-    /**\n-     * Get the byte array used for this page.\n-     *\n-     * @return the byte array\n-     */\n-    public byte[] getBytes() {\n-        return data;\n-    }\n+  /**\n+   * Get the byte array used for this page.\n+   *\n+   * @return the byte array\n+   */\n+  public byte[] getBytes() {\n+    return data;\n+  }\n \n-    /**\n-     * Set the position to 0.\n-     */\n-    public void reset() {\n-        pos = 0;\n-    }\n+  /**\n+   * Set the position to 0.\n+   */\n+  public void reset() {\n+    pos = 0;\n+  }\n \n-    /**\n-     * Append a number of bytes to this buffer.\n-     *\n-     * @param buff the data\n-     * @param off the offset in the data\n-     * @param len the length in bytes\n-     */\n-    public void write(byte[] buff, int off, int len) {\n-        System.arraycopy(buff, off, data, pos, len);\n-        pos += len;\n-    }\n+  /**\n+   * Append a number of bytes to this buffer.\n+   *\n+   * @param buff the data\n+   * @param off  the offset in the data\n+   * @param len  the length in bytes\n+   */\n+  public void write(byte[] buff, int off, int len) {\n+    System.arraycopy(buff, off, data, pos, len);\n+    pos += len;\n+  }\n \n-    /**\n-     * Copy a number of bytes to the given buffer from the current position. The\n-     * current position is incremented accordingly.\n-     *\n-     * @param buff the output buffer\n-     * @param off the offset in the output buffer\n-     * @param len the number of bytes to copy\n-     */\n-    public void read(byte[] buff, int off, int len) {\n-        System.arraycopy(data, pos, buff, off, len);\n-        pos += len;\n-    }\n+  /**\n+   * Copy a number of bytes to the given buffer from the current position. The\n+   * current position is incremented accordingly.\n+   *\n+   * @param buff the output buffer\n+   * @param off  the offset in the output buffer\n+   * @param len  the number of bytes to copy\n+   */\n+  public void read(byte[] buff, int off, int len) {\n+    System.arraycopy(data, pos, buff, off, len);\n+    pos += len;\n+  }\n \n-    /**\n-     * Append one single byte.\n-     *\n-     * @param x the value\n-     */\n-    public void writeByte(byte x) {\n-        data[pos++] = x;\n-    }\n+  /**\n+   * Append one single byte.\n+   *\n+   * @param x the value\n+   */\n+  public void writeByte(byte x) {\n+    data[pos++] = x;\n+  }\n \n-    /**\n-     * Read one single byte.\n-     *\n-     * @return the value\n-     */\n-    public byte readByte() {\n-        return data[pos++];\n-    }\n+  /**\n+   * Read one single byte.\n+   *\n+   * @return the value\n+   */\n+  public byte readByte() {\n+    return data[pos++];\n+  }\n \n-    /**\n-     * Read a long value. This method reads two int values and combines them.\n-     *\n-     * @return the long value\n-     */\n-    public long readLong() {\n-        long x = Bits.readLong(data, pos);\n-        pos += 8;\n-        return x;\n-    }\n+  /**\n+   * Read a long value. This method reads two int values and combines them.\n+   *\n+   * @return the long value\n+   */\n+  public long readLong() {\n+    long x = Bits.readLong(data, pos);\n+    pos += 8;\n+    return x;\n+  }\n \n-    /**\n-     * Append a long value. This method writes two int values.\n-     *\n-     * @param x the value\n-     */\n-    public void writeLong(long x) {\n-        Bits.writeLong(data, pos, x);\n-        pos += 8;\n-    }\n+  /**\n+   * Append a long value. This method writes two int values.\n+   *\n+   * @param x the value\n+   */\n+  public void writeLong(long x) {\n+    Bits.writeLong(data, pos, x);\n+    pos += 8;\n+  }\n \n-    /**\n-     * Append a value.\n-     *\n-     * @param v the value\n-     */\n-    public void writeValue(Value v) {\n-        int start = pos;\n-        if (v == ValueNull.INSTANCE) {\n-            data[pos++] = NULL;\n-            return;\n-        }\n-        int type = v.getValueType();\n-        switch (type) {\n-        case Value.BOOLEAN:\n-            writeByte(v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n-            break;\n-        case Value.TINYINT:\n-            writeByte(TINYINT);\n-            writeByte(v.getByte());\n-            break;\n-        case Value.SMALLINT:\n-            writeByte(SMALLINT);\n-            writeShortInt(v.getShort());\n-            break;\n-        case Value.ENUM:\n-        case Value.INTEGER: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                writeByte(INT_NEG);\n-                writeVarInt(-x);\n-            } else if (x < 16) {\n-                writeByte((byte) (INT_0_15 + x));\n-            } else {\n-                writeByte(type == Value.INTEGER ? INTEGER : ENUM);\n-                writeVarInt(x);\n-            }\n-            break;\n-        }\n-        case Value.BIGINT: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                writeByte(BIGINT_NEG);\n-                writeVarLong(-x);\n-            } else if (x < 8) {\n-                writeByte((byte) (BIGINT_0_7 + x));\n-            } else {\n-                writeByte(BIGINT);\n-                writeVarLong(x);\n-            }\n-            break;\n-        }\n-        case Value.NUMERIC: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                writeByte(NUMERIC_0_1);\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                writeByte((byte) (NUMERIC_0_1 + 1));\n-            } else {\n-                int scale = x.scale();\n-                BigInteger b = x.unscaledValue();\n-                int bits = b.bitLength();\n-                if (bits <= 63) {\n-                    if (scale == 0) {\n-                        writeByte(NUMERIC_SMALL_0);\n-                        writeVarLong(b.longValue());\n-                    } else {\n-                        writeByte(NUMERIC_SMALL);\n-                        writeVarInt(scale);\n-                        writeVarLong(b.longValue());\n-                    }\n-                } else {\n-                    writeByte(NUMERIC);\n-                    writeVarInt(scale);\n-                    byte[] bytes = b.toByteArray();\n-                    writeVarInt(bytes.length);\n-                    write(bytes, 0, bytes.length);\n-                }\n-            }\n-            break;\n-        }\n-        case Value.TIME:\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_TIME);\n-                ValueTime t = (ValueTime) v;\n-                long nanos = t.getNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                writeVarLong(millis);\n-                writeVarInt((int) nanos);\n-            } else {\n-                writeByte(TIME);\n-                writeVarLong(LegacyDateTimeUtils.toTime(null, null, v).getTime() + zoneOffsetMillis);\n-            }\n-            break;\n-        case Value.TIME_TZ: {\n-            writeByte((byte) TIME_TZ);\n-            ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n-            long nanosOfDay = ts.getNanos();\n-            writeVarInt((int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND));\n-            writeVarInt((int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND));\n-            writeTimeZone(ts.getTimeZoneOffsetSeconds());\n-            break;\n-        }\n-        case Value.DATE: {\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_DATE);\n-                long x = ((ValueDate) v).getDateValue();\n-                writeVarLong(x);\n-            } else {\n-                writeByte(DATE);\n-                long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() + zoneOffsetMillis;\n-                writeVarLong(x / MILLIS_PER_MINUTE);\n-            }\n-            break;\n-        }\n-        case Value.TIMESTAMP: {\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_TIMESTAMP);\n-                ValueTimestamp ts = (ValueTimestamp) v;\n-                long dateValue = ts.getDateValue();\n-                writeVarLong(dateValue);\n-                long nanos = ts.getTimeNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                writeVarLong(millis);\n-                writeVarInt((int) nanos);\n-            } else {\n-                Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n-                writeByte(TIMESTAMP);\n-                writeVarLong(ts.getTime() + zoneOffsetMillis);\n-                writeVarInt(ts.getNanos() % 1_000_000);\n-            }\n-            break;\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            if (timeZoneOffset % 60 == 0) {\n-                writeByte(TIMESTAMP_TZ);\n-                writeVarLong(ts.getDateValue());\n-                writeVarLong(ts.getTimeNanos());\n-                writeVarInt(timeZoneOffset / 60);\n-            } else {\n-                writeByte((byte) TIMESTAMP_TZ_2);\n-                writeVarLong(ts.getDateValue());\n-                writeVarLong(ts.getTimeNanos());\n-                writeTimeZone(timeZoneOffset);\n-            }\n-            break;\n-        }\n-        case Value.GEOMETRY:\n-            writeBinary(v, GEOMETRY);\n-            break;\n-        case Value.JAVA_OBJECT:\n-            writeBinary(v, JAVA_OBJECT);\n-            break;\n-        case Value.BINARY:\n-            writeBinary(v, (byte) BINARY);\n-            break;\n-        case Value.VARBINARY: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                writeByte((byte) (VARBINARY_0_31 + len));\n-                write(b, 0, len);\n-            } else {\n-                writeByte(VARBINARY);\n-                writeVarInt(len);\n-                write(b, 0, len);\n-            }\n-            break;\n-        }\n-        case Value.UUID: {\n-            writeByte(UUID);\n-            ValueUuid uuid = (ValueUuid) v;\n-            writeLong(uuid.getHigh());\n-            writeLong(uuid.getLow());\n-            break;\n-        }\n-        case Value.VARCHAR: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                writeByte((byte) (VARCHAR_0_31 + len));\n-                writeStringWithoutLength(s, len);\n-            } else {\n-                writeByte(VARCHAR);\n-                writeString(s);\n-            }\n-            break;\n-        }\n-        case Value.VARCHAR_IGNORECASE:\n-            writeByte(VARCHAR_IGNORECASE);\n-            writeString(v.getString());\n-            break;\n-        case Value.CHAR:\n-            writeByte(CHAR);\n-            writeString(v.getString());\n-            break;\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                writeByte((byte) (DOUBLE_0_1 + 1));\n-            } else {\n-                long d = Double.doubleToLongBits(x);\n-                if (d == ValueDouble.ZERO_BITS) {\n-                    writeByte(DOUBLE_0_1);\n-                } else {\n-                    writeByte(DOUBLE);\n-                    writeVarLong(Long.reverse(d));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.REAL: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                writeByte((byte) (REAL_0_1 + 1));\n-            } else {\n-                int f = Float.floatToIntBits(x);\n-                if (f == ValueReal.ZERO_BITS) {\n-                    writeByte(REAL_0_1);\n-                } else {\n-                    writeByte(REAL);\n-                    writeVarInt(Integer.reverse(f));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            writeByte(type == Value.BLOB ? BLOB : CLOB);\n-            ValueLob lob = (ValueLob) v;\n-            byte[] small = lob.getSmall();\n-            if (small == null) {\n-                writeVarInt(-3);\n-                writeVarInt(lob.getTableId());\n-                writeVarLong(lob.getLobId());\n-                writeVarLong(lob.getType().getPrecision());\n+  /**\n+   * Append a value.\n+   *\n+   * @param v the value\n+   */\n+  public void writeValue(Value v) {\n+    int start = pos;\n+    if (v == ValueNull.INSTANCE) {\n+      data[pos++] = NULL;\n+      return;\n+    }\n+    int type = v.getValueType();\n+    switch (type) {\n+      case Value.BOOLEAN:\n+        writeByte(v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n+        break;\n+      case Value.TINYINT:\n+        writeByte(TINYINT);\n+        writeByte(v.getByte());\n+        break;\n+      case Value.SMALLINT:\n+        writeByte(SMALLINT);\n+        writeShortInt(v.getShort());\n+        break;\n+      case Value.ENUM:\n+      case Value.INTEGER: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          writeByte(INT_NEG);\n+          writeVarInt(-x);\n+        } else if (x < 16) {\n+          writeByte((byte) (INT_0_15 + x));\n+        } else {\n+          writeByte(type == Value.INTEGER ? INTEGER : ENUM);\n+          writeVarInt(x);\n+        }\n+        break;\n+      }\n+      case Value.BIGINT: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          writeByte(BIGINT_NEG);\n+          writeVarLong(-x);\n+        } else if (x < 8) {\n+          writeByte((byte) (BIGINT_0_7 + x));\n+        } else {\n+          writeByte(BIGINT);\n+          writeVarLong(x);\n+        }\n+        break;\n+      }\n+      case Value.NUMERIC: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          writeByte(NUMERIC_0_1);\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          writeByte((byte) (NUMERIC_0_1 + 1));\n+        } else {\n+          int scale = x.scale();\n+          BigInteger b = x.unscaledValue();\n+          int bits = b.bitLength();\n+          if (bits <= 63) {\n+            if (scale == 0) {\n+              writeByte(NUMERIC_SMALL_0);\n+              writeVarLong(b.longValue());\n             } else {\n-                writeVarInt(small.length);\n-                write(small, 0, small.length);\n-            }\n-            break;\n-        }\n-        case Value.ARRAY:\n-        case Value.ROW: {\n-            writeByte(type == Value.ARRAY ? ARRAY : ROW);\n-            Value[] list = ((ValueCollectionBase) v).getList();\n-            writeVarInt(list.length);\n-            for (Value x : list) {\n-                writeValue(x);\n-            }\n-            break;\n-        }\n-        case Value.RESULT_SET: {\n-            writeByte(RESULT_SET);\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            result.reset();\n-            int columnCount = result.getVisibleColumnCount();\n-            writeVarInt(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                writeString(result.getAlias(i));\n-                writeString(result.getColumnName(i));\n-                TypeInfo columnType = result.getColumnType(i);\n-                writeVarInt(columnType.getValueType());\n-                writeVarLong(columnType.getPrecision());\n-                writeVarInt(columnType.getScale());\n-            }\n-            while (result.next()) {\n-                writeByte((byte) 1);\n-                Value[] row = result.currentRow();\n-                for (int i = 0; i < columnCount; i++) {\n-                    writeValue(row[i]);\n-                }\n+              writeByte(NUMERIC_SMALL);\n+              writeVarInt(scale);\n+              writeVarLong(b.longValue());\n             }\n-            writeByte((byte) 0);\n-            break;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n-            }\n-            writeByte(INTERVAL);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            break;\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n-            }\n-            writeByte(INTERVAL);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            writeVarLong(interval.getRemaining());\n-            break;\n-        }\n-        case Value.JSON:\n-            writeBinary(v, (byte) JSON);\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + v.getValueType());\n-        }\n-        assert pos - start == getValueLen(v)\n-                : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v);\n-    }\n-\n-    private void writeBinary(Value v, byte type) {\n-        writeByte(type);\n+          } else {\n+            writeByte(NUMERIC);\n+            writeVarInt(scale);\n+            byte[] bytes = b.toByteArray();\n+            writeVarInt(bytes.length);\n+            write(bytes, 0, bytes.length);\n+          }\n+        }\n+        break;\n+      }\n+      case Value.TIME:\n+        if (storeLocalTime) {\n+          writeByte((byte) LOCAL_TIME);\n+          ValueTime t = (ValueTime) v;\n+          long nanos = t.getNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          writeVarLong(millis);\n+          writeVarInt((int) nanos);\n+        } else {\n+          writeByte(TIME);\n+          writeVarLong(LegacyDateTimeUtils.toTime(null, null, v).getTime() +\n+              zoneOffsetMillis);\n+        }\n+        break;\n+      case Value.TIME_TZ: {\n+        writeByte((byte) TIME_TZ);\n+        ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n+        long nanosOfDay = ts.getNanos();\n+        writeVarInt((int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND));\n+        writeVarInt((int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND));\n+        writeTimeZone(ts.getTimeZoneOffsetSeconds());\n+        break;\n+      }\n+      case Value.DATE: {\n+        if (storeLocalTime) {\n+          writeByte((byte) LOCAL_DATE);\n+          long x = ((ValueDate) v).getDateValue();\n+          writeVarLong(x);\n+        } else {\n+          writeByte(DATE);\n+          long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() +\n+              zoneOffsetMillis;\n+          writeVarLong(x / MILLIS_PER_MINUTE);\n+        }\n+        break;\n+      }\n+      case Value.TIMESTAMP: {\n+        if (storeLocalTime) {\n+          writeByte((byte) LOCAL_TIMESTAMP);\n+          ValueTimestamp ts = (ValueTimestamp) v;\n+          long dateValue = ts.getDateValue();\n+          writeVarLong(dateValue);\n+          long nanos = ts.getTimeNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          writeVarLong(millis);\n+          writeVarInt((int) nanos);\n+        } else {\n+          Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n+          writeByte(TIMESTAMP);\n+          writeVarLong(ts.getTime() + zoneOffsetMillis);\n+          writeVarInt(ts.getNanos() % 1_000_000);\n+        }\n+        break;\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n+        if (timeZoneOffset % 60 == 0) {\n+          writeByte(TIMESTAMP_TZ);\n+          writeVarLong(ts.getDateValue());\n+          writeVarLong(ts.getTimeNanos());\n+          writeVarInt(timeZoneOffset / 60);\n+        } else {\n+          writeByte((byte) TIMESTAMP_TZ_2);\n+          writeVarLong(ts.getDateValue());\n+          writeVarLong(ts.getTimeNanos());\n+          writeTimeZone(timeZoneOffset);\n+        }\n+        break;\n+      }\n+      case Value.GEOMETRY:\n+        writeBinary(v, GEOMETRY);\n+        break;\n+      case Value.JAVA_OBJECT:\n+        writeBinary(v, JAVA_OBJECT);\n+        break;\n+      case Value.BINARY:\n+        writeBinary(v, (byte) BINARY);\n+        break;\n+      case Value.VARBINARY: {\n         byte[] b = v.getBytesNoCopy();\n         int len = b.length;\n-        writeVarInt(len);\n-        write(b, 0, len);\n+        if (len < 32) {\n+          writeByte((byte) (VARBINARY_0_31 + len));\n+          write(b, 0, len);\n+        } else {\n+          writeByte(VARBINARY);\n+          writeVarInt(len);\n+          write(b, 0, len);\n+        }\n+        break;\n+      }\n+      case Value.UUID: {\n+        writeByte(UUID);\n+        ValueUuid uuid = (ValueUuid) v;\n+        writeLong(uuid.getHigh());\n+        writeLong(uuid.getLow());\n+        break;\n+      }\n+      case Value.VARCHAR: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          writeByte((byte) (VARCHAR_0_31 + len));\n+          writeStringWithoutLength(s, len);\n+        } else {\n+          writeByte(VARCHAR);\n+          writeString(s);\n+        }\n+        break;\n+      }\n+      case Value.VARCHAR_IGNORECASE:\n+        writeByte(VARCHAR_IGNORECASE);\n+        writeString(v.getString());\n+        break;\n+      case Value.CHAR:\n+        writeByte(CHAR);\n+        writeString(v.getString());\n+        break;\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          writeByte((byte) (DOUBLE_0_1 + 1));\n+        } else {\n+          long d = Double.doubleToLongBits(x);\n+          if (d == ValueDouble.ZERO_BITS) {\n+            writeByte(DOUBLE_0_1);\n+          } else {\n+            writeByte(DOUBLE);\n+            writeVarLong(Long.reverse(d));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.REAL: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          writeByte((byte) (REAL_0_1 + 1));\n+        } else {\n+          int f = Float.floatToIntBits(x);\n+          if (f == ValueReal.ZERO_BITS) {\n+            writeByte(REAL_0_1);\n+          } else {\n+            writeByte(REAL);\n+            writeVarInt(Integer.reverse(f));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        writeByte(type == Value.BLOB ? BLOB : CLOB);\n+        ValueLob lob = (ValueLob) v;\n+        byte[] small = lob.getSmall();\n+        if (small == null) {\n+          writeVarInt(-3);\n+          writeVarInt(lob.getTableId());\n+          writeVarLong(lob.getLobId());\n+          writeVarLong(lob.getType().getPrecision());\n+        } else {\n+          writeVarInt(small.length);\n+          write(small, 0, small.length);\n+        }\n+        break;\n+      }\n+      case Value.ARRAY:\n+      case Value.ROW: {\n+        writeByte(type == Value.ARRAY ? ARRAY : ROW);\n+        Value[] list = ((ValueCollectionBase) v).getList();\n+        writeVarInt(list.length);\n+        for (Value x : list) {\n+          writeValue(x);\n+        }\n+        break;\n+      }\n+      case Value.RESULT_SET: {\n+        writeByte(RESULT_SET);\n+        ResultInterface result = ((ValueResultSet) v).getResult();\n+        result.reset();\n+        int columnCount = result.getVisibleColumnCount();\n+        writeVarInt(columnCount);\n+        for (int i = 0; i < columnCount; i++) {\n+          writeString(result.getAlias(i));\n+          writeString(result.getColumnName(i));\n+          TypeInfo columnType = result.getColumnType(i);\n+          writeVarInt(columnType.getValueType());\n+          writeVarLong(columnType.getPrecision());\n+          writeVarInt(columnType.getScale());\n+        }\n+        while (result.next()) {\n+          writeByte((byte) 1);\n+          Value[] row = result.currentRow();\n+          for (int i = 0; i < columnCount; i++) {\n+            writeValue(row[i]);\n+          }\n+        }\n+        writeByte((byte) 0);\n+        break;\n+      }\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE: {\n+        ValueInterval interval = (ValueInterval) v;\n+        int ordinal = type - Value.INTERVAL_YEAR;\n+        if (interval.isNegative()) {\n+          ordinal = ~ordinal;\n+        }\n+        writeByte(INTERVAL);\n+        writeByte((byte) ordinal);\n+        writeVarLong(interval.getLeading());\n+        break;\n+      }\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND: {\n+        ValueInterval interval = (ValueInterval) v;\n+        int ordinal = type - Value.INTERVAL_YEAR;\n+        if (interval.isNegative()) {\n+          ordinal = ~ordinal;\n+        }\n+        writeByte(INTERVAL);\n+        writeByte((byte) ordinal);\n+        writeVarLong(interval.getLeading());\n+        writeVarLong(interval.getRemaining());\n+        break;\n+      }\n+      case Value.JSON:\n+        writeBinary(v, (byte) JSON);\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + v.getValueType());\n     }\n+    assert pos - start == getValueLen(v)\n+        : \"value size error: got \" + (pos - start) + \" expected \" +\n+        getValueLen(v);\n+  }\n \n-    /**\n-     * Read a value.\n-     *\n-     * @return the value\n-     */\n-    public Value readValue() {\n-        int type = data[pos++] & 255;\n-        switch (type) {\n-        case NULL:\n-            return ValueNull.INSTANCE;\n-        case BOOLEAN_TRUE:\n-            return ValueBoolean.TRUE;\n-        case BOOLEAN_FALSE:\n-            return ValueBoolean.FALSE;\n-        case INT_NEG:\n-            return ValueInteger.get(-readVarInt());\n-        case ENUM:\n-        case INTEGER:\n-            return ValueInteger.get(readVarInt());\n-        case BIGINT_NEG:\n-            return ValueBigint.get(-readVarLong());\n-        case BIGINT:\n-            return ValueBigint.get(readVarLong());\n-        case TINYINT:\n-            return ValueTinyint.get(readByte());\n-        case SMALLINT:\n-            return ValueSmallint.get(readShortInt());\n-        case NUMERIC_0_1:\n-            return ValueNumeric.ZERO;\n-        case NUMERIC_0_1 + 1:\n-            return ValueNumeric.ONE;\n-        case NUMERIC_SMALL_0:\n-            return ValueNumeric.get(BigDecimal.valueOf(readVarLong()));\n-        case NUMERIC_SMALL: {\n-            int scale = readVarInt();\n-            return ValueNumeric.get(BigDecimal.valueOf(readVarLong(), scale));\n-        }\n-        case NUMERIC: {\n-            int scale = readVarInt();\n-            int len = readVarInt();\n-            byte[] buff = Utils.newBytes(len);\n-            read(buff, 0, len);\n-            BigInteger b = new BigInteger(buff);\n-            return ValueNumeric.get(new BigDecimal(b, scale));\n-        }\n-        case LOCAL_DATE:\n-            return ValueDate.fromDateValue(readVarLong());\n-        case DATE: {\n-            long ms = readVarLong() * MILLIS_PER_MINUTE - zoneOffsetMillis;\n-            return ValueDate.fromDateValue(LegacyDateTimeUtils.dateValueFromLocalMillis(\n-                    ms + LegacyDateTimeUtils.getTimeZoneOffsetMillis(null, ms)));\n-        }\n-        case LOCAL_TIME:\n-            return ValueTime.fromNanos(readVarLong() * 1_000_000 + readVarInt());\n-        case TIME: {\n-            long ms = readVarLong() - zoneOffsetMillis;\n-            return ValueTime.fromNanos(LegacyDateTimeUtils.nanosFromLocalMillis(\n-                    ms + LegacyDateTimeUtils.getTimeZoneOffsetMillis(null, ms)));\n-        }\n-        case TIME_TZ:\n-            return ValueTimeTimeZone.fromNanos(readVarInt() * DateTimeUtils.NANOS_PER_SECOND + readVarInt(),\n-                    readTimeZone());\n-        case LOCAL_TIMESTAMP:\n-            return ValueTimestamp.fromDateValueAndNanos(readVarLong(), readVarLong() * 1_000_000 + readVarInt());\n-        case TIMESTAMP:\n-            return LegacyDateTimeUtils.fromTimestamp(null, readVarLong() - zoneOffsetMillis, readVarInt() % 1_000_000);\n-        case TIMESTAMP_TZ: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong();\n-            int tz = readVarInt() * 60;\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case TIMESTAMP_TZ_2: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong();\n-            int tz = readTimeZone();\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case VARBINARY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueVarbinary.getNoCopy(b);\n-        }\n-        case BINARY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueBinary.getNoCopy(b);\n-        }\n-        case GEOMETRY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueGeometry.get(b);\n-        }\n-        case JAVA_OBJECT: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueJavaObject.getNoCopy(b);\n-        }\n-        case UUID:\n-            return ValueUuid.get(readLong(), readLong());\n-        case VARCHAR:\n-            return ValueVarchar.get(readString());\n-        case VARCHAR_IGNORECASE:\n-            return ValueVarcharIgnoreCase.get(readString());\n-        case CHAR:\n-            return ValueChar.get(readString());\n-        case REAL_0_1:\n-            return ValueReal.ZERO;\n-        case REAL_0_1 + 1:\n-            return ValueReal.ONE;\n-        case DOUBLE_0_1:\n-            return ValueDouble.ZERO;\n-        case DOUBLE_0_1 + 1:\n-            return ValueDouble.ONE;\n-        case DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(Long.reverse(readVarLong())));\n-        case REAL:\n-            return ValueReal.get(Float.intBitsToFloat(Integer.reverse(readVarInt())));\n-        case BLOB:\n-        case CLOB: {\n-            int smallLen = readVarInt();\n-            if (smallLen >= 0) {\n-                byte[] small = Utils.newBytes(smallLen);\n-                read(small, 0, smallLen);\n-                return ValueLob.createSmallLob(type == BLOB ? Value.BLOB : Value.CLOB, small);\n-            } else if (smallLen == -3) {\n-                int tableId = readVarInt();\n-                long lobId = readVarLong();\n-                long precision = readVarLong();\n-                return ValueLob.create(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n-                        lobId, null, precision);\n-            } else {\n-                throw getOldLobException(smallLen);\n-            }\n-        }\n-        case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n-            int len = readVarInt();\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n-            }\n-            return type == ARRAY ? ValueArray.get(list, null) : ValueRow.get(list);\n-        }\n-        case RESULT_SET: {\n-            SimpleResult rs = new SimpleResult();\n-            int columns = readVarInt();\n-            for (int i = 0; i < columns; i++) {\n-                rs.addColumn(readString(), readString(), readVarInt(), readVarLong(), readVarInt());\n-            }\n-            while (readByte() != 0) {\n-                Value[] o = new Value[columns];\n-                for (int i = 0; i < columns; i++) {\n-                    o[i] = readValue();\n-                }\n-                rs.addRow(o);\n-            }\n-            return ValueResultSet.get(rs);\n-        }\n-        case INTERVAL: {\n-            int ordinal = readByte();\n-            boolean negative = ordinal < 0;\n-            if (negative) {\n-                ordinal = ~ordinal;\n-            }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n-                    ordinal < 5 ? 0 : readVarLong());\n-        }\n-        case JSON: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueJson.getInternal(b);\n-        }\n-        default:\n-            if (type >= INT_0_15 && type < INT_0_15 + 16) {\n-                return ValueInteger.get(type - INT_0_15);\n-            } else if (type >= BIGINT_0_7 && type < BIGINT_0_7 + 8) {\n-                return ValueBigint.get(type - BIGINT_0_7);\n-            } else if (type >= VARBINARY_0_31 && type < VARBINARY_0_31 + 32) {\n-                int len = type - VARBINARY_0_31;\n-                byte[] b = Utils.newBytes(len);\n-                read(b, 0, len);\n-                return ValueVarbinary.getNoCopy(b);\n-            } else if (type >= VARCHAR_0_31 && type < VARCHAR_0_31 + 32) {\n-                return ValueVarchar.get(readString(type - VARCHAR_0_31));\n-            }\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n-        }\n-    }\n+  private void writeBinary(Value v, byte type) {\n+    writeByte(type);\n+    byte[] b = v.getBytesNoCopy();\n+    int len = b.length;\n+    writeVarInt(len);\n+    write(b, 0, len);\n+  }\n \n-    private DbException getOldLobException(int smallLen) {\n-        if (handler == null) {\n-            return DbException.get(ErrorCode.FILE_CORRUPTED_1, \"lob type: \" + smallLen);\n+  /**\n+   * Read a value.\n+   *\n+   * @return the value\n+   */\n+  public Value readValue() {\n+    int type = data[pos++] & 255;\n+    switch (type) {\n+      case NULL:\n+        return ValueNull.INSTANCE;\n+      case BOOLEAN_TRUE:\n+        return ValueBoolean.TRUE;\n+      case BOOLEAN_FALSE:\n+        return ValueBoolean.FALSE;\n+      case INT_NEG:\n+        return ValueInteger.get(-readVarInt());\n+      case ENUM:\n+      case INTEGER:\n+        return ValueInteger.get(readVarInt());\n+      case BIGINT_NEG:\n+        return ValueBigint.get(-readVarLong());\n+      case BIGINT:\n+        return ValueBigint.get(readVarLong());\n+      case TINYINT:\n+        return ValueTinyint.get(readByte());\n+      case SMALLINT:\n+        return ValueSmallint.get(readShortInt());\n+      case NUMERIC_0_1:\n+        return ValueNumeric.ZERO;\n+      case NUMERIC_0_1 + 1:\n+        return ValueNumeric.ONE;\n+      case NUMERIC_SMALL_0:\n+        return ValueNumeric.get(BigDecimal.valueOf(readVarLong()));\n+      case NUMERIC_SMALL: {\n+        int scale = readVarInt();\n+        return ValueNumeric.get(BigDecimal.valueOf(readVarLong(), scale));\n+      }\n+      case NUMERIC: {\n+        int scale = readVarInt();\n+        int len = readVarInt();\n+        byte[] buff = Utils.newBytes(len);\n+        read(buff, 0, len);\n+        BigInteger b = new BigInteger(buff);\n+        return ValueNumeric.get(new BigDecimal(b, scale));\n+      }\n+      case LOCAL_DATE:\n+        return ValueDate.fromDateValue(readVarLong());\n+      case DATE: {\n+        long ms = readVarLong() * MILLIS_PER_MINUTE - zoneOffsetMillis;\n+        return ValueDate\n+            .fromDateValue(LegacyDateTimeUtils.dateValueFromLocalMillis(\n+                ms + LegacyDateTimeUtils.getTimeZoneOffsetMillis(null, ms)));\n+      }\n+      case LOCAL_TIME:\n+        return ValueTime.fromNanos(readVarLong() * 1_000_000 + readVarInt());\n+      case TIME: {\n+        long ms = readVarLong() - zoneOffsetMillis;\n+        return ValueTime.fromNanos(LegacyDateTimeUtils.nanosFromLocalMillis(\n+            ms + LegacyDateTimeUtils.getTimeZoneOffsetMillis(null, ms)));\n+      }\n+      case TIME_TZ:\n+        return ValueTimeTimeZone.fromNanos(\n+            readVarInt() * DateTimeUtils.NANOS_PER_SECOND + readVarInt(),\n+            readTimeZone());\n+      case LOCAL_TIMESTAMP:\n+        return ValueTimestamp.fromDateValueAndNanos(readVarLong(),\n+            readVarLong() * 1_000_000 + readVarInt());\n+      case TIMESTAMP:\n+        return LegacyDateTimeUtils\n+            .fromTimestamp(null, readVarLong() - zoneOffsetMillis,\n+                readVarInt() % 1_000_000);\n+      case TIMESTAMP_TZ: {\n+        long dateValue = readVarLong();\n+        long nanos = readVarLong();\n+        int tz = readVarInt() * 60;\n+        return ValueTimestampTimeZone\n+            .fromDateValueAndNanos(dateValue, nanos, tz);\n+      }\n+      case TIMESTAMP_TZ_2: {\n+        long dateValue = readVarLong();\n+        long nanos = readVarLong();\n+        int tz = readTimeZone();\n+        return ValueTimestampTimeZone\n+            .fromDateValueAndNanos(dateValue, nanos, tz);\n+      }\n+      case VARBINARY: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueVarbinary.getNoCopy(b);\n+      }\n+      case BINARY: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueBinary.getNoCopy(b);\n+      }\n+      case GEOMETRY: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueGeometry.get(b);\n+      }\n+      case JAVA_OBJECT: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueJavaObject.getNoCopy(b);\n+      }\n+      case UUID:\n+        return ValueUuid.get(readLong(), readLong());\n+      case VARCHAR:\n+        return ValueVarchar.get(readString());\n+      case VARCHAR_IGNORECASE:\n+        return ValueVarcharIgnoreCase.get(readString());\n+      case CHAR:\n+        return ValueChar.get(readString());\n+      case REAL_0_1:\n+        return ValueReal.ZERO;\n+      case REAL_0_1 + 1:\n+        return ValueReal.ONE;\n+      case DOUBLE_0_1:\n+        return ValueDouble.ZERO;\n+      case DOUBLE_0_1 + 1:\n+        return ValueDouble.ONE;\n+      case DOUBLE:\n+        return ValueDouble\n+            .get(Double.longBitsToDouble(Long.reverse(readVarLong())));\n+      case REAL:\n+        return ValueReal\n+            .get(Float.intBitsToFloat(Integer.reverse(readVarInt())));\n+      case BLOB:\n+      case CLOB: {\n+        int smallLen = readVarInt();\n+        if (smallLen >= 0) {\n+          byte[] small = Utils.newBytes(smallLen);\n+          read(small, 0, smallLen);\n+          return ValueLob\n+              .createSmallLob(type == BLOB ? Value.BLOB : Value.CLOB, small);\n+        } else if (smallLen == -3) {\n+          int tableId = readVarInt();\n+          long lobId = readVarLong();\n+          long precision = readVarLong();\n+          return ValueLob\n+              .create(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n+                  lobId, null, precision);\n         } else {\n-            String s = handler.toString();\n-            int idx = s.lastIndexOf(':');\n-            if (idx >= 0) {\n-                s = s.substring(0, idx);\n-            }\n-            return DbException.getFileVersionError(s);\n+          throw getOldLobException(smallLen);\n         }\n+      }\n+      case ARRAY:\n+      case ROW: // Special storage type for ValueRow\n+      {\n+        int len = readVarInt();\n+        Value[] list = new Value[len];\n+        for (int i = 0; i < len; i++) {\n+          list[i] = readValue();\n+        }\n+        return type == ARRAY ? ValueArray.get(list, null) : ValueRow.get(list);\n+      }\n+      case RESULT_SET: {\n+        SimpleResult rs = new SimpleResult();\n+        int columns = readVarInt();\n+        for (int i = 0; i < columns; i++) {\n+          rs.addColumn(readString(), readString(), readVarInt(), readVarLong(),\n+              readVarInt());\n+        }\n+        while (readByte() != 0) {\n+          Value[] o = new Value[columns];\n+          for (int i = 0; i < columns; i++) {\n+            o[i] = readValue();\n+          }\n+          rs.addRow(o);\n+        }\n+        return ValueResultSet.get(rs);\n+      }\n+      case INTERVAL: {\n+        int ordinal = readByte();\n+        boolean negative = ordinal < 0;\n+        if (negative) {\n+          ordinal = ~ordinal;\n+        }\n+        return ValueInterval\n+            .from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n+                ordinal < 5 ? 0 : readVarLong());\n+      }\n+      case JSON: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueJson.getInternal(b);\n+      }\n+      default:\n+        if (type >= INT_0_15 && type < INT_0_15 + 16) {\n+          return ValueInteger.get(type - INT_0_15);\n+        } else if (type >= BIGINT_0_7 && type < BIGINT_0_7 + 8) {\n+          return ValueBigint.get(type - BIGINT_0_7);\n+        } else if (type >= VARBINARY_0_31 && type < VARBINARY_0_31 + 32) {\n+          int len = type - VARBINARY_0_31;\n+          byte[] b = Utils.newBytes(len);\n+          read(b, 0, len);\n+          return ValueVarbinary.getNoCopy(b);\n+        } else if (type >= VARCHAR_0_31 && type < VARCHAR_0_31 + 32) {\n+          return ValueVarchar.get(readString(type - VARCHAR_0_31));\n+        }\n+        throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n     }\n+  }\n \n-    /**\n-     * Calculate the number of bytes required to encode the given value.\n-     *\n-     * @param v the value\n-     * @return the number of bytes required to store this value\n-     */\n-    public int getValueLen(Value v) {\n-        return getValueLen(v, storeLocalTime);\n+  private DbException getOldLobException(int smallLen) {\n+    if (handler == null) {\n+      return DbException\n+          .get(ErrorCode.FILE_CORRUPTED_1, \"lob type: \" + smallLen);\n+    } else {\n+      String s = handler.toString();\n+      int idx = s.lastIndexOf(':');\n+      if (idx >= 0) {\n+        s = s.substring(0, idx);\n+      }\n+      return DbException.getFileVersionError(s);\n     }\n+  }\n \n-    /**\n-     * Calculate the number of bytes required to encode the given value.\n-     *\n-     * @param v the value\n-     * @param storeLocalTime\n-     *            calculate size of DATE, TIME, and TIMESTAMP values with local\n-     *            time storage format\n-     * @return the number of bytes required to store this value\n-     */\n-    public static int getValueLen(Value v, boolean storeLocalTime) {\n-        if (v == ValueNull.INSTANCE) {\n-            return 1;\n-        }\n-        switch (v.getValueType()) {\n-        case Value.BOOLEAN:\n-            return 1;\n-        case Value.TINYINT:\n-            return 2;\n-        case Value.SMALLINT:\n-            return 3;\n-        case Value.ENUM:\n-        case Value.INTEGER: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                return 1 + getVarIntLen(-x);\n-            } else if (x < 16) {\n-                return 1;\n-            } else {\n-                return 1 + getVarIntLen(x);\n-            }\n-        }\n-        case Value.BIGINT: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                return 1 + getVarLongLen(-x);\n-            } else if (x < 8) {\n-                return 1;\n-            } else {\n-                return 1 + getVarLongLen(x);\n-            }\n-        }\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                return 1;\n-            }\n-            long d = Double.doubleToLongBits(x);\n-            if (d == ValueDouble.ZERO_BITS) {\n-                return 1;\n-            }\n-            return 1 + getVarLongLen(Long.reverse(d));\n-        }\n-        case Value.REAL: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                return 1;\n-            }\n-            int f = Float.floatToIntBits(x);\n-            if (f == ValueReal.ZERO_BITS) {\n-                return 1;\n-            }\n-            return 1 + getVarIntLen(Integer.reverse(f));\n-        }\n-        case Value.VARCHAR: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                return 1 + getStringWithoutLengthLen(s, len);\n-            }\n-            return 1 + getStringLen(s);\n-        }\n-        case Value.VARCHAR_IGNORECASE:\n-        case Value.CHAR:\n-            return 1 + getStringLen(v.getString());\n-        case Value.NUMERIC: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                return 1;\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                return 1;\n-            }\n-            int scale = x.scale();\n-            BigInteger b = x.unscaledValue();\n-            int bits = b.bitLength();\n-            if (bits <= 63) {\n-                if (scale == 0) {\n-                    return 1 + getVarLongLen(b.longValue());\n-                }\n-                return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n-            }\n-            byte[] bytes = b.toByteArray();\n-            return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) + bytes.length;\n-        }\n-        case Value.TIME:\n-            if (storeLocalTime) {\n-                long nanos = ((ValueTime) v).getNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                return 1 + getVarLongLen(millis) + getVarLongLen(nanos);\n-            }\n-            return 1 + getVarLongLen(LegacyDateTimeUtils.toTime(null, null, v).getTime() + zoneOffsetMillis);\n-        case Value.TIME_TZ: {\n-            ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n-            long nanosOfDay = ts.getNanos();\n-            int tz = ts.getTimeZoneOffsetSeconds();\n-            return 1 + getVarIntLen((int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND))\n-                    + getVarIntLen((int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND)) + getTimeZoneLen(tz);\n-        }\n-        case Value.DATE: {\n-            if (storeLocalTime) {\n-                long dateValue = ((ValueDate) v).getDateValue();\n-                return 1 + getVarLongLen(dateValue);\n-            }\n-            long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() + zoneOffsetMillis;\n-            return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n-        }\n-        case Value.TIMESTAMP: {\n-            if (storeLocalTime) {\n-                ValueTimestamp ts = (ValueTimestamp) v;\n-                long dateValue = ts.getDateValue();\n-                long nanos = ts.getTimeNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                return 1 + getVarLongLen(dateValue) + getVarLongLen(millis) +\n-                        getVarLongLen(nanos);\n-            }\n-            Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n-            return 1 + getVarLongLen(ts.getTime() + zoneOffsetMillis) + getVarIntLen(ts.getNanos() % 1_000_000);\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            long dateValue = ts.getDateValue();\n-            long nanos = ts.getTimeNanos();\n-            int tz = ts.getTimeZoneOffsetSeconds();\n-            return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n-                    (tz % 60 == 0 ? getVarIntLen(tz / 60) : getTimeZoneLen(tz));\n-        }\n-        case Value.BINARY:\n-        case Value.GEOMETRY:\n-        case Value.JAVA_OBJECT: {\n-            byte[] b = v.getBytesNoCopy();\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.VARBINARY: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                return 1 + b.length;\n-            }\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.UUID:\n-            return 1 + LENGTH_LONG + LENGTH_LONG;\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            int len = 1;\n-            ValueLob lob = (ValueLob) v;\n-            byte[] small = lob.getSmall();\n-            if (small == null) {\n-                len += getVarIntLen(-3);\n-                len += getVarIntLen(lob.getTableId());\n-                len += getVarLongLen(lob.getLobId());\n-                len += getVarLongLen(lob.getType().getPrecision());\n-            } else {\n-                len += getVarIntLen(small.length);\n-                len += small.length;\n-            }\n-            return len;\n-        }\n-        case Value.ARRAY:\n-        case Value.ROW: {\n-            Value[] list = ((ValueCollectionBase) v).getList();\n-            int len = 1 + getVarIntLen(list.length);\n-            for (Value x : list) {\n-                len += getValueLen(x, storeLocalTime);\n-            }\n-            return len;\n-        }\n-        case Value.RESULT_SET: {\n-            int len = 1;\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            int columnCount = result.getVisibleColumnCount();\n-            len += getVarIntLen(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                len += getStringLen(result.getAlias(i));\n-                len += getStringLen(result.getColumnName(i));\n-                TypeInfo columnType = result.getColumnType(i);\n-                len += getVarIntLen(columnType.getValueType());\n-                len += getVarLongLen(columnType.getPrecision());\n-                len += getVarIntLen(columnType.getScale());\n-            }\n-            while (result.next()) {\n-                len++;\n-                Value[] row = result.currentRow();\n-                for (int i = 0; i < columnCount; i++) {\n-                    Value val = row[i];\n-                    len += getValueLen(val, storeLocalTime);\n-                }\n-            }\n-            len++;\n-            return len;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading());\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading()) + getVarLongLen(interval.getRemaining());\n-        }\n-        case Value.JSON: {\n-            byte[] b = v.getBytesNoCopy();\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + v.getValueType());\n-        }\n-    }\n+  /**\n+   * Calculate the number of bytes required to encode the given value.\n+   *\n+   * @param v the value\n+   * @return the number of bytes required to store this value\n+   */\n+  public int getValueLen(Value v) {\n+    return getValueLen(v, storeLocalTime);\n+  }\n \n-    /**\n-     * Set the current read / write position.\n-     *\n-     * @param pos the new position\n-     */\n-    public void setPos(int pos) {\n-        this.pos = pos;\n+  /**\n+   * Calculate the number of bytes required to encode the given value.\n+   *\n+   * @param v              the value\n+   * @param storeLocalTime calculate size of DATE, TIME, and TIMESTAMP values with local\n+   *                       time storage format\n+   * @return the number of bytes required to store this value\n+   */\n+  public static int getValueLen(Value v, boolean storeLocalTime) {\n+    if (v == ValueNull.INSTANCE) {\n+      return 1;\n     }\n-\n-    /**\n-     * Write a short integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @param x the value\n-     */\n-    public void writeShortInt(int x) {\n-        byte[] buff = data;\n-        buff[pos++] = (byte) (x >> 8);\n-        buff[pos++] = (byte) x;\n+    switch (v.getValueType()) {\n+      case Value.BOOLEAN:\n+        return 1;\n+      case Value.TINYINT:\n+        return 2;\n+      case Value.SMALLINT:\n+        return 3;\n+      case Value.ENUM:\n+      case Value.INTEGER: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          return 1 + getVarIntLen(-x);\n+        } else if (x < 16) {\n+          return 1;\n+        } else {\n+          return 1 + getVarIntLen(x);\n+        }\n+      }\n+      case Value.BIGINT: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          return 1 + getVarLongLen(-x);\n+        } else if (x < 8) {\n+          return 1;\n+        } else {\n+          return 1 + getVarLongLen(x);\n+        }\n+      }\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          return 1;\n+        }\n+        long d = Double.doubleToLongBits(x);\n+        if (d == ValueDouble.ZERO_BITS) {\n+          return 1;\n+        }\n+        return 1 + getVarLongLen(Long.reverse(d));\n+      }\n+      case Value.REAL: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          return 1;\n+        }\n+        int f = Float.floatToIntBits(x);\n+        if (f == ValueReal.ZERO_BITS) {\n+          return 1;\n+        }\n+        return 1 + getVarIntLen(Integer.reverse(f));\n+      }\n+      case Value.VARCHAR: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          return 1 + getStringWithoutLengthLen(s, len);\n+        }\n+        return 1 + getStringLen(s);\n+      }\n+      case Value.VARCHAR_IGNORECASE:\n+      case Value.CHAR:\n+        return 1 + getStringLen(v.getString());\n+      case Value.NUMERIC: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          return 1;\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          return 1;\n+        }\n+        int scale = x.scale();\n+        BigInteger b = x.unscaledValue();\n+        int bits = b.bitLength();\n+        if (bits <= 63) {\n+          if (scale == 0) {\n+            return 1 + getVarLongLen(b.longValue());\n+          }\n+          return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n+        }\n+        byte[] bytes = b.toByteArray();\n+        return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) +\n+            bytes.length;\n+      }\n+      case Value.TIME:\n+        if (storeLocalTime) {\n+          long nanos = ((ValueTime) v).getNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          return 1 + getVarLongLen(millis) + getVarLongLen(nanos);\n+        }\n+        return 1 + getVarLongLen(\n+            LegacyDateTimeUtils.toTime(null, null, v).getTime() +\n+                zoneOffsetMillis);\n+      case Value.TIME_TZ: {\n+        ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n+        long nanosOfDay = ts.getNanos();\n+        int tz = ts.getTimeZoneOffsetSeconds();\n+        return 1 +\n+            getVarIntLen((int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND))\n+            +\n+            getVarIntLen((int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND)) +\n+            getTimeZoneLen(tz);\n+      }\n+      case Value.DATE: {\n+        if (storeLocalTime) {\n+          long dateValue = ((ValueDate) v).getDateValue();\n+          return 1 + getVarLongLen(dateValue);\n+        }\n+        long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() +\n+            zoneOffsetMillis;\n+        return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n+      }\n+      case Value.TIMESTAMP: {\n+        if (storeLocalTime) {\n+          ValueTimestamp ts = (ValueTimestamp) v;\n+          long dateValue = ts.getDateValue();\n+          long nanos = ts.getTimeNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          return 1 + getVarLongLen(dateValue) + getVarLongLen(millis) +\n+              getVarLongLen(nanos);\n+        }\n+        Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n+        return 1 + getVarLongLen(ts.getTime() + zoneOffsetMillis) +\n+            getVarIntLen(ts.getNanos() % 1_000_000);\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        long dateValue = ts.getDateValue();\n+        long nanos = ts.getTimeNanos();\n+        int tz = ts.getTimeZoneOffsetSeconds();\n+        return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n+            (tz % 60 == 0 ? getVarIntLen(tz / 60) : getTimeZoneLen(tz));\n+      }\n+      case Value.BINARY:\n+      case Value.GEOMETRY:\n+      case Value.JAVA_OBJECT: {\n+        byte[] b = v.getBytesNoCopy();\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      case Value.VARBINARY: {\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        if (len < 32) {\n+          return 1 + b.length;\n+        }\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      case Value.UUID:\n+        return 1 + LENGTH_LONG + LENGTH_LONG;\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        int len = 1;\n+        ValueLob lob = (ValueLob) v;\n+        byte[] small = lob.getSmall();\n+        if (small == null) {\n+          len += getVarIntLen(-3);\n+          len += getVarIntLen(lob.getTableId());\n+          len += getVarLongLen(lob.getLobId());\n+          len += getVarLongLen(lob.getType().getPrecision());\n+        } else {\n+          len += getVarIntLen(small.length);\n+          len += small.length;\n+        }\n+        return len;\n+      }\n+      case Value.ARRAY:\n+      case Value.ROW: {\n+        Value[] list = ((ValueCollectionBase) v).getList();\n+        int len = 1 + getVarIntLen(list.length);\n+        for (Value x : list) {\n+          len += getValueLen(x, storeLocalTime);\n+        }\n+        return len;\n+      }\n+      case Value.RESULT_SET: {\n+        int len = 1;\n+        ResultInterface result = ((ValueResultSet) v).getResult();\n+        int columnCount = result.getVisibleColumnCount();\n+        len += getVarIntLen(columnCount);\n+        for (int i = 0; i < columnCount; i++) {\n+          len += getStringLen(result.getAlias(i));\n+          len += getStringLen(result.getColumnName(i));\n+          TypeInfo columnType = result.getColumnType(i);\n+          len += getVarIntLen(columnType.getValueType());\n+          len += getVarLongLen(columnType.getPrecision());\n+          len += getVarIntLen(columnType.getScale());\n+        }\n+        while (result.next()) {\n+          len++;\n+          Value[] row = result.currentRow();\n+          for (int i = 0; i < columnCount; i++) {\n+            Value val = row[i];\n+            len += getValueLen(val, storeLocalTime);\n+          }\n+        }\n+        len++;\n+        return len;\n+      }\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE: {\n+        ValueInterval interval = (ValueInterval) v;\n+        return 2 + getVarLongLen(interval.getLeading());\n+      }\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND: {\n+        ValueInterval interval = (ValueInterval) v;\n+        return 2 + getVarLongLen(interval.getLeading()) +\n+            getVarLongLen(interval.getRemaining());\n+      }\n+      case Value.JSON: {\n+        byte[] b = v.getBytesNoCopy();\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + v.getValueType());\n     }\n+  }\n \n-    /**\n-     * Read an short integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public short readShortInt() {\n-        byte[] buff = data;\n-        return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n-    }\n+  /**\n+   * Set the current read / write position.\n+   *\n+   * @param pos the new position\n+   */\n+  public void setPos(int pos) {\n+    this.pos = pos;\n+  }\n \n-    /**\n-     * Shrink the array to this size.\n-     *\n-     * @param size the new size\n-     */\n-    public void truncate(int size) {\n-        if (pos > size) {\n-            byte[] buff = Arrays.copyOf(data, size);\n-            this.pos = size;\n-            data = buff;\n-        }\n-    }\n+  /**\n+   * Write a short integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @param x the value\n+   */\n+  public void writeShortInt(int x) {\n+    byte[] buff = data;\n+    buff[pos++] = (byte) (x >> 8);\n+    buff[pos++] = (byte) x;\n+  }\n \n-    /**\n-     * The number of bytes required for a variable size int.\n-     *\n-     * @param x the value\n-     * @return the len\n-     */\n-    private static int getVarIntLen(int x) {\n-        if ((x & (-1 << 7)) == 0) {\n-            return 1;\n-        } else if ((x & (-1 << 14)) == 0) {\n-            return 2;\n-        } else if ((x & (-1 << 21)) == 0) {\n-            return 3;\n-        } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n-        return 5;\n-    }\n+  /**\n+   * Read an short integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public short readShortInt() {\n+    byte[] buff = data;\n+    return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n+  }\n \n-    /**\n-     * Write a variable size int.\n-     *\n-     * @param x the value\n-     */\n-    public void writeVarInt(int x) {\n-        while ((x & ~0x7f) != 0) {\n-            data[pos++] = (byte) (x | 0x80);\n-            x >>>= 7;\n-        }\n-        data[pos++] = (byte) x;\n+  /**\n+   * Shrink the array to this size.\n+   *\n+   * @param size the new size\n+   */\n+  public void truncate(int size) {\n+    if (pos > size) {\n+      byte[] buff = Arrays.copyOf(data, size);\n+      this.pos = size;\n+      data = buff;\n     }\n+  }\n \n-    /**\n-     * Read a variable size int.\n-     *\n-     * @return the value\n-     */\n-    public int readVarInt() {\n-        int b = data[pos];\n-        if (b >= 0) {\n-            pos++;\n-            return b;\n-        }\n-        // a separate function so that this one can be inlined\n-        return readVarIntRest(b);\n+  /**\n+   * The number of bytes required for a variable size int.\n+   *\n+   * @param x the value\n+   * @return the len\n+   */\n+  private static int getVarIntLen(int x) {\n+    if ((x & (-1 << 7)) == 0) {\n+      return 1;\n+    } else if ((x & (-1 << 14)) == 0) {\n+      return 2;\n+    } else if ((x & (-1 << 21)) == 0) {\n+      return 3;\n+    } else if ((x & (-1 << 28)) == 0) {\n+      return 4;\n     }\n+    return 5;\n+  }\n \n-    private int readVarIntRest(int b) {\n-        int x = b & 0x7f;\n-        b = data[pos + 1];\n-        if (b >= 0) {\n-            pos += 2;\n-            return x | (b << 7);\n-        }\n-        x |= (b & 0x7f) << 7;\n-        b = data[pos + 2];\n-        if (b >= 0) {\n-            pos += 3;\n-            return x | (b << 14);\n-        }\n-        x |= (b & 0x7f) << 14;\n-        b = data[pos + 3];\n-        if (b >= 0) {\n-            pos += 4;\n-            return x | b << 21;\n-        }\n-        x |= ((b & 0x7f) << 21) | (data[pos + 4] << 28);\n-        pos += 5;\n-        return x;\n+  /**\n+   * Write a variable size int.\n+   *\n+   * @param x the value\n+   */\n+  public void writeVarInt(int x) {\n+    while ((x & ~0x7f) != 0) {\n+      data[pos++] = (byte) (x | 0x80);\n+      x >>>= 7;\n     }\n+    data[pos++] = (byte) x;\n+  }\n \n-    /**\n-     * The number of bytes required for a variable size long.\n-     *\n-     * @param x the value\n-     * @return the len\n-     */\n-    public static int getVarLongLen(long x) {\n-        int i = 1;\n-        while (true) {\n-            x >>>= 7;\n-            if (x == 0) {\n-                return i;\n-            }\n-            i++;\n-        }\n+  /**\n+   * Read a variable size int.\n+   *\n+   * @return the value\n+   */\n+  public int readVarInt() {\n+    int b = data[pos];\n+    if (b >= 0) {\n+      pos++;\n+      return b;\n     }\n+    // a separate function so that this one can be inlined\n+    return readVarIntRest(b);\n+  }\n \n-    /**\n-     * Write a variable size long.\n-     *\n-     * @param x the value\n-     */\n-    public void writeVarLong(long x) {\n-        while ((x & ~0x7f) != 0) {\n-            data[pos++] = (byte) (x | 0x80);\n-            x >>>= 7;\n-        }\n-        data[pos++] = (byte) x;\n+  private int readVarIntRest(int b) {\n+    int x = b & 0x7f;\n+    b = data[pos + 1];\n+    if (b >= 0) {\n+      pos += 2;\n+      return x | (b << 7);\n     }\n-\n-    /**\n-     * Read a variable size long.\n-     *\n-     * @return the value\n-     */\n-    public long readVarLong() {\n-        long x = data[pos++];\n-        if (x >= 0) {\n-            return x;\n-        }\n-        x &= 0x7f;\n-        for (int s = 7;; s += 7) {\n-            long b = data[pos++];\n-            x |= (b & 0x7f) << s;\n-            if (b >= 0) {\n-                return x;\n-            }\n-        }\n+    x |= (b & 0x7f) << 7;\n+    b = data[pos + 2];\n+    if (b >= 0) {\n+      pos += 3;\n+      return x | (b << 14);\n     }\n+    x |= (b & 0x7f) << 14;\n+    b = data[pos + 3];\n+    if (b >= 0) {\n+      pos += 4;\n+      return x | b << 21;\n+    }\n+    x |= ((b & 0x7f) << 21) | (data[pos + 4] << 28);\n+    pos += 5;\n+    return x;\n+  }\n \n-    private static int getTimeZoneLen(int timeZoneOffset) {\n-        if (timeZoneOffset % 900 == 0) {\n-            return 1;\n-        } else if (timeZoneOffset > 0) {\n-            return getVarIntLen(timeZoneOffset) + 1;\n-        } else {\n-            return getVarIntLen(-timeZoneOffset) + 1;\n-        }\n+  /**\n+   * The number of bytes required for a variable size long.\n+   *\n+   * @param x the value\n+   * @return the len\n+   */\n+  public static int getVarLongLen(long x) {\n+    int i = 1;\n+    while (true) {\n+      x >>>= 7;\n+      if (x == 0) {\n+        return i;\n+      }\n+      i++;\n     }\n+  }\n \n-    private void writeTimeZone(int timeZoneOffset) {\n-        // Valid JSR-310 offsets are -64,800..64,800\n-        // Use 1 byte for common time zones (including +8:45 etc.)\n-        if (timeZoneOffset % 900 == 0) {\n-            // -72..72\n-            writeByte((byte) (timeZoneOffset / 900));\n-        } else if (timeZoneOffset > 0) {\n-            writeByte(Byte.MAX_VALUE);\n-            writeVarInt(timeZoneOffset);\n-        } else {\n-            writeByte(Byte.MIN_VALUE);\n-            writeVarInt(-timeZoneOffset);\n-        }\n+  /**\n+   * Write a variable size long.\n+   *\n+   * @param x the value\n+   */\n+  public void writeVarLong(long x) {\n+    while ((x & ~0x7f) != 0) {\n+      data[pos++] = (byte) (x | 0x80);\n+      x >>>= 7;\n     }\n+    data[pos++] = (byte) x;\n+  }\n \n-    private int readTimeZone() {\n-        byte x = data[pos++];\n-        if (x == Byte.MAX_VALUE) {\n-            return readVarInt();\n-        } else if (x == Byte.MIN_VALUE) {\n-            return -readVarInt();\n-        } else {\n-            return x * 900;\n-        }\n+  /**\n+   * Read a variable size long.\n+   *\n+   * @return the value\n+   */\n+  public long readVarLong() {\n+    long x = data[pos++];\n+    if (x >= 0) {\n+      return x;\n     }\n+    x &= 0x7f;\n+    for (int s = 7; ; s += 7) {\n+      long b = data[pos++];\n+      x |= (b & 0x7f) << s;\n+      if (b >= 0) {\n+        return x;\n+      }\n+    }\n+  }\n \n-    /**\n-     * Check if there is still enough capacity in the buffer.\n-     * This method extends the buffer if required.\n-     *\n-     * @param plus the number of additional bytes required\n-     */\n-    public void checkCapacity(int plus) {\n-        if (pos + plus >= data.length) {\n-            // a separate method to simplify inlining\n-            expand(plus);\n-        }\n+  private static int getTimeZoneLen(int timeZoneOffset) {\n+    if (timeZoneOffset % 900 == 0) {\n+      return 1;\n+    } else if (timeZoneOffset > 0) {\n+      return getVarIntLen(timeZoneOffset) + 1;\n+    } else {\n+      return getVarIntLen(-timeZoneOffset) + 1;\n     }\n+  }\n \n-    private void expand(int plus) {\n-        // must copy everything, because pos could be 0 and data may be\n-        // still required\n-        data = Utils.copyBytes(data, (data.length + plus) * 2);\n+  private void writeTimeZone(int timeZoneOffset) {\n+    // Valid JSR-310 offsets are -64,800..64,800\n+    // Use 1 byte for common time zones (including +8:45 etc.)\n+    if (timeZoneOffset % 900 == 0) {\n+      // -72..72\n+      writeByte((byte) (timeZoneOffset / 900));\n+    } else if (timeZoneOffset > 0) {\n+      writeByte(Byte.MAX_VALUE);\n+      writeVarInt(timeZoneOffset);\n+    } else {\n+      writeByte(Byte.MIN_VALUE);\n+      writeVarInt(-timeZoneOffset);\n     }\n+  }\n \n-    /**\n-     * Fill up the buffer with empty space and an (initially empty) checksum\n-     * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n-     */\n-    public void fillAligned() {\n-        // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n-        int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n-        pos = len;\n-        if (data.length < len) {\n-            checkCapacity(len - data.length);\n-        }\n+  private int readTimeZone() {\n+    byte x = data[pos++];\n+    if (x == Byte.MAX_VALUE) {\n+      return readVarInt();\n+    } else if (x == Byte.MIN_VALUE) {\n+      return -readVarInt();\n+    } else {\n+      return x * 900;\n     }\n+  }\n \n-    /**\n-     * Copy a String from a reader to an output stream.\n-     *\n-     * @param source the reader\n-     * @param target the output stream\n-     */\n-    public static void copyString(Reader source, OutputStream target)\n-            throws IOException {\n-        char[] buff = new char[Constants.IO_BUFFER_SIZE];\n-        Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE], false);\n-        while (true) {\n-            int l = source.read(buff);\n-            if (l < 0) {\n-                break;\n-            }\n-            d.writeStringWithoutLength(buff, l);\n-            target.write(d.data, 0, d.pos);\n-            d.reset();\n-        }\n+  /**\n+   * Check if there is still enough capacity in the buffer.\n+   * This method extends the buffer if required.\n+   *\n+   * @param plus the number of additional bytes required\n+   */\n+  public void checkCapacity(int plus) {\n+    if (pos + plus >= data.length) {\n+      // a separate method to simplify inlining\n+      expand(plus);\n     }\n+  }\n \n-    public DataHandler getHandler() {\n-        return handler;\n+  private void expand(int plus) {\n+    // must copy everything, because pos could be 0 and data may be\n+    // still required\n+    data = Utils.copyBytes(data, (data.length + plus) * 2);\n+  }\n+\n+  /**\n+   * Fill up the buffer with empty space and an (initially empty) checksum\n+   * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n+   */\n+  public void fillAligned() {\n+    // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n+    int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n+    pos = len;\n+    if (data.length < len) {\n+      checkCapacity(len - data.length);\n     }\n+  }\n \n-    /**\n-     * Reset the cached calendar for default timezone, for example after\n-     * changing the default timezone.\n-     */\n-    public static void resetCalendar() {\n-        zoneOffsetMillis = new GregorianCalendar().get(Calendar.ZONE_OFFSET);\n+  /**\n+   * Copy a String from a reader to an output stream.\n+   *\n+   * @param source the reader\n+   * @param target the output stream\n+   */\n+  public static void copyString(Reader source, OutputStream target)\n+      throws IOException {\n+    char[] buff = new char[Constants.IO_BUFFER_SIZE];\n+    Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE], false);\n+    while (true) {\n+      int l = source.read(buff);\n+      if (l < 0) {\n+        break;\n+      }\n+      d.writeStringWithoutLength(buff, l);\n+      target.write(d.data, 0, d.pos);\n+      d.reset();\n     }\n+  }\n+\n+  public DataHandler getHandler() {\n+    return handler;\n+  }\n+\n+  /**\n+   * Reset the cached calendar for default timezone, for example after\n+   * changing the default timezone.\n+   */\n+  public static void resetCalendar() {\n+    zoneOffsetMillis = new GregorianCalendar().get(Calendar.ZONE_OFFSET);\n+  }\n \n }\n",
            "diff_size": 2069
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "925",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/330/Data.java\nindex c99a141540..a8bf23ef55 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/330/Data.java\n@@ -922,8 +922,7 @@ public class Data {\n                 throw getOldLobException(smallLen);\n             }\n         }\n-        case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n+        case ARRAY:caseROW: // Special storage type for ValueRow\n         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "926",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/330/Data.java\nindex c99a141540..b80258ef84 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/330/Data.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/330/Data.java\n@@ -923,7 +923,7 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n+            case ROW: // Special storage type for ValueRow\n         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n",
            "diff_size": 1
        }
    ]
}