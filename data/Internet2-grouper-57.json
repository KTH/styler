{
    "error_id": "57",
    "information": {
        "errors": [
            {
                "line": "480",
                "column": "9",
                "severity": "warning",
                "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
            }
        ]
    },
    "source_code": "            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "480",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/57/EqualsBuilder.java\nindex f02aebb379..ace5cea4d8 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/57/EqualsBuilder.java\n@@ -1,959 +1,959 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.tuple.Pair;\r\n-\r\n-/**\r\n- * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\r\n- *\r\n- * <p> This class provides methods to build a good equals method for any\r\n- * class. It follows rules laid out in\r\n- * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\r\n- * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\r\n- * <code>floats</code>, and arrays can be tricky. Also, making sure that\r\n- * <code>equals()</code> and <code>hashCode()</code> are consistent can be\r\n- * difficult.</p>\r\n- *\r\n- * <p>Two Objects that compare as equals must generate the same hash code,\r\n- * but two Objects with the same hash code do not have to be equal.</p>\r\n- *\r\n- * <p>All relevant fields should be included in the calculation of equals.\r\n- * Derived fields may be ignored. In particular, any field used in\r\n- * generating a hash code must be used in the equals method, and vice\r\n- * versa.</p>\r\n- *\r\n- * <p>Typical use for the code is as follows:</p>\r\n- * <pre>\r\n- * public boolean equals(Object obj) {\r\n- *   if (obj == null) { return false; }\r\n- *   if (obj == this) { return true; }\r\n- *   if (obj.getClass() != getClass()) {\r\n- *     return false;\r\n- *   }\r\n- *   MyClass rhs = (MyClass) obj;\r\n- *   return new EqualsBuilder()\r\n- *                 .appendSuper(super.equals(obj))\r\n- *                 .append(field1, rhs.field1)\r\n- *                 .append(field2, rhs.field2)\r\n- *                 .append(field3, rhs.field3)\r\n- *                 .isEquals();\r\n- *  }\r\n- * </pre>\r\n- *\r\n- * <p> Alternatively, there is a method that uses reflection to determine\r\n- * the fields to test. Because these fields are usually private, the method,\r\n- * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\r\n- * change the visibility of the fields. This will fail under a security\r\n- * manager, unless the appropriate permissions are set up correctly. It is\r\n- * also slower than testing explicitly.</p>\r\n- *\r\n- * <p> A typical invocation for this method would look like:</p>\r\n- * <pre>\r\n- * public boolean equals(Object obj) {\r\n- *   return EqualsBuilder.reflectionEquals(this, obj);\r\n- * }\r\n- * </pre>\r\n- *\r\n- * @since 1.0\r\n- * @version $Id: EqualsBuilder.java 1091531 2011-04-12 18:29:49Z ggregory $\r\n- */\r\n-public class EqualsBuilder implements Builder<Boolean> {\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of object pairs being traversed by the reflection\r\n-     * methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 3.0\r\n-     */\r\n-    static Set<Pair<IDKey, IDKey>> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Converters value pair into a register pair.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object\r\n-     * @param rhs the other object\r\n-     *\r\n-     * @return the pair\r\n-     */\r\n-    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\r\n-        IDKey left = new IDKey(lhs);\r\n-        IDKey right = new IDKey(rhs);\r\n-        return Pair.of(left, right);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * Objects might be swapped therefore a check is needed if the object pair\r\n-     * is registered in given or swapped order.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to lookup in registry\r\n-     * @param rhs the other object to lookup on registry\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 3.0\r\n-     */\r\n-    static boolean isRegistered(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n-\r\n-        return registry != null\r\n-                && (registry.contains(pair) || registry.contains(swappedPair));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to register\r\n-     * @param rhs the other object to register\r\n-     */\r\n-    static void register(Object lhs, Object rhs) {\r\n-        synchronized (EqualsBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\r\n-            }\r\n-        }\r\n-\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        registry.add(pair);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object pair.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param lhs <code>this</code> object to unregister\r\n-     * @param rhs the other object to unregister\r\n-     * @since 3.0\r\n-     */\r\n-    static void unregister(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-            registry.remove(pair);\r\n-            synchronized (EqualsBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * If the fields tested are equals.\r\n-     * The default value is <code>true</code>.\r\n-     */\r\n-    private boolean isEquals = true;\r\n-\r\n-    /**\r\n-     * <p>Constructor for EqualsBuilder.</p>\r\n-     *\r\n-     * <p>Starts off assuming that equals is <code>true</code>.</p>\r\n-     * @see Object#equals(Object)\r\n-     */\r\n-    public EqualsBuilder() {\r\n-        // do nothing for now.\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  Collection of String field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the TestTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\r\n-        return reflectionEquals(lhs, rhs, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the testTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be included. Superclass fields will be appended\r\n-     * up to and including the specified superclass. A null superclass is treated\r\n-     * as java.lang.Object.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\r\n-     *  may be <code>null</code>\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     * @since 2.0\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n-            String... excludeFields) {\r\n-        if (lhs == rhs) {\r\n-            return true;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            return false;\r\n-        }\r\n-        // Find the leaf class since there may be transients in the leaf\r\n-        // class or in classes between the leaf and root.\r\n-        // If we are not testing transients or a subclass has no ivars,\r\n-        // then a subclass can test equals to a superclass.\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        Class<?> rhsClass = rhs.getClass();\r\n-        Class<?> testClass;\r\n-        if (lhsClass.isInstance(rhs)) {\r\n-            testClass = lhsClass;\r\n-            if (!rhsClass.isInstance(lhs)) {\r\n-                // rhsClass is a subclass of lhsClass\r\n-                testClass = rhsClass;\r\n-            }\r\n-        } else if (rhsClass.isInstance(lhs)) {\r\n-            testClass = rhsClass;\r\n-            if (!lhsClass.isInstance(rhs)) {\r\n-                // lhsClass is a subclass of rhsClass\r\n-                testClass = lhsClass;\r\n-            }\r\n-        } else {\r\n-            // The two classes are not related.\r\n-            return false;\r\n-        }\r\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n-        try {\r\n-            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n-                testClass = testClass.getSuperclass();\r\n-                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            }\r\n-        } catch (IllegalArgumentException e) {\r\n-            // In this case, we tried to test a subclass vs. a superclass and\r\n-            // the subclass has ivars or the ivars are transient and\r\n-            // we are testing transients.\r\n-            // If a subclass has ivars that we are trying to test them, we get an\r\n-            // exception and we know that the objects are not equal.\r\n-            return false;\r\n-        }\r\n-        return equalsBuilder.isEquals();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Appends the fields and values defined by the given object of the\r\n-     * given Class.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @param clazz  the class to append details of\r\n-     * @param builder  the builder to append to\r\n-     * @param useTransients  whether to test transient fields\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     */\r\n-    private static void reflectionAppend(\r\n-        Object lhs,\r\n-        Object rhs,\r\n-        Class<?> clazz,\r\n-        EqualsBuilder builder,\r\n-        boolean useTransients,\r\n-        String[] excludeFields) {\r\n-\r\n-        if (isRegistered(lhs, rhs)) {\r\n-            return;\r\n-        }\r\n-\r\n-        try {\r\n-            register(lhs, rhs);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n-                Field f = fields[i];\r\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\r\n-                    && (f.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\r\n-                    try {\r\n-                        builder.append(f.get(lhs), f.get(rhs));\r\n-                    } catch (IllegalAccessException e) {\r\n-                        //this can't happen. Would get a Security exception instead\r\n-                        //throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(lhs, rhs);\r\n-        }\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\r\n-     *\r\n-     * @param superEquals  the result of calling <code>super.equals()</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public EqualsBuilder appendSuper(boolean superEquals) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = superEquals;\r\n-        return this;\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>Object</code>s are equal using their\r\n-     * <code>equals</code> method.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object lhs, Object rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        if (!lhsClass.isArray()) {\r\n-            // The simple case, not an array, just test the element\r\n-            isEquals = lhs.equals(rhs);\r\n-        } else if (lhs.getClass() != rhs.getClass()) {\r\n-            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n-            this.setEquals(false);\r\n-        }\r\n-        // 'Switch' on type of array, to dispatch to the correct handler\r\n-        // This handles multi dimensional arrays of the same depth\r\n-        else if (lhs instanceof long[]) {\r\n-            append((long[]) lhs, (long[]) rhs);\r\n-        } else if (lhs instanceof int[]) {\r\n-            append((int[]) lhs, (int[]) rhs);\r\n-        } else if (lhs instanceof short[]) {\r\n-            append((short[]) lhs, (short[]) rhs);\r\n-        } else if (lhs instanceof char[]) {\r\n-            append((char[]) lhs, (char[]) rhs);\r\n-        } else if (lhs instanceof byte[]) {\r\n-            append((byte[]) lhs, (byte[]) rhs);\r\n-        } else if (lhs instanceof double[]) {\r\n-            append((double[]) lhs, (double[]) rhs);\r\n-        } else if (lhs instanceof float[]) {\r\n-            append((float[]) lhs, (float[]) rhs);\r\n-        } else if (lhs instanceof boolean[]) {\r\n-            append((boolean[]) lhs, (boolean[]) rhs);\r\n-        } else {\r\n-            // Not an array of primitives\r\n-            append((Object[]) lhs, (Object[]) rhs);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Test if two <code>long</code> s are equal.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs\r\n-     *                  the left hand <code>long</code>\r\n-     * @param rhs\r\n-     *                  the right hand <code>long</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long lhs, long rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>int</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int</code>\r\n-     * @param rhs  the right hand <code>int</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int lhs, int rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>short</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short</code>\r\n-     * @param rhs  the right hand <code>short</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short lhs, short rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>char</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char</code>\r\n-     * @param rhs  the right hand <code>char</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char lhs, char rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>byte</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte</code>\r\n-     * @param rhs  the right hand <code>byte</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte lhs, byte rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>double</code>s are equal by testing that the\r\n-     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double</code>\r\n-     * @param rhs  the right hand <code>double</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double lhs, double rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>float</code>s are equal byt testing that the\r\n-     * pattern of bits returned by doubleToLong are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float</code>\r\n-     * @param rhs  the right hand <code>float</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float lhs, float rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>booleans</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean</code>\r\n-     * @param rhs  the right hand <code>boolean</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-      */\r\n-    public EqualsBuilder append(boolean lhs, boolean rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\r\n-     *\r\n-     * <p>This also will be called for the top level of\r\n-     * multi-dimensional, ragged, and multi-typed arrays.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>Object[]</code>\r\n-     * @param rhs  the right hand <code>Object[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>long</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(long, long)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>long[]</code>\r\n-     * @param rhs  the right hand <code>long[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long[] lhs, long[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>int</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(int, int)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int[]</code>\r\n-     * @param rhs  the right hand <code>int[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int[] lhs, int[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>short</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(short, short)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short[]</code>\r\n-     * @param rhs  the right hand <code>short[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short[] lhs, short[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>char</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(char, char)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char[]</code>\r\n-     * @param rhs  the right hand <code>char[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char[] lhs, char[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>byte</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(byte, byte)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte[]</code>\r\n-     * @param rhs  the right hand <code>byte[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>double</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(double, double)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double[]</code>\r\n-     * @param rhs  the right hand <code>double[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double[] lhs, double[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>float</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(float, float)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float[]</code>\r\n-     * @param rhs  the right hand <code>float[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float[] lhs, float[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>boolean</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(boolean, boolean)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean[]</code>\r\n-     * @param rhs  the right hand <code>boolean[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return boolean\r\n-     */\r\n-    public boolean isEquals() {\r\n-        return this.isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return <code>true</code> if all of the fields that have been checked\r\n-     *         are equal, <code>false</code> otherwise.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Boolean build() {\r\n-        return Boolean.valueOf(isEquals());\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the <code>isEquals</code> value.\r\n-     *\r\n-     * @param isEquals The value to set.\r\n-     * @since 2.1\r\n-     */\r\n-    protected void setEquals(boolean isEquals) {\r\n-        this.isEquals = isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reset the EqualsBuilder so you can use the same object again\r\n-     * @since 2.5\r\n-     */\r\n-    public void reset() {\r\n-        this.isEquals = true;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n+ *\n+ * <p> This class provides methods to build a good equals method for any\n+ * class. It follows rules laid out in\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\n+ * <code>floats</code>, and arrays can be tricky. Also, making sure that\n+ * <code>equals()</code> and <code>hashCode()</code> are consistent can be\n+ * difficult.</p>\n+ *\n+ * <p>Two Objects that compare as equals must generate the same hash code,\n+ * but two Objects with the same hash code do not have to be equal.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of equals.\n+ * Derived fields may be ignored. In particular, any field used in\n+ * generating a hash code must be used in the equals method, and vice\n+ * versa.</p>\n+ *\n+ * <p>Typical use for the code is as follows:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   if (obj == null) { return false; }\n+ *   if (obj == this) { return true; }\n+ *   if (obj.getClass() != getClass()) {\n+ *     return false;\n+ *   }\n+ *   MyClass rhs = (MyClass) obj;\n+ *   return new EqualsBuilder()\n+ *                 .appendSuper(super.equals(obj))\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .append(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </pre>\n+ *\n+ * <p> Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly. It is\n+ * also slower than testing explicitly.</p>\n+ *\n+ * <p> A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </pre>\n+ *\n+ * @since 1.0\n+ * @version $Id: EqualsBuilder.java 1091531 2011-04-12 18:29:49Z ggregory $\n+ */\n+public class EqualsBuilder implements Builder<Boolean> {\n+\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     *\n+     * @since 3.0\n+     */\n+    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n+\n+    /*\n+     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     *\n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     *\n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     *\n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *\n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+\n+    /**\n+     * <p>\n+     * Returns the registry of object pairs being traversed by the reflection\n+     * methods in the current thread.\n+     * </p>\n+     *\n+     * @return Set the registry of objects being traversed\n+     * @since 3.0\n+     */\n+    static Set<Pair<IDKey, IDKey>> getRegistry() {\n+        return REGISTRY.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converters value pair into a register pair.\n+     * </p>\n+     *\n+     * @param lhs <code>this</code> object\n+     * @param rhs the other object\n+     *\n+     * @return the pair\n+     */\n+    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\n+        IDKey left = new IDKey(lhs);\n+        IDKey right = new IDKey(rhs);\n+        return Pair.of(left, right);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object pair.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * Objects might be swapped therefore a check is needed if the object pair\n+     * is registered in given or swapped order.\n+     * </p>\n+     *\n+     * @param lhs <code>this</code> object to lookup in registry\n+     * @param rhs the other object to lookup on registry\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 3.0\n+     */\n+    static boolean isRegistered(Object lhs, Object rhs) {\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\n+\n+        return registry != null\n+                && (registry.contains(pair) || registry.contains(swappedPair));\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object pair.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     *\n+     * @param lhs <code>this</code> object to register\n+     * @param rhs the other object to register\n+     */\n+    static void register(Object lhs, Object rhs) {\n+        synchronized (EqualsBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\n+            }\n+        }\n+\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        registry.add(pair);\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object pair.\n+     * </p>\n+     *\n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     *\n+     * @param lhs <code>this</code> object to unregister\n+     * @param rhs the other object to unregister\n+     * @since 3.0\n+     */\n+    static void unregister(Object lhs, Object rhs) {\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        if (registry != null) {\n+            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+            registry.remove(pair);\n+            synchronized (EqualsBuilder.class) {\n+                //read again\n+                registry = getRegistry();\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * If the fields tested are equals.\n+     * The default value is <code>true</code>.\n+     */\n+    private boolean isEquals = true;\n+\n+    /**\n+     * <p>Constructor for EqualsBuilder.</p>\n+     *\n+     * <p>Starts off assuming that equals is <code>true</code>.</p>\n+     * @see Object#equals(Object)\n+     */\n+    public EqualsBuilder() {\n+        // do nothing for now.\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n+            String... excludeFields) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        Class<?> lhsClass = lhs.getClass();\n+        Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            return false;\n+        }\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given Class.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class<?> clazz,\n+        EqualsBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+\n+        if (isRegistered(lhs, rhs)) {\n+            return;\n+        }\n+\n+        try {\n+            register(lhs, rhs);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+                Field f = fields[i];\n+                if (!ArrayUtils.contains(excludeFields, f.getName())\n+                    && (f.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                    && (!Modifier.isStatic(f.getModifiers()))) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(lhs, rhs);\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n+     *\n+     * @param superEquals  the result of calling <code>super.equals()</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     * @since 2.0\n+     */\n+    public EqualsBuilder appendSuper(boolean superEquals) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = superEquals;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Test if two <code>Object</code>s are equal using their\n+     * <code>equals</code> method.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        Class<?> lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            // The simple case, not an array, just test the element\n+            isEquals = lhs.equals(rhs);\n+        } else if (lhs.getClass() != rhs.getClass()) {\n+            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\n+            this.setEquals(false);\n+        }\n+        // 'Switch' on type of array, to dispatch to the correct handler\n+        // This handles multi dimensional arrays of the same depth\n+        else if (lhs instanceof long[]) {\n+            append((long[]) lhs, (long[]) rhs);\n+        } else if (lhs instanceof int[]) {\n+            append((int[]) lhs, (int[]) rhs);\n+        } else if (lhs instanceof short[]) {\n+            append((short[]) lhs, (short[]) rhs);\n+        } else if (lhs instanceof char[]) {\n+            append((char[]) lhs, (char[]) rhs);\n+        } else if (lhs instanceof byte[]) {\n+            append((byte[]) lhs, (byte[]) rhs);\n+        } else if (lhs instanceof double[]) {\n+            append((double[]) lhs, (double[]) rhs);\n+        } else if (lhs instanceof float[]) {\n+            append((float[]) lhs, (float[]) rhs);\n+        } else if (lhs instanceof boolean[]) {\n+            append((boolean[]) lhs, (boolean[]) rhs);\n+        } else {\n+            // Not an array of primitives\n+            append((Object[]) lhs, (Object[]) rhs);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Test if two <code>long</code> s are equal.\n+     * </p>\n+     *\n+     * @param lhs\n+     *                  the left hand <code>long</code>\n+     * @param rhs\n+     *                  the right hand <code>long</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>int</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>int</code>\n+     * @param rhs  the right hand <code>int</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>short</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>short</code>\n+     * @param rhs  the right hand <code>short</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>char</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>char</code>\n+     * @param rhs  the right hand <code>char</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>byte</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>byte</code>\n+     * @param rhs  the right hand <code>byte</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>double</code>s are equal by testing that the\n+     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>double</code>\n+     * @param rhs  the right hand <code>double</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>float</code>s are equal byt testing that the\n+     * pattern of bits returned by doubleToLong are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>float</code>\n+     * @param rhs  the right hand <code>float</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>booleans</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean</code>\n+     * @param rhs  the right hand <code>boolean</code>\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n+     *\n+     * <p>This also will be called for the top level of\n+     * multi-dimensional, ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  the left hand <code>Object[]</code>\n+     * @param rhs  the right hand <code>Object[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>long</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(long, long)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>long[]</code>\n+     * @param rhs  the right hand <code>long[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>int</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(int, int)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>int[]</code>\n+     * @param rhs  the right hand <code>int[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>short</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(short, short)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>short[]</code>\n+     * @param rhs  the right hand <code>short[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>char</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(char, char)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>char[]</code>\n+     * @param rhs  the right hand <code>char[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>byte</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(byte, byte)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>byte[]</code>\n+     * @param rhs  the right hand <code>byte[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>double</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(double, double)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>double[]</code>\n+     * @param rhs  the right hand <code>double[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>float</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(float, float)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>float[]</code>\n+     * @param rhs  the right hand <code>float[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean[]</code>\n+     * @param rhs  the right hand <code>boolean[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return this.isEquals;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return <code>true</code> if all of the fields that have been checked\n+     *         are equal, <code>false</code> otherwise.\n+     *\n+     * @since 3.0\n+     */\n+    public Boolean build() {\n+        return Boolean.valueOf(isEquals());\n+    }\n+\n+    /**\n+     * Sets the <code>isEquals</code> value.\n+     *\n+     * @param isEquals The value to set.\n+     * @since 2.1\n+     */\n+    protected void setEquals(boolean isEquals) {\n+        this.isEquals = isEquals;\n+    }\n+\n+    /**\n+     * Reset the EqualsBuilder so you can use the same object again\n+     * @since 2.5\n+     */\n+    public void reset() {\n+        this.isEquals = true;\n+    }\n+}\n",
            "diff_size": 959
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "481",
                    "column": "5",
                    "severity": "warning",
                    "message": "'}' at column 5 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/57/EqualsBuilder.java\nindex f02aebb379..32a2fbfe4e 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/57/EqualsBuilder.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -29,6 +29,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n \r\n import java.lang.reflect.AccessibleObject;\r\n@@ -97,863 +98,863 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.tuple.\n  */\r\n public class EqualsBuilder implements Builder<Boolean> {\r\n \r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of object pairs being traversed by the reflection\r\n-     * methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 3.0\r\n-     */\r\n-    static Set<Pair<IDKey, IDKey>> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Converters value pair into a register pair.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object\r\n-     * @param rhs the other object\r\n-     *\r\n-     * @return the pair\r\n-     */\r\n-    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\r\n-        IDKey left = new IDKey(lhs);\r\n-        IDKey right = new IDKey(rhs);\r\n-        return Pair.of(left, right);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * Objects might be swapped therefore a check is needed if the object pair\r\n-     * is registered in given or swapped order.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to lookup in registry\r\n-     * @param rhs the other object to lookup on registry\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 3.0\r\n-     */\r\n-    static boolean isRegistered(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n-\r\n-        return registry != null\r\n-                && (registry.contains(pair) || registry.contains(swappedPair));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to register\r\n-     * @param rhs the other object to register\r\n-     */\r\n-    static void register(Object lhs, Object rhs) {\r\n-        synchronized (EqualsBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\r\n-            }\r\n-        }\r\n-\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        registry.add(pair);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object pair.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param lhs <code>this</code> object to unregister\r\n-     * @param rhs the other object to unregister\r\n-     * @since 3.0\r\n-     */\r\n-    static void unregister(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-            registry.remove(pair);\r\n-            synchronized (EqualsBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * If the fields tested are equals.\r\n-     * The default value is <code>true</code>.\r\n-     */\r\n-    private boolean isEquals = true;\r\n-\r\n-    /**\r\n-     * <p>Constructor for EqualsBuilder.</p>\r\n-     *\r\n-     * <p>Starts off assuming that equals is <code>true</code>.</p>\r\n-     * @see Object#equals(Object)\r\n-     */\r\n-    public EqualsBuilder() {\r\n-        // do nothing for now.\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  Collection of String field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the TestTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\r\n-        return reflectionEquals(lhs, rhs, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the testTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be included. Superclass fields will be appended\r\n-     * up to and including the specified superclass. A null superclass is treated\r\n-     * as java.lang.Object.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\r\n-     *  may be <code>null</code>\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     * @since 2.0\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n-            String... excludeFields) {\r\n-        if (lhs == rhs) {\r\n-            return true;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            return false;\r\n-        }\r\n-        // Find the leaf class since there may be transients in the leaf\r\n-        // class or in classes between the leaf and root.\r\n-        // If we are not testing transients or a subclass has no ivars,\r\n-        // then a subclass can test equals to a superclass.\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        Class<?> rhsClass = rhs.getClass();\r\n-        Class<?> testClass;\r\n-        if (lhsClass.isInstance(rhs)) {\r\n-            testClass = lhsClass;\r\n-            if (!rhsClass.isInstance(lhs)) {\r\n-                // rhsClass is a subclass of lhsClass\r\n-                testClass = rhsClass;\r\n-            }\r\n-        } else if (rhsClass.isInstance(lhs)) {\r\n-            testClass = rhsClass;\r\n-            if (!lhsClass.isInstance(rhs)) {\r\n-                // lhsClass is a subclass of rhsClass\r\n-                testClass = lhsClass;\r\n-            }\r\n-        } else {\r\n-            // The two classes are not related.\r\n-            return false;\r\n-        }\r\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n-        try {\r\n-            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n-                testClass = testClass.getSuperclass();\r\n-                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            }\r\n-        } catch (IllegalArgumentException e) {\r\n-            // In this case, we tried to test a subclass vs. a superclass and\r\n-            // the subclass has ivars or the ivars are transient and\r\n-            // we are testing transients.\r\n-            // If a subclass has ivars that we are trying to test them, we get an\r\n-            // exception and we know that the objects are not equal.\r\n-            return false;\r\n-        }\r\n-        return equalsBuilder.isEquals();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Appends the fields and values defined by the given object of the\r\n-     * given Class.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @param clazz  the class to append details of\r\n-     * @param builder  the builder to append to\r\n-     * @param useTransients  whether to test transient fields\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     */\r\n-    private static void reflectionAppend(\r\n-        Object lhs,\r\n-        Object rhs,\r\n-        Class<?> clazz,\r\n-        EqualsBuilder builder,\r\n-        boolean useTransients,\r\n-        String[] excludeFields) {\r\n-\r\n-        if (isRegistered(lhs, rhs)) {\r\n-            return;\r\n-        }\r\n-\r\n-        try {\r\n-            register(lhs, rhs);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n-                Field f = fields[i];\r\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\r\n-                    && (f.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\r\n-                    try {\r\n-                        builder.append(f.get(lhs), f.get(rhs));\r\n-                    } catch (IllegalAccessException e) {\r\n-                        //this can't happen. Would get a Security exception instead\r\n-                        //throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(lhs, rhs);\r\n-        }\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\r\n-     *\r\n-     * @param superEquals  the result of calling <code>super.equals()</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public EqualsBuilder appendSuper(boolean superEquals) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = superEquals;\r\n-        return this;\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>Object</code>s are equal using their\r\n-     * <code>equals</code> method.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object lhs, Object rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        if (!lhsClass.isArray()) {\r\n-            // The simple case, not an array, just test the element\r\n-            isEquals = lhs.equals(rhs);\r\n-        } else if (lhs.getClass() != rhs.getClass()) {\r\n-            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n-            this.setEquals(false);\r\n-        }\r\n-        // 'Switch' on type of array, to dispatch to the correct handler\r\n-        // This handles multi dimensional arrays of the same depth\r\n-        else if (lhs instanceof long[]) {\r\n-            append((long[]) lhs, (long[]) rhs);\r\n-        } else if (lhs instanceof int[]) {\r\n-            append((int[]) lhs, (int[]) rhs);\r\n-        } else if (lhs instanceof short[]) {\r\n-            append((short[]) lhs, (short[]) rhs);\r\n-        } else if (lhs instanceof char[]) {\r\n-            append((char[]) lhs, (char[]) rhs);\r\n-        } else if (lhs instanceof byte[]) {\r\n-            append((byte[]) lhs, (byte[]) rhs);\r\n-        } else if (lhs instanceof double[]) {\r\n-            append((double[]) lhs, (double[]) rhs);\r\n-        } else if (lhs instanceof float[]) {\r\n-            append((float[]) lhs, (float[]) rhs);\r\n-        } else if (lhs instanceof boolean[]) {\r\n-            append((boolean[]) lhs, (boolean[]) rhs);\r\n-        } else {\r\n-            // Not an array of primitives\r\n-            append((Object[]) lhs, (Object[]) rhs);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Test if two <code>long</code> s are equal.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs\r\n-     *                  the left hand <code>long</code>\r\n-     * @param rhs\r\n-     *                  the right hand <code>long</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long lhs, long rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>int</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int</code>\r\n-     * @param rhs  the right hand <code>int</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int lhs, int rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>short</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short</code>\r\n-     * @param rhs  the right hand <code>short</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short lhs, short rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>char</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char</code>\r\n-     * @param rhs  the right hand <code>char</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char lhs, char rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>byte</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte</code>\r\n-     * @param rhs  the right hand <code>byte</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte lhs, byte rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>double</code>s are equal by testing that the\r\n-     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double</code>\r\n-     * @param rhs  the right hand <code>double</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double lhs, double rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>float</code>s are equal byt testing that the\r\n-     * pattern of bits returned by doubleToLong are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float</code>\r\n-     * @param rhs  the right hand <code>float</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float lhs, float rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>booleans</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean</code>\r\n-     * @param rhs  the right hand <code>boolean</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-      */\r\n-    public EqualsBuilder append(boolean lhs, boolean rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\r\n-     *\r\n-     * <p>This also will be called for the top level of\r\n-     * multi-dimensional, ragged, and multi-typed arrays.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>Object[]</code>\r\n-     * @param rhs  the right hand <code>Object[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>long</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(long, long)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>long[]</code>\r\n-     * @param rhs  the right hand <code>long[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long[] lhs, long[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>int</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(int, int)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int[]</code>\r\n-     * @param rhs  the right hand <code>int[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int[] lhs, int[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>short</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(short, short)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short[]</code>\r\n-     * @param rhs  the right hand <code>short[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short[] lhs, short[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>char</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(char, char)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char[]</code>\r\n-     * @param rhs  the right hand <code>char[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char[] lhs, char[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>byte</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(byte, byte)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte[]</code>\r\n-     * @param rhs  the right hand <code>byte[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>double</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(double, double)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double[]</code>\r\n-     * @param rhs  the right hand <code>double[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double[] lhs, double[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>float</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(float, float)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float[]</code>\r\n-     * @param rhs  the right hand <code>float[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float[] lhs, float[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>boolean</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(boolean, boolean)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean[]</code>\r\n-     * @param rhs  the right hand <code>boolean[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return boolean\r\n-     */\r\n-    public boolean isEquals() {\r\n-        return this.isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return <code>true</code> if all of the fields that have been checked\r\n-     *         are equal, <code>false</code> otherwise.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Boolean build() {\r\n-        return Boolean.valueOf(isEquals());\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the <code>isEquals</code> value.\r\n-     *\r\n-     * @param isEquals The value to set.\r\n-     * @since 2.1\r\n-     */\r\n-    protected void setEquals(boolean isEquals) {\r\n-        this.isEquals = isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reset the EqualsBuilder so you can use the same object again\r\n-     * @since 2.5\r\n-     */\r\n-    public void reset() {\r\n-        this.isEquals = true;\r\n-    }\r\n+  /**\r\n+   * <p>\r\n+   * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @since 3.0\r\n+   */\r\n+  private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n+\r\n+  /*\r\n+   * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n+   * we are in the process of calculating.\r\n+   *\r\n+   * So we generate a one-to-one mapping from the original object to a new object.\r\n+   *\r\n+   * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n+   * are equal, so we also need to ensure that the replacement objects are only equal\r\n+   * if the original objects are identical.\r\n+   *\r\n+   * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n+   * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n+   *\r\n+   * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n+   * to disambiguate the duplicate ids.\r\n+   */\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns the registry of object pairs being traversed by the reflection\r\n+   * methods in the current thread.\r\n+   * </p>\r\n+   *\r\n+   * @return Set the registry of objects being traversed\r\n+   * @since 3.0\r\n+   */\r\n+  static Set<Pair<IDKey, IDKey>> getRegistry() {\r\n+    return REGISTRY.get();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Converters value pair into a register pair.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs <code>this</code> object\r\n+   * @param rhs the other object\r\n+   *\r\n+   * @return the pair\r\n+   */\r\n+  static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\r\n+    IDKey left = new IDKey(lhs);\r\n+    IDKey right = new IDKey(rhs);\r\n+    return Pair.of(left, right);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns <code>true</code> if the registry contains the given object pair.\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   * Objects might be swapped therefore a check is needed if the object pair\r\n+   * is registered in given or swapped order.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs <code>this</code> object to lookup in registry\r\n+   * @param rhs the other object to lookup on registry\r\n+   * @return boolean <code>true</code> if the registry contains the given object.\r\n+   * @since 3.0\r\n+   */\r\n+  static boolean isRegistered(Object lhs, Object rhs) {\r\n+    Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n+    Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n+    Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n+\r\n+    return registry != null\r\n+      && (registry.contains(pair) || registry.contains(swappedPair));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Registers the given object pair.\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs <code>this</code> object to register\r\n+   * @param rhs the other object to register\r\n+   */\r\n+  static void register(Object lhs, Object rhs) {\r\n+    synchronized (EqualsBuilder.class) {\r\n+      if (getRegistry() == null) {\r\n+        REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\r\n+      }\r\n+    }\r\n+\r\n+    Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n+    Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n+    registry.add(pair);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Unregisters the given object pair.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   *\r\n+   * @param lhs <code>this</code> object to unregister\r\n+   * @param rhs the other object to unregister\r\n+   * @since 3.0\r\n+   */\r\n+  static void unregister(Object lhs, Object rhs) {\r\n+    Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n+    if (registry != null) {\r\n+      Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n+      registry.remove(pair);\r\n+      synchronized (EqualsBuilder.class) {\r\n+        //read again\r\n+        registry = getRegistry();\r\n+        if (registry != null && registry.isEmpty()) {\r\n+          REGISTRY.remove();\r\n+        }\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * If the fields tested are equals.\r\n+   * The default value is <code>true</code>.\r\n+   */\r\n+  private boolean isEquals = true;\r\n+\r\n+  /**\r\n+   * <p>Constructor for EqualsBuilder.</p>\r\n+   *\r\n+   * <p>Starts off assuming that equals is <code>true</code>.</p>\r\n+   * @see Object#equals(Object)\r\n+   */\r\n+  public EqualsBuilder() {\r\n+    // do nothing for now.\r\n+  }\r\n+\r\n+  //-------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>Transient members will be not be tested, as they are likely derived\r\n+   * fields, and not part of the value of the Object.</p>\r\n+   *\r\n+   * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param excludeFields  Collection of String field names to exclude from testing\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\r\n+    return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>Transient members will be not be tested, as they are likely derived\r\n+   * fields, and not part of the value of the Object.</p>\r\n+   *\r\n+   * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param excludeFields  array of field names to exclude from testing\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\r\n+    return reflectionEquals(lhs, rhs, false, null, excludeFields);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>If the TestTransients parameter is set to <code>true</code>, transient\r\n+   * members will be tested, otherwise they are ignored, as they are likely\r\n+   * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n+   *\r\n+   * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param testTransients  whether to include transient fields\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\r\n+    return reflectionEquals(lhs, rhs, testTransients, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>If the testTransients parameter is set to <code>true</code>, transient\r\n+   * members will be tested, otherwise they are ignored, as they are likely\r\n+   * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n+   *\r\n+   * <p>Static fields will not be included. Superclass fields will be appended\r\n+   * up to and including the specified superclass. A null superclass is treated\r\n+   * as java.lang.Object.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param testTransients  whether to include transient fields\r\n+   * @param reflectUpToClass  the superclass to reflect up to (inclusive),\r\n+   *  may be <code>null</code>\r\n+   * @param excludeFields  array of field names to exclude from testing\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   * @since 2.0\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n+                                         String... excludeFields) {\r\n+    if (lhs == rhs) {\r\n+      return true;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      return false;\r\n+    }\r\n+    // Find the leaf class since there may be transients in the leaf\r\n+    // class or in classes between the leaf and root.\r\n+    // If we are not testing transients or a subclass has no ivars,\r\n+    // then a subclass can test equals to a superclass.\r\n+    Class<?> lhsClass = lhs.getClass();\r\n+    Class<?> rhsClass = rhs.getClass();\r\n+    Class<?> testClass;\r\n+    if (lhsClass.isInstance(rhs)) {\r\n+      testClass = lhsClass;\r\n+      if (!rhsClass.isInstance(lhs)) {\r\n+        // rhsClass is a subclass of lhsClass\r\n+        testClass = rhsClass;\r\n+      }\r\n+    } else if (rhsClass.isInstance(lhs)) {\r\n+      testClass = rhsClass;\r\n+      if (!lhsClass.isInstance(rhs)) {\r\n+        // lhsClass is a subclass of rhsClass\r\n+        testClass = lhsClass;\r\n+      }\r\n+    } else {\r\n+      // The two classes are not related.\r\n+      return false;\r\n+    }\r\n+    EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n+    try {\r\n+      reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n+      while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n+        testClass = testClass.getSuperclass();\r\n+        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n+      }\r\n+    } catch (IllegalArgumentException e) {\r\n+      // In this case, we tried to test a subclass vs. a superclass and\r\n+      // the subclass has ivars or the ivars are transient and\r\n+      // we are testing transients.\r\n+      // If a subclass has ivars that we are trying to test them, we get an\r\n+      // exception and we know that the objects are not equal.\r\n+      return false;\r\n+    }\r\n+    return equalsBuilder.isEquals();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Appends the fields and values defined by the given object of the\r\n+   * given Class.</p>\r\n+   *\r\n+   * @param lhs  the left hand object\r\n+   * @param rhs  the right hand object\r\n+   * @param clazz  the class to append details of\r\n+   * @param builder  the builder to append to\r\n+   * @param useTransients  whether to test transient fields\r\n+   * @param excludeFields  array of field names to exclude from testing\r\n+   */\r\n+  private static void reflectionAppend(\r\n+    Object lhs,\r\n+    Object rhs,\r\n+    Class<?> clazz,\r\n+    EqualsBuilder builder,\r\n+    boolean useTransients,\r\n+    String[] excludeFields) {\r\n+\r\n+    if (isRegistered(lhs, rhs)) {\r\n+      return;\r\n+    }\r\n+\r\n+    try {\r\n+      register(lhs, rhs);\r\n+      Field[] fields = clazz.getDeclaredFields();\r\n+      AccessibleObject.setAccessible(fields, true);\r\n+      for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n+        Field f = fields[i];\r\n+        if (!ArrayUtils.contains(excludeFields, f.getName())\r\n+          && (f.getName().indexOf('$') == -1)\r\n+          && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n+          && (!Modifier.isStatic(f.getModifiers()))) {\r\n+          try {\r\n+            builder.append(f.get(lhs), f.get(rhs));\r\n+          } catch (IllegalAccessException e) {\r\n+            //this can't happen. Would get a Security exception instead\r\n+            //throw a runtime exception in case the impossible happens.\r\n+            throw new InternalError(\"Unexpected IllegalAccessException\");\r\n+          }\r\n+        }\r\n+      }\r\n+    } finally {\r\n+      unregister(lhs, rhs);\r\n+    }\r\n+  }\r\n+\r\n+  //-------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\r\n+   *\r\n+   * @param superEquals  the result of calling <code>super.equals()</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   * @since 2.0\r\n+   */\r\n+  public EqualsBuilder appendSuper(boolean superEquals) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = superEquals;\r\n+    return this;\r\n+  }\r\n+\r\n+  //-------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>Object</code>s are equal using their\r\n+   * <code>equals</code> method.</p>\r\n+   *\r\n+   * @param lhs  the left hand object\r\n+   * @param rhs  the right hand object\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(Object lhs, Object rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    Class<?> lhsClass = lhs.getClass();\r\n+    if (!lhsClass.isArray()) {\r\n+      // The simple case, not an array, just test the element\r\n+      isEquals = lhs.equals(rhs);\r\n+    } else if (lhs.getClass() != rhs.getClass()) {\r\n+      // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n+      this.setEquals(false);\r\n+    }\r\n+    // 'Switch' on type of array, to dispatch to the correct handler\r\n+    // This handles multi dimensional arrays of the same depth\r\n+    else if (lhs instanceof long[]) {\r\n+      append((long[]) lhs, (long[]) rhs);\r\n+    } else if (lhs instanceof int[]) {\r\n+      append((int[]) lhs, (int[]) rhs);\r\n+    } else if (lhs instanceof short[]) {\r\n+      append((short[]) lhs, (short[]) rhs);\r\n+    } else if (lhs instanceof char[]) {\r\n+      append((char[]) lhs, (char[]) rhs);\r\n+    } else if (lhs instanceof byte[]) {\r\n+      append((byte[]) lhs, (byte[]) rhs);\r\n+    } else if (lhs instanceof double[]) {\r\n+      append((double[]) lhs, (double[]) rhs);\r\n+    } else if (lhs instanceof float[]) {\r\n+      append((float[]) lhs, (float[]) rhs);\r\n+    } else if (lhs instanceof boolean[]) {\r\n+      append((boolean[]) lhs, (boolean[]) rhs);\r\n+    } else {\r\n+      // Not an array of primitives\r\n+      append((Object[]) lhs, (Object[]) rhs);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Test if two <code>long</code> s are equal.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs\r\n+   *                  the left hand <code>long</code>\r\n+   * @param rhs\r\n+   *                  the right hand <code>long</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(long lhs, long rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>int</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>int</code>\r\n+   * @param rhs  the right hand <code>int</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(int lhs, int rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>short</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>short</code>\r\n+   * @param rhs  the right hand <code>short</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(short lhs, short rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>char</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>char</code>\r\n+   * @param rhs  the right hand <code>char</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(char lhs, char rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>byte</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>byte</code>\r\n+   * @param rhs  the right hand <code>byte</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(byte lhs, byte rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>double</code>s are equal by testing that the\r\n+   * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\r\n+   *\r\n+   * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n+   *\r\n+   * <p>It is compatible with the hash code generated by\r\n+   * <code>HashCodeBuilder</code>.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>double</code>\r\n+   * @param rhs  the right hand <code>double</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(double lhs, double rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>float</code>s are equal byt testing that the\r\n+   * pattern of bits returned by doubleToLong are equal.</p>\r\n+   *\r\n+   * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n+   *\r\n+   * <p>It is compatible with the hash code generated by\r\n+   * <code>HashCodeBuilder</code>.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>float</code>\r\n+   * @param rhs  the right hand <code>float</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(float lhs, float rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>booleans</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>boolean</code>\r\n+   * @param rhs  the right hand <code>boolean</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(boolean lhs, boolean rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\r\n+   *\r\n+   * <p>This also will be called for the top level of\r\n+   * multi-dimensional, ragged, and multi-typed arrays.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>Object[]</code>\r\n+   * @param rhs  the right hand <code>Object[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(Object[] lhs, Object[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>long</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(long, long)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>long[]</code>\r\n+   * @param rhs  the right hand <code>long[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(long[] lhs, long[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>int</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(int, int)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>int[]</code>\r\n+   * @param rhs  the right hand <code>int[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(int[] lhs, int[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>short</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(short, short)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>short[]</code>\r\n+   * @param rhs  the right hand <code>short[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(short[] lhs, short[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>char</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(char, char)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>char[]</code>\r\n+   * @param rhs  the right hand <code>char[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(char[] lhs, char[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>byte</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(byte, byte)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>byte[]</code>\r\n+   * @param rhs  the right hand <code>byte[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(byte[] lhs, byte[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>double</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(double, double)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>double[]</code>\r\n+   * @param rhs  the right hand <code>double[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(double[] lhs, double[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>float</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(float, float)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>float[]</code>\r\n+   * @param rhs  the right hand <code>float[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(float[] lhs, float[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>boolean</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(boolean, boolean)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>boolean[]</code>\r\n+   * @param rhs  the right hand <code>boolean[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Returns <code>true</code> if the fields that have been checked\r\n+   * are all equal.</p>\r\n+   *\r\n+   * @return boolean\r\n+   */\r\n+  public boolean isEquals() {\r\n+    return this.isEquals;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Returns <code>true</code> if the fields that have been checked\r\n+   * are all equal.</p>\r\n+   *\r\n+   * @return <code>true</code> if all of the fields that have been checked\r\n+   *         are equal, <code>false</code> otherwise.\r\n+   *\r\n+   * @since 3.0\r\n+   */\r\n+  public Boolean build() {\r\n+    return Boolean.valueOf(isEquals());\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets the <code>isEquals</code> value.\r\n+   *\r\n+   * @param isEquals The value to set.\r\n+   * @since 2.1\r\n+   */\r\n+  protected void setEquals(boolean isEquals) {\r\n+    this.isEquals = isEquals;\r\n+  }\r\n+\r\n+  /**\r\n+   * Reset the EqualsBuilder so you can use the same object again\r\n+   * @since 2.5\r\n+   */\r\n+  public void reset() {\r\n+    this.isEquals = true;\r\n+  }\r\n }\r\n",
            "diff_size": 864
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "107",
                    "column": "60",
                    "severity": "warning",
                    "message": "'>' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "414",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 211).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "474",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/57/EqualsBuilder.java\nindex f02aebb379..a673c1c0cd 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/57/EqualsBuilder.java\n@@ -104,7 +104,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n      *\r\n      * @since 3.0\r\n      */\r\n-    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n+    private static final ThreadLocal<Set<Pair<IDKey, IDKey >>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n \r\n     /*\r\n      * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n@@ -170,8 +170,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n         Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n         Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n \r\n-        return registry != null\r\n-                && (registry.contains(pair) || registry.contains(swappedPair));\r\n+        return registry != null && (registry.contains(pair) || registry.contains(swappedPair));\r\n     }\r\n \r\n     /**\r\n@@ -336,8 +335,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n      * @return <code>true</code> if the two Objects have tested equals.\r\n      * @since 2.0\r\n      */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n-            String... excludeFields) {\r\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass, String... excludeFields) {\r\n         if (lhs == rhs) {\r\n             return true;\r\n         }\r\n@@ -402,9 +400,8 @@ public class EqualsBuilder implements Builder<Boolean> {\n         Class<?> clazz,\r\n         EqualsBuilder builder,\r\n         boolean useTransients,\r\n-        String[] excludeFields) {\r\n-\r\n-        if (isRegistered(lhs, rhs)) {\r\n+        String[] excludeFields) {\n+    if (isRegistered(lhs, rhs)) {\r\n             return;\r\n         }\r\n \r\n@@ -414,11 +411,8 @@ public class EqualsBuilder implements Builder<Boolean> {\n             AccessibleObject.setAccessible(fields, true);\r\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n                 Field f = fields[i];\r\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\r\n-                    && (f.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\r\n-                    try {\r\n+                if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) {\n+    try {\r\n                         builder.append(f.get(lhs), f.get(rhs));\r\n                     } catch (IllegalAccessException e) {\r\n                         //this can't happen. Would get a Security exception instead\r\n@@ -956,4 +950,4 @@ public class EqualsBuilder implements Builder<Boolean> {\n     public void reset() {\r\n         this.isEquals = true;\r\n     }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 14
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "480",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/57/EqualsBuilder.java\nindex f02aebb379..ace5cea4d8 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/57/EqualsBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/57/EqualsBuilder.java\n@@ -1,959 +1,959 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.tuple.Pair;\r\n-\r\n-/**\r\n- * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\r\n- *\r\n- * <p> This class provides methods to build a good equals method for any\r\n- * class. It follows rules laid out in\r\n- * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\r\n- * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\r\n- * <code>floats</code>, and arrays can be tricky. Also, making sure that\r\n- * <code>equals()</code> and <code>hashCode()</code> are consistent can be\r\n- * difficult.</p>\r\n- *\r\n- * <p>Two Objects that compare as equals must generate the same hash code,\r\n- * but two Objects with the same hash code do not have to be equal.</p>\r\n- *\r\n- * <p>All relevant fields should be included in the calculation of equals.\r\n- * Derived fields may be ignored. In particular, any field used in\r\n- * generating a hash code must be used in the equals method, and vice\r\n- * versa.</p>\r\n- *\r\n- * <p>Typical use for the code is as follows:</p>\r\n- * <pre>\r\n- * public boolean equals(Object obj) {\r\n- *   if (obj == null) { return false; }\r\n- *   if (obj == this) { return true; }\r\n- *   if (obj.getClass() != getClass()) {\r\n- *     return false;\r\n- *   }\r\n- *   MyClass rhs = (MyClass) obj;\r\n- *   return new EqualsBuilder()\r\n- *                 .appendSuper(super.equals(obj))\r\n- *                 .append(field1, rhs.field1)\r\n- *                 .append(field2, rhs.field2)\r\n- *                 .append(field3, rhs.field3)\r\n- *                 .isEquals();\r\n- *  }\r\n- * </pre>\r\n- *\r\n- * <p> Alternatively, there is a method that uses reflection to determine\r\n- * the fields to test. Because these fields are usually private, the method,\r\n- * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\r\n- * change the visibility of the fields. This will fail under a security\r\n- * manager, unless the appropriate permissions are set up correctly. It is\r\n- * also slower than testing explicitly.</p>\r\n- *\r\n- * <p> A typical invocation for this method would look like:</p>\r\n- * <pre>\r\n- * public boolean equals(Object obj) {\r\n- *   return EqualsBuilder.reflectionEquals(this, obj);\r\n- * }\r\n- * </pre>\r\n- *\r\n- * @since 1.0\r\n- * @version $Id: EqualsBuilder.java 1091531 2011-04-12 18:29:49Z ggregory $\r\n- */\r\n-public class EqualsBuilder implements Builder<Boolean> {\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of object pairs being traversed by the reflection\r\n-     * methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 3.0\r\n-     */\r\n-    static Set<Pair<IDKey, IDKey>> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Converters value pair into a register pair.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object\r\n-     * @param rhs the other object\r\n-     *\r\n-     * @return the pair\r\n-     */\r\n-    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\r\n-        IDKey left = new IDKey(lhs);\r\n-        IDKey right = new IDKey(rhs);\r\n-        return Pair.of(left, right);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * Objects might be swapped therefore a check is needed if the object pair\r\n-     * is registered in given or swapped order.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to lookup in registry\r\n-     * @param rhs the other object to lookup on registry\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 3.0\r\n-     */\r\n-    static boolean isRegistered(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n-\r\n-        return registry != null\r\n-                && (registry.contains(pair) || registry.contains(swappedPair));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to register\r\n-     * @param rhs the other object to register\r\n-     */\r\n-    static void register(Object lhs, Object rhs) {\r\n-        synchronized (EqualsBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\r\n-            }\r\n-        }\r\n-\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        registry.add(pair);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object pair.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param lhs <code>this</code> object to unregister\r\n-     * @param rhs the other object to unregister\r\n-     * @since 3.0\r\n-     */\r\n-    static void unregister(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-            registry.remove(pair);\r\n-            synchronized (EqualsBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * If the fields tested are equals.\r\n-     * The default value is <code>true</code>.\r\n-     */\r\n-    private boolean isEquals = true;\r\n-\r\n-    /**\r\n-     * <p>Constructor for EqualsBuilder.</p>\r\n-     *\r\n-     * <p>Starts off assuming that equals is <code>true</code>.</p>\r\n-     * @see Object#equals(Object)\r\n-     */\r\n-    public EqualsBuilder() {\r\n-        // do nothing for now.\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  Collection of String field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the TestTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\r\n-        return reflectionEquals(lhs, rhs, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the testTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be included. Superclass fields will be appended\r\n-     * up to and including the specified superclass. A null superclass is treated\r\n-     * as java.lang.Object.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\r\n-     *  may be <code>null</code>\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     * @since 2.0\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n-            String... excludeFields) {\r\n-        if (lhs == rhs) {\r\n-            return true;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            return false;\r\n-        }\r\n-        // Find the leaf class since there may be transients in the leaf\r\n-        // class or in classes between the leaf and root.\r\n-        // If we are not testing transients or a subclass has no ivars,\r\n-        // then a subclass can test equals to a superclass.\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        Class<?> rhsClass = rhs.getClass();\r\n-        Class<?> testClass;\r\n-        if (lhsClass.isInstance(rhs)) {\r\n-            testClass = lhsClass;\r\n-            if (!rhsClass.isInstance(lhs)) {\r\n-                // rhsClass is a subclass of lhsClass\r\n-                testClass = rhsClass;\r\n-            }\r\n-        } else if (rhsClass.isInstance(lhs)) {\r\n-            testClass = rhsClass;\r\n-            if (!lhsClass.isInstance(rhs)) {\r\n-                // lhsClass is a subclass of rhsClass\r\n-                testClass = lhsClass;\r\n-            }\r\n-        } else {\r\n-            // The two classes are not related.\r\n-            return false;\r\n-        }\r\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n-        try {\r\n-            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n-                testClass = testClass.getSuperclass();\r\n-                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            }\r\n-        } catch (IllegalArgumentException e) {\r\n-            // In this case, we tried to test a subclass vs. a superclass and\r\n-            // the subclass has ivars or the ivars are transient and\r\n-            // we are testing transients.\r\n-            // If a subclass has ivars that we are trying to test them, we get an\r\n-            // exception and we know that the objects are not equal.\r\n-            return false;\r\n-        }\r\n-        return equalsBuilder.isEquals();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Appends the fields and values defined by the given object of the\r\n-     * given Class.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @param clazz  the class to append details of\r\n-     * @param builder  the builder to append to\r\n-     * @param useTransients  whether to test transient fields\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     */\r\n-    private static void reflectionAppend(\r\n-        Object lhs,\r\n-        Object rhs,\r\n-        Class<?> clazz,\r\n-        EqualsBuilder builder,\r\n-        boolean useTransients,\r\n-        String[] excludeFields) {\r\n-\r\n-        if (isRegistered(lhs, rhs)) {\r\n-            return;\r\n-        }\r\n-\r\n-        try {\r\n-            register(lhs, rhs);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n-                Field f = fields[i];\r\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\r\n-                    && (f.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\r\n-                    try {\r\n-                        builder.append(f.get(lhs), f.get(rhs));\r\n-                    } catch (IllegalAccessException e) {\r\n-                        //this can't happen. Would get a Security exception instead\r\n-                        //throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(lhs, rhs);\r\n-        }\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\r\n-     *\r\n-     * @param superEquals  the result of calling <code>super.equals()</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public EqualsBuilder appendSuper(boolean superEquals) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = superEquals;\r\n-        return this;\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>Object</code>s are equal using their\r\n-     * <code>equals</code> method.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object lhs, Object rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        if (!lhsClass.isArray()) {\r\n-            // The simple case, not an array, just test the element\r\n-            isEquals = lhs.equals(rhs);\r\n-        } else if (lhs.getClass() != rhs.getClass()) {\r\n-            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n-            this.setEquals(false);\r\n-        }\r\n-        // 'Switch' on type of array, to dispatch to the correct handler\r\n-        // This handles multi dimensional arrays of the same depth\r\n-        else if (lhs instanceof long[]) {\r\n-            append((long[]) lhs, (long[]) rhs);\r\n-        } else if (lhs instanceof int[]) {\r\n-            append((int[]) lhs, (int[]) rhs);\r\n-        } else if (lhs instanceof short[]) {\r\n-            append((short[]) lhs, (short[]) rhs);\r\n-        } else if (lhs instanceof char[]) {\r\n-            append((char[]) lhs, (char[]) rhs);\r\n-        } else if (lhs instanceof byte[]) {\r\n-            append((byte[]) lhs, (byte[]) rhs);\r\n-        } else if (lhs instanceof double[]) {\r\n-            append((double[]) lhs, (double[]) rhs);\r\n-        } else if (lhs instanceof float[]) {\r\n-            append((float[]) lhs, (float[]) rhs);\r\n-        } else if (lhs instanceof boolean[]) {\r\n-            append((boolean[]) lhs, (boolean[]) rhs);\r\n-        } else {\r\n-            // Not an array of primitives\r\n-            append((Object[]) lhs, (Object[]) rhs);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Test if two <code>long</code> s are equal.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs\r\n-     *                  the left hand <code>long</code>\r\n-     * @param rhs\r\n-     *                  the right hand <code>long</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long lhs, long rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>int</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int</code>\r\n-     * @param rhs  the right hand <code>int</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int lhs, int rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>short</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short</code>\r\n-     * @param rhs  the right hand <code>short</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short lhs, short rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>char</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char</code>\r\n-     * @param rhs  the right hand <code>char</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char lhs, char rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>byte</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte</code>\r\n-     * @param rhs  the right hand <code>byte</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte lhs, byte rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>double</code>s are equal by testing that the\r\n-     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double</code>\r\n-     * @param rhs  the right hand <code>double</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double lhs, double rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>float</code>s are equal byt testing that the\r\n-     * pattern of bits returned by doubleToLong are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float</code>\r\n-     * @param rhs  the right hand <code>float</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float lhs, float rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>booleans</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean</code>\r\n-     * @param rhs  the right hand <code>boolean</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-      */\r\n-    public EqualsBuilder append(boolean lhs, boolean rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\r\n-     *\r\n-     * <p>This also will be called for the top level of\r\n-     * multi-dimensional, ragged, and multi-typed arrays.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>Object[]</code>\r\n-     * @param rhs  the right hand <code>Object[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>long</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(long, long)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>long[]</code>\r\n-     * @param rhs  the right hand <code>long[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long[] lhs, long[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>int</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(int, int)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int[]</code>\r\n-     * @param rhs  the right hand <code>int[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int[] lhs, int[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>short</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(short, short)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short[]</code>\r\n-     * @param rhs  the right hand <code>short[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short[] lhs, short[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>char</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(char, char)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char[]</code>\r\n-     * @param rhs  the right hand <code>char[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char[] lhs, char[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>byte</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(byte, byte)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte[]</code>\r\n-     * @param rhs  the right hand <code>byte[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>double</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(double, double)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double[]</code>\r\n-     * @param rhs  the right hand <code>double[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double[] lhs, double[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>float</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(float, float)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float[]</code>\r\n-     * @param rhs  the right hand <code>float[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float[] lhs, float[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>boolean</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(boolean, boolean)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean[]</code>\r\n-     * @param rhs  the right hand <code>boolean[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return boolean\r\n-     */\r\n-    public boolean isEquals() {\r\n-        return this.isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return <code>true</code> if all of the fields that have been checked\r\n-     *         are equal, <code>false</code> otherwise.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Boolean build() {\r\n-        return Boolean.valueOf(isEquals());\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the <code>isEquals</code> value.\r\n-     *\r\n-     * @param isEquals The value to set.\r\n-     * @since 2.1\r\n-     */\r\n-    protected void setEquals(boolean isEquals) {\r\n-        this.isEquals = isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reset the EqualsBuilder so you can use the same object again\r\n-     * @since 2.5\r\n-     */\r\n-    public void reset() {\r\n-        this.isEquals = true;\r\n-    }\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n+ *\n+ * <p> This class provides methods to build a good equals method for any\n+ * class. It follows rules laid out in\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\n+ * <code>floats</code>, and arrays can be tricky. Also, making sure that\n+ * <code>equals()</code> and <code>hashCode()</code> are consistent can be\n+ * difficult.</p>\n+ *\n+ * <p>Two Objects that compare as equals must generate the same hash code,\n+ * but two Objects with the same hash code do not have to be equal.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of equals.\n+ * Derived fields may be ignored. In particular, any field used in\n+ * generating a hash code must be used in the equals method, and vice\n+ * versa.</p>\n+ *\n+ * <p>Typical use for the code is as follows:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   if (obj == null) { return false; }\n+ *   if (obj == this) { return true; }\n+ *   if (obj.getClass() != getClass()) {\n+ *     return false;\n+ *   }\n+ *   MyClass rhs = (MyClass) obj;\n+ *   return new EqualsBuilder()\n+ *                 .appendSuper(super.equals(obj))\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .append(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </pre>\n+ *\n+ * <p> Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly. It is\n+ * also slower than testing explicitly.</p>\n+ *\n+ * <p> A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </pre>\n+ *\n+ * @since 1.0\n+ * @version $Id: EqualsBuilder.java 1091531 2011-04-12 18:29:49Z ggregory $\n+ */\n+public class EqualsBuilder implements Builder<Boolean> {\n+\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     *\n+     * @since 3.0\n+     */\n+    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\n+\n+    /*\n+     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     *\n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     *\n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     *\n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *\n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+\n+    /**\n+     * <p>\n+     * Returns the registry of object pairs being traversed by the reflection\n+     * methods in the current thread.\n+     * </p>\n+     *\n+     * @return Set the registry of objects being traversed\n+     * @since 3.0\n+     */\n+    static Set<Pair<IDKey, IDKey>> getRegistry() {\n+        return REGISTRY.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Converters value pair into a register pair.\n+     * </p>\n+     *\n+     * @param lhs <code>this</code> object\n+     * @param rhs the other object\n+     *\n+     * @return the pair\n+     */\n+    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\n+        IDKey left = new IDKey(lhs);\n+        IDKey right = new IDKey(rhs);\n+        return Pair.of(left, right);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object pair.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * Objects might be swapped therefore a check is needed if the object pair\n+     * is registered in given or swapped order.\n+     * </p>\n+     *\n+     * @param lhs <code>this</code> object to lookup in registry\n+     * @param rhs the other object to lookup on registry\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 3.0\n+     */\n+    static boolean isRegistered(Object lhs, Object rhs) {\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\n+\n+        return registry != null\n+                && (registry.contains(pair) || registry.contains(swappedPair));\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object pair.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     *\n+     * @param lhs <code>this</code> object to register\n+     * @param rhs the other object to register\n+     */\n+    static void register(Object lhs, Object rhs) {\n+        synchronized (EqualsBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\n+            }\n+        }\n+\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        registry.add(pair);\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object pair.\n+     * </p>\n+     *\n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     *\n+     * @param lhs <code>this</code> object to unregister\n+     * @param rhs the other object to unregister\n+     * @since 3.0\n+     */\n+    static void unregister(Object lhs, Object rhs) {\n+        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        if (registry != null) {\n+            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+            registry.remove(pair);\n+            synchronized (EqualsBuilder.class) {\n+                //read again\n+                registry = getRegistry();\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * If the fields tested are equals.\n+     * The default value is <code>true</code>.\n+     */\n+    private boolean isEquals = true;\n+\n+    /**\n+     * <p>Constructor for EqualsBuilder.</p>\n+     *\n+     * <p>Starts off assuming that equals is <code>true</code>.</p>\n+     * @see Object#equals(Object)\n+     */\n+    public EqualsBuilder() {\n+        // do nothing for now.\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n+            String... excludeFields) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        Class<?> lhsClass = lhs.getClass();\n+        Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            return false;\n+        }\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given Class.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class<?> clazz,\n+        EqualsBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+\n+        if (isRegistered(lhs, rhs)) {\n+            return;\n+        }\n+\n+        try {\n+            register(lhs, rhs);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+                Field f = fields[i];\n+                if (!ArrayUtils.contains(excludeFields, f.getName())\n+                    && (f.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                    && (!Modifier.isStatic(f.getModifiers()))) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(lhs, rhs);\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n+     *\n+     * @param superEquals  the result of calling <code>super.equals()</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     * @since 2.0\n+     */\n+    public EqualsBuilder appendSuper(boolean superEquals) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = superEquals;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Test if two <code>Object</code>s are equal using their\n+     * <code>equals</code> method.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        Class<?> lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            // The simple case, not an array, just test the element\n+            isEquals = lhs.equals(rhs);\n+        } else if (lhs.getClass() != rhs.getClass()) {\n+            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\n+            this.setEquals(false);\n+        }\n+        // 'Switch' on type of array, to dispatch to the correct handler\n+        // This handles multi dimensional arrays of the same depth\n+        else if (lhs instanceof long[]) {\n+            append((long[]) lhs, (long[]) rhs);\n+        } else if (lhs instanceof int[]) {\n+            append((int[]) lhs, (int[]) rhs);\n+        } else if (lhs instanceof short[]) {\n+            append((short[]) lhs, (short[]) rhs);\n+        } else if (lhs instanceof char[]) {\n+            append((char[]) lhs, (char[]) rhs);\n+        } else if (lhs instanceof byte[]) {\n+            append((byte[]) lhs, (byte[]) rhs);\n+        } else if (lhs instanceof double[]) {\n+            append((double[]) lhs, (double[]) rhs);\n+        } else if (lhs instanceof float[]) {\n+            append((float[]) lhs, (float[]) rhs);\n+        } else if (lhs instanceof boolean[]) {\n+            append((boolean[]) lhs, (boolean[]) rhs);\n+        } else {\n+            // Not an array of primitives\n+            append((Object[]) lhs, (Object[]) rhs);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Test if two <code>long</code> s are equal.\n+     * </p>\n+     *\n+     * @param lhs\n+     *                  the left hand <code>long</code>\n+     * @param rhs\n+     *                  the right hand <code>long</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>int</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>int</code>\n+     * @param rhs  the right hand <code>int</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>short</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>short</code>\n+     * @param rhs  the right hand <code>short</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>char</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>char</code>\n+     * @param rhs  the right hand <code>char</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>byte</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>byte</code>\n+     * @param rhs  the right hand <code>byte</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>double</code>s are equal by testing that the\n+     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>double</code>\n+     * @param rhs  the right hand <code>double</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>float</code>s are equal byt testing that the\n+     * pattern of bits returned by doubleToLong are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>float</code>\n+     * @param rhs  the right hand <code>float</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>booleans</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean</code>\n+     * @param rhs  the right hand <code>boolean</code>\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n+     *\n+     * <p>This also will be called for the top level of\n+     * multi-dimensional, ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  the left hand <code>Object[]</code>\n+     * @param rhs  the right hand <code>Object[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>long</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(long, long)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>long[]</code>\n+     * @param rhs  the right hand <code>long[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>int</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(int, int)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>int[]</code>\n+     * @param rhs  the right hand <code>int[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>short</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(short, short)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>short[]</code>\n+     * @param rhs  the right hand <code>short[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>char</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(char, char)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>char[]</code>\n+     * @param rhs  the right hand <code>char[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>byte</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(byte, byte)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>byte[]</code>\n+     * @param rhs  the right hand <code>byte[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>double</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(double, double)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>double[]</code>\n+     * @param rhs  the right hand <code>double[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>float</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(float, float)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>float[]</code>\n+     * @param rhs  the right hand <code>float[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean[]</code>\n+     * @param rhs  the right hand <code>boolean[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return this.isEquals;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return <code>true</code> if all of the fields that have been checked\n+     *         are equal, <code>false</code> otherwise.\n+     *\n+     * @since 3.0\n+     */\n+    public Boolean build() {\n+        return Boolean.valueOf(isEquals());\n+    }\n+\n+    /**\n+     * Sets the <code>isEquals</code> value.\n+     *\n+     * @param isEquals The value to set.\n+     * @since 2.1\n+     */\n+    protected void setEquals(boolean isEquals) {\n+        this.isEquals = isEquals;\n+    }\n+\n+    /**\n+     * Reset the EqualsBuilder so you can use the same object again\n+     * @since 2.5\n+     */\n+    public void reset() {\n+        this.isEquals = true;\n+    }\n+}\n",
            "diff_size": 959
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}