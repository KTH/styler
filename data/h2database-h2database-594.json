{
    "error_id": "594",
    "information": {
        "errors": [
            {
                "line": "299",
                "column": "37",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "            }\n            boolean alreadyOpen = e instanceof DbException\n                    && ((DbException)e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n            if (alreadyOpen) {\n                stopServer();\n            }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/594/Database.java\nindex 2ee29bf449..405bac1767 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/594/Database.java\n@@ -296,7 +296,7 @@ public class Database implements DataHandler {\n                 e.fillInStackTrace();\n             }\n             boolean alreadyOpen = e instanceof DbException\n-                    && ((DbException)e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n+                    && ((DbException) e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n             if (alreadyOpen) {\n                 stopServer();\n             }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/594/Database.java\nindex 2ee29bf449..934df7b9b4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/594/Database.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.engine;\n \n import java.io.IOException;\n@@ -81,2838 +82,2849 @@ import org.h2.value.ValueInt;\n \n /**\n  * There is one database object per open database.\n- *\n+ * <p>\n  * The format of the meta data table is:\n- *  id int, 0, objectType int, sql varchar\n+ * id int, 0, objectType int, sql varchar\n  *\n  * @since 2004-04-15 22:49\n  */\n public class Database implements DataHandler {\n \n-    private static int initialPowerOffCount;\n-\n-    /**\n-     * The default name of the system user. This name is only used as long as\n-     * there is no administrator user registered.\n-     */\n-    private static final String SYSTEM_USER_NAME = \"DBA\";\n-\n-    private final boolean persistent;\n-    private final String databaseName;\n-    private final String databaseShortName;\n-    private final String databaseURL;\n-    private final String cipher;\n-    private final byte[] filePasswordHash;\n-    private final byte[] fileEncryptionKey;\n-\n-    private final HashMap<String, Role> roles = New.hashMap();\n-    private final HashMap<String, User> users = New.hashMap();\n-    private final HashMap<String, Setting> settings = New.hashMap();\n-    private final HashMap<String, Schema> schemas = New.hashMap();\n-    private final HashMap<String, Right> rights = New.hashMap();\n-    private final HashMap<String, UserDataType> userDataTypes = New.hashMap();\n-    private final HashMap<String, UserAggregate> aggregates = New.hashMap();\n-    private final HashMap<String, Comment> comments = New.hashMap();\n-    private final HashMap<String, TableEngine> tableEngines = New.hashMap();\n-\n-    private final Set<Session> userSessions =\n-            Collections.synchronizedSet(new HashSet<Session>());\n-    private final AtomicReference<Session> exclusiveSession = new AtomicReference<>();\n-    private final BitField objectIds = new BitField();\n-    private final Object lobSyncObject = new Object();\n-\n-    private Schema mainSchema;\n-    private Schema infoSchema;\n-    private int nextSessionId;\n-    private int nextTempTableId;\n-    private User systemUser;\n-    private Session systemSession;\n-    private Session lobSession;\n-    private Table meta;\n-    private Index metaIdIndex;\n-    private FileLock lock;\n-    private WriterThread writer;\n-    private boolean starting;\n-    private TraceSystem traceSystem;\n-    private Trace trace;\n-    private final int fileLockMethod;\n-    private Role publicRole;\n-    private final AtomicLong modificationDataId = new AtomicLong();\n-    private final AtomicLong modificationMetaId = new AtomicLong();\n-    private CompareMode compareMode;\n-    private String cluster = Constants.CLUSTERING_DISABLED;\n-    private boolean readOnly;\n-    private int writeDelay = Constants.DEFAULT_WRITE_DELAY;\n-    private DatabaseEventListener eventListener;\n-    private int maxMemoryRows = SysProperties.MAX_MEMORY_ROWS;\n-    private int maxMemoryUndo = Constants.DEFAULT_MAX_MEMORY_UNDO;\n-    private int lockMode = Constants.DEFAULT_LOCK_MODE;\n-    private int maxLengthInplaceLob;\n-    private int allowLiterals = Constants.ALLOW_LITERALS_ALL;\n-\n-    private int powerOffCount = initialPowerOffCount;\n-    private int closeDelay;\n-    private DatabaseCloser delayedCloser;\n-    private volatile boolean closing;\n-    private boolean ignoreCase;\n-    private boolean deleteFilesOnDisconnect;\n-    private String lobCompressionAlgorithm;\n-    private boolean optimizeReuseResults = true;\n-    private final String cacheType;\n-    private final String accessModeData;\n-    private boolean referentialIntegrity = true;\n-    private boolean multiVersion;\n-    private DatabaseCloser closeOnExit;\n-    private Mode mode = Mode.getInstance(Mode.REGULAR);\n-    private boolean multiThreaded;\n-    private int maxOperationMemory =\n-            Constants.DEFAULT_MAX_OPERATION_MEMORY;\n-    private SmallLRUCache<String, String[]> lobFileListCache;\n-    private final boolean autoServerMode;\n-    private final int autoServerPort;\n-    private Server server;\n-    private HashMap<TableLinkConnection, TableLinkConnection> linkConnections;\n-    private final TempFileDeleter tempFileDeleter = TempFileDeleter.getInstance();\n-    private PageStore pageStore;\n-    private Properties reconnectLastLock;\n-    private volatile long reconnectCheckNext;\n-    private volatile boolean reconnectChangePending;\n-    private volatile int checkpointAllowed;\n-    private volatile boolean checkpointRunning;\n-    private final Object reconnectSync = new Object();\n-    private int cacheSize;\n-    private int compactMode;\n-    private SourceCompiler compiler;\n-    private volatile boolean metaTablesInitialized;\n-    private boolean flushOnEachCommit;\n-    private LobStorageInterface lobStorage;\n-    private final int pageSize;\n-    private int defaultTableType = Table.TYPE_CACHED;\n-    private final DbSettings dbSettings;\n-    private final long reconnectCheckDelayNs;\n-    private int logMode;\n-    private MVTableEngine.Store mvStore;\n-    private int retentionTime;\n-    private boolean allowBuiltinAliasOverride;\n-    private DbException backgroundException;\n-    private JavaObjectSerializer javaObjectSerializer;\n-    private String javaObjectSerializerName;\n-    private volatile boolean javaObjectSerializerInitialized;\n-    private boolean queryStatistics;\n-    private int queryStatisticsMaxEntries = Constants.QUERY_STATISTICS_MAX_ENTRIES;\n-    private QueryStatisticsData queryStatisticsData;\n-    private RowFactory rowFactory = RowFactory.DEFAULT;\n-\n-    public Database(ConnectionInfo ci, String cipher) {\n-        String name = ci.getName();\n-        this.dbSettings = ci.getDbSettings();\n-        this.reconnectCheckDelayNs = TimeUnit.MILLISECONDS.toNanos(dbSettings.reconnectCheckDelay);\n-        this.compareMode = CompareMode.getInstance(null, 0);\n-        this.persistent = ci.isPersistent();\n-        this.filePasswordHash = ci.getFilePasswordHash();\n-        this.fileEncryptionKey = ci.getFileEncryptionKey();\n-        this.databaseName = name;\n-        this.databaseShortName = parseDatabaseShortName();\n-        this.maxLengthInplaceLob = Constants.DEFAULT_MAX_LENGTH_INPLACE_LOB;\n-        this.cipher = cipher;\n-        String lockMethodName = ci.getProperty(\"FILE_LOCK\", null);\n-        this.accessModeData = StringUtils.toLowerEnglish(\n-                ci.getProperty(\"ACCESS_MODE_DATA\", \"rw\"));\n-        this.autoServerMode = ci.getProperty(\"AUTO_SERVER\", false);\n-        this.autoServerPort = ci.getProperty(\"AUTO_SERVER_PORT\", 0);\n-        int defaultCacheSize = Utils.scaleForAvailableMemory(\n-                Constants.CACHE_SIZE_DEFAULT);\n-        this.cacheSize =\n-                ci.getProperty(\"CACHE_SIZE\", defaultCacheSize);\n-        this.pageSize = ci.getProperty(\"PAGE_SIZE\",\n-                Constants.DEFAULT_PAGE_SIZE);\n-        if (\"r\".equals(accessModeData)) {\n-            readOnly = true;\n-        }\n-        if (dbSettings.mvStore && lockMethodName == null) {\n-            if (autoServerMode) {\n-                fileLockMethod = FileLock.LOCK_FILE;\n-            } else {\n-                fileLockMethod = FileLock.LOCK_FS;\n-            }\n-        } else {\n-            fileLockMethod = FileLock.getFileLockMethod(lockMethodName);\n-        }\n-        if (dbSettings.mvStore && fileLockMethod == FileLock.LOCK_SERIALIZED) {\n-            throw DbException.getUnsupportedException(\n-                    \"MV_STORE combined with FILE_LOCK=SERIALIZED\");\n-        }\n-        this.databaseURL = ci.getURL();\n-        String listener = ci.removeProperty(\"DATABASE_EVENT_LISTENER\", null);\n-        if (listener != null) {\n-            listener = StringUtils.trim(listener, true, true, \"'\");\n-            setEventListenerClass(listener);\n-        }\n-        String modeName = ci.removeProperty(\"MODE\", null);\n-        if (modeName != null) {\n-            this.mode = Mode.getInstance(modeName);\n-        }\n-        this.multiVersion =\n-                ci.getProperty(\"MVCC\", dbSettings.mvStore);\n-        this.logMode =\n-                ci.getProperty(\"LOG\", PageStore.LOG_MODE_SYNC);\n-        this.javaObjectSerializerName =\n-                ci.getProperty(\"JAVA_OBJECT_SERIALIZER\", null);\n-        this.multiThreaded =\n-                ci.getProperty(\"MULTI_THREADED\", false);\n-        boolean closeAtVmShutdown =\n-                dbSettings.dbCloseOnExit;\n-        int traceLevelFile =\n-                ci.getIntProperty(SetTypes.TRACE_LEVEL_FILE,\n-                TraceSystem.DEFAULT_TRACE_LEVEL_FILE);\n-        int traceLevelSystemOut =\n-                ci.getIntProperty(SetTypes.TRACE_LEVEL_SYSTEM_OUT,\n-                TraceSystem.DEFAULT_TRACE_LEVEL_SYSTEM_OUT);\n-        this.cacheType = StringUtils.toUpperEnglish(\n-                ci.removeProperty(\"CACHE_TYPE\", Constants.CACHE_TYPE_DEFAULT));\n-        openDatabase(traceLevelFile, traceLevelSystemOut, closeAtVmShutdown);\n-    }\n-\n-    private void openDatabase(int traceLevelFile, int traceLevelSystemOut,\n-            boolean closeAtVmShutdown) {\n+  private static int initialPowerOffCount;\n+\n+  /**\n+   * The default name of the system user. This name is only used as long as\n+   * there is no administrator user registered.\n+   */\n+  private static final String SYSTEM_USER_NAME = \"DBA\";\n+\n+  private final boolean persistent;\n+  private final String databaseName;\n+  private final String databaseShortName;\n+  private final String databaseURL;\n+  private final String cipher;\n+  private final byte[] filePasswordHash;\n+  private final byte[] fileEncryptionKey;\n+\n+  private final HashMap<String, Role> roles = New.hashMap();\n+  private final HashMap<String, User> users = New.hashMap();\n+  private final HashMap<String, Setting> settings = New.hashMap();\n+  private final HashMap<String, Schema> schemas = New.hashMap();\n+  private final HashMap<String, Right> rights = New.hashMap();\n+  private final HashMap<String, UserDataType> userDataTypes = New.hashMap();\n+  private final HashMap<String, UserAggregate> aggregates = New.hashMap();\n+  private final HashMap<String, Comment> comments = New.hashMap();\n+  private final HashMap<String, TableEngine> tableEngines = New.hashMap();\n+\n+  private final Set<Session> userSessions =\n+      Collections.synchronizedSet(new HashSet<Session>());\n+  private final AtomicReference<Session> exclusiveSession =\n+      new AtomicReference<>();\n+  private final BitField objectIds = new BitField();\n+  private final Object lobSyncObject = new Object();\n+\n+  private Schema mainSchema;\n+  private Schema infoSchema;\n+  private int nextSessionId;\n+  private int nextTempTableId;\n+  private User systemUser;\n+  private Session systemSession;\n+  private Session lobSession;\n+  private Table meta;\n+  private Index metaIdIndex;\n+  private FileLock lock;\n+  private WriterThread writer;\n+  private boolean starting;\n+  private TraceSystem traceSystem;\n+  private Trace trace;\n+  private final int fileLockMethod;\n+  private Role publicRole;\n+  private final AtomicLong modificationDataId = new AtomicLong();\n+  private final AtomicLong modificationMetaId = new AtomicLong();\n+  private CompareMode compareMode;\n+  private String cluster = Constants.CLUSTERING_DISABLED;\n+  private boolean readOnly;\n+  private int writeDelay = Constants.DEFAULT_WRITE_DELAY;\n+  private DatabaseEventListener eventListener;\n+  private int maxMemoryRows = SysProperties.MAX_MEMORY_ROWS;\n+  private int maxMemoryUndo = Constants.DEFAULT_MAX_MEMORY_UNDO;\n+  private int lockMode = Constants.DEFAULT_LOCK_MODE;\n+  private int maxLengthInplaceLob;\n+  private int allowLiterals = Constants.ALLOW_LITERALS_ALL;\n+\n+  private int powerOffCount = initialPowerOffCount;\n+  private int closeDelay;\n+  private DatabaseCloser delayedCloser;\n+  private volatile boolean closing;\n+  private boolean ignoreCase;\n+  private boolean deleteFilesOnDisconnect;\n+  private String lobCompressionAlgorithm;\n+  private boolean optimizeReuseResults = true;\n+  private final String cacheType;\n+  private final String accessModeData;\n+  private boolean referentialIntegrity = true;\n+  private boolean multiVersion;\n+  private DatabaseCloser closeOnExit;\n+  private Mode mode = Mode.getInstance(Mode.REGULAR);\n+  private boolean multiThreaded;\n+  private int maxOperationMemory =\n+      Constants.DEFAULT_MAX_OPERATION_MEMORY;\n+  private SmallLRUCache<String, String[]> lobFileListCache;\n+  private final boolean autoServerMode;\n+  private final int autoServerPort;\n+  private Server server;\n+  private HashMap<TableLinkConnection, TableLinkConnection> linkConnections;\n+  private final TempFileDeleter tempFileDeleter = TempFileDeleter.getInstance();\n+  private PageStore pageStore;\n+  private Properties reconnectLastLock;\n+  private volatile long reconnectCheckNext;\n+  private volatile boolean reconnectChangePending;\n+  private volatile int checkpointAllowed;\n+  private volatile boolean checkpointRunning;\n+  private final Object reconnectSync = new Object();\n+  private int cacheSize;\n+  private int compactMode;\n+  private SourceCompiler compiler;\n+  private volatile boolean metaTablesInitialized;\n+  private boolean flushOnEachCommit;\n+  private LobStorageInterface lobStorage;\n+  private final int pageSize;\n+  private int defaultTableType = Table.TYPE_CACHED;\n+  private final DbSettings dbSettings;\n+  private final long reconnectCheckDelayNs;\n+  private int logMode;\n+  private MVTableEngine.Store mvStore;\n+  private int retentionTime;\n+  private boolean allowBuiltinAliasOverride;\n+  private DbException backgroundException;\n+  private JavaObjectSerializer javaObjectSerializer;\n+  private String javaObjectSerializerName;\n+  private volatile boolean javaObjectSerializerInitialized;\n+  private boolean queryStatistics;\n+  private int queryStatisticsMaxEntries =\n+      Constants.QUERY_STATISTICS_MAX_ENTRIES;\n+  private QueryStatisticsData queryStatisticsData;\n+  private RowFactory rowFactory = RowFactory.DEFAULT;\n+\n+  public Database(ConnectionInfo ci, String cipher) {\n+    String name = ci.getName();\n+    this.dbSettings = ci.getDbSettings();\n+    this.reconnectCheckDelayNs =\n+        TimeUnit.MILLISECONDS.toNanos(dbSettings.reconnectCheckDelay);\n+    this.compareMode = CompareMode.getInstance(null, 0);\n+    this.persistent = ci.isPersistent();\n+    this.filePasswordHash = ci.getFilePasswordHash();\n+    this.fileEncryptionKey = ci.getFileEncryptionKey();\n+    this.databaseName = name;\n+    this.databaseShortName = parseDatabaseShortName();\n+    this.maxLengthInplaceLob = Constants.DEFAULT_MAX_LENGTH_INPLACE_LOB;\n+    this.cipher = cipher;\n+    String lockMethodName = ci.getProperty(\"FILE_LOCK\", null);\n+    this.accessModeData = StringUtils.toLowerEnglish(\n+        ci.getProperty(\"ACCESS_MODE_DATA\", \"rw\"));\n+    this.autoServerMode = ci.getProperty(\"AUTO_SERVER\", false);\n+    this.autoServerPort = ci.getProperty(\"AUTO_SERVER_PORT\", 0);\n+    int defaultCacheSize = Utils.scaleForAvailableMemory(\n+        Constants.CACHE_SIZE_DEFAULT);\n+    this.cacheSize =\n+        ci.getProperty(\"CACHE_SIZE\", defaultCacheSize);\n+    this.pageSize = ci.getProperty(\"PAGE_SIZE\",\n+        Constants.DEFAULT_PAGE_SIZE);\n+    if (\"r\".equals(accessModeData)) {\n+      readOnly = true;\n+    }\n+    if (dbSettings.mvStore && lockMethodName == null) {\n+      if (autoServerMode) {\n+        fileLockMethod = FileLock.LOCK_FILE;\n+      } else {\n+        fileLockMethod = FileLock.LOCK_FS;\n+      }\n+    } else {\n+      fileLockMethod = FileLock.getFileLockMethod(lockMethodName);\n+    }\n+    if (dbSettings.mvStore && fileLockMethod == FileLock.LOCK_SERIALIZED) {\n+      throw DbException.getUnsupportedException(\n+          \"MV_STORE combined with FILE_LOCK=SERIALIZED\");\n+    }\n+    this.databaseURL = ci.getURL();\n+    String listener = ci.removeProperty(\"DATABASE_EVENT_LISTENER\", null);\n+    if (listener != null) {\n+      listener = StringUtils.trim(listener, true, true, \"'\");\n+      setEventListenerClass(listener);\n+    }\n+    String modeName = ci.removeProperty(\"MODE\", null);\n+    if (modeName != null) {\n+      this.mode = Mode.getInstance(modeName);\n+    }\n+    this.multiVersion =\n+        ci.getProperty(\"MVCC\", dbSettings.mvStore);\n+    this.logMode =\n+        ci.getProperty(\"LOG\", PageStore.LOG_MODE_SYNC);\n+    this.javaObjectSerializerName =\n+        ci.getProperty(\"JAVA_OBJECT_SERIALIZER\", null);\n+    this.multiThreaded =\n+        ci.getProperty(\"MULTI_THREADED\", false);\n+    boolean closeAtVmShutdown =\n+        dbSettings.dbCloseOnExit;\n+    int traceLevelFile =\n+        ci.getIntProperty(SetTypes.TRACE_LEVEL_FILE,\n+            TraceSystem.DEFAULT_TRACE_LEVEL_FILE);\n+    int traceLevelSystemOut =\n+        ci.getIntProperty(SetTypes.TRACE_LEVEL_SYSTEM_OUT,\n+            TraceSystem.DEFAULT_TRACE_LEVEL_SYSTEM_OUT);\n+    this.cacheType = StringUtils.toUpperEnglish(\n+        ci.removeProperty(\"CACHE_TYPE\", Constants.CACHE_TYPE_DEFAULT));\n+    openDatabase(traceLevelFile, traceLevelSystemOut, closeAtVmShutdown);\n+  }\n+\n+  private void openDatabase(int traceLevelFile, int traceLevelSystemOut,\n+                            boolean closeAtVmShutdown) {\n+    try {\n+      open(traceLevelFile, traceLevelSystemOut);\n+      if (closeAtVmShutdown) {\n         try {\n-            open(traceLevelFile, traceLevelSystemOut);\n-            if (closeAtVmShutdown) {\n-                try {\n-                    closeOnExit = new DatabaseCloser(this, 0, true);\n-                    Runtime.getRuntime().addShutdownHook(closeOnExit);\n-                } catch (IllegalStateException e) {\n-                    // shutdown in progress - just don't register the handler\n-                    // (maybe an application wants to write something into a\n-                    // database at shutdown time)\n-                } catch (SecurityException  e) {\n-                    // applets may not do that - ignore\n-                    // Google App Engine doesn't allow\n-                    // to instantiate classes that extend Thread\n-                }\n-            }\n-        } catch (Throwable e) {\n-            if (e instanceof OutOfMemoryError) {\n-                e.fillInStackTrace();\n-            }\n-            boolean alreadyOpen = e instanceof DbException\n-                    && ((DbException)e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n-            if (alreadyOpen) {\n-                stopServer();\n-            }\n-\n-            if (traceSystem != null) {\n-                if (e instanceof DbException && !alreadyOpen) {\n-                    // only write if the database is not already in use\n-                    trace.error(e, \"opening {0}\", databaseName);\n-                }\n-                traceSystem.close();\n-            }\n-            closeOpenFilesAndUnlock(false);\n-            throw DbException.convert(e);\n+          closeOnExit = new DatabaseCloser(this, 0, true);\n+          Runtime.getRuntime().addShutdownHook(closeOnExit);\n+        } catch (IllegalStateException e) {\n+          // shutdown in progress - just don't register the handler\n+          // (maybe an application wants to write something into a\n+          // database at shutdown time)\n+        } catch (SecurityException e) {\n+          // applets may not do that - ignore\n+          // Google App Engine doesn't allow\n+          // to instantiate classes that extend Thread\n         }\n-    }\n-\n-    /**\n-     * Create a new row for a table.\n-     *\n-     * @param data the values\n-     * @param memory whether the row is in memory\n-     * @return the created row\n-     */\n-    public Row createRow(Value[] data, int memory) {\n-        return rowFactory.createRow(data, memory);\n-    }\n-\n-    public RowFactory getRowFactory() {\n-        return rowFactory;\n-    }\n-\n-    public void setRowFactory(RowFactory rowFactory) {\n-        this.rowFactory = rowFactory;\n-    }\n-\n-    public static void setInitialPowerOffCount(int count) {\n-        initialPowerOffCount = count;\n-    }\n+      }\n+    } catch (Throwable e) {\n+      if (e instanceof OutOfMemoryError) {\n+        e.fillInStackTrace();\n+      }\n+      boolean alreadyOpen = e instanceof DbException\n+          &&\n+          ((DbException) e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n+      if (alreadyOpen) {\n+        stopServer();\n+      }\n \n-    public void setPowerOffCount(int count) {\n-        if (powerOffCount == -1) {\n-            return;\n-        }\n-        powerOffCount = count;\n-    }\n-\n-    public MVTableEngine.Store getMvStore() {\n-        return mvStore;\n-    }\n-\n-    public void setMvStore(MVTableEngine.Store mvStore) {\n-        this.mvStore = mvStore;\n-        this.retentionTime = mvStore.getStore().getRetentionTime();\n-    }\n-\n-    /**\n-     * Check if two values are equal with the current comparison mode.\n-     *\n-     * @param a the first value\n-     * @param b the second value\n-     * @return true if both objects are equal\n-     */\n-    public boolean areEqual(Value a, Value b) {\n-        // can not use equals because ValueDecimal 0.0 is not equal to 0.00.\n-        return a.compareTo(b, compareMode) == 0;\n-    }\n-\n-    /**\n-     * Compare two values with the current comparison mode. The values may not\n-     * be of the same type.\n-     *\n-     * @param a the first value\n-     * @param b the second value\n-     * @return 0 if both values are equal, -1 if the first value is smaller, and\n-     *         1 otherwise\n-     */\n-    public int compare(Value a, Value b) {\n-        return a.compareTo(b, compareMode);\n-    }\n-\n-    /**\n-     * Compare two values with the current comparison mode. The values must be\n-     * of the same type.\n-     *\n-     * @param a the first value\n-     * @param b the second value\n-     * @return 0 if both values are equal, -1 if the first value is smaller, and\n-     *         1 otherwise\n-     */\n-    public int compareTypeSafe(Value a, Value b) {\n-        return a.compareTypeSafe(b, compareMode);\n-    }\n-\n-    public long getModificationDataId() {\n-        return modificationDataId.get();\n-    }\n-\n-    /**\n-     * Set or reset the pending change flag in the .lock.db file.\n-     *\n-     * @param pending the new value of the flag\n-     * @return true if the call was successful,\n-     *          false if another connection was faster\n-     */\n-    private synchronized boolean reconnectModified(boolean pending) {\n-        if (readOnly || lock == null ||\n-                fileLockMethod != FileLock.LOCK_SERIALIZED) {\n-            return true;\n+      if (traceSystem != null) {\n+        if (e instanceof DbException && !alreadyOpen) {\n+          // only write if the database is not already in use\n+          trace.error(e, \"opening {0}\", databaseName);\n         }\n-        try {\n-            if (pending == reconnectChangePending) {\n-                long now = System.nanoTime();\n-                if (now > reconnectCheckNext) {\n-                    if (pending) {\n-                        String pos = pageStore == null ?\n-                                null : \"\" + pageStore.getWriteCountTotal();\n-                        lock.setProperty(\"logPos\", pos);\n-                        lock.save();\n-                    }\n-                    reconnectCheckNext = now + reconnectCheckDelayNs;\n-                }\n-                return true;\n-            }\n-            Properties old = lock.load();\n-            if (pending) {\n-                if (old.getProperty(\"changePending\") != null) {\n-                    return false;\n-                }\n-                trace.debug(\"wait before writing\");\n-                Thread.sleep(TimeUnit.NANOSECONDS.toMillis((long) (reconnectCheckDelayNs * 1.1)));\n-                Properties now = lock.load();\n-                if (!now.equals(old)) {\n-                    // somebody else was faster\n-                    return false;\n-                }\n-            }\n+        traceSystem.close();\n+      }\n+      closeOpenFilesAndUnlock(false);\n+      throw DbException.convert(e);\n+    }\n+  }\n+\n+  /**\n+   * Create a new row for a table.\n+   *\n+   * @param data   the values\n+   * @param memory whether the row is in memory\n+   * @return the created row\n+   */\n+  public Row createRow(Value[] data, int memory) {\n+    return rowFactory.createRow(data, memory);\n+  }\n+\n+  public RowFactory getRowFactory() {\n+    return rowFactory;\n+  }\n+\n+  public void setRowFactory(RowFactory rowFactory) {\n+    this.rowFactory = rowFactory;\n+  }\n+\n+  public static void setInitialPowerOffCount(int count) {\n+    initialPowerOffCount = count;\n+  }\n+\n+  public void setPowerOffCount(int count) {\n+    if (powerOffCount == -1) {\n+      return;\n+    }\n+    powerOffCount = count;\n+  }\n+\n+  public MVTableEngine.Store getMvStore() {\n+    return mvStore;\n+  }\n+\n+  public void setMvStore(MVTableEngine.Store mvStore) {\n+    this.mvStore = mvStore;\n+    this.retentionTime = mvStore.getStore().getRetentionTime();\n+  }\n+\n+  /**\n+   * Check if two values are equal with the current comparison mode.\n+   *\n+   * @param a the first value\n+   * @param b the second value\n+   * @return true if both objects are equal\n+   */\n+  public boolean areEqual(Value a, Value b) {\n+    // can not use equals because ValueDecimal 0.0 is not equal to 0.00.\n+    return a.compareTo(b, compareMode) == 0;\n+  }\n+\n+  /**\n+   * Compare two values with the current comparison mode. The values may not\n+   * be of the same type.\n+   *\n+   * @param a the first value\n+   * @param b the second value\n+   * @return 0 if both values are equal, -1 if the first value is smaller, and\n+   * 1 otherwise\n+   */\n+  public int compare(Value a, Value b) {\n+    return a.compareTo(b, compareMode);\n+  }\n+\n+  /**\n+   * Compare two values with the current comparison mode. The values must be\n+   * of the same type.\n+   *\n+   * @param a the first value\n+   * @param b the second value\n+   * @return 0 if both values are equal, -1 if the first value is smaller, and\n+   * 1 otherwise\n+   */\n+  public int compareTypeSafe(Value a, Value b) {\n+    return a.compareTypeSafe(b, compareMode);\n+  }\n+\n+  public long getModificationDataId() {\n+    return modificationDataId.get();\n+  }\n+\n+  /**\n+   * Set or reset the pending change flag in the .lock.db file.\n+   *\n+   * @param pending the new value of the flag\n+   * @return true if the call was successful,\n+   * false if another connection was faster\n+   */\n+  private synchronized boolean reconnectModified(boolean pending) {\n+    if (readOnly || lock == null ||\n+        fileLockMethod != FileLock.LOCK_SERIALIZED) {\n+      return true;\n+    }\n+    try {\n+      if (pending == reconnectChangePending) {\n+        long now = System.nanoTime();\n+        if (now > reconnectCheckNext) {\n+          if (pending) {\n             String pos = pageStore == null ?\n-                    null : \"\" + pageStore.getWriteCountTotal();\n+                null : \"\" + pageStore.getWriteCountTotal();\n             lock.setProperty(\"logPos\", pos);\n-            if (pending) {\n-                lock.setProperty(\"changePending\", \"true-\" + Math.random());\n-            } else {\n-                lock.setProperty(\"changePending\", null);\n-            }\n-            // ensure that the writer thread will\n-            // not reset the flag before we are done\n-            reconnectCheckNext = System.nanoTime() +\n-                    2 * reconnectCheckDelayNs;\n-            old = lock.save();\n-            if (pending) {\n-                trace.debug(\"wait before writing again\");\n-                Thread.sleep(TimeUnit.NANOSECONDS.toMillis((long) (reconnectCheckDelayNs * 1.1)));\n-                Properties now = lock.load();\n-                if (!now.equals(old)) {\n-                    // somebody else was faster\n-                    return false;\n-                }\n-            } else {\n-                Thread.sleep(1);\n-            }\n-            reconnectLastLock = old;\n-            reconnectChangePending = pending;\n-            reconnectCheckNext = System.nanoTime() + reconnectCheckDelayNs;\n-            return true;\n-        } catch (Exception e) {\n-            trace.error(e, \"pending {0}\", pending);\n-            return false;\n-        }\n-    }\n-\n-    public long getNextModificationDataId() {\n-        return modificationDataId.incrementAndGet();\n-    }\n-\n-    public long getModificationMetaId() {\n-        return modificationMetaId.get();\n-    }\n-\n-    public long getNextModificationMetaId() {\n-        // if the meta data has been modified, the data is modified as well\n-        // (because MetaTable returns modificationDataId)\n-        modificationDataId.incrementAndGet();\n-        return modificationMetaId.incrementAndGet() - 1;\n-    }\n-\n-    public int getPowerOffCount() {\n-        return powerOffCount;\n-    }\n-\n-    @Override\n-    public void checkPowerOff() {\n-        if (powerOffCount == 0) {\n-            return;\n-        }\n-        if (powerOffCount > 1) {\n-            powerOffCount--;\n-            return;\n+            lock.save();\n+          }\n+          reconnectCheckNext = now + reconnectCheckDelayNs;\n         }\n-        if (powerOffCount != -1) {\n-            try {\n-                powerOffCount = -1;\n-                stopWriter();\n-                if (mvStore != null) {\n-                    mvStore.closeImmediately();\n-                }\n-                if (pageStore != null) {\n-                    try {\n-                        pageStore.close();\n-                    } catch (DbException e) {\n-                        // ignore\n-                    }\n-                    pageStore = null;\n-                }\n-                if (lock != null) {\n-                    stopServer();\n-                    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n-                        // allow testing shutdown\n-                        lock.unlock();\n-                    }\n-                    lock = null;\n-                }\n-                if (traceSystem != null) {\n-                    traceSystem.close();\n-                }\n-            } catch (DbException e) {\n-                DbException.traceThrowable(e);\n-            }\n+        return true;\n+      }\n+      Properties old = lock.load();\n+      if (pending) {\n+        if (old.getProperty(\"changePending\") != null) {\n+          return false;\n+        }\n+        trace.debug(\"wait before writing\");\n+        Thread.sleep(TimeUnit.NANOSECONDS\n+            .toMillis((long) (reconnectCheckDelayNs * 1.1)));\n+        Properties now = lock.load();\n+        if (!now.equals(old)) {\n+          // somebody else was faster\n+          return false;\n         }\n-        Engine.getInstance().close(databaseName);\n-        throw DbException.get(ErrorCode.DATABASE_IS_CLOSED);\n-    }\n-\n-    /**\n-     * Check if a database with the given name exists.\n-     *\n-     * @param name the name of the database (including path)\n-     * @return true if one exists\n-     */\n-    static boolean exists(String name) {\n-        if (FileUtils.exists(name + Constants.SUFFIX_PAGE_FILE)) {\n-            return true;\n+      }\n+      String pos = pageStore == null ?\n+          null : \"\" + pageStore.getWriteCountTotal();\n+      lock.setProperty(\"logPos\", pos);\n+      if (pending) {\n+        lock.setProperty(\"changePending\", \"true-\" + Math.random());\n+      } else {\n+        lock.setProperty(\"changePending\", null);\n+      }\n+      // ensure that the writer thread will\n+      // not reset the flag before we are done\n+      reconnectCheckNext = System.nanoTime() +\n+          2 * reconnectCheckDelayNs;\n+      old = lock.save();\n+      if (pending) {\n+        trace.debug(\"wait before writing again\");\n+        Thread.sleep(TimeUnit.NANOSECONDS\n+            .toMillis((long) (reconnectCheckDelayNs * 1.1)));\n+        Properties now = lock.load();\n+        if (!now.equals(old)) {\n+          // somebody else was faster\n+          return false;\n+        }\n+      } else {\n+        Thread.sleep(1);\n+      }\n+      reconnectLastLock = old;\n+      reconnectChangePending = pending;\n+      reconnectCheckNext = System.nanoTime() + reconnectCheckDelayNs;\n+      return true;\n+    } catch (Exception e) {\n+      trace.error(e, \"pending {0}\", pending);\n+      return false;\n+    }\n+  }\n+\n+  public long getNextModificationDataId() {\n+    return modificationDataId.incrementAndGet();\n+  }\n+\n+  public long getModificationMetaId() {\n+    return modificationMetaId.get();\n+  }\n+\n+  public long getNextModificationMetaId() {\n+    // if the meta data has been modified, the data is modified as well\n+    // (because MetaTable returns modificationDataId)\n+    modificationDataId.incrementAndGet();\n+    return modificationMetaId.incrementAndGet() - 1;\n+  }\n+\n+  public int getPowerOffCount() {\n+    return powerOffCount;\n+  }\n+\n+  @Override\n+  public void checkPowerOff() {\n+    if (powerOffCount == 0) {\n+      return;\n+    }\n+    if (powerOffCount > 1) {\n+      powerOffCount--;\n+      return;\n+    }\n+    if (powerOffCount != -1) {\n+      try {\n+        powerOffCount = -1;\n+        stopWriter();\n+        if (mvStore != null) {\n+          mvStore.closeImmediately();\n         }\n-        return FileUtils.exists(name + Constants.SUFFIX_MV_FILE);\n-    }\n-\n-    /**\n-     * Get the trace object for the given module id.\n-     *\n-     * @param moduleId the module id\n-     * @return the trace object\n-     */\n-    public Trace getTrace(int moduleId) {\n-        return traceSystem.getTrace(moduleId);\n-    }\n-\n-    @Override\n-    public FileStore openFile(String name, String openMode, boolean mustExist) {\n-        if (mustExist && !FileUtils.exists(name)) {\n-            throw DbException.get(ErrorCode.FILE_NOT_FOUND_1, name);\n+        if (pageStore != null) {\n+          try {\n+            pageStore.close();\n+          } catch (DbException e) {\n+            // ignore\n+          }\n+          pageStore = null;\n         }\n-        FileStore store = FileStore.open(this, name, openMode, cipher,\n-                filePasswordHash);\n-        try {\n-            store.init();\n-        } catch (DbException e) {\n-            store.closeSilently();\n-            throw e;\n+        if (lock != null) {\n+          stopServer();\n+          if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n+            // allow testing shutdown\n+            lock.unlock();\n+          }\n+          lock = null;\n         }\n-        return store;\n-    }\n-\n-    /**\n-     * Check if the file password hash is correct.\n-     *\n-     * @param testCipher the cipher algorithm\n-     * @param testHash the hash code\n-     * @return true if the cipher algorithm and the password match\n-     */\n-    boolean validateFilePasswordHash(String testCipher, byte[] testHash) {\n-        if (!StringUtils.equals(testCipher, this.cipher)) {\n-            return false;\n+        if (traceSystem != null) {\n+          traceSystem.close();\n         }\n-        return Utils.compareSecure(testHash, filePasswordHash);\n+      } catch (DbException e) {\n+        DbException.traceThrowable(e);\n+      }\n     }\n-\n-    private String parseDatabaseShortName() {\n-        String n = databaseName;\n-        if (n.endsWith(\":\")) {\n-            n = null;\n-        }\n-        if (n != null) {\n-            StringTokenizer tokenizer = new StringTokenizer(n, \"/\\\\:,;\");\n-            while (tokenizer.hasMoreTokens()) {\n-                n = tokenizer.nextToken();\n-            }\n-        }\n-        if (n == null || n.length() == 0) {\n-            n = \"unnamed\";\n-        }\n-        return dbSettings.databaseToUpper ? StringUtils.toUpperEnglish(n) : n;\n-    }\n-\n-    private synchronized void open(int traceLevelFile, int traceLevelSystemOut) {\n-        if (persistent) {\n-            String dataFileName = databaseName + Constants.SUFFIX_OLD_DATABASE_FILE;\n-            boolean existsData = FileUtils.exists(dataFileName);\n-            String pageFileName = databaseName + Constants.SUFFIX_PAGE_FILE;\n-            String mvFileName = databaseName + Constants.SUFFIX_MV_FILE;\n-            boolean existsPage = FileUtils.exists(pageFileName);\n-            boolean existsMv = FileUtils.exists(mvFileName);\n-            if (existsData && (!existsPage && !existsMv)) {\n-                throw DbException.get(\n-                        ErrorCode.FILE_VERSION_ERROR_1, \"Old database: \" +\n-                        dataFileName +\n-                        \" - please convert the database \" +\n-                        \"to a SQL script and re-create it.\");\n-            }\n-            if (existsPage && !FileUtils.canWrite(pageFileName)) {\n-                readOnly = true;\n-            }\n-            if (existsMv && !FileUtils.canWrite(mvFileName)) {\n-                readOnly = true;\n-            }\n-            if (existsPage && !existsMv) {\n-                dbSettings.mvStore = false;\n-            }\n-            if (readOnly) {\n-                if (traceLevelFile >= TraceSystem.DEBUG) {\n-                    String traceFile = Utils.getProperty(\"java.io.tmpdir\", \".\") +\n-                            \"/\" + \"h2_\" + System.currentTimeMillis();\n-                    traceSystem = new TraceSystem(traceFile +\n-                            Constants.SUFFIX_TRACE_FILE);\n-                } else {\n-                    traceSystem = new TraceSystem(null);\n-                }\n-            } else {\n-                traceSystem = new TraceSystem(databaseName +\n-                        Constants.SUFFIX_TRACE_FILE);\n-            }\n-            traceSystem.setLevelFile(traceLevelFile);\n-            traceSystem.setLevelSystemOut(traceLevelSystemOut);\n-            trace = traceSystem.getTrace(Trace.DATABASE);\n-            trace.info(\"opening {0} (build {1})\", databaseName, Constants.BUILD_ID);\n-            if (autoServerMode) {\n-                if (readOnly ||\n-                        fileLockMethod == FileLock.LOCK_NO ||\n-                        fileLockMethod == FileLock.LOCK_SERIALIZED ||\n-                        fileLockMethod == FileLock.LOCK_FS ||\n-                        !persistent) {\n-                    throw DbException.getUnsupportedException(\n-                            \"autoServerMode && (readOnly || \" +\n-                            \"fileLockMethod == NO || \" +\n-                            \"fileLockMethod == SERIALIZED || \" +\n-                            \"fileLockMethod == FS || \" +\n-                            \"inMemory)\");\n-                }\n-            }\n-            String lockFileName = databaseName + Constants.SUFFIX_LOCK_FILE;\n-            if (readOnly) {\n-                if (FileUtils.exists(lockFileName)) {\n-                    throw DbException.get(ErrorCode.DATABASE_ALREADY_OPEN_1,\n-                            \"Lock file exists: \" + lockFileName);\n-                }\n-            }\n-            if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {\n-                if (fileLockMethod != FileLock.LOCK_FS) {\n-                    lock = new FileLock(traceSystem, lockFileName, Constants.LOCK_SLEEP);\n-                    lock.lock(fileLockMethod);\n-                    if (autoServerMode) {\n-                        startServer(lock.getUniqueId());\n-                    }\n-                }\n-            }\n-            if (SysProperties.MODIFY_ON_WRITE) {\n-                while (isReconnectNeeded()) {\n-                    // wait until others stopped writing\n-                }\n-            } else {\n-                while (isReconnectNeeded() && !beforeWriting()) {\n-                    // wait until others stopped writing and\n-                    // until we can write (the file is not yet open -\n-                    // no need to re-connect)\n-                }\n-            }\n-            deleteOldTempFiles();\n-            starting = true;\n-            if (SysProperties.MODIFY_ON_WRITE) {\n-                try {\n-                    getPageStore();\n-                } catch (DbException e) {\n-                    if (e.getErrorCode() != ErrorCode.DATABASE_IS_READ_ONLY) {\n-                        throw e;\n-                    }\n-                    pageStore = null;\n-                    while (!beforeWriting()) {\n-                        // wait until others stopped writing and\n-                        // until we can write (the file is not yet open -\n-                        // no need to re-connect)\n-                    }\n-                    getPageStore();\n-                }\n-            } else {\n-                getPageStore();\n-            }\n-            starting = false;\n-            if (mvStore == null) {\n-                writer = WriterThread.create(this, writeDelay);\n-            } else {\n-                setWriteDelay(writeDelay);\n-            }\n+    Engine.getInstance().close(databaseName);\n+    throw DbException.get(ErrorCode.DATABASE_IS_CLOSED);\n+  }\n+\n+  /**\n+   * Check if a database with the given name exists.\n+   *\n+   * @param name the name of the database (including path)\n+   * @return true if one exists\n+   */\n+  static boolean exists(String name) {\n+    if (FileUtils.exists(name + Constants.SUFFIX_PAGE_FILE)) {\n+      return true;\n+    }\n+    return FileUtils.exists(name + Constants.SUFFIX_MV_FILE);\n+  }\n+\n+  /**\n+   * Get the trace object for the given module id.\n+   *\n+   * @param moduleId the module id\n+   * @return the trace object\n+   */\n+  public Trace getTrace(int moduleId) {\n+    return traceSystem.getTrace(moduleId);\n+  }\n+\n+  @Override\n+  public FileStore openFile(String name, String openMode, boolean mustExist) {\n+    if (mustExist && !FileUtils.exists(name)) {\n+      throw DbException.get(ErrorCode.FILE_NOT_FOUND_1, name);\n+    }\n+    FileStore store = FileStore.open(this, name, openMode, cipher,\n+        filePasswordHash);\n+    try {\n+      store.init();\n+    } catch (DbException e) {\n+      store.closeSilently();\n+      throw e;\n+    }\n+    return store;\n+  }\n+\n+  /**\n+   * Check if the file password hash is correct.\n+   *\n+   * @param testCipher the cipher algorithm\n+   * @param testHash   the hash code\n+   * @return true if the cipher algorithm and the password match\n+   */\n+  boolean validateFilePasswordHash(String testCipher, byte[] testHash) {\n+    if (!StringUtils.equals(testCipher, this.cipher)) {\n+      return false;\n+    }\n+    return Utils.compareSecure(testHash, filePasswordHash);\n+  }\n+\n+  private String parseDatabaseShortName() {\n+    String n = databaseName;\n+    if (n.endsWith(\":\")) {\n+      n = null;\n+    }\n+    if (n != null) {\n+      StringTokenizer tokenizer = new StringTokenizer(n, \"/\\\\:,;\");\n+      while (tokenizer.hasMoreTokens()) {\n+        n = tokenizer.nextToken();\n+      }\n+    }\n+    if (n == null || n.length() == 0) {\n+      n = \"unnamed\";\n+    }\n+    return dbSettings.databaseToUpper ? StringUtils.toUpperEnglish(n) : n;\n+  }\n+\n+  private synchronized void open(int traceLevelFile, int traceLevelSystemOut) {\n+    if (persistent) {\n+      String dataFileName = databaseName + Constants.SUFFIX_OLD_DATABASE_FILE;\n+      boolean existsData = FileUtils.exists(dataFileName);\n+      String pageFileName = databaseName + Constants.SUFFIX_PAGE_FILE;\n+      String mvFileName = databaseName + Constants.SUFFIX_MV_FILE;\n+      boolean existsPage = FileUtils.exists(pageFileName);\n+      boolean existsMv = FileUtils.exists(mvFileName);\n+      if (existsData && (!existsPage && !existsMv)) {\n+        throw DbException.get(\n+            ErrorCode.FILE_VERSION_ERROR_1, \"Old database: \" +\n+                dataFileName +\n+                \" - please convert the database \" +\n+                \"to a SQL script and re-create it.\");\n+      }\n+      if (existsPage && !FileUtils.canWrite(pageFileName)) {\n+        readOnly = true;\n+      }\n+      if (existsMv && !FileUtils.canWrite(mvFileName)) {\n+        readOnly = true;\n+      }\n+      if (existsPage && !existsMv) {\n+        dbSettings.mvStore = false;\n+      }\n+      if (readOnly) {\n+        if (traceLevelFile >= TraceSystem.DEBUG) {\n+          String traceFile = Utils.getProperty(\"java.io.tmpdir\", \".\") +\n+              \"/\" + \"h2_\" + System.currentTimeMillis();\n+          traceSystem = new TraceSystem(traceFile +\n+              Constants.SUFFIX_TRACE_FILE);\n         } else {\n-            if (autoServerMode) {\n-                throw DbException.getUnsupportedException(\n-                        \"autoServerMode && inMemory\");\n-            }\n-            traceSystem = new TraceSystem(null);\n-            trace = traceSystem.getTrace(Trace.DATABASE);\n-            if (dbSettings.mvStore) {\n-                getPageStore();\n-            }\n-        }\n-        systemUser = new User(this, 0, SYSTEM_USER_NAME, true);\n-        mainSchema = new Schema(this, 0, Constants.SCHEMA_MAIN, systemUser, true);\n-        infoSchema = new Schema(this, -1, \"INFORMATION_SCHEMA\", systemUser, true);\n-        schemas.put(mainSchema.getName(), mainSchema);\n-        schemas.put(infoSchema.getName(), infoSchema);\n-        publicRole = new Role(this, 0, Constants.PUBLIC_ROLE_NAME, true);\n-        roles.put(Constants.PUBLIC_ROLE_NAME, publicRole);\n-        systemUser.setAdmin(true);\n-        systemSession = new Session(this, systemUser, ++nextSessionId);\n-        lobSession = new Session(this, systemUser, ++nextSessionId);\n-        CreateTableData data = new CreateTableData();\n-        ArrayList<Column> cols = data.columns;\n-        Column columnId = new Column(\"ID\", Value.INT);\n-        columnId.setNullable(false);\n-        cols.add(columnId);\n-        cols.add(new Column(\"HEAD\", Value.INT));\n-        cols.add(new Column(\"TYPE\", Value.INT));\n-        cols.add(new Column(\"SQL\", Value.STRING));\n-        boolean create = true;\n-        if (pageStore != null) {\n-            create = pageStore.isNew();\n+          traceSystem = new TraceSystem(null);\n         }\n-        data.tableName = \"SYS\";\n-        data.id = 0;\n-        data.temporary = false;\n-        data.persistData = persistent;\n-        data.persistIndexes = persistent;\n-        data.create = create;\n-        data.isHidden = true;\n-        data.session = systemSession;\n-        meta = mainSchema.createTable(data);\n-        IndexColumn[] pkCols = IndexColumn.wrap(new Column[] { columnId });\n-        metaIdIndex = meta.addIndex(systemSession, \"SYS_ID\",\n-                0, pkCols, IndexType.createPrimaryKey(\n-                false, false), true, null);\n-        objectIds.set(0);\n-        starting = true;\n-        Cursor cursor = metaIdIndex.find(systemSession, null, null);\n-        ArrayList<MetaRecord> records = New.arrayList();\n-        while (cursor.next()) {\n-            MetaRecord rec = new MetaRecord(cursor.get());\n-            objectIds.set(rec.getId());\n-            records.add(rec);\n+      } else {\n+        traceSystem = new TraceSystem(databaseName +\n+            Constants.SUFFIX_TRACE_FILE);\n+      }\n+      traceSystem.setLevelFile(traceLevelFile);\n+      traceSystem.setLevelSystemOut(traceLevelSystemOut);\n+      trace = traceSystem.getTrace(Trace.DATABASE);\n+      trace.info(\"opening {0} (build {1})\", databaseName, Constants.BUILD_ID);\n+      if (autoServerMode) {\n+        if (readOnly ||\n+            fileLockMethod == FileLock.LOCK_NO ||\n+            fileLockMethod == FileLock.LOCK_SERIALIZED ||\n+            fileLockMethod == FileLock.LOCK_FS ||\n+            !persistent) {\n+          throw DbException.getUnsupportedException(\n+              \"autoServerMode && (readOnly || \" +\n+                  \"fileLockMethod == NO || \" +\n+                  \"fileLockMethod == SERIALIZED || \" +\n+                  \"fileLockMethod == FS || \" +\n+                  \"inMemory)\");\n         }\n-        Collections.sort(records);\n-        synchronized (systemSession) {\n-            for (MetaRecord rec : records) {\n-                rec.execute(this, systemSession, eventListener);\n-            }\n+      }\n+      String lockFileName = databaseName + Constants.SUFFIX_LOCK_FILE;\n+      if (readOnly) {\n+        if (FileUtils.exists(lockFileName)) {\n+          throw DbException.get(ErrorCode.DATABASE_ALREADY_OPEN_1,\n+              \"Lock file exists: \" + lockFileName);\n         }\n-        if (mvStore != null) {\n-            mvStore.initTransactions();\n-            mvStore.removeTemporaryMaps(objectIds);\n+      }\n+      if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {\n+        if (fileLockMethod != FileLock.LOCK_FS) {\n+          lock = new FileLock(traceSystem, lockFileName, Constants.LOCK_SLEEP);\n+          lock.lock(fileLockMethod);\n+          if (autoServerMode) {\n+            startServer(lock.getUniqueId());\n+          }\n         }\n-        recompileInvalidViews(systemSession);\n-        starting = false;\n-        if (!readOnly) {\n-            // set CREATE_BUILD in a new database\n-            String name = SetTypes.getTypeName(SetTypes.CREATE_BUILD);\n-            if (settings.get(name) == null) {\n-                Setting setting = new Setting(this, allocateObjectId(), name);\n-                setting.setIntValue(Constants.BUILD_ID);\n-                lockMeta(systemSession);\n-                addDatabaseObject(systemSession, setting);\n-            }\n-            // mark all ids used in the page store\n-            if (pageStore != null) {\n-                BitField f = pageStore.getObjectIds();\n-                for (int i = 0, len = f.length(); i < len; i++) {\n-                    if (f.get(i) && !objectIds.get(i)) {\n-                        trace.info(\"unused object id: \" + i);\n-                        objectIds.set(i);\n-                    }\n-                }\n-            }\n+      }\n+      if (SysProperties.MODIFY_ON_WRITE) {\n+        while (isReconnectNeeded()) {\n+          // wait until others stopped writing\n         }\n-        getLobStorage().init();\n-        systemSession.commit(true);\n-\n-        trace.info(\"opened {0}\", databaseName);\n-        if (checkpointAllowed > 0) {\n-            afterWriting();\n+      } else {\n+        while (isReconnectNeeded() && !beforeWriting()) {\n+          // wait until others stopped writing and\n+          // until we can write (the file is not yet open -\n+          // no need to re-connect)\n         }\n-    }\n-\n-    private void startServer(String key) {\n+      }\n+      deleteOldTempFiles();\n+      starting = true;\n+      if (SysProperties.MODIFY_ON_WRITE) {\n         try {\n-            server = Server.createTcpServer(\n-                    \"-tcpPort\", Integer.toString(autoServerPort),\n-                    \"-tcpAllowOthers\",\n-                    \"-tcpDaemon\",\n-                    \"-key\", key, databaseName);\n-            server.start();\n-        } catch (SQLException e) {\n-            throw DbException.convert(e);\n-        }\n-        String localAddress = NetUtils.getLocalAddress();\n-        String address = localAddress + \":\" + server.getPort();\n-        lock.setProperty(\"server\", address);\n-        String hostName = NetUtils.getHostName(localAddress);\n-        lock.setProperty(\"hostName\", hostName);\n-        lock.save();\n-    }\n-\n-    private void stopServer() {\n-        if (server != null) {\n-            Server s = server;\n-            // avoid calling stop recursively\n-            // because stopping the server will\n-            // try to close the database as well\n-            server = null;\n-            s.stop();\n-        }\n+          getPageStore();\n+        } catch (DbException e) {\n+          if (e.getErrorCode() != ErrorCode.DATABASE_IS_READ_ONLY) {\n+            throw e;\n+          }\n+          pageStore = null;\n+          while (!beforeWriting()) {\n+            // wait until others stopped writing and\n+            // until we can write (the file is not yet open -\n+            // no need to re-connect)\n+          }\n+          getPageStore();\n+        }\n+      } else {\n+        getPageStore();\n+      }\n+      starting = false;\n+      if (mvStore == null) {\n+        writer = WriterThread.create(this, writeDelay);\n+      } else {\n+        setWriteDelay(writeDelay);\n+      }\n+    } else {\n+      if (autoServerMode) {\n+        throw DbException.getUnsupportedException(\n+            \"autoServerMode && inMemory\");\n+      }\n+      traceSystem = new TraceSystem(null);\n+      trace = traceSystem.getTrace(Trace.DATABASE);\n+      if (dbSettings.mvStore) {\n+        getPageStore();\n+      }\n     }\n-\n-    private void recompileInvalidViews(Session session) {\n-        boolean atLeastOneRecompiledSuccessfully;\n-        do {\n-            atLeastOneRecompiledSuccessfully = false;\n-            for (Table obj : getAllTablesAndViews(false)) {\n-                if (obj instanceof TableView) {\n-                    TableView view = (TableView) obj;\n-                    if (view.isInvalid()) {\n-                        view.recompile(session, true, false);\n-                        if (!view.isInvalid()) {\n-                            atLeastOneRecompiledSuccessfully = true;\n-                        }\n-                    }\n-                }\n-            }\n-        } while (atLeastOneRecompiledSuccessfully);\n-        TableView.clearIndexCaches(session.getDatabase());\n+    systemUser = new User(this, 0, SYSTEM_USER_NAME, true);\n+    mainSchema = new Schema(this, 0, Constants.SCHEMA_MAIN, systemUser, true);\n+    infoSchema = new Schema(this, -1, \"INFORMATION_SCHEMA\", systemUser, true);\n+    schemas.put(mainSchema.getName(), mainSchema);\n+    schemas.put(infoSchema.getName(), infoSchema);\n+    publicRole = new Role(this, 0, Constants.PUBLIC_ROLE_NAME, true);\n+    roles.put(Constants.PUBLIC_ROLE_NAME, publicRole);\n+    systemUser.setAdmin(true);\n+    systemSession = new Session(this, systemUser, ++nextSessionId);\n+    lobSession = new Session(this, systemUser, ++nextSessionId);\n+    CreateTableData data = new CreateTableData();\n+    ArrayList<Column> cols = data.columns;\n+    Column columnId = new Column(\"ID\", Value.INT);\n+    columnId.setNullable(false);\n+    cols.add(columnId);\n+    cols.add(new Column(\"HEAD\", Value.INT));\n+    cols.add(new Column(\"TYPE\", Value.INT));\n+    cols.add(new Column(\"SQL\", Value.STRING));\n+    boolean create = true;\n+    if (pageStore != null) {\n+      create = pageStore.isNew();\n+    }\n+    data.tableName = \"SYS\";\n+    data.id = 0;\n+    data.temporary = false;\n+    data.persistData = persistent;\n+    data.persistIndexes = persistent;\n+    data.create = create;\n+    data.isHidden = true;\n+    data.session = systemSession;\n+    meta = mainSchema.createTable(data);\n+    IndexColumn[] pkCols = IndexColumn.wrap(new Column[] {columnId});\n+    metaIdIndex = meta.addIndex(systemSession, \"SYS_ID\",\n+        0, pkCols, IndexType.createPrimaryKey(\n+            false, false), true, null);\n+    objectIds.set(0);\n+    starting = true;\n+    Cursor cursor = metaIdIndex.find(systemSession, null, null);\n+    ArrayList<MetaRecord> records = New.arrayList();\n+    while (cursor.next()) {\n+      MetaRecord rec = new MetaRecord(cursor.get());\n+      objectIds.set(rec.getId());\n+      records.add(rec);\n+    }\n+    Collections.sort(records);\n+    synchronized (systemSession) {\n+      for (MetaRecord rec : records) {\n+        rec.execute(this, systemSession, eventListener);\n+      }\n     }\n-\n-    private void initMetaTables() {\n-        if (metaTablesInitialized) {\n-            return;\n-        }\n-        synchronized (infoSchema) {\n-            if (!metaTablesInitialized) {\n-                for (int type = 0, count = MetaTable.getMetaTableTypeCount();\n-                        type < count; type++) {\n-                    MetaTable m = new MetaTable(infoSchema, -1 - type, type);\n-                    infoSchema.add(m);\n-                }\n-                metaTablesInitialized = true;\n-            }\n+    if (mvStore != null) {\n+      mvStore.initTransactions();\n+      mvStore.removeTemporaryMaps(objectIds);\n+    }\n+    recompileInvalidViews(systemSession);\n+    starting = false;\n+    if (!readOnly) {\n+      // set CREATE_BUILD in a new database\n+      String name = SetTypes.getTypeName(SetTypes.CREATE_BUILD);\n+      if (settings.get(name) == null) {\n+        Setting setting = new Setting(this, allocateObjectId(), name);\n+        setting.setIntValue(Constants.BUILD_ID);\n+        lockMeta(systemSession);\n+        addDatabaseObject(systemSession, setting);\n+      }\n+      // mark all ids used in the page store\n+      if (pageStore != null) {\n+        BitField f = pageStore.getObjectIds();\n+        for (int i = 0, len = f.length(); i < len; i++) {\n+          if (f.get(i) && !objectIds.get(i)) {\n+            trace.info(\"unused object id: \" + i);\n+            objectIds.set(i);\n+          }\n         }\n+      }\n     }\n-\n-    private synchronized void addMeta(Session session, DbObject obj) {\n-        int id = obj.getId();\n-        if (id > 0 && !starting && !obj.isTemporary()) {\n-            Row r = meta.getTemplateRow();\n-            MetaRecord rec = new MetaRecord(obj);\n-            rec.setRecord(r);\n-            objectIds.set(id);\n-            if (SysProperties.CHECK) {\n-                verifyMetaLocked(session);\n-            }\n-            meta.addRow(session, r);\n-            if (isMultiVersion()) {\n-                // TODO this should work without MVCC, but avoid risks at the\n-                // moment\n-                session.log(meta, UndoLogRecord.INSERT, r);\n-            }\n+    getLobStorage().init();\n+    systemSession.commit(true);\n+\n+    trace.info(\"opened {0}\", databaseName);\n+    if (checkpointAllowed > 0) {\n+      afterWriting();\n+    }\n+  }\n+\n+  private void startServer(String key) {\n+    try {\n+      server = Server.createTcpServer(\n+          \"-tcpPort\", Integer.toString(autoServerPort),\n+          \"-tcpAllowOthers\",\n+          \"-tcpDaemon\",\n+          \"-key\", key, databaseName);\n+      server.start();\n+    } catch (SQLException e) {\n+      throw DbException.convert(e);\n+    }\n+    String localAddress = NetUtils.getLocalAddress();\n+    String address = localAddress + \":\" + server.getPort();\n+    lock.setProperty(\"server\", address);\n+    String hostName = NetUtils.getHostName(localAddress);\n+    lock.setProperty(\"hostName\", hostName);\n+    lock.save();\n+  }\n+\n+  private void stopServer() {\n+    if (server != null) {\n+      Server s = server;\n+      // avoid calling stop recursively\n+      // because stopping the server will\n+      // try to close the database as well\n+      server = null;\n+      s.stop();\n+    }\n+  }\n+\n+  private void recompileInvalidViews(Session session) {\n+    boolean atLeastOneRecompiledSuccessfully;\n+    do {\n+      atLeastOneRecompiledSuccessfully = false;\n+      for (Table obj : getAllTablesAndViews(false)) {\n+        if (obj instanceof TableView) {\n+          TableView view = (TableView) obj;\n+          if (view.isInvalid()) {\n+            view.recompile(session, true, false);\n+            if (!view.isInvalid()) {\n+              atLeastOneRecompiledSuccessfully = true;\n+            }\n+          }\n         }\n+      }\n+    } while (atLeastOneRecompiledSuccessfully);\n+    TableView.clearIndexCaches(session.getDatabase());\n+  }\n+\n+  private void initMetaTables() {\n+    if (metaTablesInitialized) {\n+      return;\n+    }\n+    synchronized (infoSchema) {\n+      if (!metaTablesInitialized) {\n+        for (int type = 0, count = MetaTable.getMetaTableTypeCount();\n+             type < count; type++) {\n+          MetaTable m = new MetaTable(infoSchema, -1 - type, type);\n+          infoSchema.add(m);\n+        }\n+        metaTablesInitialized = true;\n+      }\n     }\n-\n-    /**\n-     * Verify the meta table is locked.\n-     *\n-     * @param session the session\n-     */\n-    public void verifyMetaLocked(Session session) {\n-        if (meta != null && !meta.isLockedExclusivelyBy(session)\n-                && lockMode != Constants.LOCK_MODE_OFF) {\n+  }\n+\n+  private synchronized void addMeta(Session session, DbObject obj) {\n+    int id = obj.getId();\n+    if (id > 0 && !starting && !obj.isTemporary()) {\n+      Row r = meta.getTemplateRow();\n+      MetaRecord rec = new MetaRecord(obj);\n+      rec.setRecord(r);\n+      objectIds.set(id);\n+      if (SysProperties.CHECK) {\n+        verifyMetaLocked(session);\n+      }\n+      meta.addRow(session, r);\n+      if (isMultiVersion()) {\n+        // TODO this should work without MVCC, but avoid risks at the\n+        // moment\n+        session.log(meta, UndoLogRecord.INSERT, r);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Verify the meta table is locked.\n+   *\n+   * @param session the session\n+   */\n+  public void verifyMetaLocked(Session session) {\n+    if (meta != null && !meta.isLockedExclusivelyBy(session)\n+        && lockMode != Constants.LOCK_MODE_OFF) {\n+      throw DbException.throwInternalError();\n+    }\n+  }\n+\n+  /**\n+   * Lock the metadata table for updates.\n+   *\n+   * @param session the session\n+   * @return whether it was already locked before by this session\n+   */\n+  public boolean lockMeta(Session session) {\n+    // this method can not be synchronized on the database object,\n+    // as unlocking is also synchronized on the database object -\n+    // so if locking starts just before unlocking, locking could\n+    // never be successful\n+    if (meta == null) {\n+      return true;\n+    }\n+    boolean wasLocked = meta.lock(session, true, true);\n+    return wasLocked;\n+  }\n+\n+  /**\n+   * Unlock the metadata table.\n+   *\n+   * @param session the session\n+   */\n+  public void unlockMeta(Session session) {\n+    meta.unlock(session);\n+    session.unlock(meta);\n+  }\n+\n+  /**\n+   * Remove the given object from the meta data.\n+   *\n+   * @param session the session\n+   * @param id      the id of the object to remove\n+   */\n+  public synchronized void removeMeta(Session session, int id) {\n+    if (id > 0 && !starting) {\n+      SearchRow r = meta.getTemplateSimpleRow(false);\n+      r.setValue(0, ValueInt.get(id));\n+      boolean wasLocked = lockMeta(session);\n+      Cursor cursor = metaIdIndex.find(session, r, r);\n+      if (cursor.next()) {\n+        if (SysProperties.CHECK) {\n+          if (lockMode != Constants.LOCK_MODE_OFF && !wasLocked) {\n             throw DbException.throwInternalError();\n+          }\n         }\n-    }\n-\n-    /**\n-     * Lock the metadata table for updates.\n-     *\n-     * @param session the session\n-     * @return whether it was already locked before by this session\n-     */\n-    public boolean lockMeta(Session session) {\n-        // this method can not be synchronized on the database object,\n-        // as unlocking is also synchronized on the database object -\n-        // so if locking starts just before unlocking, locking could\n-        // never be successful\n-        if (meta == null) {\n-            return true;\n+        Row found = cursor.get();\n+        meta.removeRow(session, found);\n+        if (isMultiVersion()) {\n+          // TODO this should work without MVCC, but avoid risks at\n+          // the moment\n+          session.log(meta, UndoLogRecord.DELETE, found);\n         }\n-        boolean wasLocked = meta.lock(session, true, true);\n-        return wasLocked;\n-    }\n-\n-    /**\n-     * Unlock the metadata table.\n-     *\n-     * @param session the session\n-     */\n-    public void unlockMeta(Session session) {\n+        if (SysProperties.CHECK) {\n+          checkMetaFree(session, id);\n+        }\n+      } else if (!wasLocked) {\n+        // must not keep the lock if it was not locked\n+        // otherwise updating sequences may cause a deadlock\n         meta.unlock(session);\n         session.unlock(meta);\n+      }\n+      objectIds.clear(id);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private HashMap<String, DbObject> getMap(int type) {\n+    HashMap<String, ? extends DbObject> result;\n+    switch (type) {\n+      case DbObject.USER:\n+        result = users;\n+        break;\n+      case DbObject.SETTING:\n+        result = settings;\n+        break;\n+      case DbObject.ROLE:\n+        result = roles;\n+        break;\n+      case DbObject.RIGHT:\n+        result = rights;\n+        break;\n+      case DbObject.SCHEMA:\n+        result = schemas;\n+        break;\n+      case DbObject.USER_DATATYPE:\n+        result = userDataTypes;\n+        break;\n+      case DbObject.COMMENT:\n+        result = comments;\n+        break;\n+      case DbObject.AGGREGATE:\n+        result = aggregates;\n+        break;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + type);\n+    }\n+    return (HashMap<String, DbObject>) result;\n+  }\n+\n+  /**\n+   * Add a schema object to the database.\n+   *\n+   * @param session the session\n+   * @param obj     the object to add\n+   */\n+  public void addSchemaObject(Session session, SchemaObject obj) {\n+    int id = obj.getId();\n+    if (id > 0 && !starting) {\n+      checkWritingAllowed();\n+    }\n+    lockMeta(session);\n+    synchronized (this) {\n+      obj.getSchema().add(obj);\n+      addMeta(session, obj);\n+    }\n+  }\n+\n+  /**\n+   * Add an object to the database.\n+   *\n+   * @param session the session\n+   * @param obj     the object to add\n+   */\n+  public synchronized void addDatabaseObject(Session session, DbObject obj) {\n+    int id = obj.getId();\n+    if (id > 0 && !starting) {\n+      checkWritingAllowed();\n+    }\n+    HashMap<String, DbObject> map = getMap(obj.getType());\n+    if (obj.getType() == DbObject.USER) {\n+      User user = (User) obj;\n+      if (user.isAdmin() && systemUser.getName().equals(SYSTEM_USER_NAME)) {\n+        systemUser.rename(user.getName());\n+      }\n     }\n-\n-    /**\n-     * Remove the given object from the meta data.\n-     *\n-     * @param session the session\n-     * @param id the id of the object to remove\n-     */\n-    public synchronized void removeMeta(Session session, int id) {\n-        if (id > 0 && !starting) {\n-            SearchRow r = meta.getTemplateSimpleRow(false);\n-            r.setValue(0, ValueInt.get(id));\n-            boolean wasLocked = lockMeta(session);\n-            Cursor cursor = metaIdIndex.find(session, r, r);\n-            if (cursor.next()) {\n-                if (SysProperties.CHECK) {\n-                    if (lockMode != Constants.LOCK_MODE_OFF && !wasLocked) {\n-                        throw DbException.throwInternalError();\n-                    }\n-                }\n-                Row found = cursor.get();\n-                meta.removeRow(session, found);\n-                if (isMultiVersion()) {\n-                    // TODO this should work without MVCC, but avoid risks at\n-                    // the moment\n-                    session.log(meta, UndoLogRecord.DELETE, found);\n-                }\n-                if (SysProperties.CHECK) {\n-                    checkMetaFree(session, id);\n-                }\n-            } else if (!wasLocked) {\n-                // must not keep the lock if it was not locked\n-                // otherwise updating sequences may cause a deadlock\n-                meta.unlock(session);\n-                session.unlock(meta);\n-            }\n-            objectIds.clear(id);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private HashMap<String, DbObject> getMap(int type) {\n-        HashMap<String, ? extends DbObject> result;\n-        switch (type) {\n-        case DbObject.USER:\n-            result = users;\n-            break;\n-        case DbObject.SETTING:\n-            result = settings;\n-            break;\n-        case DbObject.ROLE:\n-            result = roles;\n-            break;\n-        case DbObject.RIGHT:\n-            result = rights;\n-            break;\n-        case DbObject.SCHEMA:\n-            result = schemas;\n-            break;\n-        case DbObject.USER_DATATYPE:\n-            result = userDataTypes;\n-            break;\n-        case DbObject.COMMENT:\n-            result = comments;\n-            break;\n-        case DbObject.AGGREGATE:\n-            result = aggregates;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        return (HashMap<String, DbObject>) result;\n-    }\n-\n-    /**\n-     * Add a schema object to the database.\n-     *\n-     * @param session the session\n-     * @param obj the object to add\n-     */\n-    public void addSchemaObject(Session session, SchemaObject obj) {\n-        int id = obj.getId();\n-        if (id > 0 && !starting) {\n-            checkWritingAllowed();\n-        }\n-        lockMeta(session);\n-        synchronized (this) {\n-            obj.getSchema().add(obj);\n-            addMeta(session, obj);\n-        }\n+    String name = obj.getName();\n+    if (SysProperties.CHECK && map.get(name) != null) {\n+      DbException.throwInternalError(\"object already exists\");\n+    }\n+    lockMeta(session);\n+    addMeta(session, obj);\n+    map.put(name, obj);\n+  }\n+\n+  /**\n+   * Get the user defined aggregate function if it exists, or null if not.\n+   *\n+   * @param name the name of the user defined aggregate function\n+   * @return the aggregate function or null\n+   */\n+  public UserAggregate findAggregate(String name) {\n+    return aggregates.get(name);\n+  }\n+\n+  /**\n+   * Get the comment for the given database object if one exists, or null if\n+   * not.\n+   *\n+   * @param object the database object\n+   * @return the comment or null\n+   */\n+  public Comment findComment(DbObject object) {\n+    if (object.getType() == DbObject.COMMENT) {\n+      return null;\n+    }\n+    String key = Comment.getKey(object);\n+    return comments.get(key);\n+  }\n+\n+  /**\n+   * Get the role if it exists, or null if not.\n+   *\n+   * @param roleName the name of the role\n+   * @return the role or null\n+   */\n+  public Role findRole(String roleName) {\n+    return roles.get(roleName);\n+  }\n+\n+  /**\n+   * Get the schema if it exists, or null if not.\n+   *\n+   * @param schemaName the name of the schema\n+   * @return the schema or null\n+   */\n+  public Schema findSchema(String schemaName) {\n+    Schema schema = schemas.get(schemaName);\n+    if (schema == infoSchema) {\n+      initMetaTables();\n+    }\n+    return schema;\n+  }\n+\n+  /**\n+   * Get the setting if it exists, or null if not.\n+   *\n+   * @param name the name of the setting\n+   * @return the setting or null\n+   */\n+  public Setting findSetting(String name) {\n+    return settings.get(name);\n+  }\n+\n+  /**\n+   * Get the user if it exists, or null if not.\n+   *\n+   * @param name the name of the user\n+   * @return the user or null\n+   */\n+  public User findUser(String name) {\n+    return users.get(name);\n+  }\n+\n+  /**\n+   * Get the user defined data type if it exists, or null if not.\n+   *\n+   * @param name the name of the user defined data type\n+   * @return the user defined data type or null\n+   */\n+  public UserDataType findUserDataType(String name) {\n+    return userDataTypes.get(name);\n+  }\n+\n+  /**\n+   * Get user with the given name. This method throws an exception if the user\n+   * does not exist.\n+   *\n+   * @param name the user name\n+   * @return the user\n+   * @throws DbException if the user does not exist\n+   */\n+  public User getUser(String name) {\n+    User user = findUser(name);\n+    if (user == null) {\n+      throw DbException.get(ErrorCode.USER_NOT_FOUND_1, name);\n+    }\n+    return user;\n+  }\n+\n+  /**\n+   * Create a session for the given user.\n+   *\n+   * @param user the user\n+   * @return the session, or null if the database is currently closing\n+   * @throws DbException if the database is in exclusive mode\n+   */\n+  synchronized Session createSession(User user) {\n+    if (closing) {\n+      return null;\n+    }\n+    if (exclusiveSession.get() != null) {\n+      throw DbException.get(ErrorCode.DATABASE_IS_IN_EXCLUSIVE_MODE);\n+    }\n+    Session session = new Session(this, user, ++nextSessionId);\n+    userSessions.add(session);\n+    trace.info(\"connecting session #{0} to {1}\", session.getId(), databaseName);\n+    if (delayedCloser != null) {\n+      delayedCloser.reset();\n+      delayedCloser = null;\n+    }\n+    return session;\n+  }\n+\n+  /**\n+   * Remove a session. This method is called after the user has disconnected.\n+   *\n+   * @param session the session\n+   */\n+  public synchronized void removeSession(Session session) {\n+    if (session != null) {\n+      exclusiveSession.compareAndSet(session, null);\n+      userSessions.remove(session);\n+      if (session != systemSession && session != lobSession) {\n+        trace.info(\"disconnecting session #{0}\", session.getId());\n+      }\n     }\n-\n-    /**\n-     * Add an object to the database.\n-     *\n-     * @param session the session\n-     * @param obj the object to add\n-     */\n-    public synchronized void addDatabaseObject(Session session, DbObject obj) {\n-        int id = obj.getId();\n-        if (id > 0 && !starting) {\n-            checkWritingAllowed();\n-        }\n-        HashMap<String, DbObject> map = getMap(obj.getType());\n-        if (obj.getType() == DbObject.USER) {\n-            User user = (User) obj;\n-            if (user.isAdmin() && systemUser.getName().equals(SYSTEM_USER_NAME)) {\n-                systemUser.rename(user.getName());\n-            }\n-        }\n-        String name = obj.getName();\n-        if (SysProperties.CHECK && map.get(name) != null) {\n-            DbException.throwInternalError(\"object already exists\");\n-        }\n-        lockMeta(session);\n-        addMeta(session, obj);\n-        map.put(name, obj);\n-    }\n-\n-    /**\n-     * Get the user defined aggregate function if it exists, or null if not.\n-     *\n-     * @param name the name of the user defined aggregate function\n-     * @return the aggregate function or null\n-     */\n-    public UserAggregate findAggregate(String name) {\n-        return aggregates.get(name);\n-    }\n-\n-    /**\n-     * Get the comment for the given database object if one exists, or null if\n-     * not.\n-     *\n-     * @param object the database object\n-     * @return the comment or null\n-     */\n-    public Comment findComment(DbObject object) {\n-        if (object.getType() == DbObject.COMMENT) {\n-            return null;\n-        }\n-        String key = Comment.getKey(object);\n-        return comments.get(key);\n-    }\n-\n-    /**\n-     * Get the role if it exists, or null if not.\n-     *\n-     * @param roleName the name of the role\n-     * @return the role or null\n-     */\n-    public Role findRole(String roleName) {\n-        return roles.get(roleName);\n-    }\n-\n-    /**\n-     * Get the schema if it exists, or null if not.\n-     *\n-     * @param schemaName the name of the schema\n-     * @return the schema or null\n-     */\n-    public Schema findSchema(String schemaName) {\n-        Schema schema = schemas.get(schemaName);\n-        if (schema == infoSchema) {\n-            initMetaTables();\n-        }\n-        return schema;\n-    }\n-\n-    /**\n-     * Get the setting if it exists, or null if not.\n-     *\n-     * @param name the name of the setting\n-     * @return the setting or null\n-     */\n-    public Setting findSetting(String name) {\n-        return settings.get(name);\n-    }\n-\n-    /**\n-     * Get the user if it exists, or null if not.\n-     *\n-     * @param name the name of the user\n-     * @return the user or null\n-     */\n-    public User findUser(String name) {\n-        return users.get(name);\n-    }\n-\n-    /**\n-     * Get the user defined data type if it exists, or null if not.\n-     *\n-     * @param name the name of the user defined data type\n-     * @return the user defined data type or null\n-     */\n-    public UserDataType findUserDataType(String name) {\n-        return userDataTypes.get(name);\n-    }\n-\n-    /**\n-     * Get user with the given name. This method throws an exception if the user\n-     * does not exist.\n-     *\n-     * @param name the user name\n-     * @return the user\n-     * @throws DbException if the user does not exist\n-     */\n-    public User getUser(String name) {\n-        User user = findUser(name);\n-        if (user == null) {\n-            throw DbException.get(ErrorCode.USER_NOT_FOUND_1, name);\n-        }\n-        return user;\n-    }\n-\n-    /**\n-     * Create a session for the given user.\n-     *\n-     * @param user the user\n-     * @return the session, or null if the database is currently closing\n-     * @throws DbException if the database is in exclusive mode\n-     */\n-    synchronized Session createSession(User user) {\n-        if (closing) {\n-            return null;\n-        }\n-        if (exclusiveSession.get() != null) {\n-            throw DbException.get(ErrorCode.DATABASE_IS_IN_EXCLUSIVE_MODE);\n-        }\n-        Session session = new Session(this, user, ++nextSessionId);\n-        userSessions.add(session);\n-        trace.info(\"connecting session #{0} to {1}\", session.getId(), databaseName);\n-        if (delayedCloser != null) {\n-            delayedCloser.reset();\n-            delayedCloser = null;\n-        }\n-        return session;\n-    }\n-\n-    /**\n-     * Remove a session. This method is called after the user has disconnected.\n-     *\n-     * @param session the session\n-     */\n-    public synchronized void removeSession(Session session) {\n-        if (session != null) {\n-            exclusiveSession.compareAndSet(session, null);\n-            userSessions.remove(session);\n-            if (session != systemSession && session != lobSession) {\n-                trace.info(\"disconnecting session #{0}\", session.getId());\n-            }\n-        }\n-        if (userSessions.size() == 0 &&\n-                session != systemSession && session != lobSession) {\n-            if (closeDelay == 0) {\n-                close(false);\n-            } else if (closeDelay < 0) {\n-                return;\n-            } else {\n-                delayedCloser = new DatabaseCloser(this, closeDelay * 1000, false);\n-                delayedCloser.setName(\"H2 Close Delay \" + getShortName());\n-                delayedCloser.setDaemon(true);\n-                delayedCloser.start();\n-            }\n-        }\n-        if (session != systemSession &&\n-                session != lobSession && session != null) {\n-            trace.info(\"disconnected session #{0}\", session.getId());\n-        }\n+    if (userSessions.size() == 0 &&\n+        session != systemSession && session != lobSession) {\n+      if (closeDelay == 0) {\n+        close(false);\n+      } else if (closeDelay < 0) {\n+        return;\n+      } else {\n+        delayedCloser = new DatabaseCloser(this, closeDelay * 1000, false);\n+        delayedCloser.setName(\"H2 Close Delay \" + getShortName());\n+        delayedCloser.setDaemon(true);\n+        delayedCloser.start();\n+      }\n     }\n-\n-    private synchronized void closeAllSessionsException(Session except) {\n-        Session[] all = new Session[userSessions.size()];\n-        userSessions.toArray(all);\n-        for (Session s : all) {\n-            if (s != except) {\n-                try {\n-                    // must roll back, otherwise the session is removed and\n-                    // the transaction log that contains its uncommitted\n-                    // operations as well\n-                    s.rollback();\n-                    s.close();\n-                } catch (DbException e) {\n-                    trace.error(e, \"disconnecting session #{0}\", s.getId());\n-                }\n-            }\n-        }\n+    if (session != systemSession &&\n+        session != lobSession && session != null) {\n+      trace.info(\"disconnected session #{0}\", session.getId());\n     }\n+  }\n \n-    /**\n-     * Close the database.\n-     *\n-     * @param fromShutdownHook true if this method is called from the shutdown\n-     *            hook\n-     */\n-    void close(boolean fromShutdownHook) {\n-        synchronized (this) {\n-            if (closing) {\n-                return;\n-            }\n-            throwLastBackgroundException();\n-            if (fileLockMethod == FileLock.LOCK_SERIALIZED &&\n-                    !reconnectChangePending) {\n-                // another connection may have written something - don't write\n-                try {\n-                    closeOpenFilesAndUnlock(false);\n-                } catch (DbException e) {\n-                    // ignore\n-                }\n-                traceSystem.close();\n-                Engine.getInstance().close(databaseName);\n-                return;\n-            }\n-            closing = true;\n-            stopServer();\n-            if (userSessions.size() > 0) {\n-                if (!fromShutdownHook) {\n-                    return;\n-                }\n-                trace.info(\"closing {0} from shutdown hook\", databaseName);\n-                closeAllSessionsException(null);\n-            }\n-            trace.info(\"closing {0}\", databaseName);\n-            if (eventListener != null) {\n-                // allow the event listener to connect to the database\n-                closing = false;\n-                DatabaseEventListener e = eventListener;\n-                // set it to null, to make sure it's called only once\n-                eventListener = null;\n-                e.closingDatabase();\n-                if (userSessions.size() > 0) {\n-                    // if a connection was opened, we can't close the database\n-                    return;\n-                }\n-                closing = true;\n-            }\n-        }\n-        removeOrphanedLobs();\n+  private synchronized void closeAllSessionsException(Session except) {\n+    Session[] all = new Session[userSessions.size()];\n+    userSessions.toArray(all);\n+    for (Session s : all) {\n+      if (s != except) {\n         try {\n-            if (systemSession != null) {\n-                if (powerOffCount != -1) {\n-                    for (Table table : getAllTablesAndViews(false)) {\n-                        if (table.isGlobalTemporary()) {\n-                            table.removeChildrenAndResources(systemSession);\n-                        } else {\n-                            table.close(systemSession);\n-                        }\n-                    }\n-                    for (SchemaObject obj : getAllSchemaObjects(\n-                            DbObject.SEQUENCE)) {\n-                        Sequence sequence = (Sequence) obj;\n-                        sequence.close();\n-                    }\n-                }\n-                for (SchemaObject obj : getAllSchemaObjects(\n-                        DbObject.TRIGGER)) {\n-                    TriggerObject trigger = (TriggerObject) obj;\n-                    try {\n-                        trigger.close();\n-                    } catch (SQLException e) {\n-                        trace.error(e, \"close\");\n-                    }\n-                }\n-                if (powerOffCount != -1) {\n-                    meta.close(systemSession);\n-                    systemSession.commit(true);\n-                }\n-            }\n+          // must roll back, otherwise the session is removed and\n+          // the transaction log that contains its uncommitted\n+          // operations as well\n+          s.rollback();\n+          s.close();\n         } catch (DbException e) {\n-            trace.error(e, \"close\");\n+          trace.error(e, \"disconnecting session #{0}\", s.getId());\n         }\n-        tempFileDeleter.deleteAll();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Close the database.\n+   *\n+   * @param fromShutdownHook true if this method is called from the shutdown\n+   *                         hook\n+   */\n+  void close(boolean fromShutdownHook) {\n+    synchronized (this) {\n+      if (closing) {\n+        return;\n+      }\n+      throwLastBackgroundException();\n+      if (fileLockMethod == FileLock.LOCK_SERIALIZED &&\n+          !reconnectChangePending) {\n+        // another connection may have written something - don't write\n         try {\n-            closeOpenFilesAndUnlock(true);\n+          closeOpenFilesAndUnlock(false);\n         } catch (DbException e) {\n-            trace.error(e, \"close\");\n+          // ignore\n         }\n-        trace.info(\"closed\");\n         traceSystem.close();\n-        if (closeOnExit != null) {\n-            closeOnExit.reset();\n-            try {\n-                Runtime.getRuntime().removeShutdownHook(closeOnExit);\n-            } catch (IllegalStateException e) {\n-                // ignore\n-            } catch (SecurityException  e) {\n-                // applets may not do that - ignore\n-            }\n-            closeOnExit = null;\n-        }\n         Engine.getInstance().close(databaseName);\n-        if (deleteFilesOnDisconnect && persistent) {\n-            deleteFilesOnDisconnect = false;\n-            try {\n-                String directory = FileUtils.getParent(databaseName);\n-                String name = FileUtils.getName(databaseName);\n-                DeleteDbFiles.execute(directory, name, true);\n-            } catch (Exception e) {\n-                // ignore (the trace is closed already)\n-            }\n-        }\n-    }\n-\n-    private void removeOrphanedLobs() {\n-        // remove all session variables and temporary lobs\n-        if (!persistent) {\n-            return;\n-        }\n-        boolean lobStorageIsUsed = infoSchema.findTableOrView(\n-                systemSession, LobStorageBackend.LOB_DATA_TABLE) != null;\n-        lobStorageIsUsed |= mvStore != null;\n-        if (!lobStorageIsUsed) {\n-            return;\n-        }\n-        try {\n-            getLobStorage();\n-            lobStorage.removeAllForTable(\n-                    LobStorageFrontend.TABLE_ID_SESSION_VARIABLE);\n-        } catch (DbException e) {\n-            trace.error(e, \"close\");\n-        }\n-    }\n-\n-    private void stopWriter() {\n-        if (writer != null) {\n-            writer.stopThread();\n-            writer = null;\n-        }\n+        return;\n+      }\n+      closing = true;\n+      stopServer();\n+      if (userSessions.size() > 0) {\n+        if (!fromShutdownHook) {\n+          return;\n+        }\n+        trace.info(\"closing {0} from shutdown hook\", databaseName);\n+        closeAllSessionsException(null);\n+      }\n+      trace.info(\"closing {0}\", databaseName);\n+      if (eventListener != null) {\n+        // allow the event listener to connect to the database\n+        closing = false;\n+        DatabaseEventListener e = eventListener;\n+        // set it to null, to make sure it's called only once\n+        eventListener = null;\n+        e.closingDatabase();\n+        if (userSessions.size() > 0) {\n+          // if a connection was opened, we can't close the database\n+          return;\n+        }\n+        closing = true;\n+      }\n     }\n-\n-    /**\n-     * Close all open files and unlock the database.\n-     *\n-     * @param flush whether writing is allowed\n-     */\n-    private synchronized void closeOpenFilesAndUnlock(boolean flush) {\n-        stopWriter();\n-        if (pageStore != null) {\n-            if (flush) {\n-                try {\n-                    pageStore.checkpoint();\n-                    if (!readOnly) {\n-                        lockMeta(pageStore.getPageStoreSession());\n-                        pageStore.compact(compactMode);\n-                    }\n-                } catch (DbException e) {\n-                    if (SysProperties.CHECK2) {\n-                        int code = e.getErrorCode();\n-                        if (code != ErrorCode.DATABASE_IS_CLOSED &&\n-                                code != ErrorCode.LOCK_TIMEOUT_1 &&\n-                                code != ErrorCode.IO_EXCEPTION_2) {\n-                            e.printStackTrace();\n-                        }\n-                    }\n-                    trace.error(e, \"close\");\n-                } catch (Throwable t) {\n-                    if (SysProperties.CHECK2) {\n-                        t.printStackTrace();\n-                    }\n-                    trace.error(t, \"close\");\n-                }\n-            }\n-        }\n-        reconnectModified(false);\n-        if (mvStore != null) {\n-            long maxCompactTime = dbSettings.maxCompactTime;\n-            if (compactMode == CommandInterface.SHUTDOWN_COMPACT) {\n-                mvStore.compactFile(dbSettings.maxCompactTime);\n-            } else if (compactMode == CommandInterface.SHUTDOWN_DEFRAG) {\n-                maxCompactTime = Long.MAX_VALUE;\n-            } else if (getSettings().defragAlways) {\n-                maxCompactTime = Long.MAX_VALUE;\n+    removeOrphanedLobs();\n+    try {\n+      if (systemSession != null) {\n+        if (powerOffCount != -1) {\n+          for (Table table : getAllTablesAndViews(false)) {\n+            if (table.isGlobalTemporary()) {\n+              table.removeChildrenAndResources(systemSession);\n+            } else {\n+              table.close(systemSession);\n             }\n-            mvStore.close(maxCompactTime);\n-        }\n-        closeFiles();\n-        if (persistent && lock == null &&\n-                fileLockMethod != FileLock.LOCK_NO &&\n-                fileLockMethod != FileLock.LOCK_FS) {\n-            // everything already closed (maybe in checkPowerOff)\n-            // don't delete temp files in this case because\n-            // the database could be open now (even from within another process)\n-            return;\n-        }\n-        if (persistent) {\n-            deleteOldTempFiles();\n-        }\n-        if (systemSession != null) {\n-            systemSession.close();\n-            systemSession = null;\n-        }\n-        if (lobSession != null) {\n-            lobSession.close();\n-            lobSession = null;\n+          }\n+          for (SchemaObject obj : getAllSchemaObjects(\n+              DbObject.SEQUENCE)) {\n+            Sequence sequence = (Sequence) obj;\n+            sequence.close();\n+          }\n+        }\n+        for (SchemaObject obj : getAllSchemaObjects(\n+            DbObject.TRIGGER)) {\n+          TriggerObject trigger = (TriggerObject) obj;\n+          try {\n+            trigger.close();\n+          } catch (SQLException e) {\n+            trace.error(e, \"close\");\n+          }\n         }\n-        if (lock != null) {\n-            if (fileLockMethod == FileLock.LOCK_SERIALIZED) {\n-                // wait before deleting the .lock file,\n-                // otherwise other connections can not detect that\n-                if (lock.load().containsKey(\"changePending\")) {\n-                    try {\n-                        Thread.sleep(TimeUnit.NANOSECONDS\n-                                .toMillis((long) (reconnectCheckDelayNs * 1.1)));\n-                    } catch (InterruptedException e) {\n-                        trace.error(e, \"close\");\n-                    }\n-                }\n-            }\n-            lock.unlock();\n-            lock = null;\n+        if (powerOffCount != -1) {\n+          meta.close(systemSession);\n+          systemSession.commit(true);\n         }\n+      }\n+    } catch (DbException e) {\n+      trace.error(e, \"close\");\n+    }\n+    tempFileDeleter.deleteAll();\n+    try {\n+      closeOpenFilesAndUnlock(true);\n+    } catch (DbException e) {\n+      trace.error(e, \"close\");\n+    }\n+    trace.info(\"closed\");\n+    traceSystem.close();\n+    if (closeOnExit != null) {\n+      closeOnExit.reset();\n+      try {\n+        Runtime.getRuntime().removeShutdownHook(closeOnExit);\n+      } catch (IllegalStateException e) {\n+        // ignore\n+      } catch (SecurityException e) {\n+        // applets may not do that - ignore\n+      }\n+      closeOnExit = null;\n+    }\n+    Engine.getInstance().close(databaseName);\n+    if (deleteFilesOnDisconnect && persistent) {\n+      deleteFilesOnDisconnect = false;\n+      try {\n+        String directory = FileUtils.getParent(databaseName);\n+        String name = FileUtils.getName(databaseName);\n+        DeleteDbFiles.execute(directory, name, true);\n+      } catch (Exception e) {\n+        // ignore (the trace is closed already)\n+      }\n     }\n-\n-    private synchronized void closeFiles() {\n+  }\n+\n+  private void removeOrphanedLobs() {\n+    // remove all session variables and temporary lobs\n+    if (!persistent) {\n+      return;\n+    }\n+    boolean lobStorageIsUsed = infoSchema.findTableOrView(\n+        systemSession, LobStorageBackend.LOB_DATA_TABLE) != null;\n+    lobStorageIsUsed |= mvStore != null;\n+    if (!lobStorageIsUsed) {\n+      return;\n+    }\n+    try {\n+      getLobStorage();\n+      lobStorage.removeAllForTable(\n+          LobStorageFrontend.TABLE_ID_SESSION_VARIABLE);\n+    } catch (DbException e) {\n+      trace.error(e, \"close\");\n+    }\n+  }\n+\n+  private void stopWriter() {\n+    if (writer != null) {\n+      writer.stopThread();\n+      writer = null;\n+    }\n+  }\n+\n+  /**\n+   * Close all open files and unlock the database.\n+   *\n+   * @param flush whether writing is allowed\n+   */\n+  private synchronized void closeOpenFilesAndUnlock(boolean flush) {\n+    stopWriter();\n+    if (pageStore != null) {\n+      if (flush) {\n         try {\n-            if (mvStore != null) {\n-                mvStore.closeImmediately();\n-            }\n-            if (pageStore != null) {\n-                pageStore.close();\n-                pageStore = null;\n-            }\n+          pageStore.checkpoint();\n+          if (!readOnly) {\n+            lockMeta(pageStore.getPageStoreSession());\n+            pageStore.compact(compactMode);\n+          }\n         } catch (DbException e) {\n-            trace.error(e, \"close\");\n+          if (SysProperties.CHECK2) {\n+            int code = e.getErrorCode();\n+            if (code != ErrorCode.DATABASE_IS_CLOSED &&\n+                code != ErrorCode.LOCK_TIMEOUT_1 &&\n+                code != ErrorCode.IO_EXCEPTION_2) {\n+              e.printStackTrace();\n+            }\n+          }\n+          trace.error(e, \"close\");\n+        } catch (Throwable t) {\n+          if (SysProperties.CHECK2) {\n+            t.printStackTrace();\n+          }\n+          trace.error(t, \"close\");\n         }\n+      }\n     }\n-\n-    private void checkMetaFree(Session session, int id) {\n-        SearchRow r = meta.getTemplateSimpleRow(false);\n-        r.setValue(0, ValueInt.get(id));\n-        Cursor cursor = metaIdIndex.find(session, r, r);\n-        if (cursor.next()) {\n-            DbException.throwInternalError();\n+    reconnectModified(false);\n+    if (mvStore != null) {\n+      long maxCompactTime = dbSettings.maxCompactTime;\n+      if (compactMode == CommandInterface.SHUTDOWN_COMPACT) {\n+        mvStore.compactFile(dbSettings.maxCompactTime);\n+      } else if (compactMode == CommandInterface.SHUTDOWN_DEFRAG) {\n+        maxCompactTime = Long.MAX_VALUE;\n+      } else if (getSettings().defragAlways) {\n+        maxCompactTime = Long.MAX_VALUE;\n+      }\n+      mvStore.close(maxCompactTime);\n+    }\n+    closeFiles();\n+    if (persistent && lock == null &&\n+        fileLockMethod != FileLock.LOCK_NO &&\n+        fileLockMethod != FileLock.LOCK_FS) {\n+      // everything already closed (maybe in checkPowerOff)\n+      // don't delete temp files in this case because\n+      // the database could be open now (even from within another process)\n+      return;\n+    }\n+    if (persistent) {\n+      deleteOldTempFiles();\n+    }\n+    if (systemSession != null) {\n+      systemSession.close();\n+      systemSession = null;\n+    }\n+    if (lobSession != null) {\n+      lobSession.close();\n+      lobSession = null;\n+    }\n+    if (lock != null) {\n+      if (fileLockMethod == FileLock.LOCK_SERIALIZED) {\n+        // wait before deleting the .lock file,\n+        // otherwise other connections can not detect that\n+        if (lock.load().containsKey(\"changePending\")) {\n+          try {\n+            Thread.sleep(TimeUnit.NANOSECONDS\n+                .toMillis((long) (reconnectCheckDelayNs * 1.1)));\n+          } catch (InterruptedException e) {\n+            trace.error(e, \"close\");\n+          }\n         }\n+      }\n+      lock.unlock();\n+      lock = null;\n     }\n+  }\n \n-    /**\n-     * Allocate a new object id.\n-     *\n-     * @return the id\n-     */\n-    public synchronized int allocateObjectId() {\n-        int i = objectIds.nextClearBit(0);\n-        objectIds.set(i);\n-        return i;\n+  private synchronized void closeFiles() {\n+    try {\n+      if (mvStore != null) {\n+        mvStore.closeImmediately();\n+      }\n+      if (pageStore != null) {\n+        pageStore.close();\n+        pageStore = null;\n+      }\n+    } catch (DbException e) {\n+      trace.error(e, \"close\");\n+    }\n+  }\n+\n+  private void checkMetaFree(Session session, int id) {\n+    SearchRow r = meta.getTemplateSimpleRow(false);\n+    r.setValue(0, ValueInt.get(id));\n+    Cursor cursor = metaIdIndex.find(session, r, r);\n+    if (cursor.next()) {\n+      DbException.throwInternalError();\n+    }\n+  }\n+\n+  /**\n+   * Allocate a new object id.\n+   *\n+   * @return the id\n+   */\n+  public synchronized int allocateObjectId() {\n+    int i = objectIds.nextClearBit(0);\n+    objectIds.set(i);\n+    return i;\n+  }\n+\n+  public ArrayList<UserAggregate> getAllAggregates() {\n+    return New.arrayList(aggregates.values());\n+  }\n+\n+  public ArrayList<Comment> getAllComments() {\n+    return New.arrayList(comments.values());\n+  }\n+\n+  public int getAllowLiterals() {\n+    if (starting) {\n+      return Constants.ALLOW_LITERALS_ALL;\n+    }\n+    return allowLiterals;\n+  }\n+\n+  public ArrayList<Right> getAllRights() {\n+    return New.arrayList(rights.values());\n+  }\n+\n+  public ArrayList<Role> getAllRoles() {\n+    return New.arrayList(roles.values());\n+  }\n+\n+  /**\n+   * Get all schema objects.\n+   *\n+   * @return all objects of all types\n+   */\n+  public ArrayList<SchemaObject> getAllSchemaObjects() {\n+    initMetaTables();\n+    ArrayList<SchemaObject> list = New.arrayList();\n+    for (Schema schema : schemas.values()) {\n+      list.addAll(schema.getAll());\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Get all schema objects of the given type.\n+   *\n+   * @param type the object type\n+   * @return all objects of that type\n+   */\n+  public ArrayList<SchemaObject> getAllSchemaObjects(int type) {\n+    if (type == DbObject.TABLE_OR_VIEW) {\n+      initMetaTables();\n+    }\n+    ArrayList<SchemaObject> list = New.arrayList();\n+    for (Schema schema : schemas.values()) {\n+      list.addAll(schema.getAll(type));\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Get all tables and views.\n+   *\n+   * @param includeMeta whether to force including the meta data tables (if\n+   *                    true, metadata tables are always included; if false, metadata\n+   *                    tables are only included if they are already initialized)\n+   * @return all objects of that type\n+   */\n+  public ArrayList<Table> getAllTablesAndViews(boolean includeMeta) {\n+    if (includeMeta) {\n+      initMetaTables();\n+    }\n+    ArrayList<Table> list = New.arrayList();\n+    for (Schema schema : schemas.values()) {\n+      list.addAll(schema.getAllTablesAndViews());\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Get all synonyms.\n+   *\n+   * @return all objects of that type\n+   */\n+  public ArrayList<TableSynonym> getAllSynonyms() {\n+    ArrayList<TableSynonym> list = New.arrayList();\n+    for (Schema schema : schemas.values()) {\n+      list.addAll(schema.getAllSynonyms());\n+    }\n+    return list;\n+  }\n+\n+  /**\n+   * Get the tables with the given name, if any.\n+   *\n+   * @param name the table name\n+   * @return the list\n+   */\n+  public ArrayList<Table> getTableOrViewByName(String name) {\n+    ArrayList<Table> list = New.arrayList();\n+    for (Schema schema : schemas.values()) {\n+      Table table = schema.getTableOrViewByName(name);\n+      if (table != null) {\n+        list.add(table);\n+      }\n     }\n-\n-    public ArrayList<UserAggregate> getAllAggregates() {\n-        return New.arrayList(aggregates.values());\n+    return list;\n+  }\n+\n+  public ArrayList<Schema> getAllSchemas() {\n+    initMetaTables();\n+    return New.arrayList(schemas.values());\n+  }\n+\n+  public ArrayList<Setting> getAllSettings() {\n+    return New.arrayList(settings.values());\n+  }\n+\n+  public ArrayList<UserDataType> getAllUserDataTypes() {\n+    return New.arrayList(userDataTypes.values());\n+  }\n+\n+  public ArrayList<User> getAllUsers() {\n+    return New.arrayList(users.values());\n+  }\n+\n+  public String getCacheType() {\n+    return cacheType;\n+  }\n+\n+  public String getCluster() {\n+    return cluster;\n+  }\n+\n+  @Override\n+  public CompareMode getCompareMode() {\n+    return compareMode;\n+  }\n+\n+  @Override\n+  public String getDatabasePath() {\n+    if (persistent) {\n+      return FileUtils.toRealPath(databaseName);\n+    }\n+    return null;\n+  }\n+\n+  public String getShortName() {\n+    return databaseShortName;\n+  }\n+\n+  public String getName() {\n+    return databaseName;\n+  }\n+\n+  /**\n+   * Get all sessions that are currently connected to the database.\n+   *\n+   * @param includingSystemSession if the system session should also be\n+   *                               included\n+   * @return the list of sessions\n+   */\n+  public Session[] getSessions(boolean includingSystemSession) {\n+    ArrayList<Session> list;\n+    // need to synchronized on userSession, otherwise the list\n+    // may contain null elements\n+    synchronized (userSessions) {\n+      list = New.arrayList(userSessions);\n+    }\n+    // copy, to ensure the reference is stable\n+    Session sys = systemSession;\n+    Session lob = lobSession;\n+    if (includingSystemSession && sys != null) {\n+      list.add(sys);\n+    }\n+    if (includingSystemSession && lob != null) {\n+      list.add(lob);\n+    }\n+    Session[] array = new Session[list.size()];\n+    list.toArray(array);\n+    return array;\n+  }\n+\n+  /**\n+   * Update an object in the system table.\n+   *\n+   * @param session the session\n+   * @param obj     the database object\n+   */\n+  public void updateMeta(Session session, DbObject obj) {\n+    lockMeta(session);\n+    synchronized (this) {\n+      int id = obj.getId();\n+      removeMeta(session, id);\n+      addMeta(session, obj);\n+      // for temporary objects\n+      if (id > 0) {\n+        objectIds.set(id);\n+      }\n     }\n-\n-    public ArrayList<Comment> getAllComments() {\n-        return New.arrayList(comments.values());\n-    }\n-\n-    public int getAllowLiterals() {\n-        if (starting) {\n-            return Constants.ALLOW_LITERALS_ALL;\n-        }\n-        return allowLiterals;\n-    }\n-\n-    public ArrayList<Right> getAllRights() {\n-        return New.arrayList(rights.values());\n-    }\n-\n-    public ArrayList<Role> getAllRoles() {\n-        return New.arrayList(roles.values());\n-    }\n-\n-    /**\n-     * Get all schema objects.\n-     *\n-     * @return all objects of all types\n-     */\n-    public ArrayList<SchemaObject> getAllSchemaObjects() {\n-        initMetaTables();\n-        ArrayList<SchemaObject> list = New.arrayList();\n-        for (Schema schema : schemas.values()) {\n-            list.addAll(schema.getAll());\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Get all schema objects of the given type.\n-     *\n-     * @param type the object type\n-     * @return all objects of that type\n-     */\n-    public ArrayList<SchemaObject> getAllSchemaObjects(int type) {\n-        if (type == DbObject.TABLE_OR_VIEW) {\n-            initMetaTables();\n-        }\n-        ArrayList<SchemaObject> list = New.arrayList();\n-        for (Schema schema : schemas.values()) {\n-            list.addAll(schema.getAll(type));\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Get all tables and views.\n-     *\n-     * @param includeMeta whether to force including the meta data tables (if\n-     *            true, metadata tables are always included; if false, metadata\n-     *            tables are only included if they are already initialized)\n-     * @return all objects of that type\n-     */\n-    public ArrayList<Table> getAllTablesAndViews(boolean includeMeta) {\n-        if (includeMeta) {\n-            initMetaTables();\n+  }\n+\n+  /**\n+   * Rename a schema object.\n+   *\n+   * @param session the session\n+   * @param obj     the object\n+   * @param newName the new name\n+   */\n+  public synchronized void renameSchemaObject(Session session,\n+                                              SchemaObject obj,\n+                                              String newName) {\n+    checkWritingAllowed();\n+    obj.getSchema().rename(obj, newName);\n+    updateMetaAndFirstLevelChildren(session, obj);\n+  }\n+\n+  private synchronized void updateMetaAndFirstLevelChildren(Session session,\n+                                                            DbObject obj) {\n+    ArrayList<DbObject> list = obj.getChildren();\n+    Comment comment = findComment(obj);\n+    if (comment != null) {\n+      DbException.throwInternalError(comment.toString());\n+    }\n+    updateMeta(session, obj);\n+    // remember that this scans only one level deep!\n+    if (list != null) {\n+      for (DbObject o : list) {\n+        if (o.getCreateSQL() != null) {\n+          updateMeta(session, o);\n         }\n-        ArrayList<Table> list = New.arrayList();\n-        for (Schema schema : schemas.values()) {\n-            list.addAll(schema.getAllTablesAndViews());\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Get all synonyms.\n-     *\n-     * @return all objects of that type\n-     */\n-    public ArrayList<TableSynonym> getAllSynonyms() {\n-        ArrayList<TableSynonym> list = New.arrayList();\n-        for (Schema schema : schemas.values()) {\n-            list.addAll(schema.getAllSynonyms());\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Get the tables with the given name, if any.\n-     *\n-     * @param name the table name\n-     * @return the list\n-     */\n-    public ArrayList<Table> getTableOrViewByName(String name) {\n-        ArrayList<Table> list = New.arrayList();\n-        for (Schema schema : schemas.values()) {\n-            Table table = schema.getTableOrViewByName(name);\n-            if (table != null) {\n-                list.add(table);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    public ArrayList<Schema> getAllSchemas() {\n-        initMetaTables();\n-        return New.arrayList(schemas.values());\n-    }\n-\n-    public ArrayList<Setting> getAllSettings() {\n-        return New.arrayList(settings.values());\n-    }\n-\n-    public ArrayList<UserDataType> getAllUserDataTypes() {\n-        return New.arrayList(userDataTypes.values());\n-    }\n-\n-    public ArrayList<User> getAllUsers() {\n-        return New.arrayList(users.values());\n-    }\n-\n-    public String getCacheType() {\n-        return cacheType;\n+      }\n     }\n-\n-    public String getCluster() {\n-        return cluster;\n+  }\n+\n+  /**\n+   * Rename a database object.\n+   *\n+   * @param session the session\n+   * @param obj     the object\n+   * @param newName the new name\n+   */\n+  public synchronized void renameDatabaseObject(Session session,\n+                                                DbObject obj, String newName) {\n+    checkWritingAllowed();\n+    int type = obj.getType();\n+    HashMap<String, DbObject> map = getMap(type);\n+    if (SysProperties.CHECK) {\n+      if (!map.containsKey(obj.getName())) {\n+        DbException.throwInternalError(\"not found: \" + obj.getName());\n+      }\n+      if (obj.getName().equals(newName) || map.containsKey(newName)) {\n+        DbException.throwInternalError(\"object already exists: \" + newName);\n+      }\n     }\n-\n-    @Override\n-    public CompareMode getCompareMode() {\n-        return compareMode;\n+    obj.checkRename();\n+    int id = obj.getId();\n+    lockMeta(session);\n+    removeMeta(session, id);\n+    map.remove(obj.getName());\n+    obj.rename(newName);\n+    map.put(newName, obj);\n+    updateMetaAndFirstLevelChildren(session, obj);\n+  }\n+\n+  /**\n+   * Create a temporary file in the database folder.\n+   *\n+   * @return the file name\n+   */\n+  public String createTempFile() {\n+    try {\n+      boolean inTempDir = readOnly;\n+      String name = databaseName;\n+      if (!persistent) {\n+        name = \"memFS:\" + name;\n+      }\n+      return FileUtils.createTempFile(name,\n+          Constants.SUFFIX_TEMP_FILE, true, inTempDir);\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, databaseName);\n+    }\n+  }\n+\n+  private void deleteOldTempFiles() {\n+    String path = FileUtils.getParent(databaseName);\n+    for (String name : FileUtils.newDirectoryStream(path)) {\n+      if (name.endsWith(Constants.SUFFIX_TEMP_FILE) &&\n+          name.startsWith(databaseName)) {\n+        // can't always delete the files, they may still be open\n+        FileUtils.tryDelete(name);\n+      }\n     }\n-\n-    @Override\n-    public String getDatabasePath() {\n-        if (persistent) {\n-            return FileUtils.toRealPath(databaseName);\n-        }\n+  }\n+\n+  /**\n+   * Get the schema. If the schema does not exist, an exception is thrown.\n+   *\n+   * @param schemaName the name of the schema\n+   * @return the schema\n+   * @throws DbException no schema with that name exists\n+   */\n+  public Schema getSchema(String schemaName) {\n+    Schema schema = findSchema(schemaName);\n+    if (schema == null) {\n+      throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schemaName);\n+    }\n+    return schema;\n+  }\n+\n+  /**\n+   * Remove the object from the database.\n+   *\n+   * @param session the session\n+   * @param obj     the object to remove\n+   */\n+  public synchronized void removeDatabaseObject(Session session, DbObject obj) {\n+    checkWritingAllowed();\n+    String objName = obj.getName();\n+    int type = obj.getType();\n+    HashMap<String, DbObject> map = getMap(type);\n+    if (SysProperties.CHECK && !map.containsKey(objName)) {\n+      DbException.throwInternalError(\"not found: \" + objName);\n+    }\n+    Comment comment = findComment(obj);\n+    lockMeta(session);\n+    if (comment != null) {\n+      removeDatabaseObject(session, comment);\n+    }\n+    int id = obj.getId();\n+    obj.removeChildrenAndResources(session);\n+    map.remove(objName);\n+    removeMeta(session, id);\n+  }\n+\n+  /**\n+   * Get the first table that depends on this object.\n+   *\n+   * @param obj    the object to find\n+   * @param except the table to exclude (or null)\n+   * @return the first dependent table, or null\n+   */\n+  public Table getDependentTable(SchemaObject obj, Table except) {\n+    switch (obj.getType()) {\n+      case DbObject.COMMENT:\n+      case DbObject.CONSTRAINT:\n+      case DbObject.INDEX:\n+      case DbObject.RIGHT:\n+      case DbObject.TRIGGER:\n+      case DbObject.USER:\n         return null;\n+      default:\n+    }\n+    HashSet<DbObject> set = New.hashSet();\n+    for (Table t : getAllTablesAndViews(false)) {\n+      if (except == t) {\n+        continue;\n+      } else if (TableType.VIEW == t.getTableType()) {\n+        continue;\n+      }\n+      set.clear();\n+      t.addDependencies(set);\n+      if (set.contains(obj)) {\n+        return t;\n+      }\n     }\n-\n-    public String getShortName() {\n-        return databaseShortName;\n-    }\n-\n-    public String getName() {\n-        return databaseName;\n-    }\n-\n-    /**\n-     * Get all sessions that are currently connected to the database.\n-     *\n-     * @param includingSystemSession if the system session should also be\n-     *            included\n-     * @return the list of sessions\n-     */\n-    public Session[] getSessions(boolean includingSystemSession) {\n-        ArrayList<Session> list;\n-        // need to synchronized on userSession, otherwise the list\n-        // may contain null elements\n-        synchronized (userSessions) {\n-            list = New.arrayList(userSessions);\n-        }\n-        // copy, to ensure the reference is stable\n-        Session sys = systemSession;\n-        Session lob = lobSession;\n-        if (includingSystemSession && sys != null) {\n-            list.add(sys);\n-        }\n-        if (includingSystemSession && lob != null) {\n-            list.add(lob);\n-        }\n-        Session[] array = new Session[list.size()];\n-        list.toArray(array);\n-        return array;\n-    }\n-\n-    /**\n-     * Update an object in the system table.\n-     *\n-     * @param session the session\n-     * @param obj the database object\n-     */\n-    public void updateMeta(Session session, DbObject obj) {\n-        lockMeta(session);\n-        synchronized (this) {\n-            int id = obj.getId();\n-            removeMeta(session, id);\n-            addMeta(session, obj);\n-            // for temporary objects\n-            if (id > 0) {\n-                objectIds.set(id);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Rename a schema object.\n-     *\n-     * @param session the session\n-     * @param obj the object\n-     * @param newName the new name\n-     */\n-    public synchronized void renameSchemaObject(Session session,\n-            SchemaObject obj, String newName) {\n-        checkWritingAllowed();\n-        obj.getSchema().rename(obj, newName);\n-        updateMetaAndFirstLevelChildren(session, obj);\n-    }\n-\n-    private synchronized void updateMetaAndFirstLevelChildren(Session session, DbObject obj) {\n-        ArrayList<DbObject> list = obj.getChildren();\n-        Comment comment = findComment(obj);\n-        if (comment != null) {\n-            DbException.throwInternalError(comment.toString());\n-        }\n-        updateMeta(session, obj);\n-        // remember that this scans only one level deep!\n-        if (list != null) {\n-            for (DbObject o : list) {\n-                if (o.getCreateSQL() != null) {\n-                    updateMeta(session, o);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Rename a database object.\n-     *\n-     * @param session the session\n-     * @param obj the object\n-     * @param newName the new name\n-     */\n-    public synchronized void renameDatabaseObject(Session session,\n-            DbObject obj, String newName) {\n-        checkWritingAllowed();\n-        int type = obj.getType();\n-        HashMap<String, DbObject> map = getMap(type);\n-        if (SysProperties.CHECK) {\n-            if (!map.containsKey(obj.getName())) {\n-                DbException.throwInternalError(\"not found: \" + obj.getName());\n-            }\n-            if (obj.getName().equals(newName) || map.containsKey(newName)) {\n-                DbException.throwInternalError(\"object already exists: \" + newName);\n-            }\n-        }\n-        obj.checkRename();\n-        int id = obj.getId();\n-        lockMeta(session);\n-        removeMeta(session, id);\n-        map.remove(obj.getName());\n-        obj.rename(newName);\n-        map.put(newName, obj);\n-        updateMetaAndFirstLevelChildren(session, obj);\n-    }\n-\n-    /**\n-     * Create a temporary file in the database folder.\n-     *\n-     * @return the file name\n-     */\n-    public String createTempFile() {\n-        try {\n-            boolean inTempDir = readOnly;\n-            String name = databaseName;\n-            if (!persistent) {\n-                name = \"memFS:\" + name;\n-            }\n-            return FileUtils.createTempFile(name,\n-                    Constants.SUFFIX_TEMP_FILE, true, inTempDir);\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(e, databaseName);\n-        }\n-    }\n-\n-    private void deleteOldTempFiles() {\n-        String path = FileUtils.getParent(databaseName);\n-        for (String name : FileUtils.newDirectoryStream(path)) {\n-            if (name.endsWith(Constants.SUFFIX_TEMP_FILE) &&\n-                    name.startsWith(databaseName)) {\n-                // can't always delete the files, they may still be open\n-                FileUtils.tryDelete(name);\n-            }\n-        }\n+    return null;\n+  }\n+\n+  /**\n+   * Remove an object from the system table.\n+   *\n+   * @param session the session\n+   * @param obj     the object to be removed\n+   */\n+  public void removeSchemaObject(Session session,\n+                                 SchemaObject obj) {\n+    int type = obj.getType();\n+    if (type == DbObject.TABLE_OR_VIEW) {\n+      Table table = (Table) obj;\n+      table.setBeingDropped(true);\n+      if (table.isTemporary() && !table.isGlobalTemporary()) {\n+        session.removeLocalTempTable(table);\n+        return;\n+      }\n+    } else if (type == DbObject.INDEX) {\n+      Index index = (Index) obj;\n+      Table table = index.getTable();\n+      if (table.isTemporary() && !table.isGlobalTemporary()) {\n+        session.removeLocalTempTableIndex(index);\n+        return;\n+      }\n+    } else if (type == DbObject.CONSTRAINT) {\n+      Constraint constraint = (Constraint) obj;\n+      Table table = constraint.getTable();\n+      if (table.isTemporary() && !table.isGlobalTemporary()) {\n+        session.removeLocalTempTableConstraint(constraint);\n+        return;\n+      }\n     }\n-\n-    /**\n-     * Get the schema. If the schema does not exist, an exception is thrown.\n-     *\n-     * @param schemaName the name of the schema\n-     * @return the schema\n-     * @throws DbException no schema with that name exists\n-     */\n-    public Schema getSchema(String schemaName) {\n-        Schema schema = findSchema(schemaName);\n-        if (schema == null) {\n-            throw DbException.get(ErrorCode.SCHEMA_NOT_FOUND_1, schemaName);\n-        }\n-        return schema;\n-    }\n-\n-    /**\n-     * Remove the object from the database.\n-     *\n-     * @param session the session\n-     * @param obj the object to remove\n-     */\n-    public synchronized void removeDatabaseObject(Session session, DbObject obj) {\n-        checkWritingAllowed();\n-        String objName = obj.getName();\n-        int type = obj.getType();\n-        HashMap<String, DbObject> map = getMap(type);\n-        if (SysProperties.CHECK && !map.containsKey(objName)) {\n-            DbException.throwInternalError(\"not found: \" + objName);\n-        }\n-        Comment comment = findComment(obj);\n-        lockMeta(session);\n-        if (comment != null) {\n-            removeDatabaseObject(session, comment);\n+    checkWritingAllowed();\n+    lockMeta(session);\n+    synchronized (this) {\n+      Comment comment = findComment(obj);\n+      if (comment != null) {\n+        removeDatabaseObject(session, comment);\n+      }\n+      obj.getSchema().remove(obj);\n+      int id = obj.getId();\n+      if (!starting) {\n+        Table t = getDependentTable(obj, null);\n+        if (t != null) {\n+          obj.getSchema().add(obj);\n+          throw DbException.get(ErrorCode.CANNOT_DROP_2, obj.getSQL(),\n+              t.getSQL());\n         }\n-        int id = obj.getId();\n         obj.removeChildrenAndResources(session);\n-        map.remove(objName);\n-        removeMeta(session, id);\n-    }\n-\n-    /**\n-     * Get the first table that depends on this object.\n-     *\n-     * @param obj the object to find\n-     * @param except the table to exclude (or null)\n-     * @return the first dependent table, or null\n-     */\n-    public Table getDependentTable(SchemaObject obj, Table except) {\n-        switch (obj.getType()) {\n-        case DbObject.COMMENT:\n-        case DbObject.CONSTRAINT:\n-        case DbObject.INDEX:\n-        case DbObject.RIGHT:\n-        case DbObject.TRIGGER:\n-        case DbObject.USER:\n-            return null;\n-        default:\n-        }\n-        HashSet<DbObject> set = New.hashSet();\n-        for (Table t : getAllTablesAndViews(false)) {\n-            if (except == t) {\n-                continue;\n-            } else if (TableType.VIEW == t.getTableType()) {\n-                continue;\n-            }\n-            set.clear();\n-            t.addDependencies(set);\n-            if (set.contains(obj)) {\n-                return t;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Remove an object from the system table.\n-     *\n-     * @param session the session\n-     * @param obj the object to be removed\n-     */\n-    public void removeSchemaObject(Session session,\n-            SchemaObject obj) {\n-        int type = obj.getType();\n-        if (type == DbObject.TABLE_OR_VIEW) {\n-            Table table = (Table) obj;\n-            table.setBeingDropped(true);\n-            if (table.isTemporary() && !table.isGlobalTemporary()) {\n-                session.removeLocalTempTable(table);\n-                return;\n-            }\n-        } else if (type == DbObject.INDEX) {\n-            Index index = (Index) obj;\n-            Table table = index.getTable();\n-            if (table.isTemporary() && !table.isGlobalTemporary()) {\n-                session.removeLocalTempTableIndex(index);\n-                return;\n-            }\n-        } else if (type == DbObject.CONSTRAINT) {\n-            Constraint constraint = (Constraint) obj;\n-            Table table = constraint.getTable();\n-            if (table.isTemporary() && !table.isGlobalTemporary()) {\n-                session.removeLocalTempTableConstraint(constraint);\n-                return;\n-            }\n-        }\n-        checkWritingAllowed();\n-        lockMeta(session);\n-        synchronized (this) {\n-            Comment comment = findComment(obj);\n-            if (comment != null) {\n-                removeDatabaseObject(session, comment);\n-            }\n-            obj.getSchema().remove(obj);\n-            int id = obj.getId();\n-            if (!starting) {\n-                Table t = getDependentTable(obj, null);\n-                if (t != null) {\n-                    obj.getSchema().add(obj);\n-                    throw DbException.get(ErrorCode.CANNOT_DROP_2, obj.getSQL(),\n-                            t.getSQL());\n-                }\n-                obj.removeChildrenAndResources(session);\n-            }\n-            removeMeta(session, id);\n-        }\n-    }\n-\n-    /**\n-     * Check if this database disk-based.\n-     *\n-     * @return true if it is disk-based, false it it is in-memory only.\n-     */\n-    public boolean isPersistent() {\n-        return persistent;\n-    }\n-\n-    public TraceSystem getTraceSystem() {\n-        return traceSystem;\n-    }\n-\n-    public synchronized void setCacheSize(int kb) {\n-        if (starting) {\n-            int max = MathUtils.convertLongToInt(Utils.getMemoryMax()) / 2;\n-            kb = Math.min(kb, max);\n-        }\n-        cacheSize = kb;\n-        if (pageStore != null) {\n-            pageStore.getCache().setMaxMemory(kb);\n-        }\n-        if (mvStore != null) {\n-            mvStore.setCacheSize(Math.max(1, kb));\n-        }\n-    }\n-\n-    public synchronized void setMasterUser(User user) {\n-        lockMeta(systemSession);\n-        addDatabaseObject(systemSession, user);\n-        systemSession.commit(true);\n-    }\n-\n-    public Role getPublicRole() {\n-        return publicRole;\n-    }\n-\n-    /**\n-     * Get a unique temporary table name.\n-     *\n-     * @param baseName the prefix of the returned name\n-     * @param session the session\n-     * @return a unique name\n-     */\n-    public synchronized String getTempTableName(String baseName, Session session) {\n-        String tempName;\n-        do {\n-            tempName = baseName + \"_COPY_\" + session.getId() +\n-                    \"_\" + nextTempTableId++;\n-        } while (mainSchema.findTableOrView(session, tempName) != null);\n-        return tempName;\n-    }\n-\n-    public void setCompareMode(CompareMode compareMode) {\n-        this.compareMode = compareMode;\n-    }\n-\n-    public void setCluster(String cluster) {\n-        this.cluster = cluster;\n-    }\n-\n-    @Override\n-    public void checkWritingAllowed() {\n-        if (readOnly) {\n-            throw DbException.get(ErrorCode.DATABASE_IS_READ_ONLY);\n-        }\n-        if (fileLockMethod == FileLock.LOCK_SERIALIZED) {\n-            if (!reconnectChangePending) {\n-                throw DbException.get(ErrorCode.DATABASE_IS_READ_ONLY);\n-            }\n-        }\n-    }\n-\n-    public boolean isReadOnly() {\n-        return readOnly;\n-    }\n-\n-    public void setWriteDelay(int value) {\n-        writeDelay = value;\n-        if (writer != null) {\n-            writer.setWriteDelay(value);\n-            // TODO check if MIN_WRITE_DELAY is a good value\n-            flushOnEachCommit = writeDelay < Constants.MIN_WRITE_DELAY;\n-        }\n-        if (mvStore != null) {\n-            int millis = value < 0 ? 0 : value;\n-            mvStore.getStore().setAutoCommitDelay(millis);\n-        }\n-    }\n-\n-    public int getRetentionTime() {\n-        return retentionTime;\n+      }\n+      removeMeta(session, id);\n+    }\n+  }\n+\n+  /**\n+   * Check if this database disk-based.\n+   *\n+   * @return true if it is disk-based, false it it is in-memory only.\n+   */\n+  public boolean isPersistent() {\n+    return persistent;\n+  }\n+\n+  public TraceSystem getTraceSystem() {\n+    return traceSystem;\n+  }\n+\n+  public synchronized void setCacheSize(int kb) {\n+    if (starting) {\n+      int max = MathUtils.convertLongToInt(Utils.getMemoryMax()) / 2;\n+      kb = Math.min(kb, max);\n+    }\n+    cacheSize = kb;\n+    if (pageStore != null) {\n+      pageStore.getCache().setMaxMemory(kb);\n+    }\n+    if (mvStore != null) {\n+      mvStore.setCacheSize(Math.max(1, kb));\n+    }\n+  }\n+\n+  public synchronized void setMasterUser(User user) {\n+    lockMeta(systemSession);\n+    addDatabaseObject(systemSession, user);\n+    systemSession.commit(true);\n+  }\n+\n+  public Role getPublicRole() {\n+    return publicRole;\n+  }\n+\n+  /**\n+   * Get a unique temporary table name.\n+   *\n+   * @param baseName the prefix of the returned name\n+   * @param session  the session\n+   * @return a unique name\n+   */\n+  public synchronized String getTempTableName(String baseName,\n+                                              Session session) {\n+    String tempName;\n+    do {\n+      tempName = baseName + \"_COPY_\" + session.getId() +\n+          \"_\" + nextTempTableId++;\n+    } while (mainSchema.findTableOrView(session, tempName) != null);\n+    return tempName;\n+  }\n+\n+  public void setCompareMode(CompareMode compareMode) {\n+    this.compareMode = compareMode;\n+  }\n+\n+  public void setCluster(String cluster) {\n+    this.cluster = cluster;\n+  }\n+\n+  @Override\n+  public void checkWritingAllowed() {\n+    if (readOnly) {\n+      throw DbException.get(ErrorCode.DATABASE_IS_READ_ONLY);\n+    }\n+    if (fileLockMethod == FileLock.LOCK_SERIALIZED) {\n+      if (!reconnectChangePending) {\n+        throw DbException.get(ErrorCode.DATABASE_IS_READ_ONLY);\n+      }\n     }\n-\n-    public void setRetentionTime(int value) {\n-        retentionTime = value;\n-        if (mvStore != null) {\n-            mvStore.getStore().setRetentionTime(value);\n-        }\n+  }\n+\n+  public boolean isReadOnly() {\n+    return readOnly;\n+  }\n+\n+  public void setWriteDelay(int value) {\n+    writeDelay = value;\n+    if (writer != null) {\n+      writer.setWriteDelay(value);\n+      // TODO check if MIN_WRITE_DELAY is a good value\n+      flushOnEachCommit = writeDelay < Constants.MIN_WRITE_DELAY;\n+    }\n+    if (mvStore != null) {\n+      int millis = value < 0 ? 0 : value;\n+      mvStore.getStore().setAutoCommitDelay(millis);\n+    }\n+  }\n+\n+  public int getRetentionTime() {\n+    return retentionTime;\n+  }\n+\n+  public void setRetentionTime(int value) {\n+    retentionTime = value;\n+    if (mvStore != null) {\n+      mvStore.getStore().setRetentionTime(value);\n+    }\n+  }\n+\n+  public void setAllowBuiltinAliasOverride(boolean b) {\n+    allowBuiltinAliasOverride = b;\n+  }\n+\n+  public boolean isAllowBuiltinAliasOverride() {\n+    return allowBuiltinAliasOverride;\n+  }\n+\n+  /**\n+   * Check if flush-on-each-commit is enabled.\n+   *\n+   * @return true if it is\n+   */\n+  public boolean getFlushOnEachCommit() {\n+    return flushOnEachCommit;\n+  }\n+\n+  /**\n+   * Get the list of in-doubt transactions.\n+   *\n+   * @return the list\n+   */\n+  public ArrayList<InDoubtTransaction> getInDoubtTransactions() {\n+    if (mvStore != null) {\n+      return mvStore.getInDoubtTransactions();\n+    }\n+    return pageStore == null ? null : pageStore.getInDoubtTransactions();\n+  }\n+\n+  /**\n+   * Prepare a transaction.\n+   *\n+   * @param session     the session\n+   * @param transaction the name of the transaction\n+   */\n+  synchronized void prepareCommit(Session session, String transaction) {\n+    if (readOnly) {\n+      return;\n+    }\n+    if (mvStore != null) {\n+      mvStore.prepareCommit(session, transaction);\n+      return;\n+    }\n+    if (pageStore != null) {\n+      pageStore.flushLog();\n+      pageStore.prepareCommit(session, transaction);\n+    }\n+  }\n+\n+  /**\n+   * Commit the current transaction of the given session.\n+   *\n+   * @param session the session\n+   */\n+  synchronized void commit(Session session) {\n+    throwLastBackgroundException();\n+    if (readOnly) {\n+      return;\n+    }\n+    if (pageStore != null) {\n+      pageStore.commit(session);\n+    }\n+    session.setAllCommitted();\n+  }\n+\n+  private void throwLastBackgroundException() {\n+    if (backgroundException != null) {\n+      // we don't care too much about concurrency here,\n+      // we just want to make sure the exception is _normally_\n+      // not just logged to the .trace.db file\n+      DbException b = backgroundException;\n+      backgroundException = null;\n+      if (b != null) {\n+        // wrap the exception, so we see it was thrown here\n+        throw DbException.get(b.getErrorCode(), b, b.getMessage());\n+      }\n     }\n+  }\n \n-    public void setAllowBuiltinAliasOverride(boolean b) {\n-        allowBuiltinAliasOverride = b;\n+  public void setBackgroundException(DbException e) {\n+    if (backgroundException == null) {\n+      backgroundException = e;\n+      TraceSystem t = getTraceSystem();\n+      if (t != null) {\n+        t.getTrace(Trace.DATABASE).error(e, \"flush\");\n+      }\n     }\n+  }\n \n-    public boolean isAllowBuiltinAliasOverride() {\n-        return allowBuiltinAliasOverride;\n+  /**\n+   * Flush all pending changes to the transaction log.\n+   */\n+  public synchronized void flush() {\n+    if (readOnly) {\n+      return;\n     }\n-\n-    /**\n-     * Check if flush-on-each-commit is enabled.\n-     *\n-     * @return true if it is\n-     */\n-    public boolean getFlushOnEachCommit() {\n-        return flushOnEachCommit;\n+    if (pageStore != null) {\n+      pageStore.flushLog();\n     }\n-\n-    /**\n-     * Get the list of in-doubt transactions.\n-     *\n-     * @return the list\n-     */\n-    public ArrayList<InDoubtTransaction> getInDoubtTransactions() {\n-        if (mvStore != null) {\n-            return mvStore.getInDoubtTransactions();\n-        }\n-        return pageStore == null ? null : pageStore.getInDoubtTransactions();\n-    }\n-\n-    /**\n-     * Prepare a transaction.\n-     *\n-     * @param session the session\n-     * @param transaction the name of the transaction\n-     */\n-    synchronized void prepareCommit(Session session, String transaction) {\n-        if (readOnly) {\n-            return;\n-        }\n-        if (mvStore != null) {\n-            mvStore.prepareCommit(session, transaction);\n-            return;\n-        }\n-        if (pageStore != null) {\n-            pageStore.flushLog();\n-            pageStore.prepareCommit(session, transaction);\n-        }\n+    if (mvStore != null) {\n+      try {\n+        mvStore.flush();\n+      } catch (RuntimeException e) {\n+        backgroundException = DbException.convert(e);\n+        throw e;\n+      }\n     }\n-\n-    /**\n-     * Commit the current transaction of the given session.\n-     *\n-     * @param session the session\n-     */\n-    synchronized void commit(Session session) {\n-        throwLastBackgroundException();\n-        if (readOnly) {\n-            return;\n-        }\n-        if (pageStore != null) {\n-            pageStore.commit(session);\n-        }\n-        session.setAllCommitted();\n-    }\n-\n-    private void throwLastBackgroundException() {\n-        if (backgroundException != null) {\n-            // we don't care too much about concurrency here,\n-            // we just want to make sure the exception is _normally_\n-            // not just logged to the .trace.db file\n-            DbException b = backgroundException;\n-            backgroundException = null;\n-            if (b != null) {\n-                // wrap the exception, so we see it was thrown here\n-                throw DbException.get(b.getErrorCode(), b, b.getMessage());\n-            }\n-        }\n+  }\n+\n+  public void setEventListener(DatabaseEventListener eventListener) {\n+    this.eventListener = eventListener;\n+  }\n+\n+  public void setEventListenerClass(String className) {\n+    if (className == null || className.length() == 0) {\n+      eventListener = null;\n+    } else {\n+      try {\n+        eventListener = (DatabaseEventListener)\n+            JdbcUtils.loadUserClass(className).newInstance();\n+        String url = databaseURL;\n+        if (cipher != null) {\n+          url += \";CIPHER=\" + cipher;\n+        }\n+        eventListener.init(url);\n+      } catch (Throwable e) {\n+        throw DbException.get(\n+            ErrorCode.ERROR_SETTING_DATABASE_EVENT_LISTENER_2, e,\n+            className, e.toString());\n+      }\n     }\n-\n-    public void setBackgroundException(DbException e) {\n-        if (backgroundException == null) {\n-            backgroundException = e;\n-            TraceSystem t = getTraceSystem();\n-            if (t != null) {\n-                t.getTrace(Trace.DATABASE).error(e, \"flush\");\n-            }\n-        }\n+  }\n+\n+  /**\n+   * Set the progress of a long running operation.\n+   * This method calls the {@link DatabaseEventListener} if one is registered.\n+   *\n+   * @param state the {@link DatabaseEventListener} state\n+   * @param name  the object name\n+   * @param x     the current position\n+   * @param max   the highest value\n+   */\n+  public void setProgress(int state, String name, int x, int max) {\n+    if (eventListener != null) {\n+      try {\n+        eventListener.setProgress(state, name, x, max);\n+      } catch (Exception e2) {\n+        // ignore this (user made) exception\n+      }\n     }\n-\n-    /**\n-     * Flush all pending changes to the transaction log.\n-     */\n-    public synchronized void flush() {\n-        if (readOnly) {\n-            return;\n-        }\n-        if (pageStore != null) {\n-            pageStore.flushLog();\n-        }\n-        if (mvStore != null) {\n-            try {\n-                mvStore.flush();\n-            } catch (RuntimeException e) {\n-                backgroundException = DbException.convert(e);\n-                throw e;\n-            }\n-        }\n+  }\n+\n+  /**\n+   * This method is called after an exception occurred, to inform the database\n+   * event listener (if one is set).\n+   *\n+   * @param e   the exception\n+   * @param sql the SQL statement\n+   */\n+  public void exceptionThrown(SQLException e, String sql) {\n+    if (eventListener != null) {\n+      try {\n+        eventListener.exceptionThrown(e, sql);\n+      } catch (Exception e2) {\n+        // ignore this (user made) exception\n+      }\n     }\n-\n-    public void setEventListener(DatabaseEventListener eventListener) {\n-        this.eventListener = eventListener;\n+  }\n+\n+  /**\n+   * Synchronize the files with the file system. This method is called when\n+   * executing the SQL statement CHECKPOINT SYNC.\n+   */\n+  public synchronized void sync() {\n+    if (readOnly) {\n+      return;\n+    }\n+    if (mvStore != null) {\n+      mvStore.sync();\n+    }\n+    if (pageStore != null) {\n+      pageStore.sync();\n+    }\n+  }\n+\n+  public int getMaxMemoryRows() {\n+    return maxMemoryRows;\n+  }\n+\n+  public void setMaxMemoryRows(int value) {\n+    this.maxMemoryRows = value;\n+  }\n+\n+  public void setMaxMemoryUndo(int value) {\n+    this.maxMemoryUndo = value;\n+  }\n+\n+  public int getMaxMemoryUndo() {\n+    return maxMemoryUndo;\n+  }\n+\n+  public void setLockMode(int lockMode) {\n+    switch (lockMode) {\n+      case Constants.LOCK_MODE_OFF:\n+        if (multiThreaded) {\n+          // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n+          // is not supported. also see code in\n+          // JdbcDatabaseMetaData#supportsTransactionIsolationLevel(int)\n+          throw DbException.get(\n+              ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n+              \"LOCK_MODE=0 & MULTI_THREADED\");\n+        }\n+        break;\n+      case Constants.LOCK_MODE_READ_COMMITTED:\n+      case Constants.LOCK_MODE_TABLE:\n+      case Constants.LOCK_MODE_TABLE_GC:\n+        break;\n+      default:\n+        throw DbException.getInvalidValueException(\"lock mode\", lockMode);\n+    }\n+    this.lockMode = lockMode;\n+  }\n+\n+  public int getLockMode() {\n+    return lockMode;\n+  }\n+\n+  public synchronized void setCloseDelay(int value) {\n+    this.closeDelay = value;\n+  }\n+\n+  public Session getSystemSession() {\n+    return systemSession;\n+  }\n+\n+  /**\n+   * Check if the database is in the process of closing.\n+   *\n+   * @return true if the database is closing\n+   */\n+  public boolean isClosing() {\n+    return closing;\n+  }\n+\n+  public void setMaxLengthInplaceLob(int value) {\n+    this.maxLengthInplaceLob = value;\n+  }\n+\n+  @Override\n+  public int getMaxLengthInplaceLob() {\n+    return maxLengthInplaceLob;\n+  }\n+\n+  public void setIgnoreCase(boolean b) {\n+    ignoreCase = b;\n+  }\n+\n+  public boolean getIgnoreCase() {\n+    if (starting) {\n+      // tables created at startup must not be converted to ignorecase\n+      return false;\n+    }\n+    return ignoreCase;\n+  }\n+\n+  public synchronized void setDeleteFilesOnDisconnect(boolean b) {\n+    this.deleteFilesOnDisconnect = b;\n+  }\n+\n+  @Override\n+  public String getLobCompressionAlgorithm(int type) {\n+    return lobCompressionAlgorithm;\n+  }\n+\n+  public void setLobCompressionAlgorithm(String stringValue) {\n+    this.lobCompressionAlgorithm = stringValue;\n+  }\n+\n+  public synchronized void setMaxLogSize(long value) {\n+    if (pageStore != null) {\n+      pageStore.setMaxLogSize(value);\n+    }\n+  }\n+\n+  public void setAllowLiterals(int value) {\n+    this.allowLiterals = value;\n+  }\n+\n+  public boolean getOptimizeReuseResults() {\n+    return optimizeReuseResults;\n+  }\n+\n+  public void setOptimizeReuseResults(boolean b) {\n+    optimizeReuseResults = b;\n+  }\n+\n+  @Override\n+  public Object getLobSyncObject() {\n+    return lobSyncObject;\n+  }\n+\n+  public int getSessionCount() {\n+    return userSessions.size();\n+  }\n+\n+  public void setReferentialIntegrity(boolean b) {\n+    referentialIntegrity = b;\n+  }\n+\n+  public boolean getReferentialIntegrity() {\n+    return referentialIntegrity;\n+  }\n+\n+  public void setQueryStatistics(boolean b) {\n+    queryStatistics = b;\n+    synchronized (this) {\n+      if (!b) {\n+        queryStatisticsData = null;\n+      }\n     }\n+  }\n \n-    public void setEventListenerClass(String className) {\n-        if (className == null || className.length() == 0) {\n-            eventListener = null;\n-        } else {\n-            try {\n-                eventListener = (DatabaseEventListener)\n-                        JdbcUtils.loadUserClass(className).newInstance();\n-                String url = databaseURL;\n-                if (cipher != null) {\n-                    url += \";CIPHER=\" + cipher;\n-                }\n-                eventListener.init(url);\n-            } catch (Throwable e) {\n-                throw DbException.get(\n-                        ErrorCode.ERROR_SETTING_DATABASE_EVENT_LISTENER_2, e,\n-                        className, e.toString());\n-            }\n-        }\n-    }\n+  public boolean getQueryStatistics() {\n+    return queryStatistics;\n+  }\n \n-    /**\n-     * Set the progress of a long running operation.\n-     * This method calls the {@link DatabaseEventListener} if one is registered.\n-     *\n-     * @param state the {@link DatabaseEventListener} state\n-     * @param name the object name\n-     * @param x the current position\n-     * @param max the highest value\n-     */\n-    public void setProgress(int state, String name, int x, int max) {\n-        if (eventListener != null) {\n-            try {\n-                eventListener.setProgress(state, name, x, max);\n-            } catch (Exception e2) {\n-                // ignore this (user made) exception\n-            }\n+  public void setQueryStatisticsMaxEntries(int n) {\n+    queryStatisticsMaxEntries = n;\n+    if (queryStatisticsData != null) {\n+      synchronized (this) {\n+        if (queryStatisticsData != null) {\n+          queryStatisticsData.setMaxQueryEntries(queryStatisticsMaxEntries);\n         }\n+      }\n     }\n+  }\n \n-    /**\n-     * This method is called after an exception occurred, to inform the database\n-     * event listener (if one is set).\n-     *\n-     * @param e the exception\n-     * @param sql the SQL statement\n-     */\n-    public void exceptionThrown(SQLException e, String sql) {\n-        if (eventListener != null) {\n-            try {\n-                eventListener.exceptionThrown(e, sql);\n-            } catch (Exception e2) {\n-                // ignore this (user made) exception\n-            }\n-        }\n+  public QueryStatisticsData getQueryStatisticsData() {\n+    if (!queryStatistics) {\n+      return null;\n     }\n-\n-    /**\n-     * Synchronize the files with the file system. This method is called when\n-     * executing the SQL statement CHECKPOINT SYNC.\n-     */\n-    public synchronized void sync() {\n-        if (readOnly) {\n-            return;\n-        }\n-        if (mvStore != null) {\n-            mvStore.sync();\n-        }\n-        if (pageStore != null) {\n-            pageStore.sync();\n+    if (queryStatisticsData == null) {\n+      synchronized (this) {\n+        if (queryStatisticsData == null) {\n+          queryStatisticsData =\n+              new QueryStatisticsData(queryStatisticsMaxEntries);\n         }\n+      }\n     }\n-\n-    public int getMaxMemoryRows() {\n-        return maxMemoryRows;\n-    }\n-\n-    public void setMaxMemoryRows(int value) {\n-        this.maxMemoryRows = value;\n+    return queryStatisticsData;\n+  }\n+\n+  /**\n+   * Check if the database is currently opening. This is true until all stored\n+   * SQL statements have been executed.\n+   *\n+   * @return true if the database is still starting\n+   */\n+  public boolean isStarting() {\n+    return starting;\n+  }\n+\n+  /**\n+   * Check if multi version concurrency is enabled for this database.\n+   *\n+   * @return true if it is enabled\n+   */\n+  public boolean isMultiVersion() {\n+    return multiVersion;\n+  }\n+\n+  /**\n+   * Called after the database has been opened and initialized. This method\n+   * notifies the event listener if one has been set.\n+   */\n+  void opened() {\n+    if (eventListener != null) {\n+      eventListener.opened();\n+    }\n+    if (writer != null) {\n+      writer.startThread();\n+    }\n+  }\n+\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  public Mode getMode() {\n+    return mode;\n+  }\n+\n+  public boolean isMultiThreaded() {\n+    return multiThreaded;\n+  }\n+\n+  public void setMultiThreaded(boolean multiThreaded) {\n+    if (multiThreaded && this.multiThreaded != multiThreaded) {\n+      if (multiVersion && mvStore == null) {\n+        // currently the combination of MVCC and MULTI_THREADED is not\n+        // supported\n+        throw DbException.get(\n+            ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n+            \"MVCC & MULTI_THREADED\");\n+      }\n+      if (lockMode == 0) {\n+        // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n+        // is not supported\n+        throw DbException.get(\n+            ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n+            \"LOCK_MODE=0 & MULTI_THREADED\");\n+      }\n     }\n-\n-    public void setMaxMemoryUndo(int value) {\n-        this.maxMemoryUndo = value;\n+    this.multiThreaded = multiThreaded;\n+  }\n+\n+  public void setMaxOperationMemory(int maxOperationMemory) {\n+    this.maxOperationMemory = maxOperationMemory;\n+  }\n+\n+  public int getMaxOperationMemory() {\n+    return maxOperationMemory;\n+  }\n+\n+  public Session getExclusiveSession() {\n+    return exclusiveSession.get();\n+  }\n+\n+  /**\n+   * Set the session that can exclusively access the database.\n+   *\n+   * @param session     the session\n+   * @param closeOthers whether other sessions are closed\n+   */\n+  public void setExclusiveSession(Session session, boolean closeOthers) {\n+    this.exclusiveSession.set(session);\n+    if (closeOthers) {\n+      closeAllSessionsException(session);\n+    }\n+  }\n+\n+  @Override\n+  public SmallLRUCache<String, String[]> getLobFileListCache() {\n+    if (lobFileListCache == null) {\n+      lobFileListCache = SmallLRUCache.newInstance(128);\n+    }\n+    return lobFileListCache;\n+  }\n+\n+  /**\n+   * Checks if the system table (containing the catalog) is locked.\n+   *\n+   * @return true if it is currently locked\n+   */\n+  public boolean isSysTableLocked() {\n+    return meta == null || meta.isLockedExclusively();\n+  }\n+\n+  /**\n+   * Checks if the system table (containing the catalog) is locked by the\n+   * given session.\n+   *\n+   * @param session the session\n+   * @return true if it is currently locked\n+   */\n+  public boolean isSysTableLockedBy(Session session) {\n+    return meta == null || meta.isLockedExclusivelyBy(session);\n+  }\n+\n+  /**\n+   * Open a new connection or get an existing connection to another database.\n+   *\n+   * @param driver   the database driver or null\n+   * @param url      the database URL\n+   * @param user     the user name\n+   * @param password the password\n+   * @return the connection\n+   */\n+  public TableLinkConnection getLinkConnection(String driver, String url,\n+                                               String user, String password) {\n+    if (linkConnections == null) {\n+      linkConnections = New.hashMap();\n+    }\n+    return TableLinkConnection.open(linkConnections, driver, url, user,\n+        password, dbSettings.shareLinkedConnections);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return databaseShortName + \":\" + super.toString();\n+  }\n+\n+  /**\n+   * Immediately close the database.\n+   */\n+  public void shutdownImmediately() {\n+    setPowerOffCount(1);\n+    try {\n+      checkPowerOff();\n+    } catch (DbException e) {\n+      // ignore\n+    }\n+    closeFiles();\n+  }\n+\n+  @Override\n+  public TempFileDeleter getTempFileDeleter() {\n+    return tempFileDeleter;\n+  }\n+\n+  public PageStore getPageStore() {\n+    if (dbSettings.mvStore) {\n+      if (mvStore == null) {\n+        mvStore = MVTableEngine.init(this);\n+      }\n+      return null;\n     }\n-\n-    public int getMaxMemoryUndo() {\n-        return maxMemoryUndo;\n+    if (pageStore == null) {\n+      pageStore = new PageStore(this, databaseName +\n+          Constants.SUFFIX_PAGE_FILE, accessModeData, cacheSize);\n+      if (pageSize != Constants.DEFAULT_PAGE_SIZE) {\n+        pageStore.setPageSize(pageSize);\n+      }\n+      if (!readOnly && fileLockMethod == FileLock.LOCK_FS) {\n+        pageStore.setLockFile(true);\n+      }\n+      pageStore.setLogMode(logMode);\n+      pageStore.open();\n+    }\n+    return pageStore;\n+  }\n+\n+  /**\n+   * Get the first user defined table.\n+   *\n+   * @return the table or null if no table is defined\n+   */\n+  public Table getFirstUserTable() {\n+    for (Table table : getAllTablesAndViews(false)) {\n+      if (table.getCreateSQL() != null) {\n+        if (table.isHidden()) {\n+          // LOB tables\n+          continue;\n+        }\n+        return table;\n+      }\n     }\n-\n-    public void setLockMode(int lockMode) {\n-        switch (lockMode) {\n-        case Constants.LOCK_MODE_OFF:\n-            if (multiThreaded) {\n-                // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n-                // is not supported. also see code in\n-                // JdbcDatabaseMetaData#supportsTransactionIsolationLevel(int)\n-                throw DbException.get(\n-                        ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n-                        \"LOCK_MODE=0 & MULTI_THREADED\");\n-            }\n+    return null;\n+  }\n+\n+  /**\n+   * Check if the contents of the database was changed and therefore it is\n+   * required to re-connect. This method waits until pending changes are\n+   * completed. If a pending change takes too long (more than 2 seconds), the\n+   * pending change is broken (removed from the properties file).\n+   *\n+   * @return true if reconnecting is required\n+   */\n+  public boolean isReconnectNeeded() {\n+    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n+      return false;\n+    }\n+    if (reconnectChangePending) {\n+      return false;\n+    }\n+    long now = System.nanoTime();\n+    if (now < reconnectCheckNext) {\n+      return false;\n+    }\n+    reconnectCheckNext = now + reconnectCheckDelayNs;\n+    if (lock == null) {\n+      lock = new FileLock(traceSystem, databaseName +\n+          Constants.SUFFIX_LOCK_FILE, Constants.LOCK_SLEEP);\n+    }\n+    try {\n+      Properties prop = lock.load(), first = prop;\n+      while (true) {\n+        if (prop.equals(reconnectLastLock)) {\n+          return false;\n+        }\n+        if (prop.getProperty(\"changePending\", null) == null) {\n+          break;\n+        }\n+        if (System.nanoTime() >\n+            now + reconnectCheckDelayNs * 10) {\n+          if (first.equals(prop)) {\n+            // the writing process didn't update the file -\n+            // it may have terminated\n+            lock.setProperty(\"changePending\", null);\n+            lock.save();\n             break;\n-        case Constants.LOCK_MODE_READ_COMMITTED:\n-        case Constants.LOCK_MODE_TABLE:\n-        case Constants.LOCK_MODE_TABLE_GC:\n-            break;\n-        default:\n-            throw DbException.getInvalidValueException(\"lock mode\", lockMode);\n+          }\n         }\n-        this.lockMode = lockMode;\n-    }\n-\n-    public int getLockMode() {\n-        return lockMode;\n-    }\n-\n-    public synchronized void setCloseDelay(int value) {\n-        this.closeDelay = value;\n-    }\n-\n-    public Session getSystemSession() {\n-        return systemSession;\n-    }\n-\n-    /**\n-     * Check if the database is in the process of closing.\n-     *\n-     * @return true if the database is closing\n-     */\n-    public boolean isClosing() {\n-        return closing;\n-    }\n-\n-    public void setMaxLengthInplaceLob(int value) {\n-        this.maxLengthInplaceLob = value;\n-    }\n-\n-    @Override\n-    public int getMaxLengthInplaceLob() {\n-        return maxLengthInplaceLob;\n-    }\n-\n-    public void setIgnoreCase(boolean b) {\n-        ignoreCase = b;\n-    }\n-\n-    public boolean getIgnoreCase() {\n-        if (starting) {\n-            // tables created at startup must not be converted to ignorecase\n-            return false;\n+        trace.debug(\"delay (change pending)\");\n+        Thread.sleep(TimeUnit.NANOSECONDS.toMillis(reconnectCheckDelayNs));\n+        prop = lock.load();\n+      }\n+      reconnectLastLock = prop;\n+    } catch (Exception e) {\n+      // DbException, InterruptedException\n+      trace.error(e, \"readOnly {0}\", readOnly);\n+      // ignore\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Flush all changes when using the serialized mode, and if there are\n+   * pending changes, and some time has passed. This switches to a new\n+   * transaction log and resets the change pending flag in\n+   * the .lock.db file.\n+   */\n+  public void checkpointIfRequired() {\n+    if (fileLockMethod != FileLock.LOCK_SERIALIZED ||\n+        readOnly || !reconnectChangePending || closing) {\n+      return;\n+    }\n+    long now = System.nanoTime();\n+    if (now > reconnectCheckNext + reconnectCheckDelayNs) {\n+      if (SysProperties.CHECK && checkpointAllowed < 0) {\n+        DbException.throwInternalError(\"\" + checkpointAllowed);\n+      }\n+      synchronized (reconnectSync) {\n+        if (checkpointAllowed > 0) {\n+          return;\n         }\n-        return ignoreCase;\n-    }\n-\n-    public synchronized void setDeleteFilesOnDisconnect(boolean b) {\n-        this.deleteFilesOnDisconnect = b;\n+        checkpointRunning = true;\n+      }\n+      synchronized (this) {\n+        trace.debug(\"checkpoint start\");\n+        flushSequences();\n+        checkpoint();\n+        reconnectModified(false);\n+        trace.debug(\"checkpoint end\");\n+      }\n+      synchronized (reconnectSync) {\n+        checkpointRunning = false;\n+      }\n     }\n+  }\n \n-    @Override\n-    public String getLobCompressionAlgorithm(int type) {\n-        return lobCompressionAlgorithm;\n-    }\n+  public boolean isFileLockSerialized() {\n+    return fileLockMethod == FileLock.LOCK_SERIALIZED;\n+  }\n \n-    public void setLobCompressionAlgorithm(String stringValue) {\n-        this.lobCompressionAlgorithm = stringValue;\n+  private void flushSequences() {\n+    for (SchemaObject obj : getAllSchemaObjects(DbObject.SEQUENCE)) {\n+      Sequence sequence = (Sequence) obj;\n+      sequence.flushWithoutMargin();\n     }\n+  }\n \n-    public synchronized void setMaxLogSize(long value) {\n+  /**\n+   * Flush all changes and open a new transaction log.\n+   */\n+  public void checkpoint() {\n+    if (persistent) {\n+      synchronized (this) {\n         if (pageStore != null) {\n-            pageStore.setMaxLogSize(value);\n+          pageStore.checkpoint();\n         }\n-    }\n-\n-    public void setAllowLiterals(int value) {\n-        this.allowLiterals = value;\n-    }\n-\n-    public boolean getOptimizeReuseResults() {\n-        return optimizeReuseResults;\n-    }\n-\n-    public void setOptimizeReuseResults(boolean b) {\n-        optimizeReuseResults = b;\n-    }\n-\n-    @Override\n-    public Object getLobSyncObject() {\n-        return lobSyncObject;\n-    }\n-\n-    public int getSessionCount() {\n-        return userSessions.size();\n-    }\n-\n-    public void setReferentialIntegrity(boolean b) {\n-        referentialIntegrity = b;\n-    }\n-\n-    public boolean getReferentialIntegrity() {\n-        return referentialIntegrity;\n-    }\n-\n-    public void setQueryStatistics(boolean b) {\n-        queryStatistics = b;\n-        synchronized (this) {\n-            if (!b) {\n-                queryStatisticsData = null;\n-            }\n-        }\n-    }\n-\n-    public boolean getQueryStatistics() {\n-        return queryStatistics;\n-    }\n-\n-    public void setQueryStatisticsMaxEntries(int n) {\n-        queryStatisticsMaxEntries = n;\n-        if (queryStatisticsData != null) {\n-            synchronized (this) {\n-                if (queryStatisticsData != null) {\n-                    queryStatisticsData.setMaxQueryEntries(queryStatisticsMaxEntries);\n-                }\n-            }\n-        }\n-    }\n-\n-    public QueryStatisticsData getQueryStatisticsData() {\n-        if (!queryStatistics) {\n-            return null;\n-        }\n-        if (queryStatisticsData == null) {\n-            synchronized (this) {\n-                if (queryStatisticsData == null) {\n-                    queryStatisticsData = new QueryStatisticsData(queryStatisticsMaxEntries);\n-                }\n-            }\n-        }\n-        return queryStatisticsData;\n-    }\n-\n-    /**\n-     * Check if the database is currently opening. This is true until all stored\n-     * SQL statements have been executed.\n-     *\n-     * @return true if the database is still starting\n-     */\n-    public boolean isStarting() {\n-        return starting;\n-    }\n-\n-    /**\n-     * Check if multi version concurrency is enabled for this database.\n-     *\n-     * @return true if it is enabled\n-     */\n-    public boolean isMultiVersion() {\n-        return multiVersion;\n-    }\n-\n-    /**\n-     * Called after the database has been opened and initialized. This method\n-     * notifies the event listener if one has been set.\n-     */\n-    void opened() {\n-        if (eventListener != null) {\n-            eventListener.opened();\n-        }\n-        if (writer != null) {\n-            writer.startThread();\n-        }\n-    }\n-\n-    public void setMode(Mode mode) {\n-        this.mode = mode;\n-    }\n-\n-    public Mode getMode() {\n-        return mode;\n-    }\n-\n-    public boolean isMultiThreaded() {\n-        return multiThreaded;\n-    }\n-\n-    public void setMultiThreaded(boolean multiThreaded) {\n-        if (multiThreaded && this.multiThreaded != multiThreaded) {\n-            if (multiVersion && mvStore == null) {\n-                // currently the combination of MVCC and MULTI_THREADED is not\n-                // supported\n-                throw DbException.get(\n-                        ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n-                        \"MVCC & MULTI_THREADED\");\n-            }\n-            if (lockMode == 0) {\n-                // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n-                // is not supported\n-                throw DbException.get(\n-                        ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n-                        \"LOCK_MODE=0 & MULTI_THREADED\");\n-            }\n-        }\n-        this.multiThreaded = multiThreaded;\n-    }\n-\n-    public void setMaxOperationMemory(int maxOperationMemory) {\n-        this.maxOperationMemory  = maxOperationMemory;\n-    }\n-\n-    public int getMaxOperationMemory() {\n-        return maxOperationMemory;\n-    }\n-\n-    public Session getExclusiveSession() {\n-        return exclusiveSession.get();\n-    }\n-\n-    /**\n-     * Set the session that can exclusively access the database.\n-     *\n-     * @param session the session\n-     * @param closeOthers whether other sessions are closed\n-     */\n-    public void setExclusiveSession(Session session, boolean closeOthers) {\n-      this.exclusiveSession.set(session);\n-      if (closeOthers) {\n-          closeAllSessionsException(session);\n+      }\n+      if (mvStore != null) {\n+        mvStore.flush();\n       }\n     }\n-\n-    @Override\n-    public SmallLRUCache<String, String[]> getLobFileListCache() {\n-        if (lobFileListCache == null) {\n-            lobFileListCache = SmallLRUCache.newInstance(128);\n-        }\n-        return lobFileListCache;\n-    }\n-\n-    /**\n-     * Checks if the system table (containing the catalog) is locked.\n-     *\n-     * @return true if it is currently locked\n-     */\n-    public boolean isSysTableLocked() {\n-        return meta == null || meta.isLockedExclusively();\n-    }\n-\n-    /**\n-     * Checks if the system table (containing the catalog) is locked by the\n-     * given session.\n-     *\n-     * @param session the session\n-     * @return true if it is currently locked\n-     */\n-    public boolean isSysTableLockedBy(Session session) {\n-        return meta == null || meta.isLockedExclusivelyBy(session);\n-    }\n-\n-    /**\n-     * Open a new connection or get an existing connection to another database.\n-     *\n-     * @param driver the database driver or null\n-     * @param url the database URL\n-     * @param user the user name\n-     * @param password the password\n-     * @return the connection\n-     */\n-    public TableLinkConnection getLinkConnection(String driver, String url,\n-            String user, String password) {\n-        if (linkConnections == null) {\n-            linkConnections = New.hashMap();\n-        }\n-        return TableLinkConnection.open(linkConnections, driver, url, user,\n-                password, dbSettings.shareLinkedConnections);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return databaseShortName + \":\" + super.toString();\n-    }\n-\n-    /**\n-     * Immediately close the database.\n-     */\n-    public void shutdownImmediately() {\n-        setPowerOffCount(1);\n-        try {\n-            checkPowerOff();\n-        } catch (DbException e) {\n-            // ignore\n-        }\n-        closeFiles();\n-    }\n-\n-    @Override\n-    public TempFileDeleter getTempFileDeleter() {\n-        return tempFileDeleter;\n-    }\n-\n-    public PageStore getPageStore() {\n-        if (dbSettings.mvStore) {\n-            if (mvStore == null) {\n-                mvStore = MVTableEngine.init(this);\n-            }\n-            return null;\n-        }\n-        if (pageStore == null) {\n-            pageStore = new PageStore(this, databaseName +\n-                    Constants.SUFFIX_PAGE_FILE, accessModeData, cacheSize);\n-            if (pageSize != Constants.DEFAULT_PAGE_SIZE) {\n-                pageStore.setPageSize(pageSize);\n-            }\n-            if (!readOnly && fileLockMethod == FileLock.LOCK_FS) {\n-                pageStore.setLockFile(true);\n-            }\n-            pageStore.setLogMode(logMode);\n-            pageStore.open();\n-        }\n-        return pageStore;\n-    }\n-\n-    /**\n-     * Get the first user defined table.\n-     *\n-     * @return the table or null if no table is defined\n-     */\n-    public Table getFirstUserTable() {\n-        for (Table table : getAllTablesAndViews(false)) {\n-            if (table.getCreateSQL() != null) {\n-                if (table.isHidden()) {\n-                    // LOB tables\n-                    continue;\n-                }\n-                return table;\n-            }\n-        }\n-        return null;\n+    getTempFileDeleter().deleteUnused();\n+  }\n+\n+  /**\n+   * This method is called before writing to the transaction log.\n+   *\n+   * @return true if the call was successful and writing is allowed,\n+   * false if another connection was faster\n+   */\n+  public boolean beforeWriting() {\n+    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n+      return true;\n+    }\n+    while (checkpointRunning) {\n+      try {\n+        Thread.sleep(10 + (int) (Math.random() * 10));\n+      } catch (Exception e) {\n+        // ignore InterruptedException\n+      }\n     }\n-\n-    /**\n-     * Check if the contents of the database was changed and therefore it is\n-     * required to re-connect. This method waits until pending changes are\n-     * completed. If a pending change takes too long (more than 2 seconds), the\n-     * pending change is broken (removed from the properties file).\n-     *\n-     * @return true if reconnecting is required\n-     */\n-    public boolean isReconnectNeeded() {\n-        if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n-            return false;\n-        }\n-        if (reconnectChangePending) {\n-            return false;\n-        }\n-        long now = System.nanoTime();\n-        if (now < reconnectCheckNext) {\n-            return false;\n-        }\n-        reconnectCheckNext = now + reconnectCheckDelayNs;\n-        if (lock == null) {\n-            lock = new FileLock(traceSystem, databaseName +\n-                    Constants.SUFFIX_LOCK_FILE, Constants.LOCK_SLEEP);\n-        }\n-        try {\n-            Properties prop = lock.load(), first = prop;\n-            while (true) {\n-                if (prop.equals(reconnectLastLock)) {\n-                    return false;\n-                }\n-                if (prop.getProperty(\"changePending\", null) == null) {\n-                    break;\n-                }\n-                if (System.nanoTime() >\n-                        now + reconnectCheckDelayNs * 10) {\n-                    if (first.equals(prop)) {\n-                        // the writing process didn't update the file -\n-                        // it may have terminated\n-                        lock.setProperty(\"changePending\", null);\n-                        lock.save();\n-                        break;\n-                    }\n-                }\n-                trace.debug(\"delay (change pending)\");\n-                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(reconnectCheckDelayNs));\n-                prop = lock.load();\n-            }\n-            reconnectLastLock = prop;\n-        } catch (Exception e) {\n-            // DbException, InterruptedException\n-            trace.error(e, \"readOnly {0}\", readOnly);\n-            // ignore\n+    synchronized (reconnectSync) {\n+      if (reconnectModified(true)) {\n+        checkpointAllowed++;\n+        if (SysProperties.CHECK && checkpointAllowed > 20) {\n+          throw DbException.throwInternalError(\"\" + checkpointAllowed);\n         }\n         return true;\n+      }\n     }\n-\n-    /**\n-     * Flush all changes when using the serialized mode, and if there are\n-     * pending changes, and some time has passed. This switches to a new\n-     * transaction log and resets the change pending flag in\n-     * the .lock.db file.\n-     */\n-    public void checkpointIfRequired() {\n-        if (fileLockMethod != FileLock.LOCK_SERIALIZED ||\n-                readOnly || !reconnectChangePending || closing) {\n-            return;\n-        }\n-        long now = System.nanoTime();\n-        if (now > reconnectCheckNext + reconnectCheckDelayNs) {\n-            if (SysProperties.CHECK && checkpointAllowed < 0) {\n-                DbException.throwInternalError(\"\" + checkpointAllowed);\n-            }\n-            synchronized (reconnectSync) {\n-                if (checkpointAllowed > 0) {\n-                    return;\n-                }\n-                checkpointRunning = true;\n-            }\n-            synchronized (this) {\n-                trace.debug(\"checkpoint start\");\n-                flushSequences();\n-                checkpoint();\n-                reconnectModified(false);\n-                trace.debug(\"checkpoint end\");\n-            }\n-            synchronized (reconnectSync) {\n-                checkpointRunning = false;\n-            }\n-        }\n-    }\n-\n-    public boolean isFileLockSerialized() {\n-        return fileLockMethod == FileLock.LOCK_SERIALIZED;\n-    }\n-\n-    private void flushSequences() {\n-        for (SchemaObject obj : getAllSchemaObjects(DbObject.SEQUENCE)) {\n-            Sequence sequence = (Sequence) obj;\n-            sequence.flushWithoutMargin();\n-        }\n-    }\n-\n-    /**\n-     * Flush all changes and open a new transaction log.\n-     */\n-    public void checkpoint() {\n-        if (persistent) {\n-            synchronized (this) {\n-                if (pageStore != null) {\n-                    pageStore.checkpoint();\n-                }\n-            }\n-            if (mvStore != null) {\n-                mvStore.flush();\n-            }\n-        }\n-        getTempFileDeleter().deleteUnused();\n-    }\n-\n-    /**\n-     * This method is called before writing to the transaction log.\n-     *\n-     * @return true if the call was successful and writing is allowed,\n-     *          false if another connection was faster\n-     */\n-    public boolean beforeWriting() {\n-        if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n-            return true;\n-        }\n-        while (checkpointRunning) {\n-            try {\n-                Thread.sleep(10 + (int) (Math.random() * 10));\n-            } catch (Exception e) {\n-                // ignore InterruptedException\n-            }\n-        }\n-        synchronized (reconnectSync) {\n-            if (reconnectModified(true)) {\n-                checkpointAllowed++;\n-                if (SysProperties.CHECK && checkpointAllowed > 20) {\n-                    throw DbException.throwInternalError(\"\" + checkpointAllowed);\n-                }\n-                return true;\n-            }\n-        }\n-        // make sure the next call to isReconnectNeeded() returns true\n-        reconnectCheckNext = System.nanoTime() - 1;\n-        reconnectLastLock = null;\n-        return false;\n-    }\n-\n-    /**\n-     * This method is called after updates are finished.\n-     */\n-    public void afterWriting() {\n-        if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n-            return;\n-        }\n-        synchronized (reconnectSync) {\n-            checkpointAllowed--;\n-        }\n-        if (SysProperties.CHECK && checkpointAllowed < 0) {\n-            throw DbException.throwInternalError(\"\" + checkpointAllowed);\n-        }\n-    }\n-\n-    /**\n-     * Switch the database to read-only mode.\n-     *\n-     * @param readOnly the new value\n-     */\n-    public void setReadOnly(boolean readOnly) {\n-        this.readOnly = readOnly;\n-    }\n-\n-    public void setCompactMode(int compactMode) {\n-        this.compactMode = compactMode;\n-    }\n-\n-    public SourceCompiler getCompiler() {\n-        if (compiler == null) {\n-            compiler = new SourceCompiler();\n-        }\n-        return compiler;\n-    }\n-\n-    @Override\n-    public LobStorageInterface getLobStorage() {\n-        if (lobStorage == null) {\n-            if (dbSettings.mvStore) {\n-                lobStorage = new LobStorageMap(this);\n-            } else {\n-                lobStorage = new LobStorageBackend(this);\n-            }\n-        }\n-        return lobStorage;\n-    }\n-\n-    public JdbcConnection getLobConnectionForInit() {\n-        String url = Constants.CONN_URL_INTERNAL;\n-        JdbcConnection conn = new JdbcConnection(\n-                systemSession, systemUser.getName(), url);\n-        conn.setTraceLevel(TraceSystem.OFF);\n-        return conn;\n-    }\n-\n-    public JdbcConnection getLobConnectionForRegularUse() {\n-        String url = Constants.CONN_URL_INTERNAL;\n-        JdbcConnection conn = new JdbcConnection(\n-                lobSession, systemUser.getName(), url);\n-        conn.setTraceLevel(TraceSystem.OFF);\n-        return conn;\n-    }\n-\n-    public Session getLobSession() {\n-        return lobSession;\n-    }\n-\n-    public void setLogMode(int log) {\n-        if (log < 0 || log > 2) {\n-            throw DbException.getInvalidValueException(\"LOG\", log);\n-        }\n-        if (pageStore != null) {\n-            if (log != PageStore.LOG_MODE_SYNC ||\n-                    pageStore.getLogMode() != PageStore.LOG_MODE_SYNC) {\n-                // write the log mode in the trace file when enabling or\n-                // disabling a dangerous mode\n-                trace.error(null, \"log {0}\", log);\n-            }\n-            this.logMode = log;\n-            pageStore.setLogMode(log);\n-        }\n-        if (mvStore != null) {\n-            this.logMode = log;\n-        }\n-    }\n-\n-    public int getLogMode() {\n-        if (pageStore != null) {\n-            return pageStore.getLogMode();\n-        }\n-        if (mvStore != null) {\n-            return logMode;\n-        }\n-        return PageStore.LOG_MODE_OFF;\n-    }\n-\n-    public int getDefaultTableType() {\n-        return defaultTableType;\n-    }\n-\n-    public void setDefaultTableType(int defaultTableType) {\n-        this.defaultTableType = defaultTableType;\n-    }\n-\n-    public void setMultiVersion(boolean multiVersion) {\n-        this.multiVersion = multiVersion;\n-    }\n-\n-    public DbSettings getSettings() {\n-        return dbSettings;\n-    }\n-\n-    /**\n-     * Create a new hash map. Depending on the configuration, the key is case\n-     * sensitive or case insensitive.\n-     *\n-     * @param <V> the value type\n-     * @return the hash map\n-     */\n-    public <V> HashMap<String, V> newStringMap() {\n-        return dbSettings.databaseToUpper ?\n-                new HashMap<String, V>() :\n-                new CaseInsensitiveMap<V>();\n-    }\n-\n-    /**\n-     * Create a new hash map. Depending on the configuration, the key is case\n-     * sensitive or case insensitive.\n-     *\n-     * @param <V> the value type\n-     * @return the hash map\n-     */\n-    public <V> ConcurrentHashMap<String, V> newConcurrentStringMap() {\n-        return dbSettings.databaseToUpper ?\n-                new NullableKeyConcurrentMap<V>() :\n-                new CaseInsensitiveConcurrentMap<V>();\n-    }\n-\n-    /**\n-     * Compare two identifiers (table names, column names,...) and verify they\n-     * are equal. Case sensitivity depends on the configuration.\n-     *\n-     * @param a the first identifier\n-     * @param b the second identifier\n-     * @return true if they match\n-     */\n-    public boolean equalsIdentifiers(String a, String b) {\n-        if (a == b || a.equals(b)) {\n-            return true;\n-        }\n-        if (!dbSettings.databaseToUpper && a.equalsIgnoreCase(b)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public int readLob(long lobId, byte[] hmac, long offset, byte[] buff,\n-            int off, int length) {\n-        throw DbException.throwInternalError();\n-    }\n-\n-    public byte[] getFileEncryptionKey() {\n-        return fileEncryptionKey;\n-    }\n-\n-    public int getPageSize() {\n-        return pageSize;\n-    }\n-\n-    @Override\n-    public JavaObjectSerializer getJavaObjectSerializer() {\n-        initJavaObjectSerializer();\n-        return javaObjectSerializer;\n-    }\n-\n-    private void initJavaObjectSerializer() {\n-        if (javaObjectSerializerInitialized) {\n-            return;\n-        }\n-        synchronized (this) {\n-            if (javaObjectSerializerInitialized) {\n-                return;\n-            }\n-            String serializerName = javaObjectSerializerName;\n-            if (serializerName != null) {\n-                serializerName = serializerName.trim();\n-                if (!serializerName.isEmpty() &&\n-                        !serializerName.equals(\"null\")) {\n-                    try {\n-                        javaObjectSerializer = (JavaObjectSerializer)\n-                                JdbcUtils.loadUserClass(serializerName).newInstance();\n-                    } catch (Exception e) {\n-                        throw DbException.convert(e);\n-                    }\n-                }\n-            }\n-            javaObjectSerializerInitialized = true;\n-        }\n-    }\n-\n-    public void setJavaObjectSerializerName(String serializerName) {\n-        synchronized (this) {\n-            javaObjectSerializerInitialized = false;\n-            javaObjectSerializerName = serializerName;\n-        }\n+    // make sure the next call to isReconnectNeeded() returns true\n+    reconnectCheckNext = System.nanoTime() - 1;\n+    reconnectLastLock = null;\n+    return false;\n+  }\n+\n+  /**\n+   * This method is called after updates are finished.\n+   */\n+  public void afterWriting() {\n+    if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n+      return;\n+    }\n+    synchronized (reconnectSync) {\n+      checkpointAllowed--;\n+    }\n+    if (SysProperties.CHECK && checkpointAllowed < 0) {\n+      throw DbException.throwInternalError(\"\" + checkpointAllowed);\n+    }\n+  }\n+\n+  /**\n+   * Switch the database to read-only mode.\n+   *\n+   * @param readOnly the new value\n+   */\n+  public void setReadOnly(boolean readOnly) {\n+    this.readOnly = readOnly;\n+  }\n+\n+  public void setCompactMode(int compactMode) {\n+    this.compactMode = compactMode;\n+  }\n+\n+  public SourceCompiler getCompiler() {\n+    if (compiler == null) {\n+      compiler = new SourceCompiler();\n+    }\n+    return compiler;\n+  }\n+\n+  @Override\n+  public LobStorageInterface getLobStorage() {\n+    if (lobStorage == null) {\n+      if (dbSettings.mvStore) {\n+        lobStorage = new LobStorageMap(this);\n+      } else {\n+        lobStorage = new LobStorageBackend(this);\n+      }\n     }\n-\n-    /**\n-     * Get the table engine class, loading it if needed.\n-     *\n-     * @param tableEngine the table engine name\n-     * @return the class\n-     */\n-    public TableEngine getTableEngine(String tableEngine) {\n-        assert Thread.holdsLock(this);\n-\n-        TableEngine engine = tableEngines.get(tableEngine);\n-        if (engine == null) {\n-            try {\n-                engine = (TableEngine) JdbcUtils.loadUserClass(tableEngine).newInstance();\n-            } catch (Exception e) {\n-                throw DbException.convert(e);\n-            }\n-            tableEngines.put(tableEngine, engine);\n+    return lobStorage;\n+  }\n+\n+  public JdbcConnection getLobConnectionForInit() {\n+    String url = Constants.CONN_URL_INTERNAL;\n+    JdbcConnection conn = new JdbcConnection(\n+        systemSession, systemUser.getName(), url);\n+    conn.setTraceLevel(TraceSystem.OFF);\n+    return conn;\n+  }\n+\n+  public JdbcConnection getLobConnectionForRegularUse() {\n+    String url = Constants.CONN_URL_INTERNAL;\n+    JdbcConnection conn = new JdbcConnection(\n+        lobSession, systemUser.getName(), url);\n+    conn.setTraceLevel(TraceSystem.OFF);\n+    return conn;\n+  }\n+\n+  public Session getLobSession() {\n+    return lobSession;\n+  }\n+\n+  public void setLogMode(int log) {\n+    if (log < 0 || log > 2) {\n+      throw DbException.getInvalidValueException(\"LOG\", log);\n+    }\n+    if (pageStore != null) {\n+      if (log != PageStore.LOG_MODE_SYNC ||\n+          pageStore.getLogMode() != PageStore.LOG_MODE_SYNC) {\n+        // write the log mode in the trace file when enabling or\n+        // disabling a dangerous mode\n+        trace.error(null, \"log {0}\", log);\n+      }\n+      this.logMode = log;\n+      pageStore.setLogMode(log);\n+    }\n+    if (mvStore != null) {\n+      this.logMode = log;\n+    }\n+  }\n+\n+  public int getLogMode() {\n+    if (pageStore != null) {\n+      return pageStore.getLogMode();\n+    }\n+    if (mvStore != null) {\n+      return logMode;\n+    }\n+    return PageStore.LOG_MODE_OFF;\n+  }\n+\n+  public int getDefaultTableType() {\n+    return defaultTableType;\n+  }\n+\n+  public void setDefaultTableType(int defaultTableType) {\n+    this.defaultTableType = defaultTableType;\n+  }\n+\n+  public void setMultiVersion(boolean multiVersion) {\n+    this.multiVersion = multiVersion;\n+  }\n+\n+  public DbSettings getSettings() {\n+    return dbSettings;\n+  }\n+\n+  /**\n+   * Create a new hash map. Depending on the configuration, the key is case\n+   * sensitive or case insensitive.\n+   *\n+   * @param <V> the value type\n+   * @return the hash map\n+   */\n+  public <V> HashMap<String, V> newStringMap() {\n+    return dbSettings.databaseToUpper ?\n+        new HashMap<String, V>() :\n+        new CaseInsensitiveMap<V>();\n+  }\n+\n+  /**\n+   * Create a new hash map. Depending on the configuration, the key is case\n+   * sensitive or case insensitive.\n+   *\n+   * @param <V> the value type\n+   * @return the hash map\n+   */\n+  public <V> ConcurrentHashMap<String, V> newConcurrentStringMap() {\n+    return dbSettings.databaseToUpper ?\n+        new NullableKeyConcurrentMap<V>() :\n+        new CaseInsensitiveConcurrentMap<V>();\n+  }\n+\n+  /**\n+   * Compare two identifiers (table names, column names,...) and verify they\n+   * are equal. Case sensitivity depends on the configuration.\n+   *\n+   * @param a the first identifier\n+   * @param b the second identifier\n+   * @return true if they match\n+   */\n+  public boolean equalsIdentifiers(String a, String b) {\n+    if (a == b || a.equals(b)) {\n+      return true;\n+    }\n+    if (!dbSettings.databaseToUpper && a.equalsIgnoreCase(b)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public int readLob(long lobId, byte[] hmac, long offset, byte[] buff,\n+                     int off, int length) {\n+    throw DbException.throwInternalError();\n+  }\n+\n+  public byte[] getFileEncryptionKey() {\n+    return fileEncryptionKey;\n+  }\n+\n+  public int getPageSize() {\n+    return pageSize;\n+  }\n+\n+  @Override\n+  public JavaObjectSerializer getJavaObjectSerializer() {\n+    initJavaObjectSerializer();\n+    return javaObjectSerializer;\n+  }\n+\n+  private void initJavaObjectSerializer() {\n+    if (javaObjectSerializerInitialized) {\n+      return;\n+    }\n+    synchronized (this) {\n+      if (javaObjectSerializerInitialized) {\n+        return;\n+      }\n+      String serializerName = javaObjectSerializerName;\n+      if (serializerName != null) {\n+        serializerName = serializerName.trim();\n+        if (!serializerName.isEmpty() &&\n+            !serializerName.equals(\"null\")) {\n+          try {\n+            javaObjectSerializer = (JavaObjectSerializer)\n+                JdbcUtils.loadUserClass(serializerName).newInstance();\n+          } catch (Exception e) {\n+            throw DbException.convert(e);\n+          }\n         }\n-        return engine;\n+      }\n+      javaObjectSerializerInitialized = true;\n+    }\n+  }\n+\n+  public void setJavaObjectSerializerName(String serializerName) {\n+    synchronized (this) {\n+      javaObjectSerializerInitialized = false;\n+      javaObjectSerializerName = serializerName;\n+    }\n+  }\n+\n+  /**\n+   * Get the table engine class, loading it if needed.\n+   *\n+   * @param tableEngine the table engine name\n+   * @return the class\n+   */\n+  public TableEngine getTableEngine(String tableEngine) {\n+    assert Thread.holdsLock(this);\n+\n+    TableEngine engine = tableEngines.get(tableEngine);\n+    if (engine == null) {\n+      try {\n+        engine =\n+            (TableEngine) JdbcUtils.loadUserClass(tableEngine).newInstance();\n+      } catch (Exception e) {\n+        throw DbException.convert(e);\n+      }\n+      tableEngines.put(tableEngine, engine);\n     }\n+    return engine;\n+  }\n \n }\n",
            "diff_size": 4300
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "299",
                    "column": "37",
                    "severity": "warning",
                    "message": "'typecast' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/594/Database.java\nindex 2ee29bf449..057d2a2f67 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/594/Database.java\n@@ -167,7 +167,7 @@ public class Database implements DataHandler {\n     private boolean multiThreaded;\n     private int maxOperationMemory =\n             Constants.DEFAULT_MAX_OPERATION_MEMORY;\n-    private SmallLRUCache<String, String[]> lobFileListCache;\n+private SmallLRUCache<String, String[]> lobFileListCache;\n     private final boolean autoServerMode;\n     private final int autoServerPort;\n     private Server server;\n@@ -285,7 +285,7 @@ public class Database implements DataHandler {\n                     // shutdown in progress - just don't register the handler\n                     // (maybe an application wants to write something into a\n                     // database at shutdown time)\n-                } catch (SecurityException  e) {\n+                } catch (SecurityException e) {\n                     // applets may not do that - ignore\n                     // Google App Engine doesn't allow\n                     // to instantiate classes that extend Thread\n@@ -1309,7 +1309,7 @@ public class Database implements DataHandler {\n                 Runtime.getRuntime().removeShutdownHook(closeOnExit);\n             } catch (IllegalStateException e) {\n                 // ignore\n-            } catch (SecurityException  e) {\n+            } catch (SecurityException e) {\n                 // applets may not do that - ignore\n             }\n             closeOnExit = null;\n@@ -1425,8 +1425,7 @@ public class Database implements DataHandler {\n                 // otherwise other connections can not detect that\n                 if (lock.load().containsKey(\"changePending\")) {\n                     try {\n-                        Thread.sleep(TimeUnit.NANOSECONDS\n-                                .toMillis((long) (reconnectCheckDelayNs * 1.1)));\n+                        Thread.sleep(TimeUnit.NANOSECONDS.toMillis((long) (reconnectCheckDelayNs * 1.1)));\n                     } catch (InterruptedException e) {\n                         trace.error(e, \"close\");\n                     }\n@@ -2402,7 +2401,7 @@ public class Database implements DataHandler {\n     }\n \n     public void setMaxOperationMemory(int maxOperationMemory) {\n-        this.maxOperationMemory  = maxOperationMemory;\n+        this.maxOperationMemory = maxOperationMemory;\n     }\n \n     public int getMaxOperationMemory() {\n@@ -2420,7 +2419,7 @@ public class Database implements DataHandler {\n      * @param closeOthers whether other sessions are closed\n      */\n     public void setExclusiveSession(Session session, boolean closeOthers) {\n-      this.exclusiveSession.set(session);\n+    this.exclusiveSession.set(session);\n       if (closeOthers) {\n           closeAllSessionsException(session);\n       }\n@@ -2915,4 +2914,4 @@ public class Database implements DataHandler {\n         return engine;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/594/Database.java\nindex 2ee29bf449..89458ac6e0 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/594/Database.java\n@@ -87,6 +87,8 @@ import org.h2.value.ValueInt;\n  *\n  * @since 2004-04-15 22:49\n  */\n+\n+\n public class Database implements DataHandler {\n \n     private static int initialPowerOffCount;\n@@ -96,7 +98,6 @@ public class Database implements DataHandler {\n      * there is no administrator user registered.\n      */\n     private static final String SYSTEM_USER_NAME = \"DBA\";\n-\n     private final boolean persistent;\n     private final String databaseName;\n     private final String databaseShortName;\n@@ -104,7 +105,6 @@ public class Database implements DataHandler {\n     private final String cipher;\n     private final byte[] filePasswordHash;\n     private final byte[] fileEncryptionKey;\n-\n     private final HashMap<String, Role> roles = New.hashMap();\n     private final HashMap<String, User> users = New.hashMap();\n     private final HashMap<String, Setting> settings = New.hashMap();\n@@ -114,13 +114,10 @@ public class Database implements DataHandler {\n     private final HashMap<String, UserAggregate> aggregates = New.hashMap();\n     private final HashMap<String, Comment> comments = New.hashMap();\n     private final HashMap<String, TableEngine> tableEngines = New.hashMap();\n-\n-    private final Set<Session> userSessions =\n-            Collections.synchronizedSet(new HashSet<Session>());\n-    private final AtomicReference<Session> exclusiveSession = new AtomicReference<>();\n+    private final Set<Session> userSessions = Collections.synchronizedSet(new HashSet<Session>());\n+    private final AtomicReference<Session> exclusiveSession = new AtomicReference< >();\n     private final BitField objectIds = new BitField();\n     private final Object lobSyncObject = new Object();\n-\n     private Schema mainSchema;\n     private Schema infoSchema;\n     private int nextSessionId;\n@@ -149,7 +146,6 @@ public class Database implements DataHandler {\n     private int lockMode = Constants.DEFAULT_LOCK_MODE;\n     private int maxLengthInplaceLob;\n     private int allowLiterals = Constants.ALLOW_LITERALS_ALL;\n-\n     private int powerOffCount = initialPowerOffCount;\n     private int closeDelay;\n     private DatabaseCloser delayedCloser;\n@@ -165,8 +161,7 @@ public class Database implements DataHandler {\n     private DatabaseCloser closeOnExit;\n     private Mode mode = Mode.getInstance(Mode.REGULAR);\n     private boolean multiThreaded;\n-    private int maxOperationMemory =\n-            Constants.DEFAULT_MAX_OPERATION_MEMORY;\n+    private int maxOperationMemory = Constants.DEFAULT_MAX_OPERATION_MEMORY;\n     private SmallLRUCache<String, String[]> lobFileListCache;\n     private final boolean autoServerMode;\n     private final int autoServerPort;\n@@ -216,16 +211,12 @@ public class Database implements DataHandler {\n         this.maxLengthInplaceLob = Constants.DEFAULT_MAX_LENGTH_INPLACE_LOB;\n         this.cipher = cipher;\n         String lockMethodName = ci.getProperty(\"FILE_LOCK\", null);\n-        this.accessModeData = StringUtils.toLowerEnglish(\n-                ci.getProperty(\"ACCESS_MODE_DATA\", \"rw\"));\n+        this.accessModeData = StringUtils.toLowerEnglish(ci.getProperty(\"ACCESS_MODE_DATA\", \"rw\"));\n         this.autoServerMode = ci.getProperty(\"AUTO_SERVER\", false);\n         this.autoServerPort = ci.getProperty(\"AUTO_SERVER_PORT\", 0);\n-        int defaultCacheSize = Utils.scaleForAvailableMemory(\n-                Constants.CACHE_SIZE_DEFAULT);\n-        this.cacheSize =\n-                ci.getProperty(\"CACHE_SIZE\", defaultCacheSize);\n-        this.pageSize = ci.getProperty(\"PAGE_SIZE\",\n-                Constants.DEFAULT_PAGE_SIZE);\n+        int defaultCacheSize = Utils.scaleForAvailableMemory(Constants.CACHE_SIZE_DEFAULT);\n+        this.cacheSize = ci.getProperty(\"CACHE_SIZE\", defaultCacheSize);\n+        this.pageSize = ci.getProperty(\"PAGE_SIZE\", Constants.DEFAULT_PAGE_SIZE);\n         if (\"r\".equals(accessModeData)) {\n             readOnly = true;\n         }\n@@ -239,8 +230,7 @@ public class Database implements DataHandler {\n             fileLockMethod = FileLock.getFileLockMethod(lockMethodName);\n         }\n         if (dbSettings.mvStore && fileLockMethod == FileLock.LOCK_SERIALIZED) {\n-            throw DbException.getUnsupportedException(\n-                    \"MV_STORE combined with FILE_LOCK=SERIALIZED\");\n+            throw DbException.getUnsupportedException(\"MV_STORE combined with FILE_LOCK=SERIALIZED\");\n         }\n         this.databaseURL = ci.getURL();\n         String listener = ci.removeProperty(\"DATABASE_EVENT_LISTENER\", null);\n@@ -252,29 +242,21 @@ public class Database implements DataHandler {\n         if (modeName != null) {\n             this.mode = Mode.getInstance(modeName);\n         }\n-        this.multiVersion =\n-                ci.getProperty(\"MVCC\", dbSettings.mvStore);\n-        this.logMode =\n-                ci.getProperty(\"LOG\", PageStore.LOG_MODE_SYNC);\n-        this.javaObjectSerializerName =\n-                ci.getProperty(\"JAVA_OBJECT_SERIALIZER\", null);\n-        this.multiThreaded =\n-                ci.getProperty(\"MULTI_THREADED\", false);\n-        boolean closeAtVmShutdown =\n-                dbSettings.dbCloseOnExit;\n-        int traceLevelFile =\n-                ci.getIntProperty(SetTypes.TRACE_LEVEL_FILE,\n-                TraceSystem.DEFAULT_TRACE_LEVEL_FILE);\n-        int traceLevelSystemOut =\n-                ci.getIntProperty(SetTypes.TRACE_LEVEL_SYSTEM_OUT,\n-                TraceSystem.DEFAULT_TRACE_LEVEL_SYSTEM_OUT);\n-        this.cacheType = StringUtils.toUpperEnglish(\n-                ci.removeProperty(\"CACHE_TYPE\", Constants.CACHE_TYPE_DEFAULT));\n+        this.multiVersion = ci.getProperty(\"MVCC\", dbSettings.mvStore);\n+        this.logMode = ci.getProperty(\"LOG\", PageStore.LOG_MODE_SYNC);\n+        this.javaObjectSerializerName = ci.getProperty(\"JAVA_OBJECT_SERIALIZER\", null);\n+        this.multiThreaded = ci.getProperty(\"MULTI_THREADED\", false);\n+        boolean closeAtVmShutdown = dbSettings.dbCloseOnExit;\n+        int traceLevelFile = ci.getIntProperty(SetTypes.TRACE_LEVEL_FILE,\n+                                               TraceSystem.DEFAULT_TRACE_LEVEL_FILE);\n+        int traceLevelSystemOut = ci.getIntProperty(SetTypes.TRACE_LEVEL_SYSTEM_OUT,\n+                                                    TraceSystem.DEFAULT_TRACE_LEVEL_SYSTEM_OUT);\n+        this.cacheType = StringUtils.toUpperEnglish(ci.removeProperty(\"CACHE_TYPE\", Constants.CACHE_TYPE_DEFAULT));\n         openDatabase(traceLevelFile, traceLevelSystemOut, closeAtVmShutdown);\n     }\n \n-    private void openDatabase(int traceLevelFile, int traceLevelSystemOut,\n-            boolean closeAtVmShutdown) {\n+    private void openDatabase(int traceLevelFile,\n+int traceLevelSystemOut, boolean closeAtVmShutdown) {\n         try {\n             open(traceLevelFile, traceLevelSystemOut);\n             if (closeAtVmShutdown) {\n@@ -285,22 +267,22 @@ public class Database implements DataHandler {\n                     // shutdown in progress - just don't register the handler\n                     // (maybe an application wants to write something into a\n                     // database at shutdown time)\n-                } catch (SecurityException  e) {\n+\n+                } catch (SecurityException e) {\n                     // applets may not do that - ignore\n                     // Google App Engine doesn't allow\n                     // to instantiate classes that extend Thread\n+\n                 }\n             }\n         } catch (Throwable e) {\n             if (e instanceof OutOfMemoryError) {\n                 e.fillInStackTrace();\n             }\n-            boolean alreadyOpen = e instanceof DbException\n-                    && ((DbException)e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n+            boolean alreadyOpen = e instanceof DbException && ((DbException) e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n             if (alreadyOpen) {\n                 stopServer();\n             }\n-\n             if (traceSystem != null) {\n                 if (e instanceof DbException && !alreadyOpen) {\n                     // only write if the database is not already in use\n@@ -320,22 +302,28 @@ public class Database implements DataHandler {\n      * @param memory whether the row is in memory\n      * @return the created row\n      */\n+\n+\n     public Row createRow(Value[] data, int memory) {\n         return rowFactory.createRow(data, memory);\n     }\n \n+\n     public RowFactory getRowFactory() {\n         return rowFactory;\n     }\n \n+\n     public void setRowFactory(RowFactory rowFactory) {\n         this.rowFactory = rowFactory;\n     }\n \n+\n     public static void setInitialPowerOffCount(int count) {\n         initialPowerOffCount = count;\n     }\n \n+\n     public void setPowerOffCount(int count) {\n         if (powerOffCount == -1) {\n             return;\n@@ -343,10 +331,12 @@ public class Database implements DataHandler {\n         powerOffCount = count;\n     }\n \n+\n     public MVTableEngine.Store getMvStore() {\n         return mvStore;\n     }\n \n+\n     public void setMvStore(MVTableEngine.Store mvStore) {\n         this.mvStore = mvStore;\n         this.retentionTime = mvStore.getStore().getRetentionTime();\n@@ -359,6 +349,8 @@ public class Database implements DataHandler {\n      * @param b the second value\n      * @return true if both objects are equal\n      */\n+\n+\n     public boolean areEqual(Value a, Value b) {\n         // can not use equals because ValueDecimal 0.0 is not equal to 0.00.\n         return a.compareTo(b, compareMode) == 0;\n@@ -373,6 +365,8 @@ public class Database implements DataHandler {\n      * @return 0 if both values are equal, -1 if the first value is smaller, and\n      *         1 otherwise\n      */\n+\n+\n     public int compare(Value a, Value b) {\n         return a.compareTo(b, compareMode);\n     }\n@@ -386,10 +380,13 @@ public class Database implements DataHandler {\n      * @return 0 if both values are equal, -1 if the first value is smaller, and\n      *         1 otherwise\n      */\n+\n+\n     public int compareTypeSafe(Value a, Value b) {\n         return a.compareTypeSafe(b, compareMode);\n     }\n \n+\n     public long getModificationDataId() {\n         return modificationDataId.get();\n     }\n@@ -401,9 +398,9 @@ public class Database implements DataHandler {\n      * @return true if the call was successful,\n      *          false if another connection was faster\n      */\n+\n     private synchronized boolean reconnectModified(boolean pending) {\n-        if (readOnly || lock == null ||\n-                fileLockMethod != FileLock.LOCK_SERIALIZED) {\n+        if (readOnly || lock == null || fileLockMethod != FileLock.LOCK_SERIALIZED) {\n             return true;\n         }\n         try {\n@@ -411,8 +408,7 @@ public class Database implements DataHandler {\n                 long now = System.nanoTime();\n                 if (now > reconnectCheckNext) {\n                     if (pending) {\n-                        String pos = pageStore == null ?\n-                                null : \"\" + pageStore.getWriteCountTotal();\n+                        String pos = pageStore == null ? null : \"\" + pageStore.getWriteCountTotal();\n                         lock.setProperty(\"logPos\", pos);\n                         lock.save();\n                     }\n@@ -433,8 +429,7 @@ public class Database implements DataHandler {\n                     return false;\n                 }\n             }\n-            String pos = pageStore == null ?\n-                    null : \"\" + pageStore.getWriteCountTotal();\n+            String pos = pageStore == null ? null : \"\" + pageStore.getWriteCountTotal();\n             lock.setProperty(\"logPos\", pos);\n             if (pending) {\n                 lock.setProperty(\"changePending\", \"true-\" + Math.random());\n@@ -443,8 +438,7 @@ public class Database implements DataHandler {\n             }\n             // ensure that the writer thread will\n             // not reset the flag before we are done\n-            reconnectCheckNext = System.nanoTime() +\n-                    2 * reconnectCheckDelayNs;\n+            reconnectCheckNext = System.nanoTime() + 2 * reconnectCheckDelayNs;\n             old = lock.save();\n             if (pending) {\n                 trace.debug(\"wait before writing again\");\n@@ -467,14 +461,17 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public long getNextModificationDataId() {\n         return modificationDataId.incrementAndGet();\n     }\n \n+\n     public long getModificationMetaId() {\n         return modificationMetaId.get();\n     }\n \n+\n     public long getNextModificationMetaId() {\n         // if the meta data has been modified, the data is modified as well\n         // (because MetaTable returns modificationDataId)\n@@ -482,6 +479,7 @@ public class Database implements DataHandler {\n         return modificationMetaId.incrementAndGet() - 1;\n     }\n \n+\n     public int getPowerOffCount() {\n         return powerOffCount;\n     }\n@@ -507,6 +505,7 @@ public class Database implements DataHandler {\n                         pageStore.close();\n                     } catch (DbException e) {\n                         // ignore\n+\n                     }\n                     pageStore = null;\n                 }\n@@ -535,6 +534,8 @@ public class Database implements DataHandler {\n      * @param name the name of the database (including path)\n      * @return true if one exists\n      */\n+\n+\n     static boolean exists(String name) {\n         if (FileUtils.exists(name + Constants.SUFFIX_PAGE_FILE)) {\n             return true;\n@@ -548,6 +549,8 @@ public class Database implements DataHandler {\n      * @param moduleId the module id\n      * @return the trace object\n      */\n+\n+\n     public Trace getTrace(int moduleId) {\n         return traceSystem.getTrace(moduleId);\n     }\n@@ -557,8 +560,7 @@ public class Database implements DataHandler {\n         if (mustExist && !FileUtils.exists(name)) {\n             throw DbException.get(ErrorCode.FILE_NOT_FOUND_1, name);\n         }\n-        FileStore store = FileStore.open(this, name, openMode, cipher,\n-                filePasswordHash);\n+        FileStore store = FileStore.open(this, name, openMode, cipher, filePasswordHash);\n         try {\n             store.init();\n         } catch (DbException e) {\n@@ -575,6 +577,7 @@ public class Database implements DataHandler {\n      * @param testHash the hash code\n      * @return true if the cipher algorithm and the password match\n      */\n+\n     boolean validateFilePasswordHash(String testCipher, byte[] testHash) {\n         if (!StringUtils.equals(testCipher, this.cipher)) {\n             return false;\n@@ -608,11 +611,7 @@ public class Database implements DataHandler {\n             boolean existsPage = FileUtils.exists(pageFileName);\n             boolean existsMv = FileUtils.exists(mvFileName);\n             if (existsData && (!existsPage && !existsMv)) {\n-                throw DbException.get(\n-                        ErrorCode.FILE_VERSION_ERROR_1, \"Old database: \" +\n-                        dataFileName +\n-                        \" - please convert the database \" +\n-                        \"to a SQL script and re-create it.\");\n+                throw DbException.get(ErrorCode.FILE_VERSION_ERROR_1, \"Old database: \" + dataFileName + \" - please convert the database \" + \"to a SQL script and re-create it.\");\n             }\n             if (existsPage && !FileUtils.canWrite(pageFileName)) {\n                 readOnly = true;\n@@ -625,40 +624,34 @@ public class Database implements DataHandler {\n             }\n             if (readOnly) {\n                 if (traceLevelFile >= TraceSystem.DEBUG) {\n-                    String traceFile = Utils.getProperty(\"java.io.tmpdir\", \".\") +\n-                            \"/\" + \"h2_\" + System.currentTimeMillis();\n-                    traceSystem = new TraceSystem(traceFile +\n-                            Constants.SUFFIX_TRACE_FILE);\n+                    String traceFile = Utils.getProperty(\"java.io.tmpdir\", \".\") + \"/\"\n+                    + \"h2_\" + System.currentTimeMillis();\n+                    traceSystem = new TraceSystem(traceFile + Constants.SUFFIX_TRACE_FILE);\n                 } else {\n                     traceSystem = new TraceSystem(null);\n                 }\n             } else {\n-                traceSystem = new TraceSystem(databaseName +\n-                        Constants.SUFFIX_TRACE_FILE);\n+                traceSystem = new TraceSystem(databaseName + Constants.SUFFIX_TRACE_FILE);\n             }\n             traceSystem.setLevelFile(traceLevelFile);\n             traceSystem.setLevelSystemOut(traceLevelSystemOut);\n             trace = traceSystem.getTrace(Trace.DATABASE);\n-            trace.info(\"opening {0} (build {1})\", databaseName, Constants.BUILD_ID);\n+            trace.info(\n+                \"opening {0} (build {1})\",\n+databaseName,\n+Constants.BUILD_ID);\n             if (autoServerMode) {\n-                if (readOnly ||\n-                        fileLockMethod == FileLock.LOCK_NO ||\n-                        fileLockMethod == FileLock.LOCK_SERIALIZED ||\n-                        fileLockMethod == FileLock.LOCK_FS ||\n-                        !persistent) {\n-                    throw DbException.getUnsupportedException(\n-                            \"autoServerMode && (readOnly || \" +\n-                            \"fileLockMethod == NO || \" +\n-                            \"fileLockMethod == SERIALIZED || \" +\n-                            \"fileLockMethod == FS || \" +\n-                            \"inMemory)\");\n+                if (readOnly || fileLockMethod == FileLock.LOCK_NO || fileLockMethod == FileLock.LOCK_SERIALIZED || fileLockMethod == FileLock.LOCK_FS || !persistent) {\n+                    throw DbException.getUnsupportedException(\"autoServerMode && (readOnly || \" + \"fileLockMethod == NO || \"\n+                    + \"fileLockMethod == SERIALIZED || \"\n+                    + \"fileLockMethod == FS || \" + \"inMemory)\");\n                 }\n             }\n             String lockFileName = databaseName + Constants.SUFFIX_LOCK_FILE;\n             if (readOnly) {\n                 if (FileUtils.exists(lockFileName)) {\n                     throw DbException.get(ErrorCode.DATABASE_ALREADY_OPEN_1,\n-                            \"Lock file exists: \" + lockFileName);\n+                        \"Lock file exists: \" + lockFileName);\n                 }\n             }\n             if (!readOnly && fileLockMethod != FileLock.LOCK_NO) {\n@@ -673,12 +666,14 @@ public class Database implements DataHandler {\n             if (SysProperties.MODIFY_ON_WRITE) {\n                 while (isReconnectNeeded()) {\n                     // wait until others stopped writing\n+\n                 }\n             } else {\n                 while (isReconnectNeeded() && !beforeWriting()) {\n                     // wait until others stopped writing and\n                     // until we can write (the file is not yet open -\n                     // no need to re-connect)\n+\n                 }\n             }\n             deleteOldTempFiles();\n@@ -695,6 +690,7 @@ public class Database implements DataHandler {\n                         // wait until others stopped writing and\n                         // until we can write (the file is not yet open -\n                         // no need to re-connect)\n+\n                     }\n                     getPageStore();\n                 }\n@@ -709,8 +705,7 @@ public class Database implements DataHandler {\n             }\n         } else {\n             if (autoServerMode) {\n-                throw DbException.getUnsupportedException(\n-                        \"autoServerMode && inMemory\");\n+                throw DbException.getUnsupportedException(\"autoServerMode && inMemory\");\n             }\n             traceSystem = new TraceSystem(null);\n             trace = traceSystem.getTrace(Trace.DATABASE);\n@@ -750,9 +745,11 @@ public class Database implements DataHandler {\n         data.session = systemSession;\n         meta = mainSchema.createTable(data);\n         IndexColumn[] pkCols = IndexColumn.wrap(new Column[] { columnId });\n-        metaIdIndex = meta.addIndex(systemSession, \"SYS_ID\",\n-                0, pkCols, IndexType.createPrimaryKey(\n-                false, false), true, null);\n+        metaIdIndex = meta.addIndex(systemSession,\n+            \"SYS_ID\", 0,\n+                                    pkCols,\n+                                    IndexType.createPrimaryKey(false, false), true,\n+            null);\n         objectIds.set(0);\n         starting = true;\n         Cursor cursor = metaIdIndex.find(systemSession, null, null);\n@@ -796,7 +793,6 @@ public class Database implements DataHandler {\n         }\n         getLobStorage().init();\n         systemSession.commit(true);\n-\n         trace.info(\"opened {0}\", databaseName);\n         if (checkpointAllowed > 0) {\n             afterWriting();\n@@ -805,11 +801,7 @@ public class Database implements DataHandler {\n \n     private void startServer(String key) {\n         try {\n-            server = Server.createTcpServer(\n-                    \"-tcpPort\", Integer.toString(autoServerPort),\n-                    \"-tcpAllowOthers\",\n-                    \"-tcpDaemon\",\n-                    \"-key\", key, databaseName);\n+            server = Server.createTcpServer(\"-tcpPort\", Integer.toString(autoServerPort), \"-tcpAllowOthers\", \"-tcpDaemon\", \"-key\", key, databaseName);\n             server.start();\n         } catch (SQLException e) {\n             throw DbException.convert(e);\n@@ -858,8 +850,7 @@ public class Database implements DataHandler {\n         }\n         synchronized (infoSchema) {\n             if (!metaTablesInitialized) {\n-                for (int type = 0, count = MetaTable.getMetaTableTypeCount();\n-                        type < count; type++) {\n+                for (int type = 0, count = MetaTable.getMetaTableTypeCount(); type < count; type++) {\n                     MetaTable m = new MetaTable(infoSchema, -1 - type, type);\n                     infoSchema.add(m);\n                 }\n@@ -892,9 +883,10 @@ public class Database implements DataHandler {\n      *\n      * @param session the session\n      */\n+\n+\n     public void verifyMetaLocked(Session session) {\n-        if (meta != null && !meta.isLockedExclusivelyBy(session)\n-                && lockMode != Constants.LOCK_MODE_OFF) {\n+        if (meta != null && !meta.isLockedExclusivelyBy(session) && lockMode != Constants.LOCK_MODE_OFF) {\n             throw DbException.throwInternalError();\n         }\n     }\n@@ -905,6 +897,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @return whether it was already locked before by this session\n      */\n+\n+\n     public boolean lockMeta(Session session) {\n         // this method can not be synchronized on the database object,\n         // as unlocking is also synchronized on the database object -\n@@ -922,6 +916,8 @@ public class Database implements DataHandler {\n      *\n      * @param session the session\n      */\n+\n+\n     public void unlockMeta(Session session) {\n         meta.unlock(session);\n         session.unlock(meta);\n@@ -933,6 +929,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param id the id of the object to remove\n      */\n+\n+\n     public synchronized void removeMeta(Session session, int id) {\n         if (id > 0 && !starting) {\n             SearchRow r = meta.getTemplateSimpleRow(false);\n@@ -1005,6 +1003,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param obj the object to add\n      */\n+\n+\n     public void addSchemaObject(Session session, SchemaObject obj) {\n         int id = obj.getId();\n         if (id > 0 && !starting) {\n@@ -1023,6 +1023,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param obj the object to add\n      */\n+\n+\n     public synchronized void addDatabaseObject(Session session, DbObject obj) {\n         int id = obj.getId();\n         if (id > 0 && !starting) {\n@@ -1050,6 +1052,8 @@ public class Database implements DataHandler {\n      * @param name the name of the user defined aggregate function\n      * @return the aggregate function or null\n      */\n+\n+\n     public UserAggregate findAggregate(String name) {\n         return aggregates.get(name);\n     }\n@@ -1061,6 +1065,8 @@ public class Database implements DataHandler {\n      * @param object the database object\n      * @return the comment or null\n      */\n+\n+\n     public Comment findComment(DbObject object) {\n         if (object.getType() == DbObject.COMMENT) {\n             return null;\n@@ -1075,6 +1081,8 @@ public class Database implements DataHandler {\n      * @param roleName the name of the role\n      * @return the role or null\n      */\n+\n+\n     public Role findRole(String roleName) {\n         return roles.get(roleName);\n     }\n@@ -1085,6 +1093,8 @@ public class Database implements DataHandler {\n      * @param schemaName the name of the schema\n      * @return the schema or null\n      */\n+\n+\n     public Schema findSchema(String schemaName) {\n         Schema schema = schemas.get(schemaName);\n         if (schema == infoSchema) {\n@@ -1099,6 +1109,8 @@ public class Database implements DataHandler {\n      * @param name the name of the setting\n      * @return the setting or null\n      */\n+\n+\n     public Setting findSetting(String name) {\n         return settings.get(name);\n     }\n@@ -1109,6 +1121,8 @@ public class Database implements DataHandler {\n      * @param name the name of the user\n      * @return the user or null\n      */\n+\n+\n     public User findUser(String name) {\n         return users.get(name);\n     }\n@@ -1119,6 +1133,8 @@ public class Database implements DataHandler {\n      * @param name the name of the user defined data type\n      * @return the user defined data type or null\n      */\n+\n+\n     public UserDataType findUserDataType(String name) {\n         return userDataTypes.get(name);\n     }\n@@ -1131,6 +1147,8 @@ public class Database implements DataHandler {\n      * @return the user\n      * @throws DbException if the user does not exist\n      */\n+\n+\n     public User getUser(String name) {\n         User user = findUser(name);\n         if (user == null) {\n@@ -1146,6 +1164,8 @@ public class Database implements DataHandler {\n      * @return the session, or null if the database is currently closing\n      * @throws DbException if the database is in exclusive mode\n      */\n+\n+\n     synchronized Session createSession(User user) {\n         if (closing) {\n             return null;\n@@ -1155,7 +1175,10 @@ public class Database implements DataHandler {\n         }\n         Session session = new Session(this, user, ++nextSessionId);\n         userSessions.add(session);\n-        trace.info(\"connecting session #{0} to {1}\", session.getId(), databaseName);\n+        trace.info(\n+            \"connecting session #{0} to {1}\",\n+session.getId(),\n+databaseName);\n         if (delayedCloser != null) {\n             delayedCloser.reset();\n             delayedCloser = null;\n@@ -1168,6 +1191,8 @@ public class Database implements DataHandler {\n      *\n      * @param session the session\n      */\n+\n+\n     public synchronized void removeSession(Session session) {\n         if (session != null) {\n             exclusiveSession.compareAndSet(session, null);\n@@ -1176,12 +1201,11 @@ public class Database implements DataHandler {\n                 trace.info(\"disconnecting session #{0}\", session.getId());\n             }\n         }\n-        if (userSessions.size() == 0 &&\n-                session != systemSession && session != lobSession) {\n+        if (userSessions.size() == 0 && session != systemSession && session != lobSession) {\n             if (closeDelay == 0) {\n                 close(false);\n             } else if (closeDelay < 0) {\n-                return;\n+                                                                                               return;\n             } else {\n                 delayedCloser = new DatabaseCloser(this, closeDelay * 1000, false);\n                 delayedCloser.setName(\"H2 Close Delay \" + getShortName());\n@@ -1189,8 +1213,7 @@ public class Database implements DataHandler {\n                 delayedCloser.start();\n             }\n         }\n-        if (session != systemSession &&\n-                session != lobSession && session != null) {\n+        if (session != systemSession && session != lobSession && session != null) {\n             trace.info(\"disconnected session #{0}\", session.getId());\n         }\n     }\n@@ -1219,19 +1242,21 @@ public class Database implements DataHandler {\n      * @param fromShutdownHook true if this method is called from the shutdown\n      *            hook\n      */\n+\n+\n     void close(boolean fromShutdownHook) {\n         synchronized (this) {\n             if (closing) {\n                 return;\n             }\n             throwLastBackgroundException();\n-            if (fileLockMethod == FileLock.LOCK_SERIALIZED &&\n-                    !reconnectChangePending) {\n+            if (fileLockMethod == FileLock.LOCK_SERIALIZED && !reconnectChangePending) {\n                 // another connection may have written something - don't write\n                 try {\n                     closeOpenFilesAndUnlock(false);\n                 } catch (DbException e) {\n                     // ignore\n+\n                 }\n                 traceSystem.close();\n                 Engine.getInstance().close(databaseName);\n@@ -1272,14 +1297,12 @@ public class Database implements DataHandler {\n                             table.close(systemSession);\n                         }\n                     }\n-                    for (SchemaObject obj : getAllSchemaObjects(\n-                            DbObject.SEQUENCE)) {\n+                    for (SchemaObject obj : getAllSchemaObjects(DbObject.SEQUENCE)) {\n                         Sequence sequence = (Sequence) obj;\n                         sequence.close();\n                     }\n                 }\n-                for (SchemaObject obj : getAllSchemaObjects(\n-                        DbObject.TRIGGER)) {\n+                for (SchemaObject obj : getAllSchemaObjects(DbObject.TRIGGER)) {\n                     TriggerObject trigger = (TriggerObject) obj;\n                     try {\n                         trigger.close();\n@@ -1309,8 +1332,10 @@ public class Database implements DataHandler {\n                 Runtime.getRuntime().removeShutdownHook(closeOnExit);\n             } catch (IllegalStateException e) {\n                 // ignore\n-            } catch (SecurityException  e) {\n+\n+            } catch (SecurityException e) {\n                 // applets may not do that - ignore\n+\n             }\n             closeOnExit = null;\n         }\n@@ -1323,6 +1348,7 @@ public class Database implements DataHandler {\n                 DeleteDbFiles.execute(directory, name, true);\n             } catch (Exception e) {\n                 // ignore (the trace is closed already)\n+\n             }\n         }\n     }\n@@ -1332,16 +1358,14 @@ public class Database implements DataHandler {\n         if (!persistent) {\n             return;\n         }\n-        boolean lobStorageIsUsed = infoSchema.findTableOrView(\n-                systemSession, LobStorageBackend.LOB_DATA_TABLE) != null;\n+        boolean lobStorageIsUsed = infoSchema.findTableOrView(systemSession, LobStorageBackend.LOB_DATA_TABLE) != null;\n         lobStorageIsUsed |= mvStore != null;\n         if (!lobStorageIsUsed) {\n             return;\n         }\n         try {\n             getLobStorage();\n-            lobStorage.removeAllForTable(\n-                    LobStorageFrontend.TABLE_ID_SESSION_VARIABLE);\n+            lobStorage.removeAllForTable(LobStorageFrontend.TABLE_ID_SESSION_VARIABLE);\n         } catch (DbException e) {\n             trace.error(e, \"close\");\n         }\n@@ -1359,6 +1383,7 @@ public class Database implements DataHandler {\n      *\n      * @param flush whether writing is allowed\n      */\n+\n     private synchronized void closeOpenFilesAndUnlock(boolean flush) {\n         stopWriter();\n         if (pageStore != null) {\n@@ -1372,9 +1397,7 @@ public class Database implements DataHandler {\n                 } catch (DbException e) {\n                     if (SysProperties.CHECK2) {\n                         int code = e.getErrorCode();\n-                        if (code != ErrorCode.DATABASE_IS_CLOSED &&\n-                                code != ErrorCode.LOCK_TIMEOUT_1 &&\n-                                code != ErrorCode.IO_EXCEPTION_2) {\n+                        if (code != ErrorCode.DATABASE_IS_CLOSED && code != ErrorCode.LOCK_TIMEOUT_1 && code != ErrorCode.IO_EXCEPTION_2) {\n                             e.printStackTrace();\n                         }\n                     }\n@@ -1395,14 +1418,12 @@ public class Database implements DataHandler {\n             } else if (compactMode == CommandInterface.SHUTDOWN_DEFRAG) {\n                 maxCompactTime = Long.MAX_VALUE;\n             } else if (getSettings().defragAlways) {\n-                maxCompactTime = Long.MAX_VALUE;\n-            }\n+                       maxCompactTime = Long.MAX_VALUE;\n+                   }\n             mvStore.close(maxCompactTime);\n         }\n         closeFiles();\n-        if (persistent && lock == null &&\n-                fileLockMethod != FileLock.LOCK_NO &&\n-                fileLockMethod != FileLock.LOCK_FS) {\n+        if (persistent && lock == null && fileLockMethod != FileLock.LOCK_NO && fileLockMethod != FileLock.LOCK_FS) {\n             // everything already closed (maybe in checkPowerOff)\n             // don't delete temp files in this case because\n             // the database could be open now (even from within another process)\n@@ -1425,8 +1446,7 @@ public class Database implements DataHandler {\n                 // otherwise other connections can not detect that\n                 if (lock.load().containsKey(\"changePending\")) {\n                     try {\n-                        Thread.sleep(TimeUnit.NANOSECONDS\n-                                .toMillis((long) (reconnectCheckDelayNs * 1.1)));\n+                        Thread.sleep(TimeUnit.NANOSECONDS.toMillis((long) (reconnectCheckDelayNs * 1.1)));\n                     } catch (InterruptedException e) {\n                         trace.error(e, \"close\");\n                     }\n@@ -1465,20 +1485,25 @@ public class Database implements DataHandler {\n      *\n      * @return the id\n      */\n+\n+\n     public synchronized int allocateObjectId() {\n         int i = objectIds.nextClearBit(0);\n         objectIds.set(i);\n         return i;\n     }\n \n+\n     public ArrayList<UserAggregate> getAllAggregates() {\n         return New.arrayList(aggregates.values());\n     }\n \n+\n     public ArrayList<Comment> getAllComments() {\n         return New.arrayList(comments.values());\n     }\n \n+\n     public int getAllowLiterals() {\n         if (starting) {\n             return Constants.ALLOW_LITERALS_ALL;\n@@ -1486,10 +1511,12 @@ public class Database implements DataHandler {\n         return allowLiterals;\n     }\n \n+\n     public ArrayList<Right> getAllRights() {\n         return New.arrayList(rights.values());\n     }\n \n+\n     public ArrayList<Role> getAllRoles() {\n         return New.arrayList(roles.values());\n     }\n@@ -1499,6 +1526,8 @@ public class Database implements DataHandler {\n      *\n      * @return all objects of all types\n      */\n+\n+\n     public ArrayList<SchemaObject> getAllSchemaObjects() {\n         initMetaTables();\n         ArrayList<SchemaObject> list = New.arrayList();\n@@ -1514,6 +1543,8 @@ public class Database implements DataHandler {\n      * @param type the object type\n      * @return all objects of that type\n      */\n+\n+\n     public ArrayList<SchemaObject> getAllSchemaObjects(int type) {\n         if (type == DbObject.TABLE_OR_VIEW) {\n             initMetaTables();\n@@ -1533,6 +1564,8 @@ public class Database implements DataHandler {\n      *            tables are only included if they are already initialized)\n      * @return all objects of that type\n      */\n+\n+\n     public ArrayList<Table> getAllTablesAndViews(boolean includeMeta) {\n         if (includeMeta) {\n             initMetaTables();\n@@ -1549,6 +1582,8 @@ public class Database implements DataHandler {\n      *\n      * @return all objects of that type\n      */\n+\n+\n     public ArrayList<TableSynonym> getAllSynonyms() {\n         ArrayList<TableSynonym> list = New.arrayList();\n         for (Schema schema : schemas.values()) {\n@@ -1563,6 +1598,8 @@ public class Database implements DataHandler {\n      * @param name the table name\n      * @return the list\n      */\n+\n+\n     public ArrayList<Table> getTableOrViewByName(String name) {\n         ArrayList<Table> list = New.arrayList();\n         for (Schema schema : schemas.values()) {\n@@ -1574,27 +1611,33 @@ public class Database implements DataHandler {\n         return list;\n     }\n \n+\n     public ArrayList<Schema> getAllSchemas() {\n         initMetaTables();\n         return New.arrayList(schemas.values());\n     }\n \n+\n     public ArrayList<Setting> getAllSettings() {\n         return New.arrayList(settings.values());\n     }\n \n+\n     public ArrayList<UserDataType> getAllUserDataTypes() {\n         return New.arrayList(userDataTypes.values());\n     }\n \n+\n     public ArrayList<User> getAllUsers() {\n         return New.arrayList(users.values());\n     }\n \n+\n     public String getCacheType() {\n         return cacheType;\n     }\n \n+\n     public String getCluster() {\n         return cluster;\n     }\n@@ -1612,10 +1655,12 @@ public class Database implements DataHandler {\n         return null;\n     }\n \n+\n     public String getShortName() {\n         return databaseShortName;\n     }\n \n+\n     public String getName() {\n         return databaseName;\n     }\n@@ -1627,6 +1672,8 @@ public class Database implements DataHandler {\n      *            included\n      * @return the list of sessions\n      */\n+\n+\n     public Session[] getSessions(boolean includingSystemSession) {\n         ArrayList<Session> list;\n         // need to synchronized on userSession, otherwise the list\n@@ -1654,6 +1701,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param obj the database object\n      */\n+\n+\n     public void updateMeta(Session session, DbObject obj) {\n         lockMeta(session);\n         synchronized (this) {\n@@ -1674,8 +1723,9 @@ public class Database implements DataHandler {\n      * @param obj the object\n      * @param newName the new name\n      */\n-    public synchronized void renameSchemaObject(Session session,\n-            SchemaObject obj, String newName) {\n+\n+\n+    public synchronized void renameSchemaObject(Session session, SchemaObject obj, String newName) {\n         checkWritingAllowed();\n         obj.getSchema().rename(obj, newName);\n         updateMetaAndFirstLevelChildren(session, obj);\n@@ -1705,8 +1755,9 @@ public class Database implements DataHandler {\n      * @param obj the object\n      * @param newName the new name\n      */\n-    public synchronized void renameDatabaseObject(Session session,\n-            DbObject obj, String newName) {\n+\n+\n+    public synchronized void renameDatabaseObject(Session session, DbObject obj, String newName) {\n         checkWritingAllowed();\n         int type = obj.getType();\n         HashMap<String, DbObject> map = getMap(type);\n@@ -1733,6 +1784,8 @@ public class Database implements DataHandler {\n      *\n      * @return the file name\n      */\n+\n+\n     public String createTempFile() {\n         try {\n             boolean inTempDir = readOnly;\n@@ -1740,8 +1793,7 @@ public class Database implements DataHandler {\n             if (!persistent) {\n                 name = \"memFS:\" + name;\n             }\n-            return FileUtils.createTempFile(name,\n-                    Constants.SUFFIX_TEMP_FILE, true, inTempDir);\n+            return FileUtils.createTempFile(name, Constants.SUFFIX_TEMP_FILE, true, inTempDir);\n         } catch (IOException e) {\n             throw DbException.convertIOException(e, databaseName);\n         }\n@@ -1750,8 +1802,7 @@ public class Database implements DataHandler {\n     private void deleteOldTempFiles() {\n         String path = FileUtils.getParent(databaseName);\n         for (String name : FileUtils.newDirectoryStream(path)) {\n-            if (name.endsWith(Constants.SUFFIX_TEMP_FILE) &&\n-                    name.startsWith(databaseName)) {\n+            if (name.endsWith(Constants.SUFFIX_TEMP_FILE) && name.startsWith(databaseName)) {\n                 // can't always delete the files, they may still be open\n                 FileUtils.tryDelete(name);\n             }\n@@ -1765,6 +1816,8 @@ public class Database implements DataHandler {\n      * @return the schema\n      * @throws DbException no schema with that name exists\n      */\n+\n+\n     public Schema getSchema(String schemaName) {\n         Schema schema = findSchema(schemaName);\n         if (schema == null) {\n@@ -1779,6 +1832,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param obj the object to remove\n      */\n+\n+\n     public synchronized void removeDatabaseObject(Session session, DbObject obj) {\n         checkWritingAllowed();\n         String objName = obj.getName();\n@@ -1805,6 +1860,8 @@ public class Database implements DataHandler {\n      * @param except the table to exclude (or null)\n      * @return the first dependent table, or null\n      */\n+\n+\n     public Table getDependentTable(SchemaObject obj, Table except) {\n         switch (obj.getType()) {\n         case DbObject.COMMENT:\n@@ -1838,8 +1895,9 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param obj the object to be removed\n      */\n-    public void removeSchemaObject(Session session,\n-            SchemaObject obj) {\n+\n+\n+    public void removeSchemaObject(Session session, SchemaObject obj) {\n         int type = obj.getType();\n         if (type == DbObject.TABLE_OR_VIEW) {\n             Table table = (Table) obj;\n@@ -1856,13 +1914,13 @@ public class Database implements DataHandler {\n                 return;\n             }\n         } else if (type == DbObject.CONSTRAINT) {\n-            Constraint constraint = (Constraint) obj;\n-            Table table = constraint.getTable();\n-            if (table.isTemporary() && !table.isGlobalTemporary()) {\n-                session.removeLocalTempTableConstraint(constraint);\n-                return;\n-            }\n-        }\n+                   Constraint constraint = (Constraint) obj;\n+                   Table table = constraint.getTable();\n+                   if (table.isTemporary() && !table.isGlobalTemporary()) {\n+                       session.removeLocalTempTableConstraint(constraint);\n+                       return;\n+                   }\n+               }\n         checkWritingAllowed();\n         lockMeta(session);\n         synchronized (this) {\n@@ -1876,8 +1934,7 @@ public class Database implements DataHandler {\n                 Table t = getDependentTable(obj, null);\n                 if (t != null) {\n                     obj.getSchema().add(obj);\n-                    throw DbException.get(ErrorCode.CANNOT_DROP_2, obj.getSQL(),\n-                            t.getSQL());\n+                    throw DbException.get(ErrorCode.CANNOT_DROP_2, obj.getSQL(), t.getSQL());\n                 }\n                 obj.removeChildrenAndResources(session);\n             }\n@@ -1890,14 +1947,18 @@ public class Database implements DataHandler {\n      *\n      * @return true if it is disk-based, false it it is in-memory only.\n      */\n+\n+\n     public boolean isPersistent() {\n         return persistent;\n     }\n \n+\n     public TraceSystem getTraceSystem() {\n         return traceSystem;\n     }\n \n+\n     public synchronized void setCacheSize(int kb) {\n         if (starting) {\n             int max = MathUtils.convertLongToInt(Utils.getMemoryMax()) / 2;\n@@ -1912,12 +1973,14 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public synchronized void setMasterUser(User user) {\n         lockMeta(systemSession);\n         addDatabaseObject(systemSession, user);\n         systemSession.commit(true);\n     }\n \n+\n     public Role getPublicRole() {\n         return publicRole;\n     }\n@@ -1929,19 +1992,23 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @return a unique name\n      */\n+\n+\n     public synchronized String getTempTableName(String baseName, Session session) {\n         String tempName;\n         do {\n-            tempName = baseName + \"_COPY_\" + session.getId() +\n-                    \"_\" + nextTempTableId++;\n+            tempName = baseName + \"_COPY_\"\n+            + session.getId() + \"_\" + nextTempTableId++;\n         } while (mainSchema.findTableOrView(session, tempName) != null);\n         return tempName;\n     }\n \n+\n     public void setCompareMode(CompareMode compareMode) {\n         this.compareMode = compareMode;\n     }\n \n+\n     public void setCluster(String cluster) {\n         this.cluster = cluster;\n     }\n@@ -1958,10 +2025,12 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public boolean isReadOnly() {\n         return readOnly;\n     }\n \n+\n     public void setWriteDelay(int value) {\n         writeDelay = value;\n         if (writer != null) {\n@@ -1975,10 +2044,12 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public int getRetentionTime() {\n         return retentionTime;\n     }\n \n+\n     public void setRetentionTime(int value) {\n         retentionTime = value;\n         if (mvStore != null) {\n@@ -1986,10 +2057,12 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public void setAllowBuiltinAliasOverride(boolean b) {\n         allowBuiltinAliasOverride = b;\n     }\n \n+\n     public boolean isAllowBuiltinAliasOverride() {\n         return allowBuiltinAliasOverride;\n     }\n@@ -1999,6 +2072,8 @@ public class Database implements DataHandler {\n      *\n      * @return true if it is\n      */\n+\n+\n     public boolean getFlushOnEachCommit() {\n         return flushOnEachCommit;\n     }\n@@ -2008,6 +2083,8 @@ public class Database implements DataHandler {\n      *\n      * @return the list\n      */\n+\n+\n     public ArrayList<InDoubtTransaction> getInDoubtTransactions() {\n         if (mvStore != null) {\n             return mvStore.getInDoubtTransactions();\n@@ -2021,6 +2098,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param transaction the name of the transaction\n      */\n+\n+\n     synchronized void prepareCommit(Session session, String transaction) {\n         if (readOnly) {\n             return;\n@@ -2040,6 +2119,8 @@ public class Database implements DataHandler {\n      *\n      * @param session the session\n      */\n+\n+\n     synchronized void commit(Session session) {\n         throwLastBackgroundException();\n         if (readOnly) {\n@@ -2065,6 +2146,7 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public void setBackgroundException(DbException e) {\n         if (backgroundException == null) {\n             backgroundException = e;\n@@ -2078,6 +2160,8 @@ public class Database implements DataHandler {\n     /**\n      * Flush all pending changes to the transaction log.\n      */\n+\n+\n     public synchronized void flush() {\n         if (readOnly) {\n             return;\n@@ -2095,26 +2179,28 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public void setEventListener(DatabaseEventListener eventListener) {\n         this.eventListener = eventListener;\n     }\n \n+\n     public void setEventListenerClass(String className) {\n         if (className == null || className.length() == 0) {\n             eventListener = null;\n         } else {\n             try {\n-                eventListener = (DatabaseEventListener)\n-                        JdbcUtils.loadUserClass(className).newInstance();\n+                eventListener = (DatabaseEventListener) JdbcUtils.loadUserClass(className).newInstance();\n                 String url = databaseURL;\n                 if (cipher != null) {\n                     url += \";CIPHER=\" + cipher;\n                 }\n                 eventListener.init(url);\n             } catch (Throwable e) {\n-                throw DbException.get(\n-                        ErrorCode.ERROR_SETTING_DATABASE_EVENT_LISTENER_2, e,\n-                        className, e.toString());\n+                throw DbException.get(ErrorCode.ERROR_SETTING_DATABASE_EVENT_LISTENER_2,\n+                                      e,\n+                                      className,\n+                                      e.toString());\n             }\n         }\n     }\n@@ -2128,12 +2214,15 @@ public class Database implements DataHandler {\n      * @param x the current position\n      * @param max the highest value\n      */\n+\n+\n     public void setProgress(int state, String name, int x, int max) {\n         if (eventListener != null) {\n             try {\n                 eventListener.setProgress(state, name, x, max);\n             } catch (Exception e2) {\n                 // ignore this (user made) exception\n+\n             }\n         }\n     }\n@@ -2145,12 +2234,15 @@ public class Database implements DataHandler {\n      * @param e the exception\n      * @param sql the SQL statement\n      */\n+\n+\n     public void exceptionThrown(SQLException e, String sql) {\n         if (eventListener != null) {\n             try {\n                 eventListener.exceptionThrown(e, sql);\n             } catch (Exception e2) {\n                 // ignore this (user made) exception\n+\n             }\n         }\n     }\n@@ -2159,6 +2251,8 @@ public class Database implements DataHandler {\n      * Synchronize the files with the file system. This method is called when\n      * executing the SQL statement CHECKPOINT SYNC.\n      */\n+\n+\n     public synchronized void sync() {\n         if (readOnly) {\n             return;\n@@ -2171,22 +2265,27 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public int getMaxMemoryRows() {\n         return maxMemoryRows;\n     }\n \n+\n     public void setMaxMemoryRows(int value) {\n         this.maxMemoryRows = value;\n     }\n \n+\n     public void setMaxMemoryUndo(int value) {\n         this.maxMemoryUndo = value;\n     }\n \n+\n     public int getMaxMemoryUndo() {\n         return maxMemoryUndo;\n     }\n \n+\n     public void setLockMode(int lockMode) {\n         switch (lockMode) {\n         case Constants.LOCK_MODE_OFF:\n@@ -2194,9 +2293,8 @@ public class Database implements DataHandler {\n                 // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n                 // is not supported. also see code in\n                 // JdbcDatabaseMetaData#supportsTransactionIsolationLevel(int)\n-                throw DbException.get(\n-                        ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n-                        \"LOCK_MODE=0 & MULTI_THREADED\");\n+                throw DbException.get(ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n+                    \"LOCK_MODE=0 & MULTI_THREADED\");\n             }\n             break;\n         case Constants.LOCK_MODE_READ_COMMITTED:\n@@ -2209,14 +2307,17 @@ public class Database implements DataHandler {\n         this.lockMode = lockMode;\n     }\n \n+\n     public int getLockMode() {\n         return lockMode;\n     }\n \n+\n     public synchronized void setCloseDelay(int value) {\n         this.closeDelay = value;\n     }\n \n+\n     public Session getSystemSession() {\n         return systemSession;\n     }\n@@ -2226,10 +2327,13 @@ public class Database implements DataHandler {\n      *\n      * @return true if the database is closing\n      */\n+\n+\n     public boolean isClosing() {\n         return closing;\n     }\n \n+\n     public void setMaxLengthInplaceLob(int value) {\n         this.maxLengthInplaceLob = value;\n     }\n@@ -2239,10 +2343,12 @@ public class Database implements DataHandler {\n         return maxLengthInplaceLob;\n     }\n \n+\n     public void setIgnoreCase(boolean b) {\n         ignoreCase = b;\n     }\n \n+\n     public boolean getIgnoreCase() {\n         if (starting) {\n             // tables created at startup must not be converted to ignorecase\n@@ -2251,6 +2357,7 @@ public class Database implements DataHandler {\n         return ignoreCase;\n     }\n \n+\n     public synchronized void setDeleteFilesOnDisconnect(boolean b) {\n         this.deleteFilesOnDisconnect = b;\n     }\n@@ -2260,24 +2367,29 @@ public class Database implements DataHandler {\n         return lobCompressionAlgorithm;\n     }\n \n+\n     public void setLobCompressionAlgorithm(String stringValue) {\n         this.lobCompressionAlgorithm = stringValue;\n     }\n \n+\n     public synchronized void setMaxLogSize(long value) {\n         if (pageStore != null) {\n             pageStore.setMaxLogSize(value);\n         }\n     }\n \n+\n     public void setAllowLiterals(int value) {\n         this.allowLiterals = value;\n     }\n \n+\n     public boolean getOptimizeReuseResults() {\n         return optimizeReuseResults;\n     }\n \n+\n     public void setOptimizeReuseResults(boolean b) {\n         optimizeReuseResults = b;\n     }\n@@ -2287,18 +2399,22 @@ public class Database implements DataHandler {\n         return lobSyncObject;\n     }\n \n+\n     public int getSessionCount() {\n         return userSessions.size();\n     }\n \n+\n     public void setReferentialIntegrity(boolean b) {\n         referentialIntegrity = b;\n     }\n \n+\n     public boolean getReferentialIntegrity() {\n         return referentialIntegrity;\n     }\n \n+\n     public void setQueryStatistics(boolean b) {\n         queryStatistics = b;\n         synchronized (this) {\n@@ -2308,10 +2424,12 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public boolean getQueryStatistics() {\n         return queryStatistics;\n     }\n \n+\n     public void setQueryStatisticsMaxEntries(int n) {\n         queryStatisticsMaxEntries = n;\n         if (queryStatisticsData != null) {\n@@ -2323,6 +2441,7 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public QueryStatisticsData getQueryStatisticsData() {\n         if (!queryStatistics) {\n             return null;\n@@ -2343,6 +2462,8 @@ public class Database implements DataHandler {\n      *\n      * @return true if the database is still starting\n      */\n+\n+\n     public boolean isStarting() {\n         return starting;\n     }\n@@ -2352,6 +2473,8 @@ public class Database implements DataHandler {\n      *\n      * @return true if it is enabled\n      */\n+\n+\n     public boolean isMultiVersion() {\n         return multiVersion;\n     }\n@@ -2360,6 +2483,8 @@ public class Database implements DataHandler {\n      * Called after the database has been opened and initialized. This method\n      * notifies the event listener if one has been set.\n      */\n+\n+\n     void opened() {\n         if (eventListener != null) {\n             eventListener.opened();\n@@ -2369,46 +2494,51 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public void setMode(Mode mode) {\n         this.mode = mode;\n     }\n \n+\n     public Mode getMode() {\n         return mode;\n     }\n \n+\n     public boolean isMultiThreaded() {\n         return multiThreaded;\n     }\n \n+\n     public void setMultiThreaded(boolean multiThreaded) {\n         if (multiThreaded && this.multiThreaded != multiThreaded) {\n             if (multiVersion && mvStore == null) {\n                 // currently the combination of MVCC and MULTI_THREADED is not\n                 // supported\n-                throw DbException.get(\n-                        ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n-                        \"MVCC & MULTI_THREADED\");\n+                throw DbException.get(ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n+                    \"MVCC & MULTI_THREADED\");\n             }\n             if (lockMode == 0) {\n                 // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n                 // is not supported\n-                throw DbException.get(\n-                        ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n-                        \"LOCK_MODE=0 & MULTI_THREADED\");\n+                throw DbException.get(ErrorCode.UNSUPPORTED_SETTING_COMBINATION,\n+                    \"LOCK_MODE=0 & MULTI_THREADED\");\n             }\n         }\n         this.multiThreaded = multiThreaded;\n     }\n \n+\n     public void setMaxOperationMemory(int maxOperationMemory) {\n-        this.maxOperationMemory  = maxOperationMemory;\n+        this.maxOperationMemory = maxOperationMemory;\n     }\n \n+\n     public int getMaxOperationMemory() {\n         return maxOperationMemory;\n     }\n \n+\n     public Session getExclusiveSession() {\n         return exclusiveSession.get();\n     }\n@@ -2419,11 +2549,13 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @param closeOthers whether other sessions are closed\n      */\n+\n+\n     public void setExclusiveSession(Session session, boolean closeOthers) {\n-      this.exclusiveSession.set(session);\n-      if (closeOthers) {\n-          closeAllSessionsException(session);\n-      }\n+        this.exclusiveSession.set(session);\n+        if (closeOthers) {\n+            closeAllSessionsException(session);\n+        }\n     }\n \n     @Override\n@@ -2439,6 +2571,8 @@ public class Database implements DataHandler {\n      *\n      * @return true if it is currently locked\n      */\n+\n+\n     public boolean isSysTableLocked() {\n         return meta == null || meta.isLockedExclusively();\n     }\n@@ -2450,6 +2584,8 @@ public class Database implements DataHandler {\n      * @param session the session\n      * @return true if it is currently locked\n      */\n+\n+\n     public boolean isSysTableLockedBy(Session session) {\n         return meta == null || meta.isLockedExclusivelyBy(session);\n     }\n@@ -2463,13 +2599,18 @@ public class Database implements DataHandler {\n      * @param password the password\n      * @return the connection\n      */\n-    public TableLinkConnection getLinkConnection(String driver, String url,\n-            String user, String password) {\n+\n+\n+    public TableLinkConnection getLinkConnection(String driver, String url, String user, String password) {\n         if (linkConnections == null) {\n             linkConnections = New.hashMap();\n         }\n-        return TableLinkConnection.open(linkConnections, driver, url, user,\n-                password, dbSettings.shareLinkedConnections);\n+        return TableLinkConnection.open(linkConnections,\n+                                        driver,\n+                                        url,\n+                                        user,\n+                                        password,\n+                                        dbSettings.shareLinkedConnections);\n     }\n \n     @Override\n@@ -2480,12 +2621,15 @@ public class Database implements DataHandler {\n     /**\n      * Immediately close the database.\n      */\n+\n+\n     public void shutdownImmediately() {\n         setPowerOffCount(1);\n         try {\n             checkPowerOff();\n         } catch (DbException e) {\n             // ignore\n+\n         }\n         closeFiles();\n     }\n@@ -2495,6 +2639,7 @@ public class Database implements DataHandler {\n         return tempFileDeleter;\n     }\n \n+\n     public PageStore getPageStore() {\n         if (dbSettings.mvStore) {\n             if (mvStore == null) {\n@@ -2503,8 +2648,10 @@ public class Database implements DataHandler {\n             return null;\n         }\n         if (pageStore == null) {\n-            pageStore = new PageStore(this, databaseName +\n-                    Constants.SUFFIX_PAGE_FILE, accessModeData, cacheSize);\n+            pageStore = new PageStore(this,\n+                databaseName + Constants.SUFFIX_PAGE_FILE,\n+                    accessModeData,\n+                        cacheSize);\n             if (pageSize != Constants.DEFAULT_PAGE_SIZE) {\n                 pageStore.setPageSize(pageSize);\n             }\n@@ -2522,6 +2669,8 @@ public class Database implements DataHandler {\n      *\n      * @return the table or null if no table is defined\n      */\n+\n+\n     public Table getFirstUserTable() {\n         for (Table table : getAllTablesAndViews(false)) {\n             if (table.getCreateSQL() != null) {\n@@ -2543,6 +2692,8 @@ public class Database implements DataHandler {\n      *\n      * @return true if reconnecting is required\n      */\n+\n+\n     public boolean isReconnectNeeded() {\n         if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n             return false;\n@@ -2556,8 +2707,9 @@ public class Database implements DataHandler {\n         }\n         reconnectCheckNext = now + reconnectCheckDelayNs;\n         if (lock == null) {\n-            lock = new FileLock(traceSystem, databaseName +\n-                    Constants.SUFFIX_LOCK_FILE, Constants.LOCK_SLEEP);\n+            lock = new FileLock(traceSystem,\n+                databaseName + Constants.SUFFIX_LOCK_FILE,\n+                    Constants.LOCK_SLEEP);\n         }\n         try {\n             Properties prop = lock.load(), first = prop;\n@@ -2568,8 +2720,7 @@ public class Database implements DataHandler {\n                 if (prop.getProperty(\"changePending\", null) == null) {\n                     break;\n                 }\n-                if (System.nanoTime() >\n-                        now + reconnectCheckDelayNs * 10) {\n+                if (System.nanoTime() > now + reconnectCheckDelayNs * 10) {\n                     if (first.equals(prop)) {\n                         // the writing process didn't update the file -\n                         // it may have terminated\n@@ -2597,9 +2748,10 @@ public class Database implements DataHandler {\n      * transaction log and resets the change pending flag in\n      * the .lock.db file.\n      */\n+\n+\n     public void checkpointIfRequired() {\n-        if (fileLockMethod != FileLock.LOCK_SERIALIZED ||\n-                readOnly || !reconnectChangePending || closing) {\n+        if (fileLockMethod != FileLock.LOCK_SERIALIZED || readOnly || !reconnectChangePending || closing) {\n             return;\n         }\n         long now = System.nanoTime();\n@@ -2626,6 +2778,7 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public boolean isFileLockSerialized() {\n         return fileLockMethod == FileLock.LOCK_SERIALIZED;\n     }\n@@ -2640,6 +2793,8 @@ public class Database implements DataHandler {\n     /**\n      * Flush all changes and open a new transaction log.\n      */\n+\n+\n     public void checkpoint() {\n         if (persistent) {\n             synchronized (this) {\n@@ -2660,6 +2815,8 @@ public class Database implements DataHandler {\n      * @return true if the call was successful and writing is allowed,\n      *          false if another connection was faster\n      */\n+\n+\n     public boolean beforeWriting() {\n         if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n             return true;\n@@ -2669,6 +2826,7 @@ public class Database implements DataHandler {\n                 Thread.sleep(10 + (int) (Math.random() * 10));\n             } catch (Exception e) {\n                 // ignore InterruptedException\n+\n             }\n         }\n         synchronized (reconnectSync) {\n@@ -2689,6 +2847,8 @@ public class Database implements DataHandler {\n     /**\n      * This method is called after updates are finished.\n      */\n+\n+\n     public void afterWriting() {\n         if (fileLockMethod != FileLock.LOCK_SERIALIZED) {\n             return;\n@@ -2706,14 +2866,18 @@ public class Database implements DataHandler {\n      *\n      * @param readOnly the new value\n      */\n+\n+\n     public void setReadOnly(boolean readOnly) {\n         this.readOnly = readOnly;\n     }\n \n+\n     public void setCompactMode(int compactMode) {\n         this.compactMode = compactMode;\n     }\n \n+\n     public SourceCompiler getCompiler() {\n         if (compiler == null) {\n             compiler = new SourceCompiler();\n@@ -2733,33 +2897,34 @@ public class Database implements DataHandler {\n         return lobStorage;\n     }\n \n+\n     public JdbcConnection getLobConnectionForInit() {\n         String url = Constants.CONN_URL_INTERNAL;\n-        JdbcConnection conn = new JdbcConnection(\n-                systemSession, systemUser.getName(), url);\n+        JdbcConnection conn = new JdbcConnection(systemSession, systemUser.getName(), url);\n         conn.setTraceLevel(TraceSystem.OFF);\n         return conn;\n     }\n \n+\n     public JdbcConnection getLobConnectionForRegularUse() {\n         String url = Constants.CONN_URL_INTERNAL;\n-        JdbcConnection conn = new JdbcConnection(\n-                lobSession, systemUser.getName(), url);\n+        JdbcConnection conn = new JdbcConnection(lobSession, systemUser.getName(), url);\n         conn.setTraceLevel(TraceSystem.OFF);\n         return conn;\n     }\n \n+\n     public Session getLobSession() {\n         return lobSession;\n     }\n \n+\n     public void setLogMode(int log) {\n         if (log < 0 || log > 2) {\n             throw DbException.getInvalidValueException(\"LOG\", log);\n         }\n         if (pageStore != null) {\n-            if (log != PageStore.LOG_MODE_SYNC ||\n-                    pageStore.getLogMode() != PageStore.LOG_MODE_SYNC) {\n+            if (log != PageStore.LOG_MODE_SYNC || pageStore.getLogMode() != PageStore.LOG_MODE_SYNC) {\n                 // write the log mode in the trace file when enabling or\n                 // disabling a dangerous mode\n                 trace.error(null, \"log {0}\", log);\n@@ -2772,6 +2937,7 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public int getLogMode() {\n         if (pageStore != null) {\n             return pageStore.getLogMode();\n@@ -2782,18 +2948,22 @@ public class Database implements DataHandler {\n         return PageStore.LOG_MODE_OFF;\n     }\n \n+\n     public int getDefaultTableType() {\n         return defaultTableType;\n     }\n \n+\n     public void setDefaultTableType(int defaultTableType) {\n         this.defaultTableType = defaultTableType;\n     }\n \n+\n     public void setMultiVersion(boolean multiVersion) {\n         this.multiVersion = multiVersion;\n     }\n \n+\n     public DbSettings getSettings() {\n         return dbSettings;\n     }\n@@ -2805,10 +2975,10 @@ public class Database implements DataHandler {\n      * @param <V> the value type\n      * @return the hash map\n      */\n+\n+\n     public <V> HashMap<String, V> newStringMap() {\n-        return dbSettings.databaseToUpper ?\n-                new HashMap<String, V>() :\n-                new CaseInsensitiveMap<V>();\n+        return dbSettings.databaseToUpper ? new HashMap<String, V>() : new CaseInsensitiveMap<V>();\n     }\n \n     /**\n@@ -2818,10 +2988,10 @@ public class Database implements DataHandler {\n      * @param <V> the value type\n      * @return the hash map\n      */\n+\n+\n     public <V> ConcurrentHashMap<String, V> newConcurrentStringMap() {\n-        return dbSettings.databaseToUpper ?\n-                new NullableKeyConcurrentMap<V>() :\n-                new CaseInsensitiveConcurrentMap<V>();\n+        return dbSettings.databaseToUpper ? new NullableKeyConcurrentMap<V>() : new CaseInsensitiveConcurrentMap<V>();\n     }\n \n     /**\n@@ -2832,6 +3002,8 @@ public class Database implements DataHandler {\n      * @param b the second identifier\n      * @return true if they match\n      */\n+\n+\n     public boolean equalsIdentifiers(String a, String b) {\n         if (a == b || a.equals(b)) {\n             return true;\n@@ -2843,15 +3015,16 @@ public class Database implements DataHandler {\n     }\n \n     @Override\n-    public int readLob(long lobId, byte[] hmac, long offset, byte[] buff,\n-            int off, int length) {\n+    public int readLob(long lobId, byte[] hmac, long offset, byte[] buff, int off, int length) {\n         throw DbException.throwInternalError();\n     }\n \n+\n     public byte[] getFileEncryptionKey() {\n         return fileEncryptionKey;\n     }\n \n+\n     public int getPageSize() {\n         return pageSize;\n     }\n@@ -2873,11 +3046,9 @@ public class Database implements DataHandler {\n             String serializerName = javaObjectSerializerName;\n             if (serializerName != null) {\n                 serializerName = serializerName.trim();\n-                if (!serializerName.isEmpty() &&\n-                        !serializerName.equals(\"null\")) {\n+                if (!serializerName.isEmpty() && !serializerName.equals(\"null\")) {\n                     try {\n-                        javaObjectSerializer = (JavaObjectSerializer)\n-                                JdbcUtils.loadUserClass(serializerName).newInstance();\n+                        javaObjectSerializer = (JavaObjectSerializer) JdbcUtils.loadUserClass(serializerName).newInstance();\n                     } catch (Exception e) {\n                         throw DbException.convert(e);\n                     }\n@@ -2887,6 +3058,7 @@ public class Database implements DataHandler {\n         }\n     }\n \n+\n     public void setJavaObjectSerializerName(String serializerName) {\n         synchronized (this) {\n             javaObjectSerializerInitialized = false;\n@@ -2900,9 +3072,10 @@ public class Database implements DataHandler {\n      * @param tableEngine the table engine name\n      * @return the class\n      */\n+\n+\n     public TableEngine getTableEngine(String tableEngine) {\n         assert Thread.holdsLock(this);\n-\n         TableEngine engine = tableEngines.get(tableEngine);\n         if (engine == null) {\n             try {\n@@ -2915,4 +3088,4 @@ public class Database implements DataHandler {\n         return engine;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 445
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/594/Database.java\nindex 2ee29bf449..405bac1767 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/594/Database.java\n@@ -296,7 +296,7 @@ public class Database implements DataHandler {\n                 e.fillInStackTrace();\n             }\n             boolean alreadyOpen = e instanceof DbException\n-                    && ((DbException)e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n+                    && ((DbException) e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n             if (alreadyOpen) {\n                 stopServer();\n             }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/594/Database.java\nindex 2ee29bf449..405bac1767 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/594/Database.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/594/Database.java\n@@ -296,7 +296,7 @@ public class Database implements DataHandler {\n                 e.fillInStackTrace();\n             }\n             boolean alreadyOpen = e instanceof DbException\n-                    && ((DbException)e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n+                    && ((DbException) e).getErrorCode() == ErrorCode.DATABASE_ALREADY_OPEN_1;\n             if (alreadyOpen) {\n                 stopServer();\n             }\n",
            "diff_size": 1
        }
    ]
}