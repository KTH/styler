{
    "error_id": "144",
    "information": {
        "errors": [
            {
                "line": "344",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                    type = TypeInfo.getTypeInfo(r);\n                    return this;\n                } else { // DATE, TIMESTAMP\n                    type = TypeInfo.TYPE_TIMESTAMP;\n                    return this;\n                }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "344",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/144/BinaryOperation.java\nindex 6740337a75..f3658e774f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/144/BinaryOperation.java\n@@ -341,137 +341,137 @@ public class BinaryOperation extends Expression {\n                 if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n                     type = TypeInfo.getTypeInfo(r);\n                     return this;\n-                } else { // DATE, TIMESTAMP\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                        } else { // DATE, TIMESTAMPtype=\n+                        TypeInfo.TYPE_TIMESTAMP;\n+                 return this;\n+             }\n+         }\n+         break;\n+     case MINUS:\n+         switch (l) {\n+         case Value.DATE:\n+         case Value.TIMESTAMP:\n+         case Value.TIMESTAMP_TZ:\n+             switch (r) {\n+             case Value.INT: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.DECIMAL:\n+             case Value.FLOAT:\n+             case Value.DOUBLE: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+                 right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                         .get(60 * 60 * 24)), right);\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.TIME:\n+                 type = TypeInfo.TYPE_TIMESTAMP;\n+                 return this;\n+             case Value.DATE:\n+             case Value.TIMESTAMP:\n+             case Value.TIMESTAMP_TZ:\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         case Value.TIME:\n+             if (r == Value.TIME) {\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         }\n+         break;\n+     case MULTIPLY:\n+         if (l == Value.TIME) {\n+             type = TypeInfo.TYPE_TIME;\n+             convertRight = false;\n+             return this;\n+         } else if (r == Value.TIME) {\n+             swap();\n+             type = TypeInfo.TYPE_TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     case DIVIDE:\n+         if (l == Value.TIME) {\n+             type = TypeInfo.TYPE_TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     default:\n+     }\n+     throw getUnsupported(l, r);\n+ }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+ private DbException getUnsupported(int l, int r) {\n+     return DbException.getUnsupportedException(\n+             DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+ }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+ private void swap() {\n+     Expression temp = left;\n+     left = right;\n+     right = temp;\n+ }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+ @Override\n+ public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+     left.setEvaluatable(tableFilter, b);\n+     right.setEvaluatable(tableFilter, b);\n+ }\n \n-    @Override\n-    public TypeInfo getType() {\n-        return type;\n-    }\n+ @Override\n+ public TypeInfo getType() {\n+     return type;\n+ }\n \n-    @Override\n-    public void updateAggregate(Session session, int stage) {\n-        left.updateAggregate(session, stage);\n-        right.updateAggregate(session, stage);\n-    }\n+ @Override\n+ public void updateAggregate(Session session, int stage) {\n+     left.updateAggregate(session, stage);\n+     right.updateAggregate(session, stage);\n+ }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+ @Override\n+ public boolean isEverything(ExpressionVisitor visitor) {\n+     return left.isEverything(visitor) && right.isEverything(visitor);\n+ }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+ @Override\n+ public int getCost() {\n+     return left.getCost() + right.getCost() + 1;\n+ }\n \n-    @Override\n-    public int getSubexpressionCount() {\n-        return 2;\n-    }\n+ @Override\n+ public int getSubexpressionCount() {\n+     return 2;\n+ }\n \n-    @Override\n-    public Expression getSubexpression(int index) {\n-        switch (index) {\n-        case 0:\n-            return left;\n-        case 1:\n-            return right;\n-        default:\n-            throw new IndexOutOfBoundsException();\n-        }\n-    }\n+ @Override\n+ public Expression getSubexpression(int index) {\n+     switch (index) {\n+     case 0:\n+         return left;\n+     case 1:\n+         return right;\n+     default:\n+         throw new IndexOutOfBoundsException();\n+     }\n+ }\n \n }\n",
            "diff_size": 123
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "360",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/144/BinaryOperation.java\nindex 6740337a75..bf9701bf18 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/144/BinaryOperation.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.expression;\n \n import java.util.Arrays;\n@@ -26,452 +27,474 @@ import org.h2.value.ValueString;\n  */\n public class BinaryOperation extends Expression {\n \n-    public enum OpType {\n-        /**\n-         * This operation represents a string concatenation as in\n-         * {@code 'Hello' || 'World'} or an array concatenation as in\n-         * {@code ARRAY[1, 2] || 3}.\n-         */\n-        CONCAT,\n+  public enum OpType {\n+    /**\n+     * This operation represents a string concatenation as in\n+     * {@code 'Hello' || 'World'} or an array concatenation as in\n+     * {@code ARRAY[1, 2] || 3}.\n+     */\n+    CONCAT,\n \n-        /**\n-         * This operation represents an addition as in 1 + 2.\n-         */\n-        PLUS,\n+    /**\n+     * This operation represents an addition as in 1 + 2.\n+     */\n+    PLUS,\n \n-        /**\n-         * This operation represents a subtraction as in 2 - 1.\n-         */\n-        MINUS,\n+    /**\n+     * This operation represents a subtraction as in 2 - 1.\n+     */\n+    MINUS,\n \n-        /**\n-         * This operation represents a multiplication as in 2 * 3.\n-         */\n-        MULTIPLY,\n+    /**\n+     * This operation represents a multiplication as in 2 * 3.\n+     */\n+    MULTIPLY,\n \n-        /**\n-         * This operation represents a division as in 4 * 2.\n-         */\n-        DIVIDE,\n+    /**\n+     * This operation represents a division as in 4 * 2.\n+     */\n+    DIVIDE,\n \n-        /**\n-         * This operation represents a modulus as in 5 % 2.\n-         */\n-        MODULUS\n-    }\n+    /**\n+     * This operation represents a modulus as in 5 % 2.\n+     */\n+    MODULUS\n+  }\n \n-    private OpType opType;\n-    private Expression left, right;\n-    private TypeInfo type;\n-    private boolean convertRight = true;\n+  private OpType opType;\n+  private Expression left, right;\n+  private TypeInfo type;\n+  private boolean convertRight = true;\n \n-    public BinaryOperation(OpType opType, Expression left, Expression right) {\n-        this.opType = opType;\n-        this.left = left;\n-        this.right = right;\n-    }\n+  public BinaryOperation(OpType opType, Expression left, Expression right) {\n+    this.opType = opType;\n+    this.left = left;\n+    this.right = right;\n+  }\n \n-    @Override\n-    public StringBuilder getSQL(StringBuilder builder, boolean alwaysQuote) {\n-        // don't remove the space, otherwise it might end up some thing like\n-        // --1 which is a line remark\n-        builder.append('(');\n-        left.getSQL(builder, alwaysQuote).append(' ').append(getOperationToken()).append(' ');\n-        return right.getSQL(builder, alwaysQuote).append(')');\n-    }\n+  @Override\n+  public StringBuilder getSQL(StringBuilder builder, boolean alwaysQuote) {\n+    // don't remove the space, otherwise it might end up some thing like\n+    // --1 which is a line remark\n+    builder.append('(');\n+    left.getSQL(builder, alwaysQuote).append(' ').append(getOperationToken())\n+        .append(' ');\n+    return right.getSQL(builder, alwaysQuote).append(')');\n+  }\n \n-    private String getOperationToken() {\n-        switch (opType) {\n-        case CONCAT:\n-            return \"||\";\n-        case PLUS:\n-            return \"+\";\n-        case MINUS:\n-            return \"-\";\n-        case MULTIPLY:\n-            return \"*\";\n-        case DIVIDE:\n-            return \"/\";\n-        case MODULUS:\n-            return \"%\";\n-        default:\n-            throw DbException.throwInternalError(\"opType=\" + opType);\n-        }\n+  private String getOperationToken() {\n+    switch (opType) {\n+      case CONCAT:\n+        return \"||\";\n+      case PLUS:\n+        return \"+\";\n+      case MINUS:\n+        return \"-\";\n+      case MULTIPLY:\n+        return \"*\";\n+      case DIVIDE:\n+        return \"/\";\n+      case MODULUS:\n+        return \"%\";\n+      default:\n+        throw DbException.throwInternalError(\"opType=\" + opType);\n     }\n+  }\n \n-    @Override\n-    public Value getValue(Session session) {\n-        Mode mode = session.getDatabase().getMode();\n-        Value l = left.getValue(session).convertTo(type, mode, null);\n-        Value r = right.getValue(session);\n-        if (convertRight) {\n-            r = r.convertTo(type, mode, null);\n-        }\n-        switch (opType) {\n-        case CONCAT: {\n-            if (type.getValueType() == Value.ARRAY) {\n-                if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                Value[] leftValues = ((ValueArray) l).getList(), rightValues = ((ValueArray) r).getList();\n-                int leftLength = leftValues.length, rightLength = rightValues.length;\n-                Value[] values = Arrays.copyOf(leftValues, leftLength + rightLength);\n-                System.arraycopy(rightValues, 0, values, leftLength, rightLength);\n-                return ValueArray.get(values);\n-            } else {\n-                if (l == ValueNull.INSTANCE) {\n-                    if (mode.nullConcatIsNull) {\n-                        return ValueNull.INSTANCE;\n-                    }\n-                    return r;\n-                } else if (r == ValueNull.INSTANCE) {\n-                    if (mode.nullConcatIsNull) {\n-                        return ValueNull.INSTANCE;\n-                    }\n-                    return l;\n-                }\n-                String s1 = l.getString(), s2 = r.getString();\n-                StringBuilder buff = new StringBuilder(s1.length() + s2.length());\n-                buff.append(s1).append(s2);\n-                return ValueString.get(buff.toString());\n-            }\n-        }\n-        case PLUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.add(r);\n-        case MINUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.subtract(r);\n-        case MULTIPLY:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.multiply(r);\n-        case DIVIDE:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n+  @Override\n+  public Value getValue(Session session) {\n+    Mode mode = session.getDatabase().getMode();\n+    Value l = left.getValue(session).convertTo(type, mode, null);\n+    Value r = right.getValue(session);\n+    if (convertRight) {\n+      r = r.convertTo(type, mode, null);\n+    }\n+    switch (opType) {\n+      case CONCAT: {\n+        if (type.getValueType() == Value.ARRAY) {\n+          if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+            return ValueNull.INSTANCE;\n+          }\n+          Value[] leftValues = ((ValueArray) l).getList(), rightValues =\n+              ((ValueArray) r).getList();\n+          int leftLength = leftValues.length, rightLength = rightValues.length;\n+          Value[] values = Arrays.copyOf(leftValues, leftLength + rightLength);\n+          System.arraycopy(rightValues, 0, values, leftLength, rightLength);\n+          return ValueArray.get(values);\n+        } else {\n+          if (l == ValueNull.INSTANCE) {\n+            if (mode.nullConcatIsNull) {\n+              return ValueNull.INSTANCE;\n             }\n-            return l.divide(r);\n-        case MODULUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n+            return r;\n+          } else if (r == ValueNull.INSTANCE) {\n+            if (mode.nullConcatIsNull) {\n+              return ValueNull.INSTANCE;\n             }\n-            return l.modulus(r);\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + opType);\n+            return l;\n+          }\n+          String s1 = l.getString(), s2 = r.getString();\n+          StringBuilder buff = new StringBuilder(s1.length() + s2.length());\n+          buff.append(s1).append(s2);\n+          return ValueString.get(buff.toString());\n         }\n-    }\n-\n-    @Override\n-    public void mapColumns(ColumnResolver resolver, int level, int state) {\n-        left.mapColumns(resolver, level, state);\n-        right.mapColumns(resolver, level, state);\n-    }\n-\n-    @Override\n-    public Expression optimize(Session session) {\n-        left = left.optimize(session);\n-        right = right.optimize(session);\n-        switch (opType) {\n-        case CONCAT: {\n-            TypeInfo l = left.getType(), r = right.getType();\n-            if (l.getValueType() == Value.ARRAY) {\n-                type = TypeInfo.TYPE_ARRAY;\n-            } else {\n-                if (DataType.isStringType(l.getValueType()) && DataType.isStringType(r.getValueType())) {\n-                    long precision = l.getPrecision() + r.getPrecision();\n-                    if (precision >= 0 && precision < Integer.MAX_VALUE) {\n-                        type = TypeInfo.getTypeInfo(Value.STRING, precision, 0, null);\n-                        break;\n-                    }\n-                }\n-                type = TypeInfo.TYPE_STRING;\n-            }\n-            break;\n+      }\n+      case PLUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        case PLUS:\n-        case MINUS:\n-        case MULTIPLY:\n-        case DIVIDE:\n-        case MODULUS:\n-            int l = left.getType().getValueType();\n-            int r = right.getType().getValueType();\n-            if ((l == Value.NULL && r == Value.NULL) ||\n-                    (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n-                // (? + ?) - use decimal by default (the most safe data type) or\n-                // string when text concatenation with + is enabled\n-                if (opType == OpType.PLUS && session.getDatabase().\n-                        getMode().allowPlusForStringConcat) {\n-                    type = TypeInfo.TYPE_STRING;\n-                    opType = OpType.CONCAT;\n-                } else {\n-                    type = TypeInfo.TYPE_DECIMAL_DEFAULT;\n-                }\n-            } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n-                return optimizeInterval(session, l, r);\n-            } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n-                return optimizeDateTime(session, l, r);\n-            } else {\n-                int dataType = Value.getHigherOrder(l, r);\n-                if (dataType == Value.ENUM) {\n-                    type = TypeInfo.TYPE_INT;\n-                } else {\n-                    type = TypeInfo.getTypeInfo(dataType);\n-                    if (DataType.isStringType(dataType) && session.getDatabase().getMode().allowPlusForStringConcat) {\n-                        opType = OpType.CONCAT;\n-                    }\n-                }\n-            }\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + opType);\n+        return l.add(r);\n+      case MINUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n+        }\n+        return l.subtract(r);\n+      case MULTIPLY:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n+        }\n+        return l.multiply(r);\n+      case DIVIDE:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        if (left.isConstant() && right.isConstant()) {\n-            return ValueExpression.get(getValue(session));\n+        return l.divide(r);\n+      case MODULUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        return this;\n+        return l.modulus(r);\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + opType);\n     }\n+  }\n \n-    private Expression optimizeInterval(Session session, int l, int r) {\n-        boolean lInterval = false, lNumeric = false, lDateTime = false;\n-        if (DataType.isIntervalType(l)) {\n-            lInterval = true;\n-        } else if (DataType.isNumericType(l)) {\n-            lNumeric = true;\n-        } else if (DataType.isDateTimeType(l)) {\n-            lDateTime = true;\n+  @Override\n+  public void mapColumns(ColumnResolver resolver, int level, int state) {\n+    left.mapColumns(resolver, level, state);\n+    right.mapColumns(resolver, level, state);\n+  }\n+\n+  @Override\n+  public Expression optimize(Session session) {\n+    left = left.optimize(session);\n+    right = right.optimize(session);\n+    switch (opType) {\n+      case CONCAT: {\n+        TypeInfo l = left.getType(), r = right.getType();\n+        if (l.getValueType() == Value.ARRAY) {\n+          type = TypeInfo.TYPE_ARRAY;\n         } else {\n-            throw getUnsupported(l, r);\n+          if (DataType.isStringType(l.getValueType()) &&\n+              DataType.isStringType(r.getValueType())) {\n+            long precision = l.getPrecision() + r.getPrecision();\n+            if (precision >= 0 && precision < Integer.MAX_VALUE) {\n+              type = TypeInfo.getTypeInfo(Value.STRING, precision, 0, null);\n+              break;\n+            }\n+          }\n+          type = TypeInfo.TYPE_STRING;\n         }\n-        boolean rInterval = false, rNumeric = false, rDateTime = false;\n-        if (DataType.isIntervalType(r)) {\n-            rInterval = true;\n-        } else if (DataType.isNumericType(r)) {\n-            rNumeric = true;\n-        } else if (DataType.isDateTimeType(r)) {\n-            rDateTime = true;\n+        break;\n+      }\n+      case PLUS:\n+      case MINUS:\n+      case MULTIPLY:\n+      case DIVIDE:\n+      case MODULUS:\n+        int l = left.getType().getValueType();\n+        int r = right.getType().getValueType();\n+        if ((l == Value.NULL && r == Value.NULL) ||\n+            (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n+          // (? + ?) - use decimal by default (the most safe data type) or\n+          // string when text concatenation with + is enabled\n+          if (opType == OpType.PLUS && session.getDatabase().\n+              getMode().allowPlusForStringConcat) {\n+            type = TypeInfo.TYPE_STRING;\n+            opType = OpType.CONCAT;\n+          } else {\n+            type = TypeInfo.TYPE_DECIMAL_DEFAULT;\n+          }\n+        } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n+          return optimizeInterval(session, l, r);\n+        } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n+          return optimizeDateTime(session, l, r);\n         } else {\n-            throw getUnsupported(l, r);\n-        }\n-        switch (opType) {\n-        case PLUS:\n-            if (lInterval && rInterval) {\n-                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL, left, right);\n-                }\n-            } else if (lInterval && rDateTime) {\n-                if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);\n-            } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n-            }\n-            break;\n-        case MINUS:\n-            if (lInterval && rInterval) {\n-                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL, left, right);\n-                }\n-            } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL, left, right);\n+          int dataType = Value.getHigherOrder(l, r);\n+          if (dataType == Value.ENUM) {\n+            type = TypeInfo.TYPE_INT;\n+          } else {\n+            type = TypeInfo.getTypeInfo(dataType);\n+            if (DataType.isStringType(dataType) &&\n+                session.getDatabase().getMode().allowPlusForStringConcat) {\n+              opType = OpType.CONCAT;\n             }\n+          }\n+        }\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + opType);\n+    }\n+    if (left.isConstant() && right.isConstant()) {\n+      return ValueExpression.get(getValue(session));\n+    }\n+    return this;\n+  }\n+\n+  private Expression optimizeInterval(Session session, int l, int r) {\n+    boolean lInterval = false, lNumeric = false, lDateTime = false;\n+    if (DataType.isIntervalType(l)) {\n+      lInterval = true;\n+    } else if (DataType.isNumericType(l)) {\n+      lNumeric = true;\n+    } else if (DataType.isDateTimeType(l)) {\n+      lDateTime = true;\n+    } else {\n+      throw getUnsupported(l, r);\n+    }\n+    boolean rInterval = false, rNumeric = false, rDateTime = false;\n+    if (DataType.isIntervalType(r)) {\n+      rInterval = true;\n+    } else if (DataType.isNumericType(r)) {\n+      rNumeric = true;\n+    } else if (DataType.isDateTimeType(r)) {\n+      rDateTime = true;\n+    } else {\n+      throw getUnsupported(l, r);\n+    }\n+    switch (opType) {\n+      case PLUS:\n+        if (lInterval && rInterval) {\n+          if (DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL,\n+                left, right);\n+          }\n+        } else if (lInterval && rDateTime) {\n+          if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {\n             break;\n-        case MULTIPLY:\n-            if (lInterval && rNumeric) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, left, right);\n-            } else if (lNumeric && rInterval) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, right, left);\n-            }\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL,\n+              right, left);\n+        } else if (lDateTime && rInterval) {\n+          if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n             break;\n-        case DIVIDE:\n-            if (lInterval && rNumeric) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC, left, right);\n-            }\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL,\n+              left, right);\n+        }\n+        break;\n+      case MINUS:\n+        if (lInterval && rInterval) {\n+          if (DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL,\n+                left, right);\n+          }\n+        } else if (lDateTime && rInterval) {\n+          if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n             break;\n-        default:\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL,\n+              left, right);\n+        }\n+        break;\n+      case MULTIPLY:\n+        if (lInterval && rNumeric) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC,\n+              left, right);\n+        } else if (lNumeric && rInterval) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC,\n+              right, left);\n         }\n-        throw getUnsupported(l, r);\n+        break;\n+      case DIVIDE:\n+        if (lInterval && rNumeric) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC,\n+              left, right);\n+        }\n+        break;\n+      default:\n     }\n+    throw getUnsupported(l, r);\n+  }\n \n-    private Expression optimizeDateTime(Session session, int l, int r) {\n-        switch (opType) {\n-        case PLUS:\n-            if (r != Value.getHigherOrder(l, r)) {\n-                // order left and right: INT < TIME < DATE < TIMESTAMP\n-                swap();\n-                int t = l;\n-                l = r;\n-                r = t;\n+  private Expression optimizeDateTime(Session session, int l, int r) {\n+    switch (opType) {\n+      case PLUS:\n+        if (r != Value.getHigherOrder(l, r)) {\n+          // order left and right: INT < TIME < DATE < TIMESTAMP\n+          swap();\n+          int t = l;\n+          l = r;\n+          r = t;\n+        }\n+        switch (l) {\n+          case Value.INT: {\n+            // Oracle date add\n+            Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+            f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+            f.setParameter(1, left);\n+            f.setParameter(2, right);\n+            f.doneWithParameters();\n+            return f.optimize(session);\n+          }\n+          case Value.DECIMAL:\n+          case Value.FLOAT:\n+          case Value.DOUBLE: {\n+            // Oracle date add\n+            Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+            f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+            left = new BinaryOperation(OpType.MULTIPLY,\n+                ValueExpression.get(ValueInt\n+                    .get(60 * 60 * 24)), left);\n+            f.setParameter(1, left);\n+            f.setParameter(2, right);\n+            f.doneWithParameters();\n+            return f.optimize(session);\n+          }\n+          case Value.TIME:\n+            if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n+              type = TypeInfo.getTypeInfo(r);\n+              return this;\n+            } else { // DATE, TIMESTAMP\n+              type = TypeInfo.TYPE_TIMESTAMP;\n+              return this;\n             }\n-            switch (l) {\n-            case Value.INT: {\n-                // Oracle date add\n-                Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+        }\n+        break;\n+      case MINUS:\n+        switch (l) {\n+          case Value.DATE:\n+          case Value.TIMESTAMP:\n+          case Value.TIMESTAMP_TZ:\n+            switch (r) {\n+              case Value.INT: {\n+                // Oracle date subtract\n+                Function f =\n+                    Function.getFunction(session.getDatabase(), \"DATEADD\");\n                 f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                f.setParameter(1, left);\n-                f.setParameter(2, right);\n+                right = new UnaryOperation(right);\n+                right = right.optimize(session);\n+                f.setParameter(1, right);\n+                f.setParameter(2, left);\n                 f.doneWithParameters();\n                 return f.optimize(session);\n-            }\n-            case Value.DECIMAL:\n-            case Value.FLOAT:\n-            case Value.DOUBLE: {\n-                // Oracle date add\n-                Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                left = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                        .get(60 * 60 * 24)), left);\n-                f.setParameter(1, left);\n-                f.setParameter(2, right);\n+              }\n+              case Value.DECIMAL:\n+              case Value.FLOAT:\n+              case Value.DOUBLE: {\n+                // Oracle date subtract\n+                Function f =\n+                    Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                f.setParameter(0,\n+                    ValueExpression.get(ValueString.get(\"SECOND\")));\n+                right = new BinaryOperation(OpType.MULTIPLY,\n+                    ValueExpression.get(ValueInt\n+                        .get(60 * 60 * 24)), right);\n+                right = new UnaryOperation(right);\n+                right = right.optimize(session);\n+                f.setParameter(1, right);\n+                f.setParameter(2, left);\n                 f.doneWithParameters();\n                 return f.optimize(session);\n-            }\n-            case Value.TIME:\n-                if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n-                    type = TypeInfo.getTypeInfo(r);\n-                    return this;\n-                } else { // DATE, TIMESTAMP\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n+              }\n+              case Value.TIME:\n+                type = TypeInfo.TYPE_TIMESTAMP;\n                 return this;\n+              case Value.DATE:\n+              case Value.TIMESTAMP:\n+              case Value.TIMESTAMP_TZ:\n+                return new IntervalOperation(\n+                    IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n             }\n             break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n+          case Value.TIME:\n+            if (r == Value.TIME) {\n+              return new IntervalOperation(\n+                  IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n             }\n             break;\n-        default:\n         }\n-        throw getUnsupported(l, r);\n+        break;\n+      case MULTIPLY:\n+        if (l == Value.TIME) {\n+          type = TypeInfo.TYPE_TIME;\n+          convertRight = false;\n+          return this;\n+        } else if (r == Value.TIME) {\n+          swap();\n+          type = TypeInfo.TYPE_TIME;\n+          convertRight = false;\n+          return this;\n+        }\n+        break;\n+      case DIVIDE:\n+        if (l == Value.TIME) {\n+          type = TypeInfo.TYPE_TIME;\n+          convertRight = false;\n+          return this;\n+        }\n+        break;\n+      default:\n     }\n+    throw getUnsupported(l, r);\n+  }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+  private DbException getUnsupported(int l, int r) {\n+    return DbException.getUnsupportedException(\n+        DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' +\n+            DataType.getDataType(r).name);\n+  }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+  private void swap() {\n+    Expression temp = left;\n+    left = right;\n+    right = temp;\n+  }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+  @Override\n+  public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+    left.setEvaluatable(tableFilter, b);\n+    right.setEvaluatable(tableFilter, b);\n+  }\n \n-    @Override\n-    public TypeInfo getType() {\n-        return type;\n-    }\n+  @Override\n+  public TypeInfo getType() {\n+    return type;\n+  }\n \n-    @Override\n-    public void updateAggregate(Session session, int stage) {\n-        left.updateAggregate(session, stage);\n-        right.updateAggregate(session, stage);\n-    }\n+  @Override\n+  public void updateAggregate(Session session, int stage) {\n+    left.updateAggregate(session, stage);\n+    right.updateAggregate(session, stage);\n+  }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+  @Override\n+  public boolean isEverything(ExpressionVisitor visitor) {\n+    return left.isEverything(visitor) && right.isEverything(visitor);\n+  }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+  @Override\n+  public int getCost() {\n+    return left.getCost() + right.getCost() + 1;\n+  }\n \n-    @Override\n-    public int getSubexpressionCount() {\n-        return 2;\n-    }\n+  @Override\n+  public int getSubexpressionCount() {\n+    return 2;\n+  }\n \n-    @Override\n-    public Expression getSubexpression(int index) {\n-        switch (index) {\n-        case 0:\n-            return left;\n-        case 1:\n-            return right;\n-        default:\n-            throw new IndexOutOfBoundsException();\n-        }\n+  @Override\n+  public Expression getSubexpression(int index) {\n+    switch (index) {\n+      case 0:\n+        return left;\n+      case 1:\n+        return right;\n+      default:\n+        throw new IndexOutOfBoundsException();\n     }\n+  }\n \n }\n",
            "diff_size": 587
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "341",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/144/BinaryOperation.java\nindex 6740337a75..4db697653b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/144/BinaryOperation.java\n@@ -24,8 +24,11 @@ import org.h2.value.ValueString;\n /**\n  * A mathematical expression, or string concatenation.\n  */\n+\n+\n public class BinaryOperation extends Expression {\n \n+\n     public enum OpType {\n         /**\n          * This operation represents a string concatenation as in\n@@ -36,30 +39,23 @@ public class BinaryOperation extends Expression {\n \n         /**\n          * This operation represents an addition as in 1 + 2.\n-         */\n-        PLUS,\n+         */ PLUS,\n \n         /**\n          * This operation represents a subtraction as in 2 - 1.\n-         */\n-        MINUS,\n+         */ MINUS,\n \n         /**\n          * This operation represents a multiplication as in 2 * 3.\n-         */\n-        MULTIPLY,\n+         */ MULTIPLY,\n \n         /**\n          * This operation represents a division as in 4 * 2.\n-         */\n-        DIVIDE,\n+         */ DIVIDE,\n \n         /**\n          * This operation represents a modulus as in 5 % 2.\n-         */\n-        MODULUS\n-    }\n-\n+         */ MODULUS }\n     private OpType opType;\n     private Expression left, right;\n     private TypeInfo type;\n@@ -198,34 +194,34 @@ public class BinaryOperation extends Expression {\n         case MULTIPLY:\n         case DIVIDE:\n         case MODULUS:\n+\n             int l = left.getType().getValueType();\n             int r = right.getType().getValueType();\n             if ((l == Value.NULL && r == Value.NULL) ||\n                     (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n                 // (? + ?) - use decimal by default (the most safe data type) or\n                 // string when text concatenation with + is enabled\n-                if (opType == OpType.PLUS && session.getDatabase().\n-                        getMode().allowPlusForStringConcat) {\n+                if (opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n                     type = TypeInfo.TYPE_STRING;\n                     opType = OpType.CONCAT;\n                 } else {\n                     type = TypeInfo.TYPE_DECIMAL_DEFAULT;\n                 }\n             } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n-                return optimizeInterval(session, l, r);\n+            return optimizeInterval(session, l, r);\n             } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n-                return optimizeDateTime(session, l, r);\n-            } else {\n-                int dataType = Value.getHigherOrder(l, r);\n-                if (dataType == Value.ENUM) {\n-                    type = TypeInfo.TYPE_INT;\n-                } else {\n-                    type = TypeInfo.getTypeInfo(dataType);\n-                    if (DataType.isStringType(dataType) && session.getDatabase().getMode().allowPlusForStringConcat) {\n-                        opType = OpType.CONCAT;\n-                    }\n-                }\n-            }\n+            return optimizeDateTime(session, l, r);\n+                   } else {\n+                       int dataType = Value.getHigherOrder(l, r);\n+                       if (dataType == Value.ENUM) {\n+                           type = TypeInfo.TYPE_INT;\n+                       } else {\n+                           type = TypeInfo.getTypeInfo(dataType);\n+                           if (DataType.isStringType(dataType) && session.getDatabase().getMode().allowPlusForStringConcat) {\n+                               opType = OpType.CONCAT;\n+                           }\n+                       }\n+                   }\n             break;\n         default:\n             DbException.throwInternalError(\"type=\" + opType);\n@@ -243,20 +239,20 @@ public class BinaryOperation extends Expression {\n         } else if (DataType.isNumericType(l)) {\n             lNumeric = true;\n         } else if (DataType.isDateTimeType(l)) {\n-            lDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n+                   lDateTime = true;\n+               } else {\n+                   throw getUnsupported(l, r);\n+               }\n         boolean rInterval = false, rNumeric = false, rDateTime = false;\n         if (DataType.isIntervalType(r)) {\n             rInterval = true;\n         } else if (DataType.isNumericType(r)) {\n             rNumeric = true;\n         } else if (DataType.isDateTimeType(r)) {\n-            rDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n+                   rDateTime = true;\n+               } else {\n+                   throw getUnsupported(l, r);\n+               }\n         switch (opType) {\n         case PLUS:\n             if (lInterval && rInterval) {\n@@ -269,11 +265,11 @@ public class BinaryOperation extends Expression {\n                 }\n                 return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);\n             } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n-            }\n+                       if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n+                           break;\n+                       }\n+                       return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n+                   }\n             break;\n         case MINUS:\n             if (lInterval && rInterval) {\n@@ -330,8 +326,9 @@ public class BinaryOperation extends Expression {\n                 // Oracle date add\n                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n                 f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                left = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                        .get(60 * 60 * 24)), left);\n+                left = new BinaryOperation(OpType.MULTIPLY,\n+                    ValueExpression.get(ValueInt.get(60 * 60 * 24)),\n+                        left);\n                 f.setParameter(1, left);\n                 f.setParameter(2, right);\n                 f.doneWithParameters();\n@@ -370,8 +367,9 @@ public class BinaryOperation extends Expression {\n                     // Oracle date subtract\n                     Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n                     f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n+                    right = new BinaryOperation(OpType.MULTIPLY,\n+                        ValueExpression.get(ValueInt.get(60 * 60 * 24)),\n+                            right);\n                     right = new UnaryOperation(right);\n                     right = right.optimize(session);\n                     f.setParameter(1, right);\n@@ -420,8 +418,7 @@ public class BinaryOperation extends Expression {\n     }\n \n     private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+        return DbException.getUnsupportedException(DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n     }\n \n     private void swap() {\n@@ -474,4 +471,4 @@ public class BinaryOperation extends Expression {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 53
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "344",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/144/BinaryOperation.java\nindex 6740337a75..f3658e774f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/144/BinaryOperation.java\n@@ -341,137 +341,137 @@ public class BinaryOperation extends Expression {\n                 if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n                     type = TypeInfo.getTypeInfo(r);\n                     return this;\n-                } else { // DATE, TIMESTAMP\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                        } else { // DATE, TIMESTAMPtype=\n+                        TypeInfo.TYPE_TIMESTAMP;\n+                 return this;\n+             }\n+         }\n+         break;\n+     case MINUS:\n+         switch (l) {\n+         case Value.DATE:\n+         case Value.TIMESTAMP:\n+         case Value.TIMESTAMP_TZ:\n+             switch (r) {\n+             case Value.INT: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.DECIMAL:\n+             case Value.FLOAT:\n+             case Value.DOUBLE: {\n+                 // Oracle date subtract\n+                 Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                 f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+                 right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                         .get(60 * 60 * 24)), right);\n+                 right = new UnaryOperation(right);\n+                 right = right.optimize(session);\n+                 f.setParameter(1, right);\n+                 f.setParameter(2, left);\n+                 f.doneWithParameters();\n+                 return f.optimize(session);\n+             }\n+             case Value.TIME:\n+                 type = TypeInfo.TYPE_TIMESTAMP;\n+                 return this;\n+             case Value.DATE:\n+             case Value.TIMESTAMP:\n+             case Value.TIMESTAMP_TZ:\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         case Value.TIME:\n+             if (r == Value.TIME) {\n+                 return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+             }\n+             break;\n+         }\n+         break;\n+     case MULTIPLY:\n+         if (l == Value.TIME) {\n+             type = TypeInfo.TYPE_TIME;\n+             convertRight = false;\n+             return this;\n+         } else if (r == Value.TIME) {\n+             swap();\n+             type = TypeInfo.TYPE_TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     case DIVIDE:\n+         if (l == Value.TIME) {\n+             type = TypeInfo.TYPE_TIME;\n+             convertRight = false;\n+             return this;\n+         }\n+         break;\n+     default:\n+     }\n+     throw getUnsupported(l, r);\n+ }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+ private DbException getUnsupported(int l, int r) {\n+     return DbException.getUnsupportedException(\n+             DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+ }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+ private void swap() {\n+     Expression temp = left;\n+     left = right;\n+     right = temp;\n+ }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+ @Override\n+ public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+     left.setEvaluatable(tableFilter, b);\n+     right.setEvaluatable(tableFilter, b);\n+ }\n \n-    @Override\n-    public TypeInfo getType() {\n-        return type;\n-    }\n+ @Override\n+ public TypeInfo getType() {\n+     return type;\n+ }\n \n-    @Override\n-    public void updateAggregate(Session session, int stage) {\n-        left.updateAggregate(session, stage);\n-        right.updateAggregate(session, stage);\n-    }\n+ @Override\n+ public void updateAggregate(Session session, int stage) {\n+     left.updateAggregate(session, stage);\n+     right.updateAggregate(session, stage);\n+ }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+ @Override\n+ public boolean isEverything(ExpressionVisitor visitor) {\n+     return left.isEverything(visitor) && right.isEverything(visitor);\n+ }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+ @Override\n+ public int getCost() {\n+     return left.getCost() + right.getCost() + 1;\n+ }\n \n-    @Override\n-    public int getSubexpressionCount() {\n-        return 2;\n-    }\n+ @Override\n+ public int getSubexpressionCount() {\n+     return 2;\n+ }\n \n-    @Override\n-    public Expression getSubexpression(int index) {\n-        switch (index) {\n-        case 0:\n-            return left;\n-        case 1:\n-            return right;\n-        default:\n-            throw new IndexOutOfBoundsException();\n-        }\n-    }\n+ @Override\n+ public Expression getSubexpression(int index) {\n+     switch (index) {\n+     case 0:\n+         return left;\n+     case 1:\n+         return right;\n+     default:\n+         throw new IndexOutOfBoundsException();\n+     }\n+ }\n \n }\n",
            "diff_size": 123
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "343",
                    "column": "34",
                    "severity": "warning",
                    "message": "'}' at column 34 should have line break before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "344",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/144/BinaryOperation.java\nindex 6740337a75..8ef7488394 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/144/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/144/BinaryOperation.java\n@@ -340,138 +340,139 @@ public class BinaryOperation extends Expression {\n             case Value.TIME:\n                 if (r == Value.TIME || r == Value.TIMESTAMP_TZ) {\n                     type = TypeInfo.getTypeInfo(r);\n-                    return this;\n-                } else { // DATE, TIMESTAMP\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                }\n-            }\n-            break;\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INT: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.DECIMAL:\n-                case Value.FLOAT:\n-                case Value.DOUBLE: {\n-                    // Oracle date subtract\n-                    Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n-                    f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n-                    right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n-                            .get(60 * 60 * 24)), right);\n-                    right = new UnaryOperation(right);\n-                    right = right.optimize(session);\n-                    f.setParameter(1, right);\n-                    f.setParameter(2, left);\n-                    f.doneWithParameters();\n-                    return f.optimize(session);\n-                }\n-                case Value.TIME:\n-                    type = TypeInfo.TYPE_TIMESTAMP;\n-                    return this;\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            case Value.TIME:\n-                if (r == Value.TIME) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                    return this; }\n+                        else { // DATE, TIMESTAMP\n+                         type = TypeInfo.TYPE_TIMESTAMP;\n+                         return this;\n+                     }\n+                 }\n+                 break;\n+             case MINUS:\n+                 switch (l) {\n+                 case Value.DATE:\n+                 case Value.TIMESTAMP:\n+                 case Value.TIMESTAMP_TZ:\n+                     switch (r) {\n+                     case Value.INT: {\n+                         // Oracle date subtract\n+                         Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                         f.setParameter(0, ValueExpression.get(ValueString.get(\"DAY\")));\n+                         right = new UnaryOperation(right);\n+                         right = right.optimize(session);\n+                         f.setParameter(1, right);\n+                         f.setParameter(2, left);\n+                         f.doneWithParameters();\n+                         return f.optimize(session);\n+                     }\n+                     case Value.DECIMAL:\n+                     case Value.FLOAT:\n+                     case Value.DOUBLE: {\n+                         // Oracle date subtract\n+                         Function f = Function.getFunction(session.getDatabase(), \"DATEADD\");\n+                         f.setParameter(0, ValueExpression.get(ValueString.get(\"SECOND\")));\n+                         right = new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInt\n+                                 .get(60 * 60 * 24)), right);\n+                         right = new UnaryOperation(right);\n+                         right = right.optimize(session);\n+                         f.setParameter(1, right);\n+                         f.setParameter(2, left);\n+                         f.doneWithParameters();\n+                         return f.optimize(session);\n+                     }\n+                     case Value.TIME:\n+                         type = TypeInfo.TYPE_TIMESTAMP;\n+                         return this;\n+                     case Value.DATE:\n+                     case Value.TIMESTAMP:\n+                     case Value.TIMESTAMP_TZ:\n+                         return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+                     }\n+                     break;\n+                 case Value.TIME:\n+                     if (r == Value.TIME) {\n+                         return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right);\n+                     }\n+                     break;\n+                 }\n+                 break;\n+             case MULTIPLY:\n+                 if (l == Value.TIME) {\n+                     type = TypeInfo.TYPE_TIME;\n+                     convertRight = false;\n+                     return this;\n+                 } else if (r == Value.TIME) {\n+                     swap();\n+                     type = TypeInfo.TYPE_TIME;\n+                     convertRight = false;\n+                     return this;\n+                 }\n+                 break;\n+             case DIVIDE:\n+                 if (l == Value.TIME) {\n+                     type = TypeInfo.TYPE_TIME;\n+                     convertRight = false;\n+                     return this;\n+                 }\n+                 break;\n+             default:\n+             }\n+             throw getUnsupported(l, r);\n+         }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+         private DbException getUnsupported(int l, int r) {\n+             return DbException.getUnsupportedException(\n+                     DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+         }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+         private void swap() {\n+             Expression temp = left;\n+             left = right;\n+             right = temp;\n+         }\n \n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n+         @Override\n+         public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+             left.setEvaluatable(tableFilter, b);\n+             right.setEvaluatable(tableFilter, b);\n+         }\n \n-    @Override\n-    public TypeInfo getType() {\n-        return type;\n-    }\n+         @Override\n+         public TypeInfo getType() {\n+             return type;\n+         }\n \n-    @Override\n-    public void updateAggregate(Session session, int stage) {\n-        left.updateAggregate(session, stage);\n-        right.updateAggregate(session, stage);\n-    }\n+         @Override\n+         public void updateAggregate(Session session, int stage) {\n+             left.updateAggregate(session, stage);\n+             right.updateAggregate(session, stage);\n+         }\n \n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n+         @Override\n+         public boolean isEverything(ExpressionVisitor visitor) {\n+             return left.isEverything(visitor) && right.isEverything(visitor);\n+         }\n \n-    @Override\n-    public int getCost() {\n-        return left.getCost() + right.getCost() + 1;\n-    }\n+         @Override\n+         public int getCost() {\n+             return left.getCost() + right.getCost() + 1;\n+         }\n \n-    @Override\n-    public int getSubexpressionCount() {\n-        return 2;\n-    }\n+         @Override\n+         public int getSubexpressionCount() {\n+             return 2;\n+         }\n \n-    @Override\n-    public Expression getSubexpression(int index) {\n-        switch (index) {\n-        case 0:\n-            return left;\n-        case 1:\n-            return right;\n-        default:\n-            throw new IndexOutOfBoundsException();\n-        }\n-    }\n+         @Override\n+         public Expression getSubexpression(int index) {\n+             switch (index) {\n+             case 0:\n+                 return left;\n+             case 1:\n+                 return right;\n+             default:\n+                 throw new IndexOutOfBoundsException();\n+             }\n+         }\n \n-}\n+     }\n+     \n\\ No newline at end of file\n",
            "diff_size": 126
        }
    ]
}