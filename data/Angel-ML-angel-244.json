{
    "error_id": "244",
    "information": {
        "errors": [
            {
                "line": "79",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 127).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "      }\n    }\n    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\n    return partParams;\n  }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler/244/IndexGetParam.java\nindex b48e2d0589..5cbe8ec672 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler/244/IndexGetParam.java\n@@ -1,142 +1,141 @@\n-/*\r\n- * Tencent is pleased to support the open source community by making Angel available.\r\n- *\r\n- * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.\r\n- *\r\n- * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- *\r\n- * https://opensource.org/licenses/BSD-3-Clause\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n- * or implied. See the License for the specific language governing permissions and limitations under\r\n- * the License.\r\n- *\r\n- */\r\n-\r\n-package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-import org.apache.commons.logging.Log;\r\n-import org.apache.commons.logging.LogFactory;\r\n-\r\n-import java.util.*;\r\n-\r\n-/**\r\n- * The GetParam of IndexGetFunc\r\n- */\r\n-public class IndexGetParam extends GetParam {\r\n-  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\r\n-  private int rowId;\r\n-  private int[] indexes;\r\n-  private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param indexes specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, int[] indexes) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.indexes = indexes;\r\n-  }\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param partKeyToIndexesMap specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.partKeyToIndexesMap = partKeyToIndexesMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @return partition get param of specified index\r\n-   */\r\n-  @Override\r\n-  public List<PartitionGetParam> split() {\r\n-    long startTs = System.currentTimeMillis();\r\n-    if(partKeyToIndexesMap == null) {\r\n-      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n-        .getPartitions(matrixId, rowId), indexes);\r\n-      indexes = null;\r\n-    }\r\n-\r\n-    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n-    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n-      if(entry.getValue().length > 0) {\r\n-        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\r\n-      }\r\n-    }\r\n-    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\r\n-    return partParams;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @param partKeys all partitions of this matrix and this row\r\n-   * @param indexes specified index array\r\n-   * @return the used partition of the specifiex index array of this matrix this row\r\n-   */\r\n-  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n-    // Sort the parts by partitionId\r\n-    Arrays.sort(indexes);\r\n-\r\n-    HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n-\r\n-    // Sort partition keys use start column index\r\n-    Collections.sort(partKeys,\r\n-      (PartitionKey key1, PartitionKey key2) -> {\r\n-        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n-      });\r\n-\r\n-    int ii = 0;\r\n-    int keyIndex = 0;\r\n-    // For each partition, we generate a update split.\r\n-    // Although the split is empty for partitions those without any update data,\r\n-    // we still need to generate a update split to update the clock info on ps.\r\n-    while (ii < indexes.length || keyIndex < partKeys.size()) {\r\n-      int length = 0;\r\n-      long endOffset = partKeys.get(keyIndex).getEndCol();\r\n-      while (ii < indexes.length && indexes[ii] < endOffset) {\r\n-        ii++;\r\n-        length++;\r\n-      }\r\n-\r\n-      int [] split = new int[length];\r\n-      System.arraycopy(indexes, ii - length, split, 0, length);\r\n-      ret.put(partKeys.get(keyIndex), split);\r\n-      keyIndex++;\r\n-    }\r\n-    return ret;\r\n-  }\r\n-\r\n-  public int getRowId() {\r\n-    return rowId;\r\n-  }\r\n-\r\n-  public int size() {\r\n-    if(indexes != null) {\r\n-      return indexes.length;\r\n-    } else {\r\n-      int counter = 0;\r\n-      for(int[] partIndexes : partKeyToIndexesMap.values()) {\r\n-        counter += partIndexes.length;\r\n-      }\r\n-\r\n-      return counter;\r\n-    }\r\n-  }\r\n-\r\n-  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\r\n-    return partKeyToIndexesMap;\r\n-  }\r\n-}\r\n+/*\n+ * Tencent is pleased to support the open source community by making Angel available.\n+ *\n+ * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.\n+ *\n+ * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * https://opensource.org/licenses/BSD-3-Clause\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\n+import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\n+import com.tencent.angel.psagent.PSAgentContext;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.util.*;\n+\n+/**\n+ * The GetParam of IndexGetFunc\n+ */\n+public class IndexGetParam extends GetParam {\n+  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\n+  private int rowId;\n+  private int[] indexes;\n+  private Map<PartitionKey, int[]> partKeyToIndexesMap;\n+\n+  /**\n+   * @param matId matrixID\n+   * @param rowId rowID\n+   * @param indexes specified index\n+   */\n+  public IndexGetParam(int matId, int rowId, int[] indexes) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.indexes = indexes;\n+  }\n+\n+  /**\n+   * @param matId matrixID\n+   * @param rowId rowID\n+   * @param partKeyToIndexesMap specified index\n+   */\n+  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.partKeyToIndexesMap = partKeyToIndexesMap;\n+  }\n+\n+  /**\n+   * Find the used partition of the specifiex index array of this matrix this row\n+   * @return partition get param of specified index\n+   */\n+  @Override\n+  public List<PartitionGetParam> split() {\n+    long startTs = System.currentTimeMillis();\n+    if(partKeyToIndexesMap == null) {\n+      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\n+        .getPartitions(matrixId, rowId), indexes);\n+      indexes = null;\n+    }\n+\n+    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\n+    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\n+      if(entry.getValue().length > 0) {\n+        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\n+      }\n+    } LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\n+    return partParams;\n+  }\n+\n+  /**\n+   * Find the used partition of the specifiex index array of this matrix this row\n+   * @param partKeys all partitions of this matrix and this row\n+   * @param indexes specified index array\n+   * @return the used partition of the specifiex index array of this matrix this row\n+   */\n+  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\n+    // Sort the parts by partitionId\n+    Arrays.sort(indexes);\n+\n+    HashMap<PartitionKey, int[]> ret = new HashMap<>();\n+\n+    // Sort partition keys use start column index\n+    Collections.sort(partKeys,\n+      (PartitionKey key1, PartitionKey key2) -> {\n+        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\n+      });\n+\n+    int ii = 0;\n+    int keyIndex = 0;\n+    // For each partition, we generate a update split.\n+    // Although the split is empty for partitions those without any update data,\n+    // we still need to generate a update split to update the clock info on ps.\n+    while (ii < indexes.length || keyIndex < partKeys.size()) {\n+      int length = 0;\n+      long endOffset = partKeys.get(keyIndex).getEndCol();\n+      while (ii < indexes.length && indexes[ii] < endOffset) {\n+        ii++;\n+        length++;\n+      }\n+\n+      int [] split = new int[length];\n+      System.arraycopy(indexes, ii - length, split, 0, length);\n+      ret.put(partKeys.get(keyIndex), split);\n+      keyIndex++;\n+    }\n+    return ret;\n+  }\n+\n+  public int getRowId() {\n+    return rowId;\n+  }\n+\n+  public int size() {\n+    if(indexes != null) {\n+      return indexes.length;\n+    } else {\n+      int counter = 0;\n+      for(int[] partIndexes : partKeyToIndexesMap.values()) {\n+        counter += partIndexes.length;\n+      }\n+\n+      return counter;\n+    }\n+  }\n+\n+  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\n+    return partKeyToIndexesMap;\n+  }\n+}\n",
            "diff_size": 142
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/244/IndexGetParam.java\nindex b48e2d0589..db6e823c15 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/244/IndexGetParam.java\n@@ -30,113 +30,117 @@ import java.util.*;\n  * The GetParam of IndexGetFunc\r\n  */\r\n public class IndexGetParam extends GetParam {\r\n-  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\r\n-  private int rowId;\r\n-  private int[] indexes;\r\n-  private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param indexes specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, int[] indexes) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.indexes = indexes;\r\n-  }\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param partKeyToIndexesMap specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.partKeyToIndexesMap = partKeyToIndexesMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @return partition get param of specified index\r\n-   */\r\n-  @Override\r\n-  public List<PartitionGetParam> split() {\r\n-    long startTs = System.currentTimeMillis();\r\n-    if(partKeyToIndexesMap == null) {\r\n-      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n-        .getPartitions(matrixId, rowId), indexes);\r\n-      indexes = null;\r\n+    private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\r\n+    private int rowId;\r\n+    private int[] indexes;\r\n+    private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n+\r\n+    /**\r\n+     * @param matId   matrixID\r\n+     * @param rowId   rowID\r\n+     * @param indexes specified index\r\n+     */\r\n+    public IndexGetParam(int matId, int rowId, int[] indexes) {\r\n+        super(matId);\r\n+        this.rowId = rowId;\r\n+        this.indexes = indexes;\r\n     }\r\n \r\n-    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n-    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n-      if(entry.getValue().length > 0) {\r\n-        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\r\n-      }\r\n+    /**\r\n+     * @param matId               matrixID\r\n+     * @param rowId               rowID\r\n+     * @param partKeyToIndexesMap specified index\r\n+     */\r\n+    public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\r\n+        super(matId);\r\n+        this.rowId = rowId;\r\n+        this.partKeyToIndexesMap = partKeyToIndexesMap;\r\n     }\r\n-    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\r\n-    return partParams;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @param partKeys all partitions of this matrix and this row\r\n-   * @param indexes specified index array\r\n-   * @return the used partition of the specifiex index array of this matrix this row\r\n-   */\r\n-  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n-    // Sort the parts by partitionId\r\n-    Arrays.sort(indexes);\r\n-\r\n-    HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n-\r\n-    // Sort partition keys use start column index\r\n-    Collections.sort(partKeys,\r\n-      (PartitionKey key1, PartitionKey key2) -> {\r\n-        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n-      });\r\n-\r\n-    int ii = 0;\r\n-    int keyIndex = 0;\r\n-    // For each partition, we generate a update split.\r\n-    // Although the split is empty for partitions those without any update data,\r\n-    // we still need to generate a update split to update the clock info on ps.\r\n-    while (ii < indexes.length || keyIndex < partKeys.size()) {\r\n-      int length = 0;\r\n-      long endOffset = partKeys.get(keyIndex).getEndCol();\r\n-      while (ii < indexes.length && indexes[ii] < endOffset) {\r\n-        ii++;\r\n-        length++;\r\n-      }\r\n-\r\n-      int [] split = new int[length];\r\n-      System.arraycopy(indexes, ii - length, split, 0, length);\r\n-      ret.put(partKeys.get(keyIndex), split);\r\n-      keyIndex++;\r\n+\r\n+    /**\r\n+     * Find the used partition of the specifiex index array of this matrix this row\r\n+     *\r\n+     * @return partition get param of specified index\r\n+     */\r\n+    @Override\r\n+    public List<PartitionGetParam> split() {\r\n+        long startTs = System.currentTimeMillis();\r\n+        if (partKeyToIndexesMap == null) {\r\n+            partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n+                    .getPartitions(matrixId, rowId), indexes);\r\n+            indexes = null;\r\n+        }\r\n+\r\n+        List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n+        for (Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n+            if (entry.getValue().length > 0) {\r\n+                partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(),\r\n+                        entry.getValue()));\r\n+            }\r\n+        }\r\n+        LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" +\r\n+                \" partParams number=\" + partParams.size());\r\n+        return partParams;\r\n+    }\r\n+\r\n+    /**\r\n+     * Find the used partition of the specifiex index array of this matrix this row\r\n+     *\r\n+     * @param partKeys all partitions of this matrix and this row\r\n+     * @param indexes  specified index array\r\n+     * @return the used partition of the specifiex index array of this matrix this row\r\n+     */\r\n+    private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n+        // Sort the parts by partitionId\r\n+        Arrays.sort(indexes);\r\n+\r\n+        HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n+\r\n+        // Sort partition keys use start column index\r\n+        Collections.sort(partKeys,\r\n+                (PartitionKey key1, PartitionKey key2) -> {\r\n+                    return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n+                });\r\n+\r\n+        int ii = 0;\r\n+        int keyIndex = 0;\r\n+        // For each partition, we generate a update split.\r\n+        // Although the split is empty for partitions those without any update data,\r\n+        // we still need to generate a update split to update the clock info on ps.\r\n+        while (ii < indexes.length || keyIndex < partKeys.size()) {\r\n+            int length = 0;\r\n+            long endOffset = partKeys.get(keyIndex).getEndCol();\r\n+            while (ii < indexes.length && indexes[ii] < endOffset) {\r\n+                ii++;\r\n+                length++;\r\n+            }\r\n+\r\n+            int[] split = new int[length];\r\n+            System.arraycopy(indexes, ii - length, split, 0, length);\r\n+            ret.put(partKeys.get(keyIndex), split);\r\n+            keyIndex++;\r\n+        }\r\n+        return ret;\r\n     }\r\n-    return ret;\r\n-  }\r\n-\r\n-  public int getRowId() {\r\n-    return rowId;\r\n-  }\r\n-\r\n-  public int size() {\r\n-    if(indexes != null) {\r\n-      return indexes.length;\r\n-    } else {\r\n-      int counter = 0;\r\n-      for(int[] partIndexes : partKeyToIndexesMap.values()) {\r\n-        counter += partIndexes.length;\r\n-      }\r\n-\r\n-      return counter;\r\n+\r\n+    public int getRowId() {\r\n+        return rowId;\r\n     }\r\n-  }\r\n \r\n-  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\r\n-    return partKeyToIndexesMap;\r\n-  }\r\n+    public int size() {\r\n+        if (indexes != null) {\r\n+            return indexes.length;\r\n+        } else {\r\n+            int counter = 0;\r\n+            for (int[] partIndexes : partKeyToIndexesMap.values()) {\r\n+                counter += partIndexes.length;\r\n+            }\r\n+\r\n+            return counter;\r\n+        }\r\n+    }\r\n+\r\n+    public Map<PartitionKey, int[]> getPartKeyToIndexesMap() {\r\n+        return partKeyToIndexesMap;\r\n+    }\r\n }\r\n",
            "diff_size": 146
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/244/IndexGetParam.java\nindex b48e2d0589..864e172136 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/244/IndexGetParam.java\n@@ -64,14 +64,14 @@ public class IndexGetParam extends GetParam {\n   @Override\r\n   public List<PartitionGetParam> split() {\r\n     long startTs = System.currentTimeMillis();\r\n-    if(partKeyToIndexesMap == null) {\r\n+    if (partKeyToIndexesMap == null) {\r\n       partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n-        .getPartitions(matrixId, rowId), indexes);\r\n-      indexes = null;\r\n+        .getPartitions(matrixId, rowId), indexes);\n+indexes = null;\r\n     }\r\n \r\n     List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n-    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n+    for (Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n       if(entry.getValue().length > 0) {\r\n         partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\r\n       }\r\n@@ -93,12 +93,10 @@ public class IndexGetParam extends GetParam {\n     HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n \r\n     // Sort partition keys use start column index\r\n-    Collections.sort(partKeys,\r\n-      (PartitionKey key1, PartitionKey key2) -> {\r\n+    Collections.sort(partKeys, (PartitionKey key1, PartitionKey key2) -> {\r\n         return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n-      });\r\n-\r\n-    int ii = 0;\r\n+      });\n+int ii = 0;\r\n     int keyIndex = 0;\r\n     // For each partition, we generate a update split.\r\n     // Although the split is empty for partitions those without any update data,\r\n@@ -111,7 +109,7 @@ public class IndexGetParam extends GetParam {\n         length++;\r\n       }\r\n \r\n-      int [] split = new int[length];\r\n+      int[] split = new int[length];\r\n       System.arraycopy(indexes, ii - length, split, 0, length);\r\n       ret.put(partKeys.get(keyIndex), split);\r\n       keyIndex++;\r\n@@ -128,7 +126,7 @@ public class IndexGetParam extends GetParam {\n       return indexes.length;\r\n     } else {\r\n       int counter = 0;\r\n-      for(int[] partIndexes : partKeyToIndexesMap.values()) {\r\n+      for (int[] partIndexes : partKeyToIndexesMap.values()) {\r\n         counter += partIndexes.length;\r\n       }\r\n \r\n@@ -136,7 +134,7 @@ public class IndexGetParam extends GetParam {\n     }\r\n   }\r\n \r\n-  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\r\n+  public Map<PartitionKey, int[]> getPartKeyToIndexesMap() {\r\n     return partKeyToIndexesMap;\r\n   }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 13
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "38",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 44.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "50",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 56.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 67.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "71",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "81",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "85",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 92.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/244/IndexGetParam.java\nindex b48e2d0589..f55955c649 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/244/IndexGetParam.java\n@@ -15,128 +15,130 @@\n  *\r\n  */\r\n \r\n-package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-import org.apache.commons.logging.Log;\r\n-import org.apache.commons.logging.LogFactory;\r\n-\r\n+package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\n+import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\n+import com.tencent.angel.psagent.PSAgentContext;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n import java.util.*;\r\n \r\n /**\r\n  * The GetParam of IndexGetFunc\r\n- */\r\n-public class IndexGetParam extends GetParam {\r\n-  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\r\n-  private int rowId;\r\n-  private int[] indexes;\r\n-  private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n+ */\n+\n+public class IndexGetParam extends GetParam {\n+    private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\n+    private int rowId;\n+    private int[] indexes;\n+    private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n \r\n   /**\r\n    * @param matId matrixID\r\n    * @param rowId rowID\r\n    * @param indexes specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, int[] indexes) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.indexes = indexes;\r\n-  }\r\n+   */\n+\n+    public IndexGetParam(int matId, int rowId, int[] indexes) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.indexes = indexes;\n+    }\r\n \r\n   /**\r\n    * @param matId matrixID\r\n    * @param rowId rowID\r\n    * @param partKeyToIndexesMap specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.partKeyToIndexesMap = partKeyToIndexesMap;\r\n-  }\r\n+   */\n+\n+    public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.partKeyToIndexesMap = partKeyToIndexesMap;\n+    }\r\n \r\n   /**\r\n    * Find the used partition of the specifiex index array of this matrix this row\r\n    * @return partition get param of specified index\r\n-   */\r\n-  @Override\r\n-  public List<PartitionGetParam> split() {\r\n-    long startTs = System.currentTimeMillis();\r\n-    if(partKeyToIndexesMap == null) {\r\n-      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n-        .getPartitions(matrixId, rowId), indexes);\r\n-      indexes = null;\r\n-    }\r\n-\r\n-    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n-    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n-      if(entry.getValue().length > 0) {\r\n-        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\r\n-      }\r\n+   */\n+\n+    @Override\n+    public List<PartitionGetParam> split() {\n+    long startTs = System.currentTimeMillis();\n+    if (partKeyToIndexesMap == null) {\n+        partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager().getPartitions(matrixId, rowId), indexes);\n+        indexes = null;\n+    }\n+\n+    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\n+    for (Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\n+        if (entry.getValue().length > 0) {\n+        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\n+        }\n+    }\n+    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\n+    return partParams;\n     }\r\n-    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\r\n-    return partParams;\r\n-  }\r\n \r\n   /**\r\n    * Find the used partition of the specifiex index array of this matrix this row\r\n    * @param partKeys all partitions of this matrix and this row\r\n    * @param indexes specified index array\r\n    * @return the used partition of the specifiex index array of this matrix this row\r\n-   */\r\n-  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n-    // Sort the parts by partitionId\r\n-    Arrays.sort(indexes);\r\n-\r\n+   */\n+\n+    private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n+    // Sort the parts by partitionId\n+    Arrays.sort(indexes);\n     HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n \r\n-    // Sort partition keys use start column index\r\n-    Collections.sort(partKeys,\r\n-      (PartitionKey key1, PartitionKey key2) -> {\r\n-        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n-      });\r\n-\r\n-    int ii = 0;\r\n+    // Sort partition keys use start column index\n+    Collections.sort(partKeys,\n+                     (PartitionKey key1, PartitionKey key2)-> {\n+        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\n+                     });\n+\n+    int ii = 0;\n     int keyIndex = 0;\r\n     // For each partition, we generate a update split.\r\n     // Although the split is empty for partitions those without any update data,\r\n-    // we still need to generate a update split to update the clock info on ps.\r\n-    while (ii < indexes.length || keyIndex < partKeys.size()) {\r\n-      int length = 0;\r\n-      long endOffset = partKeys.get(keyIndex).getEndCol();\r\n-      while (ii < indexes.length && indexes[ii] < endOffset) {\r\n-        ii++;\r\n-        length++;\r\n-      }\r\n-\r\n-      int [] split = new int[length];\r\n-      System.arraycopy(indexes, ii - length, split, 0, length);\r\n-      ret.put(partKeys.get(keyIndex), split);\r\n-      keyIndex++;\r\n-    }\r\n-    return ret;\r\n-  }\r\n-\r\n-  public int getRowId() {\r\n-    return rowId;\r\n-  }\r\n-\r\n-  public int size() {\r\n-    if(indexes != null) {\r\n-      return indexes.length;\r\n-    } else {\r\n-      int counter = 0;\r\n-      for(int[] partIndexes : partKeyToIndexesMap.values()) {\r\n-        counter += partIndexes.length;\r\n-      }\r\n-\r\n-      return counter;\r\n-    }\r\n-  }\r\n-\r\n-  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\r\n-    return partKeyToIndexesMap;\r\n-  }\r\n-}\r\n+    // we still need to generate a update split to update the clock info on ps.\n+    while (ii < indexes.length || keyIndex < partKeys.size()) {\n+        int length = 0;\n+        long endOffset = partKeys.get(keyIndex).getEndCol();\n+        while (ii < indexes.length && indexes[ii] < endOffset) {\n+                                                                  ii++;\n+                                                                  length++;\n+        }\n+\n+        int[] split = new int[length];\n+        System.arraycopy(indexes, ii - length, split, 0, length);\n+        ret.put(partKeys.get(keyIndex), split);\n+        keyIndex++;\n+    }\n+    return ret;\n+    }\n+\n+    public int getRowId() {\n+    return rowId;\n+    }\n+\n+    public int size() {\n+    if (indexes != null) {\n+        return indexes.length;\n+    } else {\n+      int counter = 0;\n+      for (int[] partIndexes : partKeyToIndexesMap.values()) {\n+               counter += partIndexes.length;\n+      }\n+      return counter;\n+    }\n+    }\n+\n+    public Map<PartitionKey, int[]> getPartKeyToIndexesMap() {\n+    return partKeyToIndexesMap;\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 101
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_random/244/IndexGetParam.java\nindex b48e2d0589..1f6d6c05d0 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_random/244/IndexGetParam.java\n@@ -1,142 +1,143 @@\n-/*\r\n- * Tencent is pleased to support the open source community by making Angel available.\r\n- *\r\n- * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.\r\n- *\r\n- * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- *\r\n- * https://opensource.org/licenses/BSD-3-Clause\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n- * or implied. See the License for the specific language governing permissions and limitations under\r\n- * the License.\r\n- *\r\n- */\r\n-\r\n-package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-import org.apache.commons.logging.Log;\r\n-import org.apache.commons.logging.LogFactory;\r\n-\r\n-import java.util.*;\r\n-\r\n-/**\r\n- * The GetParam of IndexGetFunc\r\n- */\r\n-public class IndexGetParam extends GetParam {\r\n-  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\r\n-  private int rowId;\r\n-  private int[] indexes;\r\n-  private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param indexes specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, int[] indexes) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.indexes = indexes;\r\n-  }\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param partKeyToIndexesMap specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.partKeyToIndexesMap = partKeyToIndexesMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @return partition get param of specified index\r\n-   */\r\n-  @Override\r\n-  public List<PartitionGetParam> split() {\r\n-    long startTs = System.currentTimeMillis();\r\n-    if(partKeyToIndexesMap == null) {\r\n-      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n-        .getPartitions(matrixId, rowId), indexes);\r\n-      indexes = null;\r\n-    }\r\n-\r\n-    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n-    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n-      if(entry.getValue().length > 0) {\r\n-        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\r\n-      }\r\n-    }\r\n-    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\r\n-    return partParams;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @param partKeys all partitions of this matrix and this row\r\n-   * @param indexes specified index array\r\n-   * @return the used partition of the specifiex index array of this matrix this row\r\n-   */\r\n-  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n-    // Sort the parts by partitionId\r\n-    Arrays.sort(indexes);\r\n-\r\n-    HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n-\r\n-    // Sort partition keys use start column index\r\n-    Collections.sort(partKeys,\r\n-      (PartitionKey key1, PartitionKey key2) -> {\r\n-        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n-      });\r\n-\r\n-    int ii = 0;\r\n-    int keyIndex = 0;\r\n-    // For each partition, we generate a update split.\r\n-    // Although the split is empty for partitions those without any update data,\r\n-    // we still need to generate a update split to update the clock info on ps.\r\n-    while (ii < indexes.length || keyIndex < partKeys.size()) {\r\n-      int length = 0;\r\n-      long endOffset = partKeys.get(keyIndex).getEndCol();\r\n-      while (ii < indexes.length && indexes[ii] < endOffset) {\r\n-        ii++;\r\n-        length++;\r\n-      }\r\n-\r\n-      int [] split = new int[length];\r\n-      System.arraycopy(indexes, ii - length, split, 0, length);\r\n-      ret.put(partKeys.get(keyIndex), split);\r\n-      keyIndex++;\r\n-    }\r\n-    return ret;\r\n-  }\r\n-\r\n-  public int getRowId() {\r\n-    return rowId;\r\n-  }\r\n-\r\n-  public int size() {\r\n-    if(indexes != null) {\r\n-      return indexes.length;\r\n-    } else {\r\n-      int counter = 0;\r\n-      for(int[] partIndexes : partKeyToIndexesMap.values()) {\r\n-        counter += partIndexes.length;\r\n-      }\r\n-\r\n-      return counter;\r\n-    }\r\n-  }\r\n-\r\n-  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\r\n-    return partKeyToIndexesMap;\r\n-  }\r\n-}\r\n+/*\n+ * Tencent is pleased to support the open source community by making Angel available.\n+ *\n+ * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.\n+ *\n+ * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * https://opensource.org/licenses/BSD-3-Clause\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\n+import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\n+import com.tencent.angel.psagent.PSAgentContext;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.util.*;\n+\n+/**\n+ * The GetParam of IndexGetFunc\n+ */\n+public class IndexGetParam extends GetParam {\n+  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\n+  private int rowId;\n+  private int[] indexes;\n+  private Map<PartitionKey, int[]> partKeyToIndexesMap;\n+\n+  /**\n+   * @param matId matrixID\n+   * @param rowId rowID\n+   * @param indexes specified index\n+   */\n+  public IndexGetParam(int matId, int rowId, int[] indexes) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.indexes = indexes;\n+  }\n+\n+  /**\n+   * @param matId matrixID\n+   * @param rowId rowID\n+   * @param partKeyToIndexesMap specified index\n+   */\n+  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.partKeyToIndexesMap = partKeyToIndexesMap;\n+  }\n+\n+  /**\n+   * Find the used partition of the specifiex index array of this matrix this row\n+   * @return partition get param of specified index\n+   */\n+  @Override\n+  public List<PartitionGetParam> split() {\n+    long startTs = System.currentTimeMillis();\n+    if(partKeyToIndexesMap == null) {\n+      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\n+        .getPartitions(matrixId, rowId), indexes);\n+      indexes = null;\n+    }\n+\n+    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\n+    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\n+      if(entry.getValue().length > 0) {\n+        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\n+      }\n+    }\n+    LOG.debug(\"split use time=\" + (System.currentTimeMillis()-startTs)+ \" ms \"+\" partParams number=\"+partParams.size(\n+    ));\n+    return partParams;\n+  }\n+\n+  /**\n+   * Find the used partition of the specifiex index array of this matrix this row\n+   * @param partKeys all partitions of this matrix and this row\n+   * @param indexes specified index array\n+   * @return the used partition of the specifiex index array of this matrix this row\n+   */\n+  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\n+    // Sort the parts by partitionId\n+    Arrays.sort(indexes);\n+\n+    HashMap<PartitionKey, int[]> ret = new HashMap<>();\n+\n+    // Sort partition keys use start column index\n+    Collections.sort(partKeys,\n+      (PartitionKey key1, PartitionKey key2) -> {\n+        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\n+      });\n+\n+    int ii = 0;\n+    int keyIndex = 0;\n+    // For each partition, we generate a update split.\n+    // Although the split is empty for partitions those without any update data,\n+    // we still need to generate a update split to update the clock info on ps.\n+    while (ii < indexes.length || keyIndex < partKeys.size()) {\n+      int length = 0;\n+      long endOffset = partKeys.get(keyIndex).getEndCol();\n+      while (ii < indexes.length && indexes[ii] < endOffset) {\n+        ii++;\n+        length++;\n+      }\n+\n+      int [] split = new int[length];\n+      System.arraycopy(indexes, ii - length, split, 0, length);\n+      ret.put(partKeys.get(keyIndex), split);\n+      keyIndex++;\n+    }\n+    return ret;\n+  }\n+\n+  public int getRowId() {\n+    return rowId;\n+  }\n+\n+  public int size() {\n+    if(indexes != null) {\n+      return indexes.length;\n+    } else {\n+      int counter = 0;\n+      for(int[] partIndexes : partKeyToIndexesMap.values()) {\n+        counter += partIndexes.length;\n+      }\n+\n+      return counter;\n+    }\n+  }\n+\n+  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\n+    return partKeyToIndexesMap;\n+  }\n+}\n",
            "diff_size": 143
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/244/IndexGetParam.java\nindex b48e2d0589..5cbe8ec672 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/244/IndexGetParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/244/IndexGetParam.java\n@@ -1,142 +1,141 @@\n-/*\r\n- * Tencent is pleased to support the open source community by making Angel available.\r\n- *\r\n- * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.\r\n- *\r\n- * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- *\r\n- * https://opensource.org/licenses/BSD-3-Clause\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n- * or implied. See the License for the specific language governing permissions and limitations under\r\n- * the License.\r\n- *\r\n- */\r\n-\r\n-package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\r\n-import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-import org.apache.commons.logging.Log;\r\n-import org.apache.commons.logging.LogFactory;\r\n-\r\n-import java.util.*;\r\n-\r\n-/**\r\n- * The GetParam of IndexGetFunc\r\n- */\r\n-public class IndexGetParam extends GetParam {\r\n-  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\r\n-  private int rowId;\r\n-  private int[] indexes;\r\n-  private Map<PartitionKey, int[]> partKeyToIndexesMap;\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param indexes specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, int[] indexes) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.indexes = indexes;\r\n-  }\r\n-\r\n-  /**\r\n-   * @param matId matrixID\r\n-   * @param rowId rowID\r\n-   * @param partKeyToIndexesMap specified index\r\n-   */\r\n-  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\r\n-    super(matId);\r\n-    this.rowId = rowId;\r\n-    this.partKeyToIndexesMap = partKeyToIndexesMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @return partition get param of specified index\r\n-   */\r\n-  @Override\r\n-  public List<PartitionGetParam> split() {\r\n-    long startTs = System.currentTimeMillis();\r\n-    if(partKeyToIndexesMap == null) {\r\n-      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\r\n-        .getPartitions(matrixId, rowId), indexes);\r\n-      indexes = null;\r\n-    }\r\n-\r\n-    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\r\n-    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\r\n-      if(entry.getValue().length > 0) {\r\n-        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\r\n-      }\r\n-    }\r\n-    LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\r\n-    return partParams;\r\n-  }\r\n-\r\n-  /**\r\n-   * Find the used partition of the specifiex index array of this matrix this row\r\n-   * @param partKeys all partitions of this matrix and this row\r\n-   * @param indexes specified index array\r\n-   * @return the used partition of the specifiex index array of this matrix this row\r\n-   */\r\n-  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\r\n-    // Sort the parts by partitionId\r\n-    Arrays.sort(indexes);\r\n-\r\n-    HashMap<PartitionKey, int[]> ret = new HashMap<>();\r\n-\r\n-    // Sort partition keys use start column index\r\n-    Collections.sort(partKeys,\r\n-      (PartitionKey key1, PartitionKey key2) -> {\r\n-        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\r\n-      });\r\n-\r\n-    int ii = 0;\r\n-    int keyIndex = 0;\r\n-    // For each partition, we generate a update split.\r\n-    // Although the split is empty for partitions those without any update data,\r\n-    // we still need to generate a update split to update the clock info on ps.\r\n-    while (ii < indexes.length || keyIndex < partKeys.size()) {\r\n-      int length = 0;\r\n-      long endOffset = partKeys.get(keyIndex).getEndCol();\r\n-      while (ii < indexes.length && indexes[ii] < endOffset) {\r\n-        ii++;\r\n-        length++;\r\n-      }\r\n-\r\n-      int [] split = new int[length];\r\n-      System.arraycopy(indexes, ii - length, split, 0, length);\r\n-      ret.put(partKeys.get(keyIndex), split);\r\n-      keyIndex++;\r\n-    }\r\n-    return ret;\r\n-  }\r\n-\r\n-  public int getRowId() {\r\n-    return rowId;\r\n-  }\r\n-\r\n-  public int size() {\r\n-    if(indexes != null) {\r\n-      return indexes.length;\r\n-    } else {\r\n-      int counter = 0;\r\n-      for(int[] partIndexes : partKeyToIndexesMap.values()) {\r\n-        counter += partIndexes.length;\r\n-      }\r\n-\r\n-      return counter;\r\n-    }\r\n-  }\r\n-\r\n-  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\r\n-    return partKeyToIndexesMap;\r\n-  }\r\n-}\r\n+/*\n+ * Tencent is pleased to support the open source community by making Angel available.\n+ *\n+ * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.\n+ *\n+ * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * https://opensource.org/licenses/BSD-3-Clause\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package com.tencent.angel.ml.matrix.psf.get.enhance.indexed;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.psf.get.base.GetParam;\n+import com.tencent.angel.ml.matrix.psf.get.base.PartitionGetParam;\n+import com.tencent.angel.psagent.PSAgentContext;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import java.util.*;\n+\n+/**\n+ * The GetParam of IndexGetFunc\n+ */\n+public class IndexGetParam extends GetParam {\n+  private static final Log LOG = LogFactory.getLog(IndexGetParam.class);\n+  private int rowId;\n+  private int[] indexes;\n+  private Map<PartitionKey, int[]> partKeyToIndexesMap;\n+\n+  /**\n+   * @param matId matrixID\n+   * @param rowId rowID\n+   * @param indexes specified index\n+   */\n+  public IndexGetParam(int matId, int rowId, int[] indexes) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.indexes = indexes;\n+  }\n+\n+  /**\n+   * @param matId matrixID\n+   * @param rowId rowID\n+   * @param partKeyToIndexesMap specified index\n+   */\n+  public IndexGetParam(int matId, int rowId, Map<PartitionKey, int[]> partKeyToIndexesMap) {\n+    super(matId);\n+    this.rowId = rowId;\n+    this.partKeyToIndexesMap = partKeyToIndexesMap;\n+  }\n+\n+  /**\n+   * Find the used partition of the specifiex index array of this matrix this row\n+   * @return partition get param of specified index\n+   */\n+  @Override\n+  public List<PartitionGetParam> split() {\n+    long startTs = System.currentTimeMillis();\n+    if(partKeyToIndexesMap == null) {\n+      partKeyToIndexesMap = split(PSAgentContext.get().getMatrixMetaManager()\n+        .getPartitions(matrixId, rowId), indexes);\n+      indexes = null;\n+    }\n+\n+    List<PartitionGetParam> partParams = new ArrayList<>(partKeyToIndexesMap.size());\n+    for(Map.Entry<PartitionKey, int[]> entry : partKeyToIndexesMap.entrySet()) {\n+      if(entry.getValue().length > 0) {\n+        partParams.add(new IndexPartGetParam(matrixId, rowId, entry.getKey(), entry.getValue()));\n+      }\n+    } LOG.debug(\"split use time=\" + (System.currentTimeMillis() - startTs) + \" ms \" + \" partParams number=\" + partParams.size());\n+    return partParams;\n+  }\n+\n+  /**\n+   * Find the used partition of the specifiex index array of this matrix this row\n+   * @param partKeys all partitions of this matrix and this row\n+   * @param indexes specified index array\n+   * @return the used partition of the specifiex index array of this matrix this row\n+   */\n+  private Map<PartitionKey, int[]> split(List<PartitionKey> partKeys, int[] indexes) {\n+    // Sort the parts by partitionId\n+    Arrays.sort(indexes);\n+\n+    HashMap<PartitionKey, int[]> ret = new HashMap<>();\n+\n+    // Sort partition keys use start column index\n+    Collections.sort(partKeys,\n+      (PartitionKey key1, PartitionKey key2) -> {\n+        return key1.getStartCol() < key2.getStartCol() ? -1 : 1;\n+      });\n+\n+    int ii = 0;\n+    int keyIndex = 0;\n+    // For each partition, we generate a update split.\n+    // Although the split is empty for partitions those without any update data,\n+    // we still need to generate a update split to update the clock info on ps.\n+    while (ii < indexes.length || keyIndex < partKeys.size()) {\n+      int length = 0;\n+      long endOffset = partKeys.get(keyIndex).getEndCol();\n+      while (ii < indexes.length && indexes[ii] < endOffset) {\n+        ii++;\n+        length++;\n+      }\n+\n+      int [] split = new int[length];\n+      System.arraycopy(indexes, ii - length, split, 0, length);\n+      ret.put(partKeys.get(keyIndex), split);\n+      keyIndex++;\n+    }\n+    return ret;\n+  }\n+\n+  public int getRowId() {\n+    return rowId;\n+  }\n+\n+  public int size() {\n+    if(indexes != null) {\n+      return indexes.length;\n+    } else {\n+      int counter = 0;\n+      for(int[] partIndexes : partKeyToIndexesMap.values()) {\n+        counter += partIndexes.length;\n+      }\n+\n+      return counter;\n+    }\n+  }\n+\n+  public Map<PartitionKey,int[]> getPartKeyToIndexesMap() {\n+    return partKeyToIndexesMap;\n+  }\n+}\n",
            "diff_size": 142
        }
    ]
}