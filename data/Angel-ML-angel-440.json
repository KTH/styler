{
    "error_id": "440",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "883",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "888",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "893",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "903",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "908",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "913",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "918",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "963",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "968",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "973",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "978",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "983",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "988",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "993",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "998",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/440/MFactory.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/440/MFactory.java\nindex f02aef3418..896ee52e06 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/440/MFactory.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/440/MFactory.java\n@@ -58,958 +58,984 @@ import java.util.HashMap;\n \n public class MFactory {\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock,\n-      CompIntDoubleVector[] rows) {\n-    return new RBCompIntDoubleMatrix(matrixId, clock, rows);\n-  }\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock,\n+                                                              CompIntDoubleVector[] rows) {\n+        return new RBCompIntDoubleMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(CompIntDoubleVector[] rows) {\n+        return new RBCompIntDoubleMatrix(rows);\n+    }\n+\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                              int numCols, int subDim) {\n+        return new RBCompIntDoubleMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols,\n+                                                              int subDim) {\n+        return new RBCompIntDoubleMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                              int numCols, int subDim,\n+                                                              StorageType storageType) {\n+        CompIntDoubleVector[] rows = new CompIntDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] =\n+                    VFactory.compIntDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntDoubleMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim,\n+                                                              StorageType storageType) {\n+        CompIntDoubleVector[] rows = new CompIntDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntDoubleVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntDoubleMatrix(rows);\n+    }\n+\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock,\n+                                                            CompIntFloatVector[] rows) {\n+        return new RBCompIntFloatMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(CompIntFloatVector[] rows) {\n+        return new RBCompIntFloatMatrix(rows);\n+    }\n+\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows,\n+                                                            int numCols, int subDim) {\n+        return new RBCompIntFloatMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim) {\n+        return new RBCompIntFloatMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows,\n+                                                            int numCols, int subDim,\n+                                                            StorageType storageType) {\n+        CompIntFloatVector[] rows = new CompIntFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntFloatMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim,\n+                                                            StorageType storageType) {\n+        CompIntFloatVector[] rows = new CompIntFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntFloatVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntFloatMatrix(rows);\n+    }\n+\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock,\n+                                                          CompIntLongVector[] rows) {\n+        return new RBCompIntLongMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(CompIntLongVector[] rows) {\n+        return new RBCompIntLongMatrix(rows);\n+    }\n+\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows,\n+                                                          int numCols, int subDim) {\n+        return new RBCompIntLongMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim) {\n+        return new RBCompIntLongMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows,\n+                                                          int numCols, int subDim,\n+                                                          StorageType storageType) {\n+        CompIntLongVector[] rows = new CompIntLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntLongVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntLongMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim,\n+                                                          StorageType storageType) {\n+        CompIntLongVector[] rows = new CompIntLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntLongVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntLongMatrix(rows);\n+    }\n+\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock,\n+                                                        CompIntIntVector[] rows) {\n+        return new RBCompIntIntMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(CompIntIntVector[] rows) {\n+        return new RBCompIntIntMatrix(rows);\n+    }\n+\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows,\n+                                                        int numCols, int subDim) {\n+        return new RBCompIntIntMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim) {\n+        return new RBCompIntIntMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows,\n+                                                        int numCols, int subDim,\n+                                                        StorageType storageType) {\n+        CompIntIntVector[] rows = new CompIntIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntIntVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntIntMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim,\n+                                                        StorageType storageType) {\n+        CompIntIntVector[] rows = new CompIntIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compIntIntVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompIntIntMatrix(rows);\n+    }\n+\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock,\n+                                                                CompLongDoubleVector[] rows) {\n+        return new RBCompLongDoubleMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(CompLongDoubleVector[] rows) {\n+        return new RBCompLongDoubleMatrix(rows);\n+    }\n+\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock,\n+                                                                int numRows,\n+                                                                long numCols, long subDim) {\n+        return new RBCompLongDoubleMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols,\n+                                                                long subDim) {\n+        return new RBCompLongDoubleMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock,\n+                                                                int numRows,\n+                                                                long numCols, long subDim,\n+                                                                StorageType storageType) {\n+        CompLongDoubleVector[] rows = new CompLongDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] =\n+                    VFactory.compLongDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongDoubleMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols,\n+                                                                long subDim,\n+                                                                StorageType storageType) {\n+        CompLongDoubleVector[] rows = new CompLongDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compLongDoubleVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongDoubleMatrix(rows);\n+    }\n+\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock,\n+                                                              CompLongFloatVector[] rows) {\n+        return new RBCompLongFloatMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(CompLongFloatVector[] rows) {\n+        return new RBCompLongFloatMatrix(rows);\n+    }\n+\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows,\n+                                                              long numCols, long subDim) {\n+        return new RBCompLongFloatMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols,\n+                                                              long subDim) {\n+        return new RBCompLongFloatMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows,\n+                                                              long numCols, long subDim,\n+                                                              StorageType storageType) {\n+        CompLongFloatVector[] rows = new CompLongFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] =\n+                    VFactory.compLongFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongFloatMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols,\n+                                                              long subDim,\n+                                                              StorageType storageType) {\n+        CompLongFloatVector[] rows = new CompLongFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compLongFloatVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongFloatMatrix(rows);\n+    }\n+\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock,\n+                                                            CompLongLongVector[] rows) {\n+        return new RBCompLongLongMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(CompLongLongVector[] rows) {\n+        return new RBCompLongLongMatrix(rows);\n+    }\n+\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows,\n+                                                            long numCols, long subDim) {\n+        return new RBCompLongLongMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols,\n+                                                            long subDim) {\n+        return new RBCompLongLongMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows,\n+                                                            long numCols, long subDim,\n+                                                            StorageType storageType) {\n+        CompLongLongVector[] rows = new CompLongLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compLongLongVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongLongMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim,\n+                                                            StorageType storageType) {\n+        CompLongLongVector[] rows = new CompLongLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compLongLongVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongLongMatrix(rows);\n+    }\n+\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock,\n+                                                          CompLongIntVector[] rows) {\n+        return new RBCompLongIntMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(CompLongIntVector[] rows) {\n+        return new RBCompLongIntMatrix(rows);\n+    }\n+\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows,\n+                                                          long numCols, long subDim) {\n+        return new RBCompLongIntMatrix(matrixId, clock, numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim) {\n+        return new RBCompLongIntMatrix(numRows, numCols, subDim);\n+    }\n+\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows,\n+                                                          long numCols, long subDim,\n+                                                          StorageType storageType) {\n+        CompLongIntVector[] rows = new CompLongIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compLongIntVector(matrixId, i, clock, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongIntMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim,\n+                                                          StorageType storageType) {\n+        CompLongIntVector[] rows = new CompLongIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            rows[i] = VFactory.compLongIntVector(0, i, 0, numCols, subDim, storageType);\n+        }\n+\n+        return new RBCompLongIntMatrix(rows);\n+    }\n+\n+    //---------------------------------------------------\n+\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock,\n+                                                      IntDoubleVector[] rows) {\n+        return new RBIntDoubleMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(CompIntDoubleVector[] rows) {\n-    return new RBCompIntDoubleMatrix(rows);\n-  }\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                      int numCols) {\n+        return new RBIntDoubleMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n-    return new RBCompIntDoubleMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                      int numCols, StorageType storageType) {\n+        IntDoubleVector[] rows = new IntDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseDoubleVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseDoubleVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedDoubleVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntDoubleMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim) {\n-    return new RBCompIntDoubleMatrix(numRows, numCols, subDim);\n-  }\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols,\n+                                                      StorageType storageType) {\n+        IntDoubleVector[] rows = new IntDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseDoubleVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseDoubleVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedDoubleVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntDoubleMatrix(rows);\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n-    CompIntDoubleVector[] rows = new CompIntDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(IntDoubleVector[] rows) {\n+        return new RBIntDoubleMatrix(rows);\n     }\n \n-    return new RBCompIntDoubleMatrix(matrixId, clock, rows);\n-  }\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols) {\n+        return new RBIntDoubleMatrix(numRows, numCols);\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n-    CompIntDoubleVector[] rows = new CompIntDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntDoubleVector(0, i, 0, numCols, subDim, storageType);\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock,\n+                                                    IntFloatVector[] rows) {\n+        return new RBIntFloatMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompIntDoubleMatrix(rows);\n-  }\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows,\n+                                                    int numCols) {\n+        return new RBIntFloatMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock,\n-      CompIntFloatVector[] rows) {\n-    return new RBCompIntFloatMatrix(matrixId, clock, rows);\n-  }\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows,\n+                                                    int numCols,\n+                                                    StorageType storageType) {\n+        IntFloatVector[] rows = new IntFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseFloatVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseFloatVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedFloatVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntFloatMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(CompIntFloatVector[] rows) {\n-    return new RBCompIntFloatMatrix(rows);\n-  }\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols,\n+                                                    StorageType storageType) {\n+        IntFloatVector[] rows = new IntFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseFloatVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseFloatVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedFloatVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntFloatMatrix(rows);\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n-    return new RBCompIntFloatMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    public static RBIntFloatMatrix rbIntFloatMatrix(IntFloatVector[] rows) {\n+        return new RBIntFloatMatrix(rows);\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim) {\n-    return new RBCompIntFloatMatrix(numRows, numCols, subDim);\n-  }\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols) {\n+        return new RBIntFloatMatrix(numRows, numCols);\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n-    CompIntFloatVector[] rows = new CompIntFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n+    public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, IntLongVector[] rows) {\n+        return new RBIntLongMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompIntFloatMatrix(matrixId, clock, rows);\n-  }\n+    public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows,\n+                                                  int numCols) {\n+        return new RBIntLongMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n-    CompIntFloatVector[] rows = new CompIntFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntFloatVector(0, i, 0, numCols, subDim, storageType);\n+    public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols,\n+                                                  StorageType storageType) {\n+        IntLongVector[] rows = new IntLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseLongVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntLongMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompIntFloatMatrix(rows);\n-  }\n+    public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols,\n+                                                  StorageType storageType) {\n+        IntLongVector[] rows = new IntLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseLongVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntLongMatrix(rows);\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock,\n-      CompIntLongVector[] rows) {\n-    return new RBCompIntLongMatrix(matrixId, clock, rows);\n-  }\n+    public static RBIntLongMatrix rbIntLongMatrix(IntLongVector[] rows) {\n+        return new RBIntLongMatrix(rows);\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(CompIntLongVector[] rows) {\n-    return new RBCompIntLongMatrix(rows);\n-  }\n+    public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols) {\n+        return new RBIntLongMatrix(numRows, numCols);\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n-    return new RBCompIntLongMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, IntIntVector[] rows) {\n+        return new RBIntIntMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim) {\n-    return new RBCompIntLongMatrix(numRows, numCols, subDim);\n-  }\n+    public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols) {\n+        return new RBIntIntMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n-    CompIntLongVector[] rows = new CompIntLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntLongVector(matrixId, i, clock, numCols, subDim, storageType);\n+    public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols,\n+                                                StorageType storageType) {\n+        IntIntVector[] rows = new IntIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseIntVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseIntVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedIntVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntIntMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompIntLongMatrix(matrixId, clock, rows);\n-  }\n+    public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols, StorageType storageType) {\n+        IntIntVector[] rows = new IntIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    rows[i] = VFactory.denseIntVector(numCols);\n+                    break;\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseIntVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedIntVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBIntIntMatrix(rows);\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n-    CompIntLongVector[] rows = new CompIntLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntLongVector(0, i, 0, numCols, subDim, storageType);\n+    public static RBIntIntMatrix rbIntIntMatrix(IntIntVector[] rows) {\n+        return new RBIntIntMatrix(rows);\n     }\n \n-    return new RBCompIntLongMatrix(rows);\n-  }\n+    public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols) {\n+        return new RBIntIntMatrix(numRows, numCols);\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock,\n-      CompIntIntVector[] rows) {\n-    return new RBCompIntIntMatrix(matrixId, clock, rows);\n-  }\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock,\n+                                                        LongDoubleVector[] rows) {\n+        return new RBLongDoubleMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(CompIntIntVector[] rows) {\n-    return new RBCompIntIntMatrix(rows);\n-  }\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                        long numCols) {\n+        return new RBLongDoubleMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n-    return new RBCompIntIntMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                        long numCols, StorageType storageType) {\n+        LongDoubleVector[] rows = new LongDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongDoubleMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim) {\n-    return new RBCompIntIntMatrix(numRows, numCols, subDim);\n-  }\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols,\n+                                                        StorageType storageType) {\n+        LongDoubleVector[] rows = new LongDoubleVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongDoubleMatrix(rows);\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n-    CompIntIntVector[] rows = new CompIntIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntIntVector(matrixId, i, clock, numCols, subDim, storageType);\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(LongDoubleVector[] rows) {\n+        return new RBLongDoubleMatrix(rows);\n     }\n \n-    return new RBCompIntIntMatrix(matrixId, clock, rows);\n-  }\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols) {\n+        return new RBLongDoubleMatrix(numRows, numCols);\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n-    CompIntIntVector[] rows = new CompIntIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntIntVector(0, i, 0, numCols, subDim, storageType);\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock,\n+                                                      LongFloatVector[] rows) {\n+        return new RBLongFloatMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompIntIntMatrix(rows);\n-  }\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows,\n+                                                      long numCols) {\n+        return new RBLongFloatMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock,\n-      CompLongDoubleVector[] rows) {\n-    return new RBCompLongDoubleMatrix(matrixId, clock, rows);\n-  }\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows,\n+                                                      long numCols, StorageType storageType) {\n+        LongFloatVector[] rows = new LongFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongFloatMatrix(matrixId, clock, rows);\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(CompLongDoubleVector[] rows) {\n-    return new RBCompLongDoubleMatrix(rows);\n-  }\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols,\n+                                                      StorageType storageType) {\n+        LongFloatVector[] rows = new LongFloatVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongFloatMatrix(rows);\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n-    return new RBCompLongDoubleMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    public static RBLongFloatMatrix rbLongFloatMatrix(LongFloatVector[] rows) {\n+        return new RBLongFloatMatrix(rows);\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols,\n-      long subDim) {\n-    return new RBCompLongDoubleMatrix(numRows, numCols, subDim);\n-  }\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols) {\n+        return new RBLongFloatMatrix(numRows, numCols);\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n-    CompLongDoubleVector[] rows = new CompLongDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n+    public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock,\n+                                                    LongLongVector[] rows) {\n+        return new RBLongLongMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompLongDoubleMatrix(matrixId, clock, rows);\n-  }\n+    public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows,\n+                                                    long numCols) {\n+        return new RBLongLongMatrix(matrixId, clock, numRows, numCols);\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols,\n-      long subDim, StorageType storageType) {\n-    CompLongDoubleVector[] rows = new CompLongDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongDoubleVector(0, i, 0, numCols, subDim, storageType);\n+    public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows,\n+                                                    long numCols, StorageType storageType) {\n+        LongLongVector[] rows = new LongLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongLongMatrix(matrixId, clock, rows);\n     }\n \n-    return new RBCompLongDoubleMatrix(rows);\n-  }\n+    public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols,\n+                                                    StorageType storageType) {\n+        LongLongVector[] rows = new LongLongVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongLongMatrix(rows);\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock,\n-      CompLongFloatVector[] rows) {\n-    return new RBCompLongFloatMatrix(matrixId, clock, rows);\n-  }\n+    public static RBLongLongMatrix rbLongLongMatrix(LongLongVector[] rows) {\n+        return new RBLongLongMatrix(rows);\n+    }\n+\n+    public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols) {\n+        return new RBLongLongMatrix(numRows, numCols);\n+    }\n+\n+    public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, LongIntVector[] rows) {\n+        return new RBLongIntMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows,\n+                                                  long numCols) {\n+        return new RBLongIntMatrix(matrixId, clock, numRows, numCols);\n+    }\n+\n+    public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows,\n+                                                  long numCols,\n+                                                  StorageType storageType) {\n+        LongIntVector[] rows = new LongIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongIntMatrix(matrixId, clock, rows);\n+    }\n+\n+    public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols,\n+                                                  StorageType storageType) {\n+        LongIntVector[] rows = new LongIntVector[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            switch (storageType) {\n+                case DENSE:\n+                    throw new AngelException(\"DENSE long key is not supported!\");\n+                case SPARSE:\n+                    rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n+                    break;\n+                case SORTED:\n+                    rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n+                    break;\n+            }\n+        }\n+\n+        return new RBLongIntMatrix(rows);\n+    }\n+\n+    public static RBLongIntMatrix rbLongIntMatrix(LongIntVector[] rows) {\n+        return new RBLongIntMatrix(rows);\n+    }\n+\n+    public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols) {\n+        return new RBLongIntMatrix(numRows, numCols);\n+    }\n+\n+    //---------------------------------------------------\n+\n+    public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                     int numCols, double[] data) {\n+        return new BlasDoubleMatrix(matrixId, clock, numRows, numCols, data);\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(CompLongFloatVector[] rows) {\n-    return new RBCompLongFloatMatrix(rows);\n-  }\n+    public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows,\n+                                                     int numCols) {\n+        double[] data = new double[numRows * numCols];\n+        return new BlasDoubleMatrix(matrixId, clock, numRows, numCols, data);\n+    }\n+\n+    public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols, double[] data) {\n+        return new BlasDoubleMatrix(numRows, numCols, data);\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n-    return new RBCompLongFloatMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols) {\n+        double[] data = new double[numRows * numCols];\n+        return new BlasDoubleMatrix(numRows, numCols, data);\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols,\n-      long subDim) {\n-    return new RBCompLongFloatMatrix(numRows, numCols, subDim);\n-  }\n+    public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows,\n+                                                   int numCols,\n+                                                   float[] data) {\n+        return new BlasFloatMatrix(matrixId, clock, numRows, numCols, data);\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n-    CompLongFloatVector[] rows = new CompLongFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n+    public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows,\n+                                                   int numCols) {\n+        float[] data = new float[numRows * numCols];\n+        return new BlasFloatMatrix(matrixId, clock, numRows, numCols, data);\n     }\n \n-    return new RBCompLongFloatMatrix(matrixId, clock, rows);\n-  }\n+    public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols, float[] data) {\n+        return new BlasFloatMatrix(numRows, numCols, data);\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols, long subDim,\n-      StorageType storageType) {\n-    CompLongFloatVector[] rows = new CompLongFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongFloatVector(0, i, 0, numCols, subDim, storageType);\n+    public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols) {\n+        float[] data = new float[numRows * numCols];\n+        return new BlasFloatMatrix(numRows, numCols, data);\n     }\n \n-    return new RBCompLongFloatMatrix(rows);\n-  }\n+    public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(int matrixId, int clock,\n+                                                                HashMap<Long, IntDoubleVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock,\n-      CompLongLongVector[] rows) {\n-    return new RBCompLongLongMatrix(matrixId, clock, rows);\n-  }\n+    public static MapMatrix<IntFloatVector> intFloatMapMatrix(int matrixId, int clock,\n+                                                              HashMap<Long, IntFloatVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(CompLongLongVector[] rows) {\n-    return new RBCompLongLongMatrix(rows);\n-  }\n+    public static MapMatrix<IntLongVector> intLongMapMatrix(int matrixId, int clock,\n+                                                            HashMap<Long, IntLongVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n-    return new RBCompLongLongMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n-\n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim) {\n-    return new RBCompLongLongMatrix(numRows, numCols, subDim);\n-  }\n-\n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n-    CompLongLongVector[] rows = new CompLongLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongLongVector(matrixId, i, clock, numCols, subDim, storageType);\n-    }\n-\n-    return new RBCompLongLongMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim,\n-      StorageType storageType) {\n-    CompLongLongVector[] rows = new CompLongLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongLongVector(0, i, 0, numCols, subDim, storageType);\n-    }\n-\n-    return new RBCompLongLongMatrix(rows);\n-  }\n-\n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock,\n-      CompLongIntVector[] rows) {\n-    return new RBCompLongIntMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(CompLongIntVector[] rows) {\n-    return new RBCompLongIntMatrix(rows);\n-  }\n-\n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n-    return new RBCompLongIntMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n-\n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim) {\n-    return new RBCompLongIntMatrix(numRows, numCols, subDim);\n-  }\n-\n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n-    CompLongIntVector[] rows = new CompLongIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongIntVector(matrixId, i, clock, numCols, subDim, storageType);\n-    }\n-\n-    return new RBCompLongIntMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim,\n-      StorageType storageType) {\n-    CompLongIntVector[] rows = new CompLongIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongIntVector(0, i, 0, numCols, subDim, storageType);\n-    }\n-\n-    return new RBCompLongIntMatrix(rows);\n-  }\n-\n-  //---------------------------------------------------\n-\n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock,\n-      IntDoubleVector[] rows) {\n-    return new RBIntDoubleMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n-    return new RBIntDoubleMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, StorageType storageType) {\n-    IntDoubleVector[] rows = new IntDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseDoubleVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedDoubleVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntDoubleMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols,\n-      StorageType storageType) {\n-    IntDoubleVector[] rows = new IntDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseDoubleVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedDoubleVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntDoubleMatrix(rows);\n-  }\n-\n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(IntDoubleVector[] rows) {\n-    return new RBIntDoubleMatrix(rows);\n-  }\n-\n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols) {\n-    return new RBIntDoubleMatrix(numRows, numCols);\n-  }\n-\n-  public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, IntFloatVector[] rows) {\n-    return new RBIntFloatMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n-    return new RBIntFloatMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows, int numCols,\n-      StorageType storageType) {\n-    IntFloatVector[] rows = new IntFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseFloatVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedFloatVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntFloatMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols,\n-      StorageType storageType) {\n-    IntFloatVector[] rows = new IntFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseFloatVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedFloatVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntFloatMatrix(rows);\n-  }\n-\n-  public static RBIntFloatMatrix rbIntFloatMatrix(IntFloatVector[] rows) {\n-    return new RBIntFloatMatrix(rows);\n-  }\n-\n-  public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols) {\n-    return new RBIntFloatMatrix(numRows, numCols);\n-  }\n-\n-  public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, IntLongVector[] rows) {\n-    return new RBIntLongMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols) {\n-    return new RBIntLongMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols,\n-      StorageType storageType) {\n-    IntLongVector[] rows = new IntLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseLongVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntLongMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols, StorageType storageType) {\n-    IntLongVector[] rows = new IntLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseLongVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntLongMatrix(rows);\n-  }\n-\n-  public static RBIntLongMatrix rbIntLongMatrix(IntLongVector[] rows) {\n-    return new RBIntLongMatrix(rows);\n-  }\n-\n-  public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols) {\n-    return new RBIntLongMatrix(numRows, numCols);\n-  }\n-\n-  public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, IntIntVector[] rows) {\n-    return new RBIntIntMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols) {\n-    return new RBIntIntMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols,\n-      StorageType storageType) {\n-    IntIntVector[] rows = new IntIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseIntVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedIntVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntIntMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols, StorageType storageType) {\n-    IntIntVector[] rows = new IntIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseIntVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedIntVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBIntIntMatrix(rows);\n-  }\n-\n-  public static RBIntIntMatrix rbIntIntMatrix(IntIntVector[] rows) {\n-    return new RBIntIntMatrix(rows);\n-  }\n-\n-  public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols) {\n-    return new RBIntIntMatrix(numRows, numCols);\n-  }\n-\n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock,\n-      LongDoubleVector[] rows) {\n-    return new RBLongDoubleMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n-    return new RBLongDoubleMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols, StorageType storageType) {\n-    LongDoubleVector[] rows = new LongDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongDoubleMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n-    LongDoubleVector[] rows = new LongDoubleVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongDoubleMatrix(rows);\n-  }\n-\n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(LongDoubleVector[] rows) {\n-    return new RBLongDoubleMatrix(rows);\n-  }\n-\n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols) {\n-    return new RBLongDoubleMatrix(numRows, numCols);\n-  }\n-\n-  public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock,\n-      LongFloatVector[] rows) {\n-    return new RBLongFloatMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n-    return new RBLongFloatMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols, StorageType storageType) {\n-    LongFloatVector[] rows = new LongFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongFloatMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n-    LongFloatVector[] rows = new LongFloatVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongFloatMatrix(rows);\n-  }\n-\n-  public static RBLongFloatMatrix rbLongFloatMatrix(LongFloatVector[] rows) {\n-    return new RBLongFloatMatrix(rows);\n-  }\n-\n-  public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols) {\n-    return new RBLongFloatMatrix(numRows, numCols);\n-  }\n-\n-  public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, LongLongVector[] rows) {\n-    return new RBLongLongMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n-    return new RBLongLongMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols, StorageType storageType) {\n-    LongLongVector[] rows = new LongLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongLongMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n-    LongLongVector[] rows = new LongLongVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongLongMatrix(rows);\n-  }\n-\n-  public static RBLongLongMatrix rbLongLongMatrix(LongLongVector[] rows) {\n-    return new RBLongLongMatrix(rows);\n-  }\n-\n-  public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols) {\n-    return new RBLongLongMatrix(numRows, numCols);\n-  }\n-\n-  public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, LongIntVector[] rows) {\n-    return new RBLongIntMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n-    return new RBLongIntMatrix(matrixId, clock, numRows, numCols);\n-  }\n-\n-  public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows, long numCols,\n-      StorageType storageType) {\n-    LongIntVector[] rows = new LongIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongIntMatrix(matrixId, clock, rows);\n-  }\n-\n-  public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n-    LongIntVector[] rows = new LongIntVector[numRows];\n-    for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n-          break;\n-      }\n-    }\n-\n-    return new RBLongIntMatrix(rows);\n-  }\n-\n-  public static RBLongIntMatrix rbLongIntMatrix(LongIntVector[] rows) {\n-    return new RBLongIntMatrix(rows);\n-  }\n-\n-  public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols) {\n-    return new RBLongIntMatrix(numRows, numCols);\n-  }\n-\n-  //---------------------------------------------------\n-\n-  public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, double[] data) {\n-    return new BlasDoubleMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n-\n-  public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n-    double[] data = new double[numRows * numCols];\n-    return new BlasDoubleMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n-\n-  public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols, double[] data) {\n-    return new BlasDoubleMatrix(numRows, numCols, data);\n-  }\n-\n-  public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols) {\n-    double[] data = new double[numRows * numCols];\n-    return new BlasDoubleMatrix(numRows, numCols, data);\n-  }\n-\n-  public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows, int numCols,\n-      float[] data) {\n-    return new BlasFloatMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n-\n-  public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n-    float[] data = new float[numRows * numCols];\n-    return new BlasFloatMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n-\n-  public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols, float[] data) {\n-    return new BlasFloatMatrix(numRows, numCols, data);\n-  }\n-\n-  public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols) {\n-    float[] data = new float[numRows * numCols];\n-    return new BlasFloatMatrix(numRows, numCols, data);\n-  }\n-\n-  public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntDoubleVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntFloatVector> intFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntFloatVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntLongVector> intLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntLongVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntIntVector> intIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntIntVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongDoubleVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongFloatVector> longFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongFloatVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongLongVector> longLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongLongVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongIntVector> longIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongIntVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(\n-      HashMap<Integer, IntDoubleVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntFloatVector> intFloatMapMatrix(\n-      HashMap<Integer, IntFloatVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntLongVector> intLongMapMatrix(\n-      HashMap<Integer, IntLongVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntIntVector> intIntMapMatrix(HashMap<Integer, IntIntVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(\n-      HashMap<Long, LongDoubleVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongFloatVector> longFloatMapMatrix(\n-      HashMap<Long, LongFloatVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongLongVector> longLongMapMatrix(\n-      HashMap<Long, LongLongVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongIntVector> longIntMapMatrix(HashMap<Long, LongIntVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntDoubleVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntFloatVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntLongVector> compIntLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntLongVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntIntVector> compIntIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntIntVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongDoubleVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongFloatVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongLongVector> compLongLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongLongVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongIntVector> compLongIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongIntVector> mapMatrix) {\n-    return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(\n-      HashMap<Integer, CompIntDoubleVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(\n-      HashMap<Integer, CompIntFloatVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntLongVector> compIntLongMapMatrix(\n-      HashMap<Integer, CompIntLongVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<IntIntVector> compIntIntMapMatrix(\n-      HashMap<Integer, CompIntIntVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(\n-      HashMap<Long, CompLongDoubleVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(\n-      HashMap<Long, CompLongFloatVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongLongVector> compLongLongMapMatrix(\n-      HashMap<Long, CompLongLongVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n-\n-  public static MapMatrix<LongIntVector> compLongIntMapMatrix(\n-      HashMap<Long, CompLongIntVector> mapMatrix) {\n-    return new MapMatrix(mapMatrix);\n-  }\n+    public static MapMatrix<IntIntVector> intIntMapMatrix(int matrixId, int clock,\n+                                                          HashMap<Long, IntIntVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(int matrixId, int clock,\n+                                                                  HashMap<Long, LongDoubleVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongFloatVector> longFloatMapMatrix(int matrixId, int clock,\n+                                                                HashMap<Long, LongFloatVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongLongVector> longLongMapMatrix(int matrixId, int clock,\n+                                                              HashMap<Long, LongLongVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongIntVector> longIntMapMatrix(int matrixId, int clock,\n+                                                            HashMap<Long, LongIntVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(\n+            HashMap<Integer, IntDoubleVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntFloatVector> intFloatMapMatrix(\n+            HashMap<Integer, IntFloatVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntLongVector> intLongMapMatrix(\n+            HashMap<Integer, IntLongVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntIntVector> intIntMapMatrix(\n+            HashMap<Integer, IntIntVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(\n+            HashMap<Long, LongDoubleVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongFloatVector> longFloatMapMatrix(\n+            HashMap<Long, LongFloatVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongLongVector> longLongMapMatrix(\n+            HashMap<Long, LongLongVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongIntVector> longIntMapMatrix(\n+            HashMap<Long, LongIntVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(int matrixId, int clock,\n+                                                                    HashMap<Long, CompIntDoubleVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(int matrixId, int clock,\n+                                                                  HashMap<Long, CompIntFloatVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntLongVector> compIntLongMapMatrix(int matrixId, int clock,\n+                                                                HashMap<Long, CompIntLongVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntIntVector> compIntIntMapMatrix(int matrixId, int clock,\n+                                                              HashMap<Long, CompIntIntVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(int matrixId, int clock,\n+                                                                      HashMap<Long, CompLongDoubleVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(int matrixId, int clock,\n+                                                                    HashMap<Long, CompLongFloatVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongLongVector> compLongLongMapMatrix(int matrixId, int clock,\n+                                                                  HashMap<Long, CompLongLongVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongIntVector> compLongIntMapMatrix(int matrixId, int clock,\n+                                                                HashMap<Long, CompLongIntVector> mapMatrix) {\n+        return new MapMatrix(matrixId, clock, mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(\n+            HashMap<Integer, CompIntDoubleVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(\n+            HashMap<Integer, CompIntFloatVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntLongVector> compIntLongMapMatrix(\n+            HashMap<Integer, CompIntLongVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<IntIntVector> compIntIntMapMatrix(\n+            HashMap<Integer, CompIntIntVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(\n+            HashMap<Long, CompLongDoubleVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(\n+            HashMap<Long, CompLongFloatVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongLongVector> compLongLongMapMatrix(\n+            HashMap<Long, CompLongLongVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n+\n+    public static MapMatrix<LongIntVector> compLongIntMapMatrix(\n+            HashMap<Long, CompLongIntVector> mapMatrix) {\n+        return new MapMatrix(mapMatrix);\n+    }\n }\n",
            "diff_size": 1515
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "61",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "73",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "77",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 151).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "85",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "93",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "101",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 149).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "117",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "125",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "133",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "141",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "149",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "157",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "165",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "173",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "181",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "189",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "197",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "201",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "205",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 155).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "213",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "221",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "229",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "233",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "237",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "245",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "253",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "261",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "265",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "269",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 151).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "277",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "285",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "293",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "301",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 149).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "309",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "317",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 319.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "319",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "323",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "327",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "345",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "371",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "375",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "379",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "397",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "427",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "431",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "449",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "483",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "527",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "531",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "535",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "552",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "577",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "581",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "585",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "602",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "627",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "631",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "635",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "652",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "681",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "685",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "702",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "727",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 729.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "729",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "733",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "747",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "751",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "765",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "769",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "773",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "777",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "781",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "785",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "789",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "793",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "797",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "801",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "805",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "809",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "813",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "817",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "821",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "825",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "829",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 140).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "833",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 137).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "837",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "841",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "845",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "849",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 140).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "853",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 137).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "857",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "861",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "865",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "869",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "873",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "877",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "881",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "885",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "889",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/440/MFactory.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/440/MFactory.java\nindex f02aef3418..da9ee85696 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/440/MFactory.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/440/MFactory.java\n@@ -58,958 +58,836 @@ import java.util.HashMap;\n \n public class MFactory {\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock,\n-      CompIntDoubleVector[] rows) {\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, CompIntDoubleVector[] rows) {\n     return new RBCompIntDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(CompIntDoubleVector[] rows) {\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(CompIntDoubleVector[] rows) {\n     return new RBCompIntDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows, int numCols, int subDim) {\n     return new RBCompIntDoubleMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim) {\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim) {\n     return new RBCompIntDoubleMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int matrixId, int clock, int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntDoubleVector[] rows = new CompIntDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n+    public static RBCompIntDoubleMatrix rbCompIntDoubleMatrix(int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntDoubleVector[] rows = new CompIntDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntDoubleVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntDoubleVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock,\n-      CompIntFloatVector[] rows) {\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, CompIntFloatVector[] rows) {\n     return new RBCompIntFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(CompIntFloatVector[] rows) {\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(CompIntFloatVector[] rows) {\n     return new RBCompIntFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows, int numCols, int subDim) {\n     return new RBCompIntFloatMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim) {\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim) {\n     return new RBCompIntFloatMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int matrixId, int clock, int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntFloatVector[] rows = new CompIntFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n+    public static RBCompIntFloatMatrix rbCompIntFloatMatrix(int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntFloatVector[] rows = new CompIntFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntFloatVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntFloatVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock,\n-      CompIntLongVector[] rows) {\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, CompIntLongVector[] rows) {\n     return new RBCompIntLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(CompIntLongVector[] rows) {\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(CompIntLongVector[] rows) {\n     return new RBCompIntLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows, int numCols, int subDim) {\n     return new RBCompIntLongMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim) {\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim) {\n     return new RBCompIntLongMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int matrixId, int clock, int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntLongVector[] rows = new CompIntLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntLongVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntLongVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n+    public static RBCompIntLongMatrix rbCompIntLongMatrix(int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntLongVector[] rows = new CompIntLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntLongVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntLongVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock,\n-      CompIntIntVector[] rows) {\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, CompIntIntVector[] rows) {\n     return new RBCompIntIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(CompIntIntVector[] rows) {\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(CompIntIntVector[] rows) {\n     return new RBCompIntIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim) {\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows, int numCols, int subDim) {\n     return new RBCompIntIntMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim) {\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim) {\n     return new RBCompIntIntMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows,\n-      int numCols, int subDim, StorageType storageType) {\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int matrixId, int clock, int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntIntVector[] rows = new CompIntIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntIntVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntIntVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim,\n-      StorageType storageType) {\n+    public static RBCompIntIntMatrix rbCompIntIntMatrix(int numRows, int numCols, int subDim, StorageType storageType) {\n     CompIntIntVector[] rows = new CompIntIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compIntIntVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compIntIntVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompIntIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock,\n-      CompLongDoubleVector[] rows) {\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, CompLongDoubleVector[] rows) {\n     return new RBCompLongDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(CompLongDoubleVector[] rows) {\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(CompLongDoubleVector[] rows) {\n     return new RBCompLongDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, int numRows, long numCols, long subDim) {\n     return new RBCompLongDoubleMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols,\n-      long subDim) {\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols, long subDim) {\n     return new RBCompLongDoubleMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int matrixId, int clock, int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongDoubleVector[] rows = new CompLongDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongDoubleVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols,\n-      long subDim, StorageType storageType) {\n+    public static RBCompLongDoubleMatrix rbCompLongDoubleMatrix(int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongDoubleVector[] rows = new CompLongDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongDoubleVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongDoubleVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock,\n-      CompLongFloatVector[] rows) {\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, CompLongFloatVector[] rows) {\n     return new RBCompLongFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(CompLongFloatVector[] rows) {\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(CompLongFloatVector[] rows) {\n     return new RBCompLongFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows, long numCols, long subDim) {\n     return new RBCompLongFloatMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols,\n-      long subDim) {\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols, long subDim) {\n     return new RBCompLongFloatMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int matrixId, int clock, int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongFloatVector[] rows = new CompLongFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongFloatVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols, long subDim,\n-      StorageType storageType) {\n+    public static RBCompLongFloatMatrix rbCompLongFloatMatrix(int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongFloatVector[] rows = new CompLongFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongFloatVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongFloatVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock,\n-      CompLongLongVector[] rows) {\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, CompLongLongVector[] rows) {\n     return new RBCompLongLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(CompLongLongVector[] rows) {\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(CompLongLongVector[] rows) {\n     return new RBCompLongLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows, long numCols, long subDim) {\n     return new RBCompLongLongMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim) {\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim) {\n     return new RBCompLongLongMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int matrixId, int clock, int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongLongVector[] rows = new CompLongLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongLongVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongLongVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim,\n-      StorageType storageType) {\n+    public static RBCompLongLongMatrix rbCompLongLongMatrix(int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongLongVector[] rows = new CompLongLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongLongVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongLongVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock,\n-      CompLongIntVector[] rows) {\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, CompLongIntVector[] rows) {\n     return new RBCompLongIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(CompLongIntVector[] rows) {\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(CompLongIntVector[] rows) {\n     return new RBCompLongIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim) {\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows, long numCols, long subDim) {\n     return new RBCompLongIntMatrix(matrixId, clock, numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim) {\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim) {\n     return new RBCompLongIntMatrix(numRows, numCols, subDim);\n-  }\n+    }\n \n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows,\n-      long numCols, long subDim, StorageType storageType) {\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int matrixId, int clock, int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongIntVector[] rows = new CompLongIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongIntVector(matrixId, i, clock, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongIntVector(matrixId, i, clock, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim,\n-      StorageType storageType) {\n+    public static RBCompLongIntMatrix rbCompLongIntMatrix(int numRows, long numCols, long subDim, StorageType storageType) {\n     CompLongIntVector[] rows = new CompLongIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      rows[i] = VFactory.compLongIntVector(0, i, 0, numCols, subDim, storageType);\n+        rows[i] = VFactory.compLongIntVector(0, i, 0, numCols, subDim, storageType);\n     }\n-\n     return new RBCompLongIntMatrix(rows);\n-  }\n+    }\n \n   //---------------------------------------------------\n \n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock,\n-      IntDoubleVector[] rows) {\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, IntDoubleVector[] rows) {\n     return new RBIntDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows, int numCols) {\n     return new RBIntDoubleMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, StorageType storageType) {\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int matrixId, int clock, int numRows, int numCols, StorageType storageType) {\n     IntDoubleVector[] rows = new IntDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseDoubleVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedDoubleVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseDoubleVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseDoubleVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedDoubleVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols,\n-      StorageType storageType) {\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols, StorageType storageType) {\n     IntDoubleVector[] rows = new IntDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseDoubleVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedDoubleVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseDoubleVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseDoubleVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedDoubleVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(IntDoubleVector[] rows) {\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(IntDoubleVector[] rows) {\n     return new RBIntDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols) {\n+    public static RBIntDoubleMatrix rbIntDoubleMatrix(int numRows, int numCols) {\n     return new RBIntDoubleMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, IntFloatVector[] rows) {\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, IntFloatVector[] rows) {\n     return new RBIntFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows, int numCols) {\n     return new RBIntFloatMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows, int numCols,\n-      StorageType storageType) {\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int matrixId, int clock, int numRows, int numCols, StorageType storageType) {\n     IntFloatVector[] rows = new IntFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseFloatVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedFloatVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseFloatVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseFloatVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedFloatVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols,\n-      StorageType storageType) {\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols, StorageType storageType) {\n     IntFloatVector[] rows = new IntFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseFloatVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedFloatVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseFloatVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseFloatVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedFloatVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntFloatMatrix rbIntFloatMatrix(IntFloatVector[] rows) {\n+    public static RBIntFloatMatrix rbIntFloatMatrix(IntFloatVector[] rows) {\n     return new RBIntFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols) {\n+    public static RBIntFloatMatrix rbIntFloatMatrix(int numRows, int numCols) {\n     return new RBIntFloatMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, IntLongVector[] rows) {\n+    public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, IntLongVector[] rows) {\n     return new RBIntLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols) {\n+    public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols) {\n     return new RBIntLongMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols,\n-      StorageType storageType) {\n+    public static RBIntLongMatrix rbIntLongMatrix(int matrixId, int clock, int numRows, int numCols, StorageType storageType) {\n     IntLongVector[] rows = new IntLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseLongVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseLongVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols, StorageType storageType) {\n+    public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols, StorageType storageType) {\n     IntLongVector[] rows = new IntLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseLongVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseLongVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntLongMatrix rbIntLongMatrix(IntLongVector[] rows) {\n+    public static RBIntLongMatrix rbIntLongMatrix(IntLongVector[] rows) {\n     return new RBIntLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols) {\n+    public static RBIntLongMatrix rbIntLongMatrix(int numRows, int numCols) {\n     return new RBIntLongMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, IntIntVector[] rows) {\n+    public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, IntIntVector[] rows) {\n     return new RBIntIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols) {\n+    public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols) {\n     return new RBIntIntMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols,\n-      StorageType storageType) {\n+    public static RBIntIntMatrix rbIntIntMatrix(int matrixId, int clock, int numRows, int numCols, StorageType storageType) {\n     IntIntVector[] rows = new IntIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseIntVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedIntVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseIntVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseIntVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedIntVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols, StorageType storageType) {\n+    public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols, StorageType storageType) {\n     IntIntVector[] rows = new IntIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          rows[i] = VFactory.denseIntVector(numCols);\n-          break;\n-        case SPARSE:\n-          rows[i] = VFactory.sparseIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedIntVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            rows[i] = VFactory.denseIntVector(numCols);\n+            break;\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseIntVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedIntVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBIntIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntIntMatrix rbIntIntMatrix(IntIntVector[] rows) {\n+    public static RBIntIntMatrix rbIntIntMatrix(IntIntVector[] rows) {\n     return new RBIntIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols) {\n+    public static RBIntIntMatrix rbIntIntMatrix(int numRows, int numCols) {\n     return new RBIntIntMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock,\n-      LongDoubleVector[] rows) {\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, LongDoubleVector[] rows) {\n     return new RBLongDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows, long numCols) {\n     return new RBLongDoubleMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows,\n-      long numCols, StorageType storageType) {\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int matrixId, int clock, int numRows, long numCols, StorageType storageType) {\n     LongDoubleVector[] rows = new LongDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongDoubleMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols, StorageType storageType) {\n     LongDoubleVector[] rows = new LongDoubleVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyDoubleVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyDoubleVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(LongDoubleVector[] rows) {\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(LongDoubleVector[] rows) {\n     return new RBLongDoubleMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols) {\n+    public static RBLongDoubleMatrix rbLongDoubleMatrix(int numRows, long numCols) {\n     return new RBLongDoubleMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock,\n-      LongFloatVector[] rows) {\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, LongFloatVector[] rows) {\n     return new RBLongFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows, long numCols) {\n     return new RBLongFloatMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows,\n-      long numCols, StorageType storageType) {\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int matrixId, int clock, int numRows, long numCols, StorageType storageType) {\n     LongFloatVector[] rows = new LongFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongFloatMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols, StorageType storageType) {\n     LongFloatVector[] rows = new LongFloatVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyFloatVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyFloatVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongFloatMatrix rbLongFloatMatrix(LongFloatVector[] rows) {\n+    public static RBLongFloatMatrix rbLongFloatMatrix(LongFloatVector[] rows) {\n     return new RBLongFloatMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols) {\n+    public static RBLongFloatMatrix rbLongFloatMatrix(int numRows, long numCols) {\n     return new RBLongFloatMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, LongLongVector[] rows) {\n+    public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, LongLongVector[] rows) {\n     return new RBLongLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n+    public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows, long numCols) {\n     return new RBLongLongMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows,\n-      long numCols, StorageType storageType) {\n+    public static RBLongLongMatrix rbLongLongMatrix(int matrixId, int clock, int numRows, long numCols, StorageType storageType) {\n     LongLongVector[] rows = new LongLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongLongMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n+    public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols, StorageType storageType) {\n     LongLongVector[] rows = new LongLongVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyLongVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyLongVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongLongMatrix rbLongLongMatrix(LongLongVector[] rows) {\n+    public static RBLongLongMatrix rbLongLongMatrix(LongLongVector[] rows) {\n     return new RBLongLongMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols) {\n+    public static RBLongLongMatrix rbLongLongMatrix(int numRows, long numCols) {\n     return new RBLongLongMatrix(numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, LongIntVector[] rows) {\n+    public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, LongIntVector[] rows) {\n     return new RBLongIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows,\n-      long numCols) {\n+    public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows, long numCols) {\n     return new RBLongIntMatrix(matrixId, clock, numRows, numCols);\n-  }\n+    }\n \n-  public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows, long numCols,\n-      StorageType storageType) {\n+    public static RBLongIntMatrix rbLongIntMatrix(int matrixId, int clock, int numRows, long numCols, StorageType storageType) {\n     LongIntVector[] rows = new LongIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongIntMatrix(matrixId, clock, rows);\n-  }\n+    }\n \n-  public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols,\n-      StorageType storageType) {\n+    public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols, StorageType storageType) {\n     LongIntVector[] rows = new LongIntVector[numRows];\n     for (int i = 0; i < numRows; i++) {\n-      switch (storageType) {\n-        case DENSE:\n-          throw new AngelException(\"DENSE long key is not supported!\");\n-        case SPARSE:\n-          rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n-          break;\n-        case SORTED:\n-          rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n-          break;\n-      }\n+        switch (storageType) {\n+                                          case DENSE:\n+            throw new AngelException(\"DENSE long key is not supported!\");\n+                                          case SPARSE:\n+            rows[i] = VFactory.sparseLongKeyIntVector(numCols);\n+            break;\n+                                          case SORTED:\n+            rows[i] = VFactory.sortedLongKeyIntVector(numCols);\n+            break;\n+        }\n     }\n-\n     return new RBLongIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongIntMatrix rbLongIntMatrix(LongIntVector[] rows) {\n+    public static RBLongIntMatrix rbLongIntMatrix(LongIntVector[] rows) {\n     return new RBLongIntMatrix(rows);\n-  }\n+    }\n \n-  public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols) {\n+    public static RBLongIntMatrix rbLongIntMatrix(int numRows, long numCols) {\n     return new RBLongIntMatrix(numRows, numCols);\n-  }\n+    }\n \n   //---------------------------------------------------\n \n-  public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols, double[] data) {\n+    public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows, int numCols, double[] data) {\n     return new BlasDoubleMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n+    public static BlasDoubleMatrix denseDoubleMatrix(int matrixId, int clock, int numRows, int numCols) {\n     double[] data = new double[numRows * numCols];\n     return new BlasDoubleMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols, double[] data) {\n+    public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols, double[] data) {\n     return new BlasDoubleMatrix(numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols) {\n+    public static BlasDoubleMatrix denseDoubleMatrix(int numRows, int numCols) {\n     double[] data = new double[numRows * numCols];\n     return new BlasDoubleMatrix(numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows, int numCols,\n-      float[] data) {\n+    public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows, int numCols, float[] data) {\n     return new BlasFloatMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows,\n-      int numCols) {\n+    public static BlasFloatMatrix denseFloatMatrix(int matrixId, int clock, int numRows, int numCols) {\n     float[] data = new float[numRows * numCols];\n     return new BlasFloatMatrix(matrixId, clock, numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols, float[] data) {\n+    public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols, float[] data) {\n     return new BlasFloatMatrix(numRows, numCols, data);\n-  }\n+    }\n \n-  public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols) {\n+    public static BlasFloatMatrix denseFloatMatrix(int numRows, int numCols) {\n     float[] data = new float[numRows * numCols];\n     return new BlasFloatMatrix(numRows, numCols, data);\n-  }\n+    }\n \n-  public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntDoubleVector> mapMatrix) {\n+    public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(int matrixId, int clock, HashMap<Long, IntDoubleVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntFloatVector> intFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntFloatVector> mapMatrix) {\n+    public static MapMatrix<IntFloatVector> intFloatMapMatrix(int matrixId, int clock, HashMap<Long, IntFloatVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntLongVector> intLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntLongVector> mapMatrix) {\n+    public static MapMatrix<IntLongVector> intLongMapMatrix(int matrixId, int clock, HashMap<Long, IntLongVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntIntVector> intIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, IntIntVector> mapMatrix) {\n+    public static MapMatrix<IntIntVector> intIntMapMatrix(int matrixId, int clock, HashMap<Long, IntIntVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongDoubleVector> mapMatrix) {\n+    public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(int matrixId, int clock, HashMap<Long, LongDoubleVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongFloatVector> longFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongFloatVector> mapMatrix) {\n+    public static MapMatrix<LongFloatVector> longFloatMapMatrix(int matrixId, int clock, HashMap<Long, LongFloatVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongLongVector> longLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongLongVector> mapMatrix) {\n+    public static MapMatrix<LongLongVector> longLongMapMatrix(int matrixId, int clock, HashMap<Long, LongLongVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongIntVector> longIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, LongIntVector> mapMatrix) {\n+    public static MapMatrix<LongIntVector> longIntMapMatrix(int matrixId, int clock, HashMap<Long, LongIntVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(\n-      HashMap<Integer, IntDoubleVector> mapMatrix) {\n+    public static MapMatrix<IntDoubleVector> intDoubleMapMatrix(HashMap<Integer, IntDoubleVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntFloatVector> intFloatMapMatrix(\n-      HashMap<Integer, IntFloatVector> mapMatrix) {\n+    public static MapMatrix<IntFloatVector> intFloatMapMatrix(HashMap<Integer, IntFloatVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntLongVector> intLongMapMatrix(\n-      HashMap<Integer, IntLongVector> mapMatrix) {\n+    public static MapMatrix<IntLongVector> intLongMapMatrix(HashMap<Integer, IntLongVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntIntVector> intIntMapMatrix(HashMap<Integer, IntIntVector> mapMatrix) {\n+    public static MapMatrix<IntIntVector> intIntMapMatrix(HashMap<Integer, IntIntVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(\n-      HashMap<Long, LongDoubleVector> mapMatrix) {\n+    public static MapMatrix<LongDoubleVector> longDoubleMapMatrix(HashMap<Long, LongDoubleVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongFloatVector> longFloatMapMatrix(\n-      HashMap<Long, LongFloatVector> mapMatrix) {\n+    public static MapMatrix<LongFloatVector> longFloatMapMatrix(HashMap<Long, LongFloatVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongLongVector> longLongMapMatrix(\n-      HashMap<Long, LongLongVector> mapMatrix) {\n+    public static MapMatrix<LongLongVector> longLongMapMatrix(HashMap<Long, LongLongVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongIntVector> longIntMapMatrix(HashMap<Long, LongIntVector> mapMatrix) {\n+    public static MapMatrix<LongIntVector> longIntMapMatrix(HashMap<Long, LongIntVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntDoubleVector> mapMatrix) {\n+    public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(int matrixId, int clock, HashMap<Long, CompIntDoubleVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntFloatVector> mapMatrix) {\n+    public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(int matrixId, int clock, HashMap<Long, CompIntFloatVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntLongVector> compIntLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntLongVector> mapMatrix) {\n+    public static MapMatrix<IntLongVector> compIntLongMapMatrix(int matrixId, int clock, HashMap<Long, CompIntLongVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntIntVector> compIntIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompIntIntVector> mapMatrix) {\n+    public static MapMatrix<IntIntVector> compIntIntMapMatrix(int matrixId, int clock, HashMap<Long, CompIntIntVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongDoubleVector> mapMatrix) {\n+    public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(int matrixId, int clock, HashMap<Long, CompLongDoubleVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongFloatVector> mapMatrix) {\n+    public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(int matrixId, int clock, HashMap<Long, CompLongFloatVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongLongVector> compLongLongMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongLongVector> mapMatrix) {\n+    public static MapMatrix<LongLongVector> compLongLongMapMatrix(int matrixId, int clock, HashMap<Long, CompLongLongVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongIntVector> compLongIntMapMatrix(int matrixId, int clock,\n-      HashMap<Long, CompLongIntVector> mapMatrix) {\n+    public static MapMatrix<LongIntVector> compLongIntMapMatrix(int matrixId, int clock, HashMap<Long, CompLongIntVector> mapMatrix) {\n     return new MapMatrix(matrixId, clock, mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(\n-      HashMap<Integer, CompIntDoubleVector> mapMatrix) {\n+    public static MapMatrix<IntDoubleVector> compIntDoubleMapMatrix(HashMap<Integer, CompIntDoubleVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(\n-      HashMap<Integer, CompIntFloatVector> mapMatrix) {\n+    public static MapMatrix<IntFloatVector> compIntFloatMapMatrix(HashMap<Integer, CompIntFloatVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntLongVector> compIntLongMapMatrix(\n-      HashMap<Integer, CompIntLongVector> mapMatrix) {\n+    public static MapMatrix<IntLongVector> compIntLongMapMatrix(HashMap<Integer, CompIntLongVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<IntIntVector> compIntIntMapMatrix(\n-      HashMap<Integer, CompIntIntVector> mapMatrix) {\n+    public static MapMatrix<IntIntVector> compIntIntMapMatrix(HashMap<Integer, CompIntIntVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(\n-      HashMap<Long, CompLongDoubleVector> mapMatrix) {\n+    public static MapMatrix<LongDoubleVector> compLongDoubleMapMatrix(HashMap<Long, CompLongDoubleVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(\n-      HashMap<Long, CompLongFloatVector> mapMatrix) {\n+    public static MapMatrix<LongFloatVector> compLongFloatMapMatrix(HashMap<Long, CompLongFloatVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongLongVector> compLongLongMapMatrix(\n-      HashMap<Long, CompLongLongVector> mapMatrix) {\n+    public static MapMatrix<LongLongVector> compLongLongMapMatrix(HashMap<Long, CompLongLongVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n+    }\n \n-  public static MapMatrix<LongIntVector> compLongIntMapMatrix(\n-      HashMap<Long, CompLongIntVector> mapMatrix) {\n+    public static MapMatrix<LongIntVector> compLongIntMapMatrix(HashMap<Long, CompLongIntVector> mapMatrix) {\n     return new MapMatrix(mapMatrix);\n-  }\n-}\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 581
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/440/MFactory.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/440/MFactory.java\nindex f02aef3418..821dcb73a3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/440/MFactory.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/440/MFactory.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.ml.math2;\n \n import com.tencent.angel.exception.AngelException;\n",
            "diff_size": 1
        }
    ]
}