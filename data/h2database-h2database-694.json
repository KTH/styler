{
    "error_id": "694",
    "information": {
        "errors": [
            {
                "line": "270",
                "column": "13",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "        for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n            long collectionTime = gcMXBean.getCollectionTime();\n            if(collectionTime > 0) {\n                totalGCTime += collectionTime;\n            }\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/694/Utils.java\nindex d065fd4809..af7a529ce7 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/694/Utils.java\n@@ -267,7 +267,7 @@ public class Utils {\n         long totalGCTime = 0;\n         for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n             long collectionTime = gcMXBean.getCollectionTime();\n-            if(collectionTime > 0) {\n+            if (collectionTime > 0) {\n                 totalGCTime += collectionTime;\n             }\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/694/Utils.java\nindex d065fd4809..fb317f86b1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/694/Utils.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.util;\n \n import java.io.ByteArrayOutputStream;\n@@ -26,756 +27,755 @@ import java.util.zip.ZipInputStream;\n  */\n public class Utils {\n \n-    /**\n-     * An 0-size byte array.\n-     */\n-    public static final byte[] EMPTY_BYTES = {};\n-\n-    /**\n-     * An 0-size int array.\n-     */\n-    public static final int[] EMPTY_INT_ARRAY = {};\n-\n-    /**\n-     * An 0-size long array.\n-     */\n-    private static final long[] EMPTY_LONG_ARRAY = {};\n-\n-    private static final int GC_DELAY = 50;\n-    private static final int MAX_GC = 8;\n-    private static long lastGC;\n-\n-    private static final HashMap<String, byte[]> RESOURCES = new HashMap<>();\n-\n-    private Utils() {\n-        // utility class\n-    }\n-\n-    /**\n-     * Calculate the index of the first occurrence of the pattern in the byte\n-     * array, starting with the given index. This methods returns -1 if the\n-     * pattern has not been found, and the start position if the pattern is\n-     * empty.\n-     *\n-     * @param bytes the byte array\n-     * @param pattern the pattern\n-     * @param start the start index from where to search\n-     * @return the index\n-     */\n-    public static int indexOf(byte[] bytes, byte[] pattern, int start) {\n-        if (pattern.length == 0) {\n-            return start;\n-        }\n-        if (start > bytes.length) {\n-            return -1;\n-        }\n-        int last = bytes.length - pattern.length + 1;\n-        int patternLen = pattern.length;\n-        next:\n-        for (; start < last; start++) {\n-            for (int i = 0; i < patternLen; i++) {\n-                if (bytes[start + i] != pattern[i]) {\n-                    continue next;\n-                }\n-            }\n-            return start;\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * Calculate the hash code of the given byte array.\n-     *\n-     * @param value the byte array\n-     * @return the hash code\n-     */\n-    public static int getByteArrayHash(byte[] value) {\n-        int len = value.length;\n-        int h = len;\n-        if (len < 50) {\n-            for (int i = 0; i < len; i++) {\n-                h = 31 * h + value[i];\n-            }\n-        } else {\n-            int step = len / 16;\n-            for (int i = 0; i < 4; i++) {\n-                h = 31 * h + value[i];\n-                h = 31 * h + value[--len];\n-            }\n-            for (int i = 4 + step; i < len; i += step) {\n-                h = 31 * h + value[i];\n-            }\n-        }\n-        return h;\n-    }\n-\n-    /**\n-     * Compare two byte arrays. This method will always loop over all bytes and\n-     * doesn't use conditional operations in the loop to make sure an attacker\n-     * can not use a timing attack when trying out passwords.\n-     *\n-     * @param test the first array\n-     * @param good the second array\n-     * @return true if both byte arrays contain the same bytes\n-     */\n-    public static boolean compareSecure(byte[] test, byte[] good) {\n-        if ((test == null) || (good == null)) {\n-            return (test == null) && (good == null);\n-        }\n-        int len = test.length;\n-        if (len != good.length) {\n-            return false;\n-        }\n-        if (len == 0) {\n-            return true;\n-        }\n-        // don't use conditional operations inside the loop\n-        int bits = 0;\n-        for (int i = 0; i < len; i++) {\n-            // this will never reset any bits\n-            bits |= test[i] ^ good[i];\n-        }\n-        return bits == 0;\n-    }\n-\n-    /**\n-     * Compare the contents of two byte arrays. If the content or length of the\n-     * first array is smaller than the second array, -1 is returned. If the\n-     * content or length of the second array is smaller than the first array, 1\n-     * is returned. If the contents and lengths are the same, 0 is returned.\n-     * <p>\n-     * This method interprets bytes as signed.\n-     *\n-     * @param data1 the first byte array (must not be null)\n-     * @param data2 the second byte array (must not be null)\n-     * @return the result of the comparison (-1, 1 or 0)\n-     */\n-    public static int compareNotNullSigned(byte[] data1, byte[] data2) {\n-        if (data1 == data2) {\n-            return 0;\n-        }\n-        int len = Math.min(data1.length, data2.length);\n-        for (int i = 0; i < len; i++) {\n-            byte b = data1[i];\n-            byte b2 = data2[i];\n-            if (b != b2) {\n-                return b > b2 ? 1 : -1;\n-            }\n-        }\n-        return Integer.signum(data1.length - data2.length);\n-    }\n-\n-    /**\n-     * Compare the contents of two byte arrays. If the content or length of the\n-     * first array is smaller than the second array, -1 is returned. If the\n-     * content or length of the second array is smaller than the first array, 1\n-     * is returned. If the contents and lengths are the same, 0 is returned.\n-     * <p>\n-     * This method interprets bytes as unsigned.\n-     *\n-     * @param data1 the first byte array (must not be null)\n-     * @param data2 the second byte array (must not be null)\n-     * @return the result of the comparison (-1, 1 or 0)\n-     */\n-    public static int compareNotNullUnsigned(byte[] data1, byte[] data2) {\n-        if (data1 == data2) {\n-            return 0;\n-        }\n-        int len = Math.min(data1.length, data2.length);\n-        for (int i = 0; i < len; i++) {\n-            int b = data1[i] & 0xff;\n-            int b2 = data2[i] & 0xff;\n-            if (b != b2) {\n-                return b > b2 ? 1 : -1;\n-            }\n-        }\n-        return Integer.signum(data1.length - data2.length);\n-    }\n-\n-    /**\n-     * Copy the contents of the source array to the target array. If the size if\n-     * the target array is too small, a larger array is created.\n-     *\n-     * @param source the source array\n-     * @param target the target array\n-     * @return the target array or a new one if the target array was too small\n-     */\n-    public static byte[] copy(byte[] source, byte[] target) {\n-        int len = source.length;\n-        if (len > target.length) {\n-            target = new byte[len];\n-        }\n-        System.arraycopy(source, 0, target, 0, len);\n-        return target;\n-    }\n-\n-    /**\n-     * Create a new byte array and copy all the data. If the size of the byte\n-     * array is zero, the same array is returned.\n-     *\n-     * @param b the byte array (may not be null)\n-     * @return a new byte array\n-     */\n-    public static byte[] cloneByteArray(byte[] b) {\n-        if (b == null) {\n-            return null;\n-        }\n-        int len = b.length;\n-        if (len == 0) {\n-            return EMPTY_BYTES;\n-        }\n-        return Arrays.copyOf(b, len);\n-    }\n-\n-    /**\n-     * Get the used memory in KB.\n-     * This method possibly calls System.gc().\n-     *\n-     * @return the used memory\n-     */\n-    public static int getMemoryUsed() {\n-        collectGarbage();\n-        Runtime rt = Runtime.getRuntime();\n-        long mem = rt.totalMemory() - rt.freeMemory();\n-        return (int) (mem >> 10);\n-    }\n-\n-    /**\n-     * Get the free memory in KB.\n-     * This method possibly calls System.gc().\n-     *\n-     * @return the free memory\n-     */\n-    public static int getMemoryFree() {\n-        collectGarbage();\n-        Runtime rt = Runtime.getRuntime();\n-        long mem = rt.freeMemory();\n-        return (int) (mem >> 10);\n-    }\n-\n-    /**\n-     * Get the maximum memory in KB.\n-     *\n-     * @return the maximum memory\n-     */\n-    public static long getMemoryMax() {\n-        long max = Runtime.getRuntime().maxMemory();\n-        return max / 1024;\n-    }\n-\n-    public static long getGarbageCollectionTime() {\n-        long totalGCTime = 0;\n-        for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n-            long collectionTime = gcMXBean.getCollectionTime();\n-            if(collectionTime > 0) {\n-                totalGCTime += collectionTime;\n-            }\n-        }\n-        return totalGCTime;\n-    }\n-\n-    private static synchronized void collectGarbage() {\n-        Runtime runtime = Runtime.getRuntime();\n-        long total = runtime.totalMemory();\n-        long time = System.nanoTime();\n-        if (lastGC + TimeUnit.MILLISECONDS.toNanos(GC_DELAY) < time) {\n-            for (int i = 0; i < MAX_GC; i++) {\n-                runtime.gc();\n-                long now = runtime.totalMemory();\n-                if (now == total) {\n-                    lastGC = System.nanoTime();\n-                    break;\n-                }\n-                total = now;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Create an int array with the given size.\n-     *\n-     * @param len the number of bytes requested\n-     * @return the int array\n-     */\n-    public static int[] newIntArray(int len) {\n-        if (len == 0) {\n-            return EMPTY_INT_ARRAY;\n-        }\n-        return new int[len];\n-    }\n-\n-    /**\n-     * Create a long array with the given size.\n-     *\n-     * @param len the number of bytes requested\n-     * @return the int array\n-     */\n-    public static long[] newLongArray(int len) {\n-        if (len == 0) {\n-            return EMPTY_LONG_ARRAY;\n-        }\n-        return new long[len];\n-    }\n-\n-    /**\n-     * Find the top limit values using given comparator and place them as in a\n-     * full array sort, in descending order.\n-     *\n-     * @param array the array.\n-     * @param offset the offset.\n-     * @param limit the limit.\n-     * @param comp the comparator.\n-     */\n-    public static <X> void sortTopN(X[] array, int offset, int limit,\n-            Comparator<? super X> comp) {\n-        partitionTopN(array, offset, limit, comp);\n-        Arrays.sort(array, offset,\n-                (int) Math.min((long) offset + limit, array.length), comp);\n-    }\n-\n-    /**\n-     * Find the top limit values using given comparator and place them as in a\n-     * full array sort. This method does not sort the top elements themselves.\n-     *\n-     * @param array the array\n-     * @param offset the offset\n-     * @param limit the limit\n-     * @param comp the comparator\n-     */\n-    private static <X> void partitionTopN(X[] array, int offset, int limit,\n-            Comparator<? super X> comp) {\n-        partialQuickSort(array, 0, array.length - 1, comp, offset, offset +\n-                limit - 1);\n-    }\n-\n-    private static <X> void partialQuickSort(X[] array, int low, int high,\n-            Comparator<? super X> comp, int start, int end) {\n-        if (low > end || high < start || (low > start && high < end)) {\n-            return;\n-        }\n-        if (low == high) {\n-            return;\n-        }\n-        int i = low, j = high;\n-        // use a random pivot to protect against\n-        // the worst case order\n-        int p = low + MathUtils.randomInt(high - low);\n-        X pivot = array[p];\n-        int m = (low + high) >>> 1;\n-        X temp = array[m];\n-        array[m] = pivot;\n-        array[p] = temp;\n-        while (i <= j) {\n-            while (comp.compare(array[i], pivot) < 0) {\n-                i++;\n-            }\n-            while (comp.compare(array[j], pivot) > 0) {\n-                j--;\n-            }\n-            if (i <= j) {\n-                temp = array[i];\n-                array[i++] = array[j];\n-                array[j--] = temp;\n-            }\n-        }\n-        if (low < j) {\n-            partialQuickSort(array, low, j, comp, start, end);\n-        }\n-        if (i < high) {\n-            partialQuickSort(array, i, high, comp, start, end);\n-        }\n-    }\n-\n-    /**\n-     * Checks if given classes have a common Comparable superclass.\n-     *\n-     * @param c1 the first class\n-     * @param c2 the second class\n-     * @return true if they have\n-     */\n-    public static boolean haveCommonComparableSuperclass(\n-            Class<?> c1, Class<?> c2) {\n-        if (c1 == c2 || c1.isAssignableFrom(c2) || c2.isAssignableFrom(c1)) {\n-            return true;\n-        }\n-        Class<?> top1;\n-        do {\n-            top1 = c1;\n-            c1 = c1.getSuperclass();\n-        } while (Comparable.class.isAssignableFrom(c1));\n-\n-        Class<?> top2;\n-        do {\n-            top2 = c2;\n-            c2 = c2.getSuperclass();\n-        } while (Comparable.class.isAssignableFrom(c2));\n-\n-        return top1 == top2;\n-    }\n-\n-    /**\n-     * Get a resource from the resource map.\n-     *\n-     * @param name the name of the resource\n-     * @return the resource data\n-     */\n-    public static byte[] getResource(String name) throws IOException {\n-        byte[] data = RESOURCES.get(name);\n-        if (data == null) {\n-            data = loadResource(name);\n-            if (data != null) {\n-                RESOURCES.put(name, data);\n-            }\n-        }\n-        return data;\n-    }\n-\n-    private static byte[] loadResource(String name) throws IOException {\n-        InputStream in = Utils.class.getResourceAsStream(\"data.zip\");\n-        if (in == null) {\n-            in = Utils.class.getResourceAsStream(name);\n-            if (in == null) {\n-                return null;\n-            }\n-            return IOUtils.readBytesAndClose(in, 0);\n-        }\n-\n-        try (ZipInputStream zipIn = new ZipInputStream(in)) {\n-            while (true) {\n-                ZipEntry entry = zipIn.getNextEntry();\n-                if (entry == null) {\n-                    break;\n-                }\n-                String entryName = entry.getName();\n-                if (!entryName.startsWith(\"/\")) {\n-                    entryName = \"/\" + entryName;\n-                }\n-                if (entryName.equals(name)) {\n-                    ByteArrayOutputStream out = new ByteArrayOutputStream();\n-                    IOUtils.copy(zipIn, out);\n-                    zipIn.closeEntry();\n-                    return out.toByteArray();\n-                }\n-                zipIn.closeEntry();\n-            }\n-        } catch (IOException e) {\n-            // if this happens we have a real problem\n-            e.printStackTrace();\n-        }\n+  /**\n+   * An 0-size byte array.\n+   */\n+  public static final byte[] EMPTY_BYTES = {};\n+\n+  /**\n+   * An 0-size int array.\n+   */\n+  public static final int[] EMPTY_INT_ARRAY = {};\n+\n+  /**\n+   * An 0-size long array.\n+   */\n+  private static final long[] EMPTY_LONG_ARRAY = {};\n+\n+  private static final int GC_DELAY = 50;\n+  private static final int MAX_GC = 8;\n+  private static long lastGC;\n+\n+  private static final HashMap<String, byte[]> RESOURCES = new HashMap<>();\n+\n+  private Utils() {\n+    // utility class\n+  }\n+\n+  /**\n+   * Calculate the index of the first occurrence of the pattern in the byte\n+   * array, starting with the given index. This methods returns -1 if the\n+   * pattern has not been found, and the start position if the pattern is\n+   * empty.\n+   *\n+   * @param bytes   the byte array\n+   * @param pattern the pattern\n+   * @param start   the start index from where to search\n+   * @return the index\n+   */\n+  public static int indexOf(byte[] bytes, byte[] pattern, int start) {\n+    if (pattern.length == 0) {\n+      return start;\n+    }\n+    if (start > bytes.length) {\n+      return -1;\n+    }\n+    int last = bytes.length - pattern.length + 1;\n+    int patternLen = pattern.length;\n+    next:\n+    for (; start < last; start++) {\n+      for (int i = 0; i < patternLen; i++) {\n+        if (bytes[start + i] != pattern[i]) {\n+          continue next;\n+        }\n+      }\n+      return start;\n+    }\n+    return -1;\n+  }\n+\n+  /**\n+   * Calculate the hash code of the given byte array.\n+   *\n+   * @param value the byte array\n+   * @return the hash code\n+   */\n+  public static int getByteArrayHash(byte[] value) {\n+    int len = value.length;\n+    int h = len;\n+    if (len < 50) {\n+      for (int i = 0; i < len; i++) {\n+        h = 31 * h + value[i];\n+      }\n+    } else {\n+      int step = len / 16;\n+      for (int i = 0; i < 4; i++) {\n+        h = 31 * h + value[i];\n+        h = 31 * h + value[--len];\n+      }\n+      for (int i = 4 + step; i < len; i += step) {\n+        h = 31 * h + value[i];\n+      }\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Compare two byte arrays. This method will always loop over all bytes and\n+   * doesn't use conditional operations in the loop to make sure an attacker\n+   * can not use a timing attack when trying out passwords.\n+   *\n+   * @param test the first array\n+   * @param good the second array\n+   * @return true if both byte arrays contain the same bytes\n+   */\n+  public static boolean compareSecure(byte[] test, byte[] good) {\n+    if ((test == null) || (good == null)) {\n+      return (test == null) && (good == null);\n+    }\n+    int len = test.length;\n+    if (len != good.length) {\n+      return false;\n+    }\n+    if (len == 0) {\n+      return true;\n+    }\n+    // don't use conditional operations inside the loop\n+    int bits = 0;\n+    for (int i = 0; i < len; i++) {\n+      // this will never reset any bits\n+      bits |= test[i] ^ good[i];\n+    }\n+    return bits == 0;\n+  }\n+\n+  /**\n+   * Compare the contents of two byte arrays. If the content or length of the\n+   * first array is smaller than the second array, -1 is returned. If the\n+   * content or length of the second array is smaller than the first array, 1\n+   * is returned. If the contents and lengths are the same, 0 is returned.\n+   * <p>\n+   * This method interprets bytes as signed.\n+   *\n+   * @param data1 the first byte array (must not be null)\n+   * @param data2 the second byte array (must not be null)\n+   * @return the result of the comparison (-1, 1 or 0)\n+   */\n+  public static int compareNotNullSigned(byte[] data1, byte[] data2) {\n+    if (data1 == data2) {\n+      return 0;\n+    }\n+    int len = Math.min(data1.length, data2.length);\n+    for (int i = 0; i < len; i++) {\n+      byte b = data1[i];\n+      byte b2 = data2[i];\n+      if (b != b2) {\n+        return b > b2 ? 1 : -1;\n+      }\n+    }\n+    return Integer.signum(data1.length - data2.length);\n+  }\n+\n+  /**\n+   * Compare the contents of two byte arrays. If the content or length of the\n+   * first array is smaller than the second array, -1 is returned. If the\n+   * content or length of the second array is smaller than the first array, 1\n+   * is returned. If the contents and lengths are the same, 0 is returned.\n+   * <p>\n+   * This method interprets bytes as unsigned.\n+   *\n+   * @param data1 the first byte array (must not be null)\n+   * @param data2 the second byte array (must not be null)\n+   * @return the result of the comparison (-1, 1 or 0)\n+   */\n+  public static int compareNotNullUnsigned(byte[] data1, byte[] data2) {\n+    if (data1 == data2) {\n+      return 0;\n+    }\n+    int len = Math.min(data1.length, data2.length);\n+    for (int i = 0; i < len; i++) {\n+      int b = data1[i] & 0xff;\n+      int b2 = data2[i] & 0xff;\n+      if (b != b2) {\n+        return b > b2 ? 1 : -1;\n+      }\n+    }\n+    return Integer.signum(data1.length - data2.length);\n+  }\n+\n+  /**\n+   * Copy the contents of the source array to the target array. If the size if\n+   * the target array is too small, a larger array is created.\n+   *\n+   * @param source the source array\n+   * @param target the target array\n+   * @return the target array or a new one if the target array was too small\n+   */\n+  public static byte[] copy(byte[] source, byte[] target) {\n+    int len = source.length;\n+    if (len > target.length) {\n+      target = new byte[len];\n+    }\n+    System.arraycopy(source, 0, target, 0, len);\n+    return target;\n+  }\n+\n+  /**\n+   * Create a new byte array and copy all the data. If the size of the byte\n+   * array is zero, the same array is returned.\n+   *\n+   * @param b the byte array (may not be null)\n+   * @return a new byte array\n+   */\n+  public static byte[] cloneByteArray(byte[] b) {\n+    if (b == null) {\n+      return null;\n+    }\n+    int len = b.length;\n+    if (len == 0) {\n+      return EMPTY_BYTES;\n+    }\n+    return Arrays.copyOf(b, len);\n+  }\n+\n+  /**\n+   * Get the used memory in KB.\n+   * This method possibly calls System.gc().\n+   *\n+   * @return the used memory\n+   */\n+  public static int getMemoryUsed() {\n+    collectGarbage();\n+    Runtime rt = Runtime.getRuntime();\n+    long mem = rt.totalMemory() - rt.freeMemory();\n+    return (int) (mem >> 10);\n+  }\n+\n+  /**\n+   * Get the free memory in KB.\n+   * This method possibly calls System.gc().\n+   *\n+   * @return the free memory\n+   */\n+  public static int getMemoryFree() {\n+    collectGarbage();\n+    Runtime rt = Runtime.getRuntime();\n+    long mem = rt.freeMemory();\n+    return (int) (mem >> 10);\n+  }\n+\n+  /**\n+   * Get the maximum memory in KB.\n+   *\n+   * @return the maximum memory\n+   */\n+  public static long getMemoryMax() {\n+    long max = Runtime.getRuntime().maxMemory();\n+    return max / 1024;\n+  }\n+\n+  public static long getGarbageCollectionTime() {\n+    long totalGCTime = 0;\n+    for (GarbageCollectorMXBean gcMXBean : ManagementFactory\n+        .getGarbageCollectorMXBeans()) {\n+      long collectionTime = gcMXBean.getCollectionTime();\n+      if (collectionTime > 0) {\n+        totalGCTime += collectionTime;\n+      }\n+    }\n+    return totalGCTime;\n+  }\n+\n+  private static synchronized void collectGarbage() {\n+    Runtime runtime = Runtime.getRuntime();\n+    long total = runtime.totalMemory();\n+    long time = System.nanoTime();\n+    if (lastGC + TimeUnit.MILLISECONDS.toNanos(GC_DELAY) < time) {\n+      for (int i = 0; i < MAX_GC; i++) {\n+        runtime.gc();\n+        long now = runtime.totalMemory();\n+        if (now == total) {\n+          lastGC = System.nanoTime();\n+          break;\n+        }\n+        total = now;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create an int array with the given size.\n+   *\n+   * @param len the number of bytes requested\n+   * @return the int array\n+   */\n+  public static int[] newIntArray(int len) {\n+    if (len == 0) {\n+      return EMPTY_INT_ARRAY;\n+    }\n+    return new int[len];\n+  }\n+\n+  /**\n+   * Create a long array with the given size.\n+   *\n+   * @param len the number of bytes requested\n+   * @return the int array\n+   */\n+  public static long[] newLongArray(int len) {\n+    if (len == 0) {\n+      return EMPTY_LONG_ARRAY;\n+    }\n+    return new long[len];\n+  }\n+\n+  /**\n+   * Find the top limit values using given comparator and place them as in a\n+   * full array sort, in descending order.\n+   *\n+   * @param array  the array.\n+   * @param offset the offset.\n+   * @param limit  the limit.\n+   * @param comp   the comparator.\n+   */\n+  public static <X> void sortTopN(X[] array, int offset, int limit,\n+                                  Comparator<? super X> comp) {\n+    partitionTopN(array, offset, limit, comp);\n+    Arrays.sort(array, offset,\n+        (int) Math.min((long) offset + limit, array.length), comp);\n+  }\n+\n+  /**\n+   * Find the top limit values using given comparator and place them as in a\n+   * full array sort. This method does not sort the top elements themselves.\n+   *\n+   * @param array  the array\n+   * @param offset the offset\n+   * @param limit  the limit\n+   * @param comp   the comparator\n+   */\n+  private static <X> void partitionTopN(X[] array, int offset, int limit,\n+                                        Comparator<? super X> comp) {\n+    partialQuickSort(array, 0, array.length - 1, comp, offset, offset +\n+        limit - 1);\n+  }\n+\n+  private static <X> void partialQuickSort(X[] array, int low, int high,\n+                                           Comparator<? super X> comp,\n+                                           int start, int end) {\n+    if (low > end || high < start || (low > start && high < end)) {\n+      return;\n+    }\n+    if (low == high) {\n+      return;\n+    }\n+    int i = low, j = high;\n+    // use a random pivot to protect against\n+    // the worst case order\n+    int p = low + MathUtils.randomInt(high - low);\n+    X pivot = array[p];\n+    int m = (low + high) >>> 1;\n+    X temp = array[m];\n+    array[m] = pivot;\n+    array[p] = temp;\n+    while (i <= j) {\n+      while (comp.compare(array[i], pivot) < 0) {\n+        i++;\n+      }\n+      while (comp.compare(array[j], pivot) > 0) {\n+        j--;\n+      }\n+      if (i <= j) {\n+        temp = array[i];\n+        array[i++] = array[j];\n+        array[j--] = temp;\n+      }\n+    }\n+    if (low < j) {\n+      partialQuickSort(array, low, j, comp, start, end);\n+    }\n+    if (i < high) {\n+      partialQuickSort(array, i, high, comp, start, end);\n+    }\n+  }\n+\n+  /**\n+   * Checks if given classes have a common Comparable superclass.\n+   *\n+   * @param c1 the first class\n+   * @param c2 the second class\n+   * @return true if they have\n+   */\n+  public static boolean haveCommonComparableSuperclass(\n+      Class<?> c1, Class<?> c2) {\n+    if (c1 == c2 || c1.isAssignableFrom(c2) || c2.isAssignableFrom(c1)) {\n+      return true;\n+    }\n+    Class<?> top1;\n+    do {\n+      top1 = c1;\n+      c1 = c1.getSuperclass();\n+    } while (Comparable.class.isAssignableFrom(c1));\n+\n+    Class<?> top2;\n+    do {\n+      top2 = c2;\n+      c2 = c2.getSuperclass();\n+    } while (Comparable.class.isAssignableFrom(c2));\n+\n+    return top1 == top2;\n+  }\n+\n+  /**\n+   * Get a resource from the resource map.\n+   *\n+   * @param name the name of the resource\n+   * @return the resource data\n+   */\n+  public static byte[] getResource(String name) throws IOException {\n+    byte[] data = RESOURCES.get(name);\n+    if (data == null) {\n+      data = loadResource(name);\n+      if (data != null) {\n+        RESOURCES.put(name, data);\n+      }\n+    }\n+    return data;\n+  }\n+\n+  private static byte[] loadResource(String name) throws IOException {\n+    InputStream in = Utils.class.getResourceAsStream(\"data.zip\");\n+    if (in == null) {\n+      in = Utils.class.getResourceAsStream(name);\n+      if (in == null) {\n         return null;\n-    }\n-\n-    /**\n-     * Calls a static method via reflection. This will try to use the method\n-     * where the most parameter classes match exactly (this algorithm is simpler\n-     * than the one in the Java specification, but works well for most cases).\n+      }\n+      return IOUtils.readBytesAndClose(in, 0);\n+    }\n+\n+    try (ZipInputStream zipIn = new ZipInputStream(in)) {\n+      while (true) {\n+        ZipEntry entry = zipIn.getNextEntry();\n+        if (entry == null) {\n+          break;\n+        }\n+        String entryName = entry.getName();\n+        if (!entryName.startsWith(\"/\")) {\n+          entryName = \"/\" + entryName;\n+        }\n+        if (entryName.equals(name)) {\n+          ByteArrayOutputStream out = new ByteArrayOutputStream();\n+          IOUtils.copy(zipIn, out);\n+          zipIn.closeEntry();\n+          return out.toByteArray();\n+        }\n+        zipIn.closeEntry();\n+      }\n+    } catch (IOException e) {\n+      // if this happens we have a real problem\n+      e.printStackTrace();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Calls a static method via reflection. This will try to use the method\n+   * where the most parameter classes match exactly (this algorithm is simpler\n+   * than the one in the Java specification, but works well for most cases).\n+   *\n+   * @param classAndMethod a string with the entire class and method name, eg.\n+   *                       \"java.lang.System.gc\"\n+   * @param params         the method parameters\n+   * @return the return value from this call\n+   */\n+  public static Object callStaticMethod(String classAndMethod,\n+                                        Object... params) throws Exception {\n+    int lastDot = classAndMethod.lastIndexOf('.');\n+    String className = classAndMethod.substring(0, lastDot);\n+    String methodName = classAndMethod.substring(lastDot + 1);\n+    return callMethod(null, Class.forName(className), methodName, params);\n+  }\n+\n+  /**\n+   * Calls an instance method via reflection. This will try to use the method\n+   * where the most parameter classes match exactly (this algorithm is simpler\n+   * than the one in the Java specification, but works well for most cases).\n+   *\n+   * @param instance   the instance on which the call is done\n+   * @param methodName a string with the method name\n+   * @param params     the method parameters\n+   * @return the return value from this call\n+   */\n+  public static Object callMethod(\n+      Object instance,\n+      String methodName,\n+      Object... params) throws Exception {\n+    return callMethod(instance, instance.getClass(), methodName, params);\n+  }\n+\n+  private static Object callMethod(\n+      Object instance, Class<?> clazz,\n+      String methodName,\n+      Object... params) throws Exception {\n+    Method best = null;\n+    int bestMatch = 0;\n+    boolean isStatic = instance == null;\n+    for (Method m : clazz.getMethods()) {\n+      if (Modifier.isStatic(m.getModifiers()) == isStatic &&\n+          m.getName().equals(methodName)) {\n+        int p = match(m.getParameterTypes(), params);\n+        if (p > bestMatch) {\n+          bestMatch = p;\n+          best = m;\n+        }\n+      }\n+    }\n+    if (best == null) {\n+      throw new NoSuchMethodException(methodName);\n+    }\n+    return best.invoke(instance, params);\n+  }\n+\n+  /**\n+   * Creates a new instance. This will try to use the constructor where the\n+   * most parameter classes match exactly (this algorithm is simpler than the\n+   * one in the Java specification, but works well for most cases).\n+   *\n+   * @param className a string with the entire class, eg. \"java.lang.Integer\"\n+   * @param params    the constructor parameters\n+   * @return the newly created object\n+   */\n+  public static Object newInstance(String className, Object... params)\n+      throws Exception {\n+    Constructor<?> best = null;\n+    int bestMatch = 0;\n+    for (Constructor<?> c : Class.forName(className).getConstructors()) {\n+      int p = match(c.getParameterTypes(), params);\n+      if (p > bestMatch) {\n+        bestMatch = p;\n+        best = c;\n+      }\n+    }\n+    if (best == null) {\n+      throw new NoSuchMethodException(className);\n+    }\n+    return best.newInstance(params);\n+  }\n+\n+  private static int match(Class<?>[] params, Object[] values) {\n+    int len = params.length;\n+    if (len == values.length) {\n+      int points = 1;\n+      for (int i = 0; i < len; i++) {\n+        Class<?> pc = getNonPrimitiveClass(params[i]);\n+        Object v = values[i];\n+        Class<?> vc = v == null ? null : v.getClass();\n+        if (pc == vc) {\n+          points++;\n+        } else if (vc == null) {\n+          // can't verify\n+        } else if (!pc.isAssignableFrom(vc)) {\n+          return 0;\n+        }\n+      }\n+      return points;\n+    }\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns a static field.\n+   *\n+   * @param classAndField a string with the entire class and field name\n+   * @return the field value\n+   */\n+  public static Object getStaticField(String classAndField) throws Exception {\n+    int lastDot = classAndField.lastIndexOf('.');\n+    String className = classAndField.substring(0, lastDot);\n+    String fieldName = classAndField.substring(lastDot + 1);\n+    return Class.forName(className).getField(fieldName).get(null);\n+  }\n+\n+  /**\n+   * Returns a static field.\n+   *\n+   * @param instance  the instance on which the call is done\n+   * @param fieldName the field name\n+   * @return the field value\n+   */\n+  public static Object getField(Object instance, String fieldName)\n+      throws Exception {\n+    return instance.getClass().getField(fieldName).get(instance);\n+  }\n+\n+  /**\n+   * Returns true if the class is present in the current class loader.\n+   *\n+   * @param fullyQualifiedClassName a string with the entire class name, eg.\n+   *                                \"java.lang.System\"\n+   * @return true if the class is present\n+   */\n+  public static boolean isClassPresent(String fullyQualifiedClassName) {\n+    try {\n+      Class.forName(fullyQualifiedClassName);\n+      return true;\n+    } catch (ClassNotFoundException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Convert primitive class names to java.lang.* class names.\n+   *\n+   * @param clazz the class (for example: int)\n+   * @return the non-primitive class (for example: java.lang.Integer)\n+   */\n+  public static Class<?> getNonPrimitiveClass(Class<?> clazz) {\n+    if (!clazz.isPrimitive()) {\n+      return clazz;\n+    } else if (clazz == boolean.class) {\n+      return Boolean.class;\n+    } else if (clazz == byte.class) {\n+      return Byte.class;\n+    } else if (clazz == char.class) {\n+      return Character.class;\n+    } else if (clazz == double.class) {\n+      return Double.class;\n+    } else if (clazz == float.class) {\n+      return Float.class;\n+    } else if (clazz == int.class) {\n+      return Integer.class;\n+    } else if (clazz == long.class) {\n+      return Long.class;\n+    } else if (clazz == short.class) {\n+      return Short.class;\n+    } else if (clazz == void.class) {\n+      return Void.class;\n+    }\n+    return clazz;\n+  }\n+\n+  /**\n+   * Parses the specified string to boolean value.\n+   *\n+   * @param value          string to parse\n+   * @param defaultValue   value to return if value is null or on parsing error\n+   * @param throwException throw exception on parsing error or return default value instead\n+   * @return parsed or default value\n+   * @throws IllegalArgumentException on parsing error if {@code throwException} is true\n+   */\n+  public static boolean parseBoolean(String value, boolean defaultValue,\n+                                     boolean throwException) {\n+    if (value == null) {\n+      return defaultValue;\n+    }\n+    if (value.equalsIgnoreCase(\"true\") || value.equals(\"1\")) {\n+      return true;\n+    }\n+    if (value.equalsIgnoreCase(\"false\") || value.equals(\"0\")) {\n+      return false;\n+    }\n+    if (throwException) {\n+      throw new IllegalArgumentException(value);\n+    }\n+    return defaultValue;\n+  }\n+\n+  /**\n+   * Get the system property. If the system property is not set, or if a\n+   * security exception occurs, the default value is returned.\n+   *\n+   * @param key          the key\n+   * @param defaultValue the default value\n+   * @return the value\n+   */\n+  public static String getProperty(String key, String defaultValue) {\n+    try {\n+      return System.getProperty(key, defaultValue);\n+    } catch (SecurityException se) {\n+      return defaultValue;\n+    }\n+  }\n+\n+  /**\n+   * Get the system property. If the system property is not set, or if a\n+   * security exception occurs, the default value is returned.\n+   *\n+   * @param key          the key\n+   * @param defaultValue the default value\n+   * @return the value\n+   */\n+  public static int getProperty(String key, int defaultValue) {\n+    String s = getProperty(key, null);\n+    if (s != null) {\n+      try {\n+        return Integer.decode(s);\n+      } catch (NumberFormatException e) {\n+        // ignore\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  /**\n+   * Get the system property. If the system property is not set, or if a\n+   * security exception occurs, the default value is returned.\n+   *\n+   * @param key          the key\n+   * @param defaultValue the default value\n+   * @return the value\n+   */\n+  public static boolean getProperty(String key, boolean defaultValue) {\n+    return parseBoolean(getProperty(key, null), defaultValue, false);\n+  }\n+\n+  /**\n+   * Scale the value with the available memory. If 1 GB of RAM is available,\n+   * the value is returned, if 2 GB are available, then twice the value, and\n+   * so on.\n+   *\n+   * @param value the value to scale\n+   * @return the scaled value\n+   */\n+  public static int scaleForAvailableMemory(int value) {\n+    long maxMemory = Runtime.getRuntime().maxMemory();\n+    if (maxMemory != Long.MAX_VALUE) {\n+      // we are limited by an -XmX parameter\n+      return (int) (value * maxMemory / (1024 * 1024 * 1024));\n+    }\n+    try {\n+      OperatingSystemMXBean mxBean = ManagementFactory\n+          .getOperatingSystemMXBean();\n+      // this method is only available on the class\n+      // com.sun.management.OperatingSystemMXBean, which mxBean\n+      // is an instance of under the Oracle JDK, but it is not present on\n+      // Android and other JDK's\n+      Method method = Class.forName(\n+          \"com.sun.management.OperatingSystemMXBean\").\n+          getMethod(\"getTotalPhysicalMemorySize\");\n+      long physicalMemorySize = ((Number) method.invoke(mxBean)).longValue();\n+      return (int) (value * physicalMemorySize / (1024 * 1024 * 1024));\n+    } catch (Exception e) {\n+      // ignore\n+    }\n+    return value;\n+  }\n+\n+  /**\n+   * The utility methods will try to use the provided class factories to\n+   * convert binary name of class to Class object. Used by H2 OSGi Activator\n+   * in order to provide a class from another bundle ClassLoader.\n+   */\n+  public interface ClassFactory {\n+\n+    /**\n+     * Check whether the factory can return the named class.\n      *\n-     * @param classAndMethod a string with the entire class and method name, eg.\n-     *            \"java.lang.System.gc\"\n-     * @param params the method parameters\n-     * @return the return value from this call\n+     * @param name the binary name of the class\n+     * @return true if this factory can return a valid class for the\n+     * provided class name\n      */\n-    public static Object callStaticMethod(String classAndMethod,\n-            Object... params) throws Exception {\n-        int lastDot = classAndMethod.lastIndexOf('.');\n-        String className = classAndMethod.substring(0, lastDot);\n-        String methodName = classAndMethod.substring(lastDot + 1);\n-        return callMethod(null, Class.forName(className), methodName, params);\n-    }\n+    boolean match(String name);\n \n     /**\n-     * Calls an instance method via reflection. This will try to use the method\n-     * where the most parameter classes match exactly (this algorithm is simpler\n-     * than the one in the Java specification, but works well for most cases).\n+     * Load the class.\n      *\n-     * @param instance the instance on which the call is done\n-     * @param methodName a string with the method name\n-     * @param params the method parameters\n-     * @return the return value from this call\n-     */\n-    public static Object callMethod(\n-            Object instance,\n-            String methodName,\n-            Object... params) throws Exception {\n-        return callMethod(instance, instance.getClass(), methodName, params);\n-    }\n-\n-    private static Object callMethod(\n-            Object instance, Class<?> clazz,\n-            String methodName,\n-            Object... params) throws Exception {\n-        Method best = null;\n-        int bestMatch = 0;\n-        boolean isStatic = instance == null;\n-        for (Method m : clazz.getMethods()) {\n-            if (Modifier.isStatic(m.getModifiers()) == isStatic &&\n-                    m.getName().equals(methodName)) {\n-                int p = match(m.getParameterTypes(), params);\n-                if (p > bestMatch) {\n-                    bestMatch = p;\n-                    best = m;\n-                }\n-            }\n-        }\n-        if (best == null) {\n-            throw new NoSuchMethodException(methodName);\n-        }\n-        return best.invoke(instance, params);\n-    }\n-\n-    /**\n-     * Creates a new instance. This will try to use the constructor where the\n-     * most parameter classes match exactly (this algorithm is simpler than the\n-     * one in the Java specification, but works well for most cases).\n-     *\n-     * @param className a string with the entire class, eg. \"java.lang.Integer\"\n-     * @param params the constructor parameters\n-     * @return the newly created object\n-     */\n-    public static Object newInstance(String className, Object... params)\n-            throws Exception {\n-        Constructor<?> best = null;\n-        int bestMatch = 0;\n-        for (Constructor<?> c : Class.forName(className).getConstructors()) {\n-            int p = match(c.getParameterTypes(), params);\n-            if (p > bestMatch) {\n-                bestMatch = p;\n-                best = c;\n-            }\n-        }\n-        if (best == null) {\n-            throw new NoSuchMethodException(className);\n-        }\n-        return best.newInstance(params);\n-    }\n-\n-    private static int match(Class<?>[] params, Object[] values) {\n-        int len = params.length;\n-        if (len == values.length) {\n-            int points = 1;\n-            for (int i = 0; i < len; i++) {\n-                Class<?> pc = getNonPrimitiveClass(params[i]);\n-                Object v = values[i];\n-                Class<?> vc = v == null ? null : v.getClass();\n-                if (pc == vc) {\n-                    points++;\n-                } else if (vc == null) {\n-                    // can't verify\n-                } else if (!pc.isAssignableFrom(vc)) {\n-                    return 0;\n-                }\n-            }\n-            return points;\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns a static field.\n-     *\n-     * @param classAndField a string with the entire class and field name\n-     * @return the field value\n-     */\n-    public static Object getStaticField(String classAndField) throws Exception {\n-        int lastDot = classAndField.lastIndexOf('.');\n-        String className = classAndField.substring(0, lastDot);\n-        String fieldName = classAndField.substring(lastDot + 1);\n-        return Class.forName(className).getField(fieldName).get(null);\n-    }\n-\n-    /**\n-     * Returns a static field.\n-     *\n-     * @param instance the instance on which the call is done\n-     * @param fieldName the field name\n-     * @return the field value\n-     */\n-    public static Object getField(Object instance, String fieldName)\n-            throws Exception {\n-        return instance.getClass().getField(fieldName).get(instance);\n-    }\n-\n-    /**\n-     * Returns true if the class is present in the current class loader.\n-     *\n-     * @param fullyQualifiedClassName a string with the entire class name, eg.\n-     *        \"java.lang.System\"\n-     * @return true if the class is present\n-     */\n-    public static boolean isClassPresent(String fullyQualifiedClassName) {\n-        try {\n-            Class.forName(fullyQualifiedClassName);\n-            return true;\n-        } catch (ClassNotFoundException e) {\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Convert primitive class names to java.lang.* class names.\n-     *\n-     * @param clazz the class (for example: int)\n-     * @return the non-primitive class (for example: java.lang.Integer)\n-     */\n-    public static Class<?> getNonPrimitiveClass(Class<?> clazz) {\n-        if (!clazz.isPrimitive()) {\n-            return clazz;\n-        } else if (clazz == boolean.class) {\n-            return Boolean.class;\n-        } else if (clazz == byte.class) {\n-            return Byte.class;\n-        } else if (clazz == char.class) {\n-            return Character.class;\n-        } else if (clazz == double.class) {\n-            return Double.class;\n-        } else if (clazz == float.class) {\n-            return Float.class;\n-        } else if (clazz == int.class) {\n-            return Integer.class;\n-        } else if (clazz == long.class) {\n-            return Long.class;\n-        } else if (clazz == short.class) {\n-            return Short.class;\n-        } else if (clazz == void.class) {\n-            return Void.class;\n-        }\n-        return clazz;\n-    }\n-\n-    /**\n-     * Parses the specified string to boolean value.\n-     *\n-     * @param value\n-     *            string to parse\n-     * @param defaultValue\n-     *            value to return if value is null or on parsing error\n-     * @param throwException\n-     *            throw exception on parsing error or return default value instead\n-     * @return parsed or default value\n-     * @throws IllegalArgumentException\n-     *             on parsing error if {@code throwException} is true\n-     */\n-    public static boolean parseBoolean(String value, boolean defaultValue, boolean throwException) {\n-        if (value == null) {\n-            return defaultValue;\n-        }\n-        if (value.equalsIgnoreCase(\"true\") || value.equals(\"1\")) {\n-            return true;\n-        }\n-        if (value.equalsIgnoreCase(\"false\") || value.equals(\"0\")) {\n-            return false;\n-        }\n-        if (throwException) {\n-            throw new IllegalArgumentException(value);\n-        }\n-        return defaultValue;\n-    }\n-\n-    /**\n-     * Get the system property. If the system property is not set, or if a\n-     * security exception occurs, the default value is returned.\n-     *\n-     * @param key the key\n-     * @param defaultValue the default value\n-     * @return the value\n-     */\n-    public static String getProperty(String key, String defaultValue) {\n-        try {\n-            return System.getProperty(key, defaultValue);\n-        } catch (SecurityException se) {\n-            return defaultValue;\n-        }\n-    }\n-\n-    /**\n-     * Get the system property. If the system property is not set, or if a\n-     * security exception occurs, the default value is returned.\n-     *\n-     * @param key the key\n-     * @param defaultValue the default value\n-     * @return the value\n-     */\n-    public static int getProperty(String key, int defaultValue) {\n-        String s = getProperty(key, null);\n-        if (s != null) {\n-            try {\n-                return Integer.decode(s);\n-            } catch (NumberFormatException e) {\n-                // ignore\n-            }\n-        }\n-        return defaultValue;\n-    }\n-\n-    /**\n-     * Get the system property. If the system property is not set, or if a\n-     * security exception occurs, the default value is returned.\n-     *\n-     * @param key the key\n-     * @param defaultValue the default value\n-     * @return the value\n-     */\n-    public static boolean getProperty(String key, boolean defaultValue) {\n-        return parseBoolean(getProperty(key, null), defaultValue, false);\n-    }\n-\n-    /**\n-     * Scale the value with the available memory. If 1 GB of RAM is available,\n-     * the value is returned, if 2 GB are available, then twice the value, and\n-     * so on.\n-     *\n-     * @param value the value to scale\n-     * @return the scaled value\n-     */\n-    public static int scaleForAvailableMemory(int value) {\n-        long maxMemory = Runtime.getRuntime().maxMemory();\n-        if (maxMemory != Long.MAX_VALUE) {\n-            // we are limited by an -XmX parameter\n-            return (int) (value * maxMemory / (1024 * 1024 * 1024));\n-        }\n-        try {\n-            OperatingSystemMXBean mxBean = ManagementFactory\n-                    .getOperatingSystemMXBean();\n-            // this method is only available on the class\n-            // com.sun.management.OperatingSystemMXBean, which mxBean\n-            // is an instance of under the Oracle JDK, but it is not present on\n-            // Android and other JDK's\n-            Method method = Class.forName(\n-                    \"com.sun.management.OperatingSystemMXBean\").\n-                    getMethod(\"getTotalPhysicalMemorySize\");\n-            long physicalMemorySize = ((Number) method.invoke(mxBean)).longValue();\n-            return (int) (value * physicalMemorySize / (1024 * 1024 * 1024));\n-        } catch (Exception e) {\n-            // ignore\n-        }\n-        return value;\n-    }\n-\n-    /**\n-     * The utility methods will try to use the provided class factories to\n-     * convert binary name of class to Class object. Used by H2 OSGi Activator\n-     * in order to provide a class from another bundle ClassLoader.\n-     */\n-    public interface ClassFactory {\n-\n-        /**\n-         * Check whether the factory can return the named class.\n-         *\n-         * @param name the binary name of the class\n-         * @return true if this factory can return a valid class for the\n-         *         provided class name\n-         */\n-        boolean match(String name);\n-\n-        /**\n-         * Load the class.\n-         *\n-         * @param name the binary name of the class\n-         * @return the class object\n-         * @throws ClassNotFoundException If the class is not handle by this\n-         *             factory\n-         */\n-        Class<?> loadClass(String name)\n-                throws ClassNotFoundException;\n-    }\n+     * @param name the binary name of the class\n+     * @return the class object\n+     * @throws ClassNotFoundException If the class is not handle by this\n+     *                                factory\n+     */\n+    Class<?> loadClass(String name)\n+        throws ClassNotFoundException;\n+  }\n }\n",
            "diff_size": 1062
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/694/Utils.java\nindex d065fd4809..3bd4708ed8 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/694/Utils.java\n@@ -267,7 +267,7 @@ public class Utils {\n         long totalGCTime = 0;\n         for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n             long collectionTime = gcMXBean.getCollectionTime();\n-            if(collectionTime > 0) {\n+            if (collectionTime > 0) {\n                 totalGCTime += collectionTime;\n             }\n         }\n@@ -778,4 +778,4 @@ public class Utils {\n         Class<?> loadClass(String name)\n                 throws ClassNotFoundException;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/694/Utils.java\nindex d065fd4809..bec5a299c3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/694/Utils.java\n@@ -24,31 +24,36 @@ import java.util.zip.ZipInputStream;\n /**\n  * This utility class contains miscellaneous functions.\n  */\n+\n+\n public class Utils {\n \n     /**\n      * An 0-size byte array.\n      */\n+\n+\n     public static final byte[] EMPTY_BYTES = {};\n \n     /**\n      * An 0-size int array.\n      */\n+\n+\n     public static final int[] EMPTY_INT_ARRAY = {};\n \n     /**\n      * An 0-size long array.\n      */\n     private static final long[] EMPTY_LONG_ARRAY = {};\n-\n     private static final int GC_DELAY = 50;\n     private static final int MAX_GC = 8;\n     private static long lastGC;\n-\n-    private static final HashMap<String, byte[]> RESOURCES = new HashMap<>();\n+    private static final HashMap<String, byte[]> RESOURCES = new HashMap< >();\n \n     private Utils() {\n         // utility class\n+\n     }\n \n     /**\n@@ -62,6 +67,8 @@ public class Utils {\n      * @param start the start index from where to search\n      * @return the index\n      */\n+\n+\n     public static int indexOf(byte[] bytes, byte[] pattern, int start) {\n         if (pattern.length == 0) {\n             return start;\n@@ -89,6 +96,8 @@ public class Utils {\n      * @param value the byte array\n      * @return the hash code\n      */\n+\n+\n     public static int getByteArrayHash(byte[] value) {\n         int len = value.length;\n         int h = len;\n@@ -118,8 +127,11 @@ public class Utils {\n      * @param good the second array\n      * @return true if both byte arrays contain the same bytes\n      */\n+\n+\n     public static boolean compareSecure(byte[] test, byte[] good) {\n-        if ((test == null) || (good == null)) {\n+        if ((test == null) ||\n+                (good == null)) {\n             return (test == null) && (good == null);\n         }\n         int len = test.length;\n@@ -150,6 +162,8 @@ public class Utils {\n      * @param data2 the second byte array (must not be null)\n      * @return the result of the comparison (-1, 1 or 0)\n      */\n+\n+\n     public static int compareNotNullSigned(byte[] data1, byte[] data2) {\n         if (data1 == data2) {\n             return 0;\n@@ -177,6 +191,8 @@ public class Utils {\n      * @param data2 the second byte array (must not be null)\n      * @return the result of the comparison (-1, 1 or 0)\n      */\n+\n+\n     public static int compareNotNullUnsigned(byte[] data1, byte[] data2) {\n         if (data1 == data2) {\n             return 0;\n@@ -200,6 +216,8 @@ public class Utils {\n      * @param target the target array\n      * @return the target array or a new one if the target array was too small\n      */\n+\n+\n     public static byte[] copy(byte[] source, byte[] target) {\n         int len = source.length;\n         if (len > target.length) {\n@@ -216,6 +234,8 @@ public class Utils {\n      * @param b the byte array (may not be null)\n      * @return a new byte array\n      */\n+\n+\n     public static byte[] cloneByteArray(byte[] b) {\n         if (b == null) {\n             return null;\n@@ -233,6 +253,8 @@ public class Utils {\n      *\n      * @return the used memory\n      */\n+\n+\n     public static int getMemoryUsed() {\n         collectGarbage();\n         Runtime rt = Runtime.getRuntime();\n@@ -246,6 +268,8 @@ public class Utils {\n      *\n      * @return the free memory\n      */\n+\n+\n     public static int getMemoryFree() {\n         collectGarbage();\n         Runtime rt = Runtime.getRuntime();\n@@ -258,16 +282,19 @@ public class Utils {\n      *\n      * @return the maximum memory\n      */\n+\n+\n     public static long getMemoryMax() {\n         long max = Runtime.getRuntime().maxMemory();\n         return max / 1024;\n     }\n \n+\n     public static long getGarbageCollectionTime() {\n         long totalGCTime = 0;\n         for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n             long collectionTime = gcMXBean.getCollectionTime();\n-            if(collectionTime > 0) {\n+            if (collectionTime > 0) {\n                 totalGCTime += collectionTime;\n             }\n         }\n@@ -297,6 +324,8 @@ public class Utils {\n      * @param len the number of bytes requested\n      * @return the int array\n      */\n+\n+\n     public static int[] newIntArray(int len) {\n         if (len == 0) {\n             return EMPTY_INT_ARRAY;\n@@ -310,6 +339,8 @@ public class Utils {\n      * @param len the number of bytes requested\n      * @return the int array\n      */\n+\n+\n     public static long[] newLongArray(int len) {\n         if (len == 0) {\n             return EMPTY_LONG_ARRAY;\n@@ -326,11 +357,14 @@ public class Utils {\n      * @param limit the limit.\n      * @param comp the comparator.\n      */\n-    public static <X> void sortTopN(X[] array, int offset, int limit,\n-            Comparator<? super X> comp) {\n+\n+\n+    public static <X> void sortTopN(X[] array, int offset, int limit, Comparator<? super X> comp) {\n         partitionTopN(array, offset, limit, comp);\n-        Arrays.sort(array, offset,\n-                (int) Math.min((long) offset + limit, array.length), comp);\n+        Arrays.sort(array,\n+offset,\n+                    (int) Math.min((long) offset + limit, array.length),\n+comp);\n     }\n \n     /**\n@@ -342,15 +376,14 @@ public class Utils {\n      * @param limit the limit\n      * @param comp the comparator\n      */\n-    private static <X> void partitionTopN(X[] array, int offset, int limit,\n-            Comparator<? super X> comp) {\n-        partialQuickSort(array, 0, array.length - 1, comp, offset, offset +\n-                limit - 1);\n+\n+    private static <X> void partitionTopN(X[] array, int offset, int limit, Comparator<? super X> comp) {\n+        partialQuickSort(array, 0, array.length - 1, comp, offset, offset + limit - 1);\n     }\n \n-    private static <X> void partialQuickSort(X[] array, int low, int high,\n-            Comparator<? super X> comp, int start, int end) {\n-        if (low > end || high < start || (low > start && high < end)) {\n+    private static <X> void partialQuickSort(X[] array, int low, int high, Comparator<? super X> comp, int start, int end) {\n+        if (low > end || high < start ||\n+                (low > start && high < end)) {\n             return;\n         }\n         if (low == high) {\n@@ -393,8 +426,9 @@ public class Utils {\n      * @param c2 the second class\n      * @return true if they have\n      */\n-    public static boolean haveCommonComparableSuperclass(\n-            Class<?> c1, Class<?> c2) {\n+\n+\n+    public static boolean haveCommonComparableSuperclass(Class<?> c1, Class<?> c2) {\n         if (c1 == c2 || c1.isAssignableFrom(c2) || c2.isAssignableFrom(c1)) {\n             return true;\n         }\n@@ -403,13 +437,11 @@ public class Utils {\n             top1 = c1;\n             c1 = c1.getSuperclass();\n         } while (Comparable.class.isAssignableFrom(c1));\n-\n         Class<?> top2;\n         do {\n             top2 = c2;\n             c2 = c2.getSuperclass();\n         } while (Comparable.class.isAssignableFrom(c2));\n-\n         return top1 == top2;\n     }\n \n@@ -419,6 +451,8 @@ public class Utils {\n      * @param name the name of the resource\n      * @return the resource data\n      */\n+\n+\n     public static byte[] getResource(String name) throws IOException {\n         byte[] data = RESOURCES.get(name);\n         if (data == null) {\n@@ -439,7 +473,6 @@ public class Utils {\n             }\n             return IOUtils.readBytesAndClose(in, 0);\n         }\n-\n         try (ZipInputStream zipIn = new ZipInputStream(in)) {\n             while (true) {\n                 ZipEntry entry = zipIn.getNextEntry();\n@@ -475,8 +508,9 @@ public class Utils {\n      * @param params the method parameters\n      * @return the return value from this call\n      */\n-    public static Object callStaticMethod(String classAndMethod,\n-            Object... params) throws Exception {\n+\n+\n+    public static Object callStaticMethod(String classAndMethod, Object... params) throws Exception {\n         int lastDot = classAndMethod.lastIndexOf('.');\n         String className = classAndMethod.substring(0, lastDot);\n         String methodName = classAndMethod.substring(lastDot + 1);\n@@ -493,23 +527,18 @@ public class Utils {\n      * @param params the method parameters\n      * @return the return value from this call\n      */\n-    public static Object callMethod(\n-            Object instance,\n-            String methodName,\n-            Object... params) throws Exception {\n+\n+\n+    public static Object callMethod(Object instance, String methodName, Object... params) throws Exception {\n         return callMethod(instance, instance.getClass(), methodName, params);\n     }\n \n-    private static Object callMethod(\n-            Object instance, Class<?> clazz,\n-            String methodName,\n-            Object... params) throws Exception {\n+    private static Object callMethod(Object instance, Class<?> clazz, String methodName, Object... params) throws Exception {\n         Method best = null;\n         int bestMatch = 0;\n         boolean isStatic = instance == null;\n         for (Method m : clazz.getMethods()) {\n-            if (Modifier.isStatic(m.getModifiers()) == isStatic &&\n-                    m.getName().equals(methodName)) {\n+            if (Modifier.isStatic(m.getModifiers()) == isStatic && m.getName().equals(methodName)) {\n                 int p = match(m.getParameterTypes(), params);\n                 if (p > bestMatch) {\n                     bestMatch = p;\n@@ -532,8 +561,9 @@ public class Utils {\n      * @param params the constructor parameters\n      * @return the newly created object\n      */\n-    public static Object newInstance(String className, Object... params)\n-            throws Exception {\n+\n+\n+    public static Object newInstance(String className, Object... params) throws Exception {\n         Constructor<?> best = null;\n         int bestMatch = 0;\n         for (Constructor<?> c : Class.forName(className).getConstructors()) {\n@@ -561,9 +591,10 @@ public class Utils {\n                     points++;\n                 } else if (vc == null) {\n                     // can't verify\n+\n                 } else if (!pc.isAssignableFrom(vc)) {\n-                    return 0;\n-                }\n+                           return 0;\n+                       }\n             }\n             return points;\n         }\n@@ -576,6 +607,8 @@ public class Utils {\n      * @param classAndField a string with the entire class and field name\n      * @return the field value\n      */\n+\n+\n     public static Object getStaticField(String classAndField) throws Exception {\n         int lastDot = classAndField.lastIndexOf('.');\n         String className = classAndField.substring(0, lastDot);\n@@ -590,8 +623,9 @@ public class Utils {\n      * @param fieldName the field name\n      * @return the field value\n      */\n-    public static Object getField(Object instance, String fieldName)\n-            throws Exception {\n+\n+\n+    public static Object getField(Object instance, String fieldName) throws Exception {\n         return instance.getClass().getField(fieldName).get(instance);\n     }\n \n@@ -602,6 +636,8 @@ public class Utils {\n      *        \"java.lang.System\"\n      * @return true if the class is present\n      */\n+\n+\n     public static boolean isClassPresent(String fullyQualifiedClassName) {\n         try {\n             Class.forName(fullyQualifiedClassName);\n@@ -617,28 +653,30 @@ public class Utils {\n      * @param clazz the class (for example: int)\n      * @return the non-primitive class (for example: java.lang.Integer)\n      */\n+\n+\n     public static Class<?> getNonPrimitiveClass(Class<?> clazz) {\n         if (!clazz.isPrimitive()) {\n             return clazz;\n         } else if (clazz == boolean.class) {\n-            return Boolean.class;\n+        return Boolean.class;\n         } else if (clazz == byte.class) {\n-            return Byte.class;\n-        } else if (clazz == char.class) {\n+                                                                    return Byte.class;\n+               } else if (clazz == char.class) {\n             return Character.class;\n-        } else if (clazz == double.class) {\n+               } else if (clazz == double.class) {\n             return Double.class;\n-        } else if (clazz == float.class) {\n-            return Float.class;\n-        } else if (clazz == int.class) {\n-            return Integer.class;\n-        } else if (clazz == long.class) {\n-            return Long.class;\n-        } else if (clazz == short.class) {\n-            return Short.class;\n-        } else if (clazz == void.class) {\n-            return Void.class;\n-        }\n+                      } else if (clazz == float.class) {\n+                   return Float.class;\n+                      } else if (clazz == int.class) {\n+                   return Integer.class;\n+                             } else if (clazz == long.class) {\n+                          return Long.class;\n+                             } else if (clazz == short.class) {\n+                          return Short.class;\n+                                    } else if (clazz == void.class) {\n+                                        return Void.class;\n+                                    }\n         return clazz;\n     }\n \n@@ -655,6 +693,8 @@ public class Utils {\n      * @throws IllegalArgumentException\n      *             on parsing error if {@code throwException} is true\n      */\n+\n+\n     public static boolean parseBoolean(String value, boolean defaultValue, boolean throwException) {\n         if (value == null) {\n             return defaultValue;\n@@ -679,6 +719,8 @@ public class Utils {\n      * @param defaultValue the default value\n      * @return the value\n      */\n+\n+\n     public static String getProperty(String key, String defaultValue) {\n         try {\n             return System.getProperty(key, defaultValue);\n@@ -695,6 +737,8 @@ public class Utils {\n      * @param defaultValue the default value\n      * @return the value\n      */\n+\n+\n     public static int getProperty(String key, int defaultValue) {\n         String s = getProperty(key, null);\n         if (s != null) {\n@@ -702,6 +746,7 @@ public class Utils {\n                 return Integer.decode(s);\n             } catch (NumberFormatException e) {\n                 // ignore\n+\n             }\n         }\n         return defaultValue;\n@@ -715,6 +760,8 @@ public class Utils {\n      * @param defaultValue the default value\n      * @return the value\n      */\n+\n+\n     public static boolean getProperty(String key, boolean defaultValue) {\n         return parseBoolean(getProperty(key, null), defaultValue, false);\n     }\n@@ -727,6 +774,8 @@ public class Utils {\n      * @param value the value to scale\n      * @return the scaled value\n      */\n+\n+\n     public static int scaleForAvailableMemory(int value) {\n         long maxMemory = Runtime.getRuntime().maxMemory();\n         if (maxMemory != Long.MAX_VALUE) {\n@@ -734,19 +783,17 @@ public class Utils {\n             return (int) (value * maxMemory / (1024 * 1024 * 1024));\n         }\n         try {\n-            OperatingSystemMXBean mxBean = ManagementFactory\n-                    .getOperatingSystemMXBean();\n+            OperatingSystemMXBean mxBean = ManagementFactory.getOperatingSystemMXBean();\n             // this method is only available on the class\n             // com.sun.management.OperatingSystemMXBean, which mxBean\n             // is an instance of under the Oracle JDK, but it is not present on\n             // Android and other JDK's\n-            Method method = Class.forName(\n-                    \"com.sun.management.OperatingSystemMXBean\").\n-                    getMethod(\"getTotalPhysicalMemorySize\");\n+            Method method = Class.forName(\"com.sun.management.OperatingSystemMXBean\").getMethod(\"getTotalPhysicalMemorySize\");\n             long physicalMemorySize = ((Number) method.invoke(mxBean)).longValue();\n             return (int) (value * physicalMemorySize / (1024 * 1024 * 1024));\n         } catch (Exception e) {\n             // ignore\n+\n         }\n         return value;\n     }\n@@ -756,6 +803,8 @@ public class Utils {\n      * convert binary name of class to Class object. Used by H2 OSGi Activator\n      * in order to provide a class from another bundle ClassLoader.\n      */\n+\n+\n     public interface ClassFactory {\n \n         /**\n@@ -765,6 +814,8 @@ public class Utils {\n          * @return true if this factory can return a valid class for the\n          *         provided class name\n          */\n+\n+\n         boolean match(String name);\n \n         /**\n@@ -775,7 +826,10 @@ public class Utils {\n          * @throws ClassNotFoundException If the class is not handle by this\n          *             factory\n          */\n-        Class<?> loadClass(String name)\n-                throws ClassNotFoundException;\n+\n+\n+        Class<?> loadClass(String name) throws ClassNotFoundException;\n+\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 130
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/694/Utils.java\nindex d065fd4809..af7a529ce7 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/694/Utils.java\n@@ -267,7 +267,7 @@ public class Utils {\n         long totalGCTime = 0;\n         for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n             long collectionTime = gcMXBean.getCollectionTime();\n-            if(collectionTime > 0) {\n+            if (collectionTime > 0) {\n                 totalGCTime += collectionTime;\n             }\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/694/Utils.java\nindex d065fd4809..af7a529ce7 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/694/Utils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/694/Utils.java\n@@ -267,7 +267,7 @@ public class Utils {\n         long totalGCTime = 0;\n         for (GarbageCollectorMXBean gcMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n             long collectionTime = gcMXBean.getCollectionTime();\n-            if(collectionTime > 0) {\n+            if (collectionTime > 0) {\n                 totalGCTime += collectionTime;\n             }\n         }\n",
            "diff_size": 1
        }
    ]
}