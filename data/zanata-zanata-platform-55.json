{
    "error_id": "55",
    "information": {
        "errors": [
            {
                "line": "132",
                "column": "61",
                "severity": "error",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "            zanataIdentity.tryLogin();\n        } else if (!allowAnonymousAccessProvider.get() ||\n                !HttpUtil.isReadMethod(context.getMethod())){\n            // special cases for path such as '/test/' or '/oauth/' are now\n            // handled by having annotation @NoSecurityCheck on those API\n            // methods/classes. ZanataRestSecurityBinder will ensure that this",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler/55/ZanataRestSecurityInterceptor.java\nindex 3ee0513e59..66af909748 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler/55/ZanataRestSecurityInterceptor.java\n@@ -129,7 +129,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // here the tryLogin() will just set up the correct system state\n             zanataIdentity.tryLogin();\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/intellij/55/ZanataRestSecurityInterceptor.java\nindex 3ee0513e59..f20d317d53 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/intellij/55/ZanataRestSecurityInterceptor.java\n@@ -61,7 +61,7 @@ import com.google.common.base.MoreObjects;\n @ApplicationScoped\n public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n     private static final Logger log =\n-            LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n+        LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n     private HttpServletRequest request;\n \n     private SecurityTokens securityTokens;\n@@ -79,9 +79,9 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n     @Inject\n     protected ZanataRestSecurityInterceptor(@DeltaSpike HttpServletRequest request,\n-            SecurityTokens securityTokens, ZanataIdentity zanataIdentity,\n-            @SupportOAuth boolean isOAuthEnabled, IServiceLocator serviceLocator,\n-            @AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n+                                            SecurityTokens securityTokens, ZanataIdentity zanataIdentity,\n+                                            @SupportOAuth boolean isOAuthEnabled, IServiceLocator serviceLocator,\n+                                            @AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n         this.request = request;\n         this.securityTokens = securityTokens;\n         this.zanataIdentity = zanataIdentity;\n@@ -92,7 +92,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n     @Override\n     public void filter(ContainerRequestContext context)\n-            throws IOException {\n+        throws IOException {\n         if (hasAuthenticatedAccount()) {\n             // request come from the same browser and the user has logged in\n             return;\n@@ -106,14 +106,14 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             zanataIdentity.setApiKey(restCredentials.apiKey.get());\n             zanataIdentity.tryLogin();\n             if (!SecurityFunctions.canAccessRestPath(zanataIdentity,\n-                    context.getUriInfo().getPath())) {\n+                context.getUriInfo().getPath())) {\n                 String message = InvalidApiKeyUtil\n-                        .getMessage(restCredentials.username.get(),\n-                                restCredentials.apiKey.get());\n+                    .getMessage(restCredentials.username.get(),\n+                        restCredentials.apiKey.get());\n                 log.info(\"can not authenticate REST request: {}\", message);\n                 context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                        .entity(message)\n-                        .build());\n+                    .entity(message)\n+                    .build());\n             }\n         } else if (restCredentials.hasOAuthToken()) {\n             Either<Response, String> usernameOrError =\n@@ -129,7 +129,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // here the tryLogin() will just set up the correct system state\n             zanataIdentity.tryLogin();\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+            !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n@@ -140,9 +140,9 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // requesting API does NOT allow anonymous access\n             log.info(\"can not authenticate REST request: {}\", restCredentials);\n             context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                    .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n-                    .entity(\"User authentication required for REST request\")\n-                    .build());\n+                .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n+                .entity(\"User authentication required for REST request\")\n+                .build());\n         }\n     }\n \n@@ -150,17 +150,17 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n         Optional<String> usernameOpt;\n         Optional<String> accessTokenOpt =\n-                OAuthUtil.getAccessTokenFromHeader(request);\n+            OAuthUtil.getAccessTokenFromHeader(request);\n         usernameOpt = accessTokenOpt.flatMap(\n-                token -> securityTokens.findUsernameByAccessToken(token));\n+            token -> securityTokens.findUsernameByAccessToken(token));\n \n         if (!usernameOpt.isPresent()) {\n             log.info(\n-                    \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n-                    accessTokenOpt);\n+                \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n+                accessTokenOpt);\n             return Either.left(buildUnauthorizedResponse(\n-                    \"Bad OAuth request, invalid or expired tokens: access token [\" +\n-                            accessTokenOpt + \"]\"));\n+                \"Bad OAuth request, invalid or expired tokens: access token [\" +\n+                    accessTokenOpt + \"]\"));\n         }\n         String username = usernameOpt.get();\n         return Either.right(username);\n@@ -170,15 +170,15 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n         OAuthResponse oauthResponse = null;\n         try {\n             oauthResponse = OAuthRSResponse\n-                    .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n-                    .buildHeaderMessage();\n+                .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n+                .buildHeaderMessage();\n         } catch (OAuthSystemException e1) {\n             return buildServerErrorResponse(message);\n         }\n \n         return Response\n-                .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n-                        OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n+            .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n+                OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n     }\n \n     private Response buildServerErrorResponse(String message) {\n@@ -187,8 +187,8 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n     private boolean hasAuthenticatedAccount() {\n         return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n+            .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n+            null;\n     }\n \n     /**\n@@ -201,7 +201,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n         private final Optional<String> accessToken;\n \n         RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n-                boolean isOAuthSupported) {\n+                        boolean isOAuthSupported) {\n             String username = HttpUtil.getUsername(context.getHeaders());\n             String apiKey = HttpUtil.getApiKey(context.getHeaders());\n             this.username = optionalNotEmptyString(username);\n@@ -215,8 +215,8 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n         private static Optional<String> optionalNotEmptyString(String value) {\n             return value == null || value.isEmpty() ?\n-                    Optional.empty() :\n-                    Optional.of(value);\n+                Optional.empty() :\n+                Optional.of(value);\n         }\n \n         boolean hasApiKey() {\n@@ -230,10 +230,10 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n         @Override\n         public String toString() {\n             return MoreObjects.toStringHelper(this)\n-                    .add(\"username\", username)\n-                    .add(\"apiKey\", apiKey)\n-                    .add(\"accessToken\", accessToken)\n-                    .toString();\n+                .add(\"username\", username)\n+                .add(\"apiKey\", apiKey)\n+                .add(\"accessToken\", accessToken)\n+                .toString();\n         }\n     }\n \n@@ -251,11 +251,11 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n         @Override\n         public void configure(ResourceInfo resourceInfo,\n-                FeatureContext featureContext) {\n+                              FeatureContext featureContext) {\n             Class<?> clazz = resourceInfo.getResourceClass();\n             Method method = resourceInfo.getResourceMethod();\n             if (!method.isAnnotationPresent(NoSecurityCheck.class)\n-                    && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n+                && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n                 featureContext.register(securityInterceptor);\n             }\n         }\n",
            "diff_size": 35
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/naturalize/55/ZanataRestSecurityInterceptor.java\nindex 3ee0513e59..cc5a61b7b7 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/naturalize/55/ZanataRestSecurityInterceptor.java\n@@ -129,7 +129,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // here the tryLogin() will just set up the correct system state\n             zanataIdentity.tryLogin();\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n@@ -187,8 +187,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n     private boolean hasAuthenticatedAccount() {\n         return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n+                .getInstance(HAccount.class, new AuthenticatedLiteral()) != null;\n     }\n \n     /**\n@@ -260,4 +259,4 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/codebuff/55/ZanataRestSecurityInterceptor.java\nindex 3ee0513e59..285e73b323 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/codebuff/55/ZanataRestSecurityInterceptor.java\n@@ -17,7 +17,6 @@ import javax.ws.rs.core.FeatureContext;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.Response.Status;\n-\n import javaslang.control.Either;\n import org.apache.deltaspike.core.api.common.DeltaSpike;\n import org.apache.oltu.oauth2.common.OAuth;\n@@ -58,30 +57,28 @@ import com.google.common.base.MoreObjects;\n  * @see org.zanata.security.annotations.CheckLoggedIn\n  */\n // TODO rename this class to Filter since it's no longer a seam JAX-RS interceptor\n+\n+\n @ApplicationScoped\n public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n-    private static final Logger log =\n-            LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n+    private static final Logger log = LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n     private HttpServletRequest request;\n-\n     private SecurityTokens securityTokens;\n-\n     private ZanataIdentity zanataIdentity;\n-\n     private boolean isOAuthEnabled;\n     private IServiceLocator serviceLocator = ServiceLocator.instance();\n-\n     private Provider<Boolean> allowAnonymousAccessProvider;\n \n-\n     public ZanataRestSecurityInterceptor() {\n     }\n \n     @Inject\n     protected ZanataRestSecurityInterceptor(@DeltaSpike HttpServletRequest request,\n-            SecurityTokens securityTokens, ZanataIdentity zanataIdentity,\n-            @SupportOAuth boolean isOAuthEnabled, IServiceLocator serviceLocator,\n-            @AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n+SecurityTokens securityTokens,\n+ZanataIdentity zanataIdentity,\n+   @SupportOAuth boolean isOAuthEnabled,\n+IServiceLocator serviceLocator,\n+@AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n         this.request = request;\n         this.securityTokens = securityTokens;\n         this.zanataIdentity = zanataIdentity;\n@@ -91,33 +88,26 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n     }\n \n     @Override\n-    public void filter(ContainerRequestContext context)\n-            throws IOException {\n+    public void filter(ContainerRequestContext context) throws IOException {\n         if (hasAuthenticatedAccount()) {\n             // request come from the same browser and the user has logged in\n             return;\n         }\n-\n         RestCredentials restCredentials = new RestCredentials(context, request, isOAuthEnabled);\n-\n         if (restCredentials.hasApiKey()) {\n             // if apiKey presents, we use apiKey for security check\n             zanataIdentity.getCredentials().setUsername(restCredentials.username.get());\n             zanataIdentity.setApiKey(restCredentials.apiKey.get());\n             zanataIdentity.tryLogin();\n-            if (!SecurityFunctions.canAccessRestPath(zanataIdentity,\n-                    context.getUriInfo().getPath())) {\n-                String message = InvalidApiKeyUtil\n-                        .getMessage(restCredentials.username.get(),\n-                                restCredentials.apiKey.get());\n+            if (!SecurityFunctions.canAccessRestPath(zanataIdentity, context.getUriInfo().getPath())) {\n+                String message = InvalidApiKeyUtil.getMessage(restCredentials.username.get(),\n+                                                              restCredentials.apiKey.get());\n                 log.info(\"can not authenticate REST request: {}\", message);\n-                context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                        .entity(message)\n-                        .build());\n+                context.abortWith(Response.status(Status.UNAUTHORIZED).entity(message)\n+                                                                      .build());\n             }\n         } else if (restCredentials.hasOAuthToken()) {\n-            Either<Response, String> usernameOrError =\n-                getAuthenticatedUsernameOrError();\n+            Either<Response, String> usernameOrError = getAuthenticatedUsernameOrError();\n             if (usernameOrError.isLeft()) {\n                 context.abortWith(usernameOrError.getLeft());\n                 return;\n@@ -128,8 +118,8 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // login will always success since the check was done above\n             // here the tryLogin() will just set up the correct system state\n             zanataIdentity.tryLogin();\n-        } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+        } else if (!allowAnonymousAccessProvider.get()\n+                       || !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n@@ -138,29 +128,22 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n             // if we don't have any information to authenticate and the\n             // requesting API does NOT allow anonymous access\n-            log.info(\"can not authenticate REST request: {}\", restCredentials);\n-            context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                    .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n-                    .entity(\"User authentication required for REST request\")\n-                    .build());\n-        }\n+                   log.info(\"can not authenticate REST request: {}\",\n+restCredentials);\n+                   context.abortWith(Response.status(Status.UNAUTHORIZED).header(\"Content-Type\", MediaType.TEXT_PLAIN)\n+                                                                         .entity(\"User authentication required for REST request\")\n+                                                                         .build());\n+               }\n     }\n \n     private Either<Response, String> getAuthenticatedUsernameOrError() {\n-\n         Optional<String> usernameOpt;\n-        Optional<String> accessTokenOpt =\n-                OAuthUtil.getAccessTokenFromHeader(request);\n-        usernameOpt = accessTokenOpt.flatMap(\n-                token -> securityTokens.findUsernameByAccessToken(token));\n-\n+        Optional<String> accessTokenOpt = OAuthUtil.getAccessTokenFromHeader(request);\n+        usernameOpt = accessTokenOpt.flatMap(token -> securityTokens.findUsernameByAccessToken(token));\n         if (!usernameOpt.isPresent()) {\n-            log.info(\n-                    \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n-                    accessTokenOpt);\n-            return Either.left(buildUnauthorizedResponse(\n-                    \"Bad OAuth request, invalid or expired tokens: access token [\" +\n-                            accessTokenOpt + \"]\"));\n+            log.info(\"Bad OAuth request, invalid or expired tokens: access token: {}\",\n+accessTokenOpt);\n+            return Either.left(buildUnauthorizedResponse(\"Bad OAuth request, invalid or expired tokens: access token [\" + accessTokenOpt + \"]\"));\n         }\n         String username = usernameOpt.get();\n         return Either.right(username);\n@@ -169,39 +152,35 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n     private Response buildUnauthorizedResponse(String message) {\n         OAuthResponse oauthResponse = null;\n         try {\n-            oauthResponse = OAuthRSResponse\n-                    .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n-                    .buildHeaderMessage();\n+            oauthResponse = OAuthRSResponse.errorResponse(HttpServletResponse.SC_UNAUTHORIZED).buildHeaderMessage();\n         } catch (OAuthSystemException e1) {\n             return buildServerErrorResponse(message);\n         }\n-\n-        return Response\n-                .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n-                        OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n+        return Response.status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE,\n+            oauthResponse.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE))\n+                                                                 .build();\n     }\n \n     private Response buildServerErrorResponse(String message) {\n-        return Response.serverError().entity(message).build();\n+        return Response.serverError().entity(message)\n+                                     .build();\n     }\n \n     private boolean hasAuthenticatedAccount() {\n-        return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n+        return serviceLocator.getInstance(HAccount.class, new AuthenticatedLiteral()) != null;\n     }\n \n     /**\n      * Encapsulate all possible authentication values from a REST request.\n      */\n-    private static class RestCredentials {\n \n+    private static class RestCredentials {\n         private final Optional<String> username;\n         private final Optional<String> apiKey;\n         private final Optional<String> accessToken;\n \n         RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n-                boolean isOAuthSupported) {\n+        boolean isOAuthSupported) {\n             String username = HttpUtil.getUsername(context.getHeaders());\n             String apiKey = HttpUtil.getApiKey(context.getHeaders());\n             this.username = optionalNotEmptyString(username);\n@@ -214,9 +193,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n         }\n \n         private static Optional<String> optionalNotEmptyString(String value) {\n-            return value == null || value.isEmpty() ?\n-                    Optional.empty() :\n-                    Optional.of(value);\n+            return value == null || value.isEmpty() ? Optional.empty() : Optional.of(value);\n         }\n \n         boolean hasApiKey() {\n@@ -229,11 +206,10 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n         @Override\n         public String toString() {\n-            return MoreObjects.toStringHelper(this)\n-                    .add(\"username\", username)\n-                    .add(\"apiKey\", apiKey)\n-                    .add(\"accessToken\", accessToken)\n-                    .toString();\n+            return MoreObjects.toStringHelper(this).add(\"username\", username)\n+                                                   .add(\"apiKey\", apiKey)\n+                                                   .add(\"accessToken\", accessToken)\n+                                                   .toString();\n         }\n     }\n \n@@ -243,6 +219,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n      *\n      * @author Patrick Huang <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n      */\n+\n     @javax.ws.rs.ext.Provider\n     @PreMatching\n     public static class ZanataRestSecurityBinder implements DynamicFeature {\n@@ -250,14 +227,12 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n         private ZanataRestSecurityInterceptor securityInterceptor;\n \n         @Override\n-        public void configure(ResourceInfo resourceInfo,\n-                FeatureContext featureContext) {\n+        public void configure(ResourceInfo resourceInfo, FeatureContext featureContext) {\n             Class<?> clazz = resourceInfo.getResourceClass();\n             Method method = resourceInfo.getResourceMethod();\n-            if (!method.isAnnotationPresent(NoSecurityCheck.class)\n-                    && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n+            if (!method.isAnnotationPresent(NoSecurityCheck.class) && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n                 featureContext.register(securityInterceptor);\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 78
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_random/55/ZanataRestSecurityInterceptor.java\nindex 3ee0513e59..66af909748 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_random/55/ZanataRestSecurityInterceptor.java\n@@ -129,7 +129,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // here the tryLogin() will just set up the correct system state\n             zanataIdentity.tryLogin();\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "132",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                },
                {
                    "line": "132",
                    "column": "62",
                    "severity": "error",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "263",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_three_grams/55/ZanataRestSecurityInterceptor.java\nindex 3ee0513e59..2db22a215e 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/errored/1/55/ZanataRestSecurityInterceptor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/zanata-zanata-platform/styler_three_grams/55/ZanataRestSecurityInterceptor.java\n@@ -129,135 +129,135 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             // here the tryLogin() will just set up the correct system state\n             zanataIdentity.tryLogin();\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n-            // special cases for path such as '/test/' or '/oauth/' are now\n-            // handled by having annotation @NoSecurityCheck on those API\n-            // methods/classes. ZanataRestSecurityBinder will ensure that this\n-            // ContainerRequestFilter will not be called for those annotated\n-            // services.\n+                !HttpUtil.isReadMethod(context.getMethod())) {// special cases for path such as '/test/' or '/oauth/' are now\n+                // handled by having annotation @NoSecurityCheck on those API\n+                // methods/classes. ZanataRestSecurityBinder will ensure that this\n+                // ContainerRequestFilter will not be called for those annotated\n+                // services.\n \n-            // if we don't have any information to authenticate and the\n-            // requesting API does NOT allow anonymous access\n-            log.info(\"can not authenticate REST request: {}\", restCredentials);\n-            context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                    .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n-                    .entity(\"User authentication required for REST request\")\n-                    .build());\n+                // if we don't have any information to authenticate and the\n+                // requesting API does NOT allow anonymous access\n+                log.info(\"can not authenticate REST request: {}\", restCredentials);\n+                context.abortWith(Response.status(Status.UNAUTHORIZED)\n+                        .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n+                        .entity(\"User authentication required for REST request\")\n+                        .build());\n+            }\n         }\n-    }\n \n-    private Either<Response, String> getAuthenticatedUsernameOrError() {\n+        private Either<Response, String> getAuthenticatedUsernameOrError() {\n \n-        Optional<String> usernameOpt;\n-        Optional<String> accessTokenOpt =\n-                OAuthUtil.getAccessTokenFromHeader(request);\n-        usernameOpt = accessTokenOpt.flatMap(\n-                token -> securityTokens.findUsernameByAccessToken(token));\n+            Optional<String> usernameOpt;\n+            Optional<String> accessTokenOpt =\n+                    OAuthUtil.getAccessTokenFromHeader(request);\n+            usernameOpt = accessTokenOpt.flatMap(\n+                    token -> securityTokens.findUsernameByAccessToken(token));\n \n-        if (!usernameOpt.isPresent()) {\n-            log.info(\n-                    \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n-                    accessTokenOpt);\n-            return Either.left(buildUnauthorizedResponse(\n-                    \"Bad OAuth request, invalid or expired tokens: access token [\" +\n-                            accessTokenOpt + \"]\"));\n+            if (!usernameOpt.isPresent()) {\n+                log.info(\n+                        \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n+                        accessTokenOpt);\n+                return Either.left(buildUnauthorizedResponse(\n+                        \"Bad OAuth request, invalid or expired tokens: access token [\" +\n+                                accessTokenOpt + \"]\"));\n+            }\n+            String username = usernameOpt.get();\n+            return Either.right(username);\n         }\n-        String username = usernameOpt.get();\n-        return Either.right(username);\n-    }\n \n-    private Response buildUnauthorizedResponse(String message) {\n-        OAuthResponse oauthResponse = null;\n-        try {\n-            oauthResponse = OAuthRSResponse\n-                    .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n-                    .buildHeaderMessage();\n-        } catch (OAuthSystemException e1) {\n-            return buildServerErrorResponse(message);\n-        }\n+        private Response buildUnauthorizedResponse(String message) {\n+            OAuthResponse oauthResponse = null;\n+            try {\n+                oauthResponse = OAuthRSResponse\n+                        .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n+                        .buildHeaderMessage();\n+            } catch (OAuthSystemException e1) {\n+                return buildServerErrorResponse(message);\n+            }\n \n-        return Response\n-                .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n-                        OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n-    }\n+            return Response\n+                    .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n+                            OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n+        }\n \n-    private Response buildServerErrorResponse(String message) {\n-        return Response.serverError().entity(message).build();\n-    }\n+        private Response buildServerErrorResponse(String message) {\n+            return Response.serverError().entity(message).build();\n+        }\n \n-    private boolean hasAuthenticatedAccount() {\n-        return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n-    }\n+        private boolean hasAuthenticatedAccount() {\n+            return serviceLocator\n+                    .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n+                    null;\n+        }\n \n-    /**\n+        /**\n      * Encapsulate all possible authentication values from a REST request.\n      */\n-    private static class RestCredentials {\n+        private static class RestCredentials {\n \n-        private final Optional<String> username;\n-        private final Optional<String> apiKey;\n-        private final Optional<String> accessToken;\n+            private final Optional<String> username;\n+            private final Optional<String> apiKey;\n+            private final Optional<String> accessToken;\n \n-        RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n-                boolean isOAuthSupported) {\n-            String username = HttpUtil.getUsername(context.getHeaders());\n-            String apiKey = HttpUtil.getApiKey(context.getHeaders());\n-            this.username = optionalNotEmptyString(username);\n-            this.apiKey = optionalNotEmptyString(apiKey);\n-            if (isOAuthSupported) {\n-                accessToken = OAuthUtil.getAccessTokenFromHeader(request);\n-            } else {\n-                accessToken = Optional.empty();\n+            RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n+                    boolean isOAuthSupported) {\n+                String username = HttpUtil.getUsername(context.getHeaders());\n+                String apiKey = HttpUtil.getApiKey(context.getHeaders());\n+                this.username = optionalNotEmptyString(username);\n+                this.apiKey = optionalNotEmptyString(apiKey);\n+                if (isOAuthSupported) {\n+                    accessToken = OAuthUtil.getAccessTokenFromHeader(request);\n+                } else {\n+                    accessToken = Optional.empty();\n+                }\n             }\n-        }\n \n-        private static Optional<String> optionalNotEmptyString(String value) {\n-            return value == null || value.isEmpty() ?\n-                    Optional.empty() :\n-                    Optional.of(value);\n-        }\n+            private static Optional<String> optionalNotEmptyString(String value) {\n+                return value == null || value.isEmpty() ?\n+                        Optional.empty() :\n+                        Optional.of(value);\n+            }\n \n-        boolean hasApiKey() {\n-            return username.isPresent() && apiKey.isPresent();\n-        }\n+            boolean hasApiKey() {\n+                return username.isPresent() && apiKey.isPresent();\n+            }\n \n-        boolean hasOAuthToken() {\n-            return accessToken.isPresent();\n-        }\n+            boolean hasOAuthToken() {\n+                return accessToken.isPresent();\n+            }\n \n-        @Override\n-        public String toString() {\n-            return MoreObjects.toStringHelper(this)\n-                    .add(\"username\", username)\n-                    .add(\"apiKey\", apiKey)\n-                    .add(\"accessToken\", accessToken)\n-                    .toString();\n+            @Override\n+            public String toString() {\n+                return MoreObjects.toStringHelper(this)\n+                        .add(\"username\", username)\n+                        .add(\"apiKey\", apiKey)\n+                        .add(\"accessToken\", accessToken)\n+                        .toString();\n+            }\n         }\n-    }\n \n-    /**\n+        /**\n      * This will use the {@code NoSecurityCheck} annotation and only apply\n      * security request filter to endpoints that don't have that annotation.\n      *\n      * @author Patrick Huang <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n      */\n-    @javax.ws.rs.ext.Provider\n-    @PreMatching\n-    public static class ZanataRestSecurityBinder implements DynamicFeature {\n-        @Inject\n-        private ZanataRestSecurityInterceptor securityInterceptor;\n+        @javax.ws.rs.ext.Provider\n+        @PreMatching\n+        public static class ZanataRestSecurityBinder implements DynamicFeature {\n+            @Inject\n+            private ZanataRestSecurityInterceptor securityInterceptor;\n \n-        @Override\n-        public void configure(ResourceInfo resourceInfo,\n-                FeatureContext featureContext) {\n-            Class<?> clazz = resourceInfo.getResourceClass();\n-            Method method = resourceInfo.getResourceMethod();\n-            if (!method.isAnnotationPresent(NoSecurityCheck.class)\n-                    && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n-                featureContext.register(securityInterceptor);\n+            @Override\n+            public void configure(ResourceInfo resourceInfo,\n+                    FeatureContext featureContext) {\n+                Class<?> clazz = resourceInfo.getResourceClass();\n+                Method method = resourceInfo.getResourceMethod();\n+                if (!method.isAnnotationPresent(NoSecurityCheck.class)\n+                        && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n+                    featureContext.register(securityInterceptor);\n+                }\n             }\n         }\n     }\n-}\n+    \n\\ No newline at end of file\n",
            "diff_size": 108
        }
    ]
}