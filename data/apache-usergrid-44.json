{
    "error_id": "44",
    "information": {
        "errors": [
            {
                "line": "48",
                "column": "5",
                "severity": "warning",
                "message": "Only one statement per line allowed.",
                "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
            }
        ]
    },
    "source_code": "\n    private boolean includedInExport = true;\n    ;\n\n\n    public EntityInfo() {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "48",
                    "column": "5",
                    "severity": "warning",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "49",
                    "column": "3",
                    "severity": "warning",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/errored/1/44/EntityInfo.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/intellij/44/EntityInfo.java\nindex e61bcdd96e..58a3c1ecab 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/errored/1/44/EntityInfo.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/intellij/44/EntityInfo.java\n@@ -14,6 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.usergrid.persistence.schema;\n \n \n@@ -28,273 +29,275 @@ import org.apache.usergrid.persistence.Schema;\n \n public class EntityInfo {\n \n-    private String type;\n+  private String type;\n \n-    private String aliasProperty;\n+  private String aliasProperty;\n \n-    private Map<String, PropertyInfo> properties = new TreeMap<String, PropertyInfo>( String.CASE_INSENSITIVE_ORDER );\n-    private final Set<String> indexed = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n-    private final Set<String> basic = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n-    private final Set<String> required = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n-    private Map<String, DictionaryInfo> dictionaries =\n-            new TreeMap<String, DictionaryInfo>( String.CASE_INSENSITIVE_ORDER );\n-    private Map<String, CollectionInfo> collections =\n-            new TreeMap<String, CollectionInfo>( String.CASE_INSENSITIVE_ORDER );\n-    private final Set<String> fulltextIndexed = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n+  private Map<String, PropertyInfo> properties = new TreeMap<String, PropertyInfo>(String.CASE_INSENSITIVE_ORDER);\n+  private final Set<String> indexed = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n+  private final Set<String> basic = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n+  private final Set<String> required = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n+  private Map<String, DictionaryInfo> dictionaries =\n+      new TreeMap<String, DictionaryInfo>(String.CASE_INSENSITIVE_ORDER);\n+  private Map<String, CollectionInfo> collections =\n+      new TreeMap<String, CollectionInfo>(String.CASE_INSENSITIVE_ORDER);\n+  private final Set<String> fulltextIndexed = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n \n-    private boolean publicVisible = true;\n+  private boolean publicVisible = true;\n \n-    private boolean includedInExport = true;\n-    ;\n+  private boolean includedInExport = true;\n+  ;\n \n \n-    public EntityInfo() {\n-    }\n+  public EntityInfo() {\n+  }\n \n \n-    public String getType() {\n-        return type;\n-    }\n+  public String getType() {\n+    return type;\n+  }\n \n \n-    public void setType( String type ) {\n-        this.type = type;\n-    }\n+  public void setType(String type) {\n+    this.type = type;\n+  }\n \n \n-    public boolean hasProperty( String propertyName ) {\n-        return properties.containsKey( propertyName );\n-    }\n+  public boolean hasProperty(String propertyName) {\n+    return properties.containsKey(propertyName);\n+  }\n \n \n-    public PropertyInfo getProperty( String propertyName ) {\n-        return properties.get( propertyName );\n-    }\n+  public PropertyInfo getProperty(String propertyName) {\n+    return properties.get(propertyName);\n+  }\n \n \n-    public boolean hasProperties() {\n-        return !properties.isEmpty();\n-    }\n+  public boolean hasProperties() {\n+    return !properties.isEmpty();\n+  }\n \n \n-    public Map<String, PropertyInfo> getProperties() {\n-        return properties;\n-    }\n+  public Map<String, PropertyInfo> getProperties() {\n+    return properties;\n+  }\n \n \n-    public void setProperties( Map<String, PropertyInfo> properties ) {\n-        this.properties = new TreeMap<String, PropertyInfo>( String.CASE_INSENSITIVE_ORDER );\n-        this.properties.putAll( properties );\n-        for ( String key : properties.keySet() ) {\n-            PropertyInfo property = properties.get( key );\n-            property.setName( key );\n+  public void setProperties(Map<String, PropertyInfo> properties) {\n+    this.properties = new TreeMap<String, PropertyInfo>(String.CASE_INSENSITIVE_ORDER);\n+    this.properties.putAll(properties);\n+    for (String key : properties.keySet()) {\n+      PropertyInfo property = properties.get(key);\n+      property.setName(key);\n \n-            if ( property.isIndexed() ) {\n-                indexed.add( key );\n-            }\n+      if (property.isIndexed()) {\n+        indexed.add(key);\n+      }\n \n-            if ( property.isRequired() ) {\n-                required.add( key );\n-                // logger.info(\"property \" + key + \" is required\");\n-            }\n+      if (property.isRequired()) {\n+        required.add(key);\n+        // logger.info(\"property \" + key + \" is required\");\n+      }\n \n-            if ( property.isBasic() ) {\n-                basic.add( key );\n-            }\n+      if (property.isBasic()) {\n+        basic.add(key);\n+      }\n \n \n-            if ( property.isFulltextIndexed() ) {\n-                fulltextIndexed.add( key );\n-            }\n+      if (property.isFulltextIndexed()) {\n+        fulltextIndexed.add(key);\n+      }\n \n-            if ( property.isAliasProperty() ) {\n-                aliasProperty = property.getName();\n-            }\n-        }\n+      if (property.isAliasProperty()) {\n+        aliasProperty = property.getName();\n+      }\n     }\n+  }\n \n \n-    public boolean isPropertyMutable( String propertyName ) {\n-        PropertyInfo property = properties.get( propertyName );\n-        if ( property == null ) {\n-            return false;\n-        }\n-        return property.isMutable();\n+  public boolean isPropertyMutable(String propertyName) {\n+    PropertyInfo property = properties.get(propertyName);\n+    if (property == null) {\n+      return false;\n     }\n+    return property.isMutable();\n+  }\n \n \n-    /** A property is unique if it has either been declared as unique, or as an alias property */\n-    public boolean isPropertyUnique( String propertyName ) {\n-        PropertyInfo property = properties.get( propertyName );\n-        if ( property == null ) {\n-            return false;\n-        }\n-        return property.isUnique() || property.isAliasProperty();\n+  /**\n+   * A property is unique if it has either been declared as unique, or as an alias property\n+   */\n+  public boolean isPropertyUnique(String propertyName) {\n+    PropertyInfo property = properties.get(propertyName);\n+    if (property == null) {\n+      return false;\n     }\n+    return property.isUnique() || property.isAliasProperty();\n+  }\n \n \n-    public boolean isPropertyTimestamp( String propertyName ) {\n-        PropertyInfo property = properties.get( propertyName );\n-        if ( property == null ) {\n-            return false;\n-        }\n-        return property.isTimestamp();\n+  public boolean isPropertyTimestamp(String propertyName) {\n+    PropertyInfo property = properties.get(propertyName);\n+    if (property == null) {\n+      return false;\n     }\n+    return property.isTimestamp();\n+  }\n \n \n-    public boolean isPropertyRequired( String propertyName ) {\n-        return required.contains( propertyName );\n-    }\n+  public boolean isPropertyRequired(String propertyName) {\n+    return required.contains(propertyName);\n+  }\n \n \n-    public Set<String> getIndexedProperties() {\n-        return indexed;\n-    }\n+  public Set<String> getIndexedProperties() {\n+    return indexed;\n+  }\n \n \n-    public boolean isPropertyIndexed( String propertyName ) {\n-        return indexed.contains( propertyName );\n-    }\n+  public boolean isPropertyIndexed(String propertyName) {\n+    return indexed.contains(propertyName);\n+  }\n \n \n-    public boolean isPropertyFulltextIndexed( String propertyName ) {\n-        return fulltextIndexed.contains( propertyName );\n-    }\n+  public boolean isPropertyFulltextIndexed(String propertyName) {\n+    return fulltextIndexed.contains(propertyName);\n+  }\n \n \n-    public Set<String> getRequiredProperties() {\n-        return required;\n-    }\n+  public Set<String> getRequiredProperties() {\n+    return required;\n+  }\n \n \n-    public boolean isPropertyBasic( String propertyName ) {\n-        return basic.contains( propertyName );\n-    }\n+  public boolean isPropertyBasic(String propertyName) {\n+    return basic.contains(propertyName);\n+  }\n \n \n-    public Set<String> getBasicProperties() {\n-        return basic;\n-    }\n+  public Set<String> getBasicProperties() {\n+    return basic;\n+  }\n \n \n-    public boolean hasDictionary( String dictionaryName ) {\n-        return dictionaries.containsKey( dictionaryName );\n-    }\n+  public boolean hasDictionary(String dictionaryName) {\n+    return dictionaries.containsKey(dictionaryName);\n+  }\n \n \n-    public DictionaryInfo getDictionary( String dictionaryName ) {\n-        return dictionaries.get( dictionaryName );\n-    }\n+  public DictionaryInfo getDictionary(String dictionaryName) {\n+    return dictionaries.get(dictionaryName);\n+  }\n \n \n-    public boolean hasDictionaries() {\n-        return !dictionaries.isEmpty();\n-    }\n+  public boolean hasDictionaries() {\n+    return !dictionaries.isEmpty();\n+  }\n \n \n-    public Map<String, DictionaryInfo> getDictionaries() {\n-        return dictionaries;\n-    }\n+  public Map<String, DictionaryInfo> getDictionaries() {\n+    return dictionaries;\n+  }\n \n \n-    public void setDictionaries( Map<String, DictionaryInfo> dictionaries ) {\n-        this.dictionaries = new TreeMap<String, DictionaryInfo>( String.CASE_INSENSITIVE_ORDER );\n-        this.dictionaries.putAll( dictionaries );\n-        for ( String key : dictionaries.keySet() ) {\n-            DictionaryInfo dictionary = dictionaries.get( key );\n-            dictionary.setName( key );\n-        }\n-\n-        for ( @SuppressWarnings( \"rawtypes\" ) Entry<String, Class> dictionaryEntry : Schema.DEFAULT_DICTIONARIES\n-                                                                                           .entrySet() ) {\n-            String dictionaryName = dictionaryEntry.getKey();\n-            if ( !this.dictionaries.containsKey( dictionaryName ) ) {\n-                DictionaryInfo dictionary = new DictionaryInfo();\n-                dictionary.setName( dictionaryName );\n-                dictionary.setKeyType( String.class );\n-                dictionary.setValueType( dictionaryEntry.getValue() );\n-                this.dictionaries.put( dictionaryName, dictionary );\n-            }\n-        }\n+  public void setDictionaries(Map<String, DictionaryInfo> dictionaries) {\n+    this.dictionaries = new TreeMap<String, DictionaryInfo>(String.CASE_INSENSITIVE_ORDER);\n+    this.dictionaries.putAll(dictionaries);\n+    for (String key : dictionaries.keySet()) {\n+      DictionaryInfo dictionary = dictionaries.get(key);\n+      dictionary.setName(key);\n     }\n \n-\n-    public boolean hasCollection( String collectionName ) {\n-        return collections.containsKey( collectionName );\n+    for (@SuppressWarnings(\"rawtypes\") Entry<String, Class> dictionaryEntry : Schema.DEFAULT_DICTIONARIES\n+        .entrySet()) {\n+      String dictionaryName = dictionaryEntry.getKey();\n+      if (!this.dictionaries.containsKey(dictionaryName)) {\n+        DictionaryInfo dictionary = new DictionaryInfo();\n+        dictionary.setName(dictionaryName);\n+        dictionary.setKeyType(String.class);\n+        dictionary.setValueType(dictionaryEntry.getValue());\n+        this.dictionaries.put(dictionaryName, dictionary);\n+      }\n     }\n+  }\n \n \n-    public CollectionInfo getCollection( String collectionName ) {\n-        return collections.get( collectionName );\n-    }\n+  public boolean hasCollection(String collectionName) {\n+    return collections.containsKey(collectionName);\n+  }\n \n \n-    public Map<String, CollectionInfo> getCollections() {\n-        return collections;\n-    }\n+  public CollectionInfo getCollection(String collectionName) {\n+    return collections.get(collectionName);\n+  }\n \n \n-    public void setCollections( Map<String, CollectionInfo> collections ) {\n-        this.collections = new TreeMap<String, CollectionInfo>( String.CASE_INSENSITIVE_ORDER );\n-        this.collections.putAll( collections );\n-    }\n+  public Map<String, CollectionInfo> getCollections() {\n+    return collections;\n+  }\n \n \n-    public void mapCollectors( Schema schema, String entityType ) {\n+  public void setCollections(Map<String, CollectionInfo> collections) {\n+    this.collections = new TreeMap<String, CollectionInfo>(String.CASE_INSENSITIVE_ORDER);\n+    this.collections.putAll(collections);\n+  }\n \n-        setType( entityType );\n \n-        for ( String collectionName : collections.keySet() ) {\n-            CollectionInfo collection = collections.get( collectionName );\n-            collection.setContainer( this );\n-            collection.setName( collectionName );\n-            schema.mapCollector( collection.getType(), entityType, collectionName, collection );\n-        }\n-    }\n+  public void mapCollectors(Schema schema, String entityType) {\n \n+    setType(entityType);\n \n-    public String getAliasProperty() {\n-        return aliasProperty;\n+    for (String collectionName : collections.keySet()) {\n+      CollectionInfo collection = collections.get(collectionName);\n+      collection.setContainer(this);\n+      collection.setName(collectionName);\n+      schema.mapCollector(collection.getType(), entityType, collectionName, collection);\n     }\n+  }\n \n \n-    public void setAliasProperty( String nameProperty ) {\n-        aliasProperty = nameProperty;\n-    }\n+  public String getAliasProperty() {\n+    return aliasProperty;\n+  }\n \n \n-    public PropertyInfo getAliasPropertyObject() {\n-        if ( aliasProperty == null ) {\n-            return null;\n-        }\n-        return getProperty( aliasProperty );\n-    }\n+  public void setAliasProperty(String nameProperty) {\n+    aliasProperty = nameProperty;\n+  }\n \n \n-    public boolean isPublic() {\n-        return publicVisible;\n+  public PropertyInfo getAliasPropertyObject() {\n+    if (aliasProperty == null) {\n+      return null;\n     }\n+    return getProperty(aliasProperty);\n+  }\n \n \n-    public void setPublic( boolean publicVisible ) {\n-        this.publicVisible = publicVisible;\n-    }\n+  public boolean isPublic() {\n+    return publicVisible;\n+  }\n \n \n-    public void setIncludedInExport( boolean includedInExport ) {\n-        this.includedInExport = includedInExport;\n-    }\n+  public void setPublic(boolean publicVisible) {\n+    this.publicVisible = publicVisible;\n+  }\n \n \n-    public boolean isIncludedInExport() {\n-        return includedInExport;\n-    }\n+  public void setIncludedInExport(boolean includedInExport) {\n+    this.includedInExport = includedInExport;\n+  }\n \n \n-    @Override\n-    public String toString() {\n-        return \"Entity [type=\" + type + \", aliasProperty=\" + aliasProperty + \", properties=\" + properties + \", indexed=\"\n-                + indexed + \", required=\" + required + \", sets=\" + dictionaries + \", collections=\" + collections\n-                + \", fulltextIndexed=\" + fulltextIndexed + \", publicVisible=\" + publicVisible + \"]\";\n-    }\n+  public boolean isIncludedInExport() {\n+    return includedInExport;\n+  }\n+\n+\n+  @Override\n+  public String toString() {\n+    return \"Entity [type=\" + type + \", aliasProperty=\" + aliasProperty + \", properties=\" + properties + \", indexed=\"\n+        + indexed + \", required=\" + required + \", sets=\" + dictionaries + \", collections=\" + collections\n+        + \", fulltextIndexed=\" + fulltextIndexed + \", publicVisible=\" + publicVisible + \"]\";\n+  }\n }\n",
            "diff_size": 210
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "49",
                    "column": "5",
                    "severity": "warning",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                },
                {
                    "line": "209",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/errored/1/44/EntityInfo.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/naturalize/44/EntityInfo.java\nindex e61bcdd96e..401e66a5cf 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/errored/1/44/EntityInfo.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/naturalize/44/EntityInfo.java\n@@ -38,9 +38,10 @@ public class EntityInfo {\n     private final Set<String> required = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n     private Map<String, DictionaryInfo> dictionaries =\n             new TreeMap<String, DictionaryInfo>( String.CASE_INSENSITIVE_ORDER );\n-    private Map<String, CollectionInfo> collections =\n+\n+private Map<String, CollectionInfo> collections =\n             new TreeMap<String, CollectionInfo>( String.CASE_INSENSITIVE_ORDER );\n-    private final Set<String> fulltextIndexed = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n+private final Set<String> fulltextIndexed = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n \n     private boolean publicVisible = true;\n \n@@ -205,9 +206,8 @@ public class EntityInfo {\n             dictionary.setName( key );\n         }\n \n-        for ( @SuppressWarnings( \"rawtypes\" ) Entry<String, Class> dictionaryEntry : Schema.DEFAULT_DICTIONARIES\n-                                                                                           .entrySet() ) {\n-            String dictionaryName = dictionaryEntry.getKey();\n+        for ( @SuppressWarnings( \"rawtypes\" ) Entry<String, Class> dictionaryEntry : Schema.DEFAULT_DICTIONARIES.entrySet() ) {\n+    String dictionaryName = dictionaryEntry.getKey();\n             if ( !this.dictionaries.containsKey( dictionaryName ) ) {\n                 DictionaryInfo dictionary = new DictionaryInfo();\n                 dictionary.setName( dictionaryName );\n@@ -297,4 +297,4 @@ public class EntityInfo {\n                 + indexed + \", required=\" + required + \", sets=\" + dictionaries + \", collections=\" + collections\n                 + \", fulltextIndexed=\" + fulltextIndexed + \", publicVisible=\" + publicVisible + \"]\";\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "36",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "37",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "41",
                    "column": "5",
                    "severity": "warning",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                },
                {
                    "line": "197",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "282",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 302).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/errored/1/44/EntityInfo.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/codebuff/44/EntityInfo.java\nindex e61bcdd96e..b3dafb8a5f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/errored/1/44/EntityInfo.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-usergrid/codebuff/44/EntityInfo.java\n@@ -22,28 +22,21 @@ import java.util.Map.Entry;\n import java.util.Set;\n import java.util.TreeMap;\n import java.util.TreeSet;\n-\n import org.apache.usergrid.persistence.Schema;\n \n \n public class EntityInfo {\n \n     private String type;\n-\n     private String aliasProperty;\n-\n     private Map<String, PropertyInfo> properties = new TreeMap<String, PropertyInfo>( String.CASE_INSENSITIVE_ORDER );\n     private final Set<String> indexed = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n     private final Set<String> basic = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n     private final Set<String> required = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n-    private Map<String, DictionaryInfo> dictionaries =\n-            new TreeMap<String, DictionaryInfo>( String.CASE_INSENSITIVE_ORDER );\n-    private Map<String, CollectionInfo> collections =\n-            new TreeMap<String, CollectionInfo>( String.CASE_INSENSITIVE_ORDER );\n+    private Map<String, DictionaryInfo> dictionaries = new TreeMap<String, DictionaryInfo>( String.CASE_INSENSITIVE_ORDER );\n+    private Map<String, CollectionInfo> collections = new TreeMap<String, CollectionInfo>( String.CASE_INSENSITIVE_ORDER );\n     private final Set<String> fulltextIndexed = new TreeSet<String>( String.CASE_INSENSITIVE_ORDER );\n-\n     private boolean publicVisible = true;\n-\n     private boolean includedInExport = true;\n     ;\n \n@@ -88,25 +81,19 @@ public class EntityInfo {\n         for ( String key : properties.keySet() ) {\n             PropertyInfo property = properties.get( key );\n             property.setName( key );\n-\n             if ( property.isIndexed() ) {\n                 indexed.add( key );\n             }\n-\n             if ( property.isRequired() ) {\n                 required.add( key );\n                 // logger.info(\"property \" + key + \" is required\");\n             }\n-\n             if ( property.isBasic() ) {\n                 basic.add( key );\n             }\n-\n-\n             if ( property.isFulltextIndexed() ) {\n                 fulltextIndexed.add( key );\n             }\n-\n             if ( property.isAliasProperty() ) {\n                 aliasProperty = property.getName();\n             }\n@@ -124,6 +111,8 @@ public class EntityInfo {\n \n \n     /** A property is unique if it has either been declared as unique, or as an alias property */\n+\n+\n     public boolean isPropertyUnique( String propertyName ) {\n         PropertyInfo property = properties.get( propertyName );\n         if ( property == null ) {\n@@ -205,8 +194,7 @@ public class EntityInfo {\n             dictionary.setName( key );\n         }\n \n-        for ( @SuppressWarnings( \"rawtypes\" ) Entry<String, Class> dictionaryEntry : Schema.DEFAULT_DICTIONARIES\n-                                                                                           .entrySet() ) {\n+        for ( @SuppressWarnings(\"rawtypes\") Entry<String, Class> dictionaryEntry : Schema.DEFAULT_DICTIONARIES.entrySet() ) {\n             String dictionaryName = dictionaryEntry.getKey();\n             if ( !this.dictionaries.containsKey( dictionaryName ) ) {\n                 DictionaryInfo dictionary = new DictionaryInfo();\n@@ -241,9 +229,7 @@ public class EntityInfo {\n \n \n     public void mapCollectors( Schema schema, String entityType ) {\n-\n         setType( entityType );\n-\n         for ( String collectionName : collections.keySet() ) {\n             CollectionInfo collection = collections.get( collectionName );\n             collection.setContainer( this );\n@@ -293,8 +279,6 @@ public class EntityInfo {\n \n     @Override\n     public String toString() {\n-        return \"Entity [type=\" + type + \", aliasProperty=\" + aliasProperty + \", properties=\" + properties + \", indexed=\"\n-                + indexed + \", required=\" + required + \", sets=\" + dictionaries + \", collections=\" + collections\n-                + \", fulltextIndexed=\" + fulltextIndexed + \", publicVisible=\" + publicVisible + \"]\";\n+        return \"Entity [type=\" + type + \", aliasProperty=\" + aliasProperty + \", properties=\" + properties + \", indexed=\" + indexed + \", required=\" + required + \", sets=\" + dictionaries + \", collections=\" + collections + \", fulltextIndexed=\" + fulltextIndexed + \", publicVisible=\" + publicVisible + \"]\";\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 25
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "48",
                    "column": "5",
                    "severity": "warning",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "48",
                    "column": "5",
                    "severity": "warning",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}