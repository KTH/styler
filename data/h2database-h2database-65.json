{
    "error_id": "65",
    "information": {
        "errors": [
            {
                "line": "188",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        case Comparison.EQUAL_NULL_SAFE:\n            builder.append(expression.isNullConstant()\n                    || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n                            ? \" IS \"\n                            : \" IS NOT DISTINCT FROM \");\n            break;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "188",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/65/IndexCondition.java\nindex 9daa91e1c8..6e56b2eb2c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/65/IndexCondition.java\n@@ -185,7 +185,7 @@ public class IndexCondition {\n             break;\n         case Comparison.EQUAL_NULL_SAFE:\n             builder.append(expression.isNullConstant()\n-                    || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n+                || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n                             ? \" IS \"\n                             : \" IS NOT DISTINCT FROM \");\n             break;\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "192",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/65/IndexCondition.java\nindex 9daa91e1c8..630d126af1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/65/IndexCondition.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n@@ -32,404 +33,409 @@ import org.h2.value.Value;\n  */\n public class IndexCondition {\n \n-    /**\n-     * A bit of a search mask meaning 'equal'.\n-     */\n-    public static final int EQUALITY = 1;\n-\n-    /**\n-     * A bit of a search mask meaning 'larger or equal'.\n-     */\n-    public static final int START = 2;\n-\n-    /**\n-     * A bit of a search mask meaning 'smaller or equal'.\n-     */\n-    public static final int END = 4;\n-\n-    /**\n-     * A search mask meaning 'between'.\n-     */\n-    public static final int RANGE = START | END;\n-\n-    /**\n-     * A bit of a search mask meaning 'the condition is always false'.\n-     */\n-    public static final int ALWAYS_FALSE = 8;\n-\n-    /**\n-     * A bit of a search mask meaning 'spatial intersection'.\n-     */\n-    public static final int SPATIAL_INTERSECTS = 16;\n-\n-    private final Column column;\n-    /**\n-     * see constants in {@link Comparison}\n-     */\n-    private final int compareType;\n-\n-    private final Expression expression;\n-    private List<Expression> expressionList;\n-    private Query expressionQuery;\n-\n-    /**\n-     * @param compareType the comparison type, see constants in\n-     *            {@link Comparison}\n-     */\n-    private IndexCondition(int compareType, ExpressionColumn column,\n-            Expression expression) {\n-        this.compareType = compareType;\n-        this.column = column == null ? null : column.getColumn();\n-        this.expression = expression;\n-    }\n-\n-    /**\n-     * Create an index condition with the given parameters.\n-     *\n-     * @param compareType the comparison type, see constants in\n-     *            {@link Comparison}\n-     * @param column the column\n-     * @param expression the expression\n-     * @return the index condition\n-     */\n-    public static IndexCondition get(int compareType, ExpressionColumn column,\n-            Expression expression) {\n-        return new IndexCondition(compareType, column, expression);\n-    }\n-\n-    /**\n-     * Create an index condition with the compare type IN_LIST and with the\n-     * given parameters.\n-     *\n-     * @param column the column\n-     * @param list the expression list\n-     * @return the index condition\n-     */\n-    public static IndexCondition getInList(ExpressionColumn column,\n-            List<Expression> list) {\n-        IndexCondition cond = new IndexCondition(Comparison.IN_LIST, column,\n-                null);\n-        cond.expressionList = list;\n-        return cond;\n+  /**\n+   * A bit of a search mask meaning 'equal'.\n+   */\n+  public static final int EQUALITY = 1;\n+\n+  /**\n+   * A bit of a search mask meaning 'larger or equal'.\n+   */\n+  public static final int START = 2;\n+\n+  /**\n+   * A bit of a search mask meaning 'smaller or equal'.\n+   */\n+  public static final int END = 4;\n+\n+  /**\n+   * A search mask meaning 'between'.\n+   */\n+  public static final int RANGE = START | END;\n+\n+  /**\n+   * A bit of a search mask meaning 'the condition is always false'.\n+   */\n+  public static final int ALWAYS_FALSE = 8;\n+\n+  /**\n+   * A bit of a search mask meaning 'spatial intersection'.\n+   */\n+  public static final int SPATIAL_INTERSECTS = 16;\n+\n+  private final Column column;\n+  /**\n+   * see constants in {@link Comparison}\n+   */\n+  private final int compareType;\n+\n+  private final Expression expression;\n+  private List<Expression> expressionList;\n+  private Query expressionQuery;\n+\n+  /**\n+   * @param compareType the comparison type, see constants in\n+   *                    {@link Comparison}\n+   */\n+  private IndexCondition(int compareType, ExpressionColumn column,\n+                         Expression expression) {\n+    this.compareType = compareType;\n+    this.column = column == null ? null : column.getColumn();\n+    this.expression = expression;\n+  }\n+\n+  /**\n+   * Create an index condition with the given parameters.\n+   *\n+   * @param compareType the comparison type, see constants in\n+   *                    {@link Comparison}\n+   * @param column      the column\n+   * @param expression  the expression\n+   * @return the index condition\n+   */\n+  public static IndexCondition get(int compareType, ExpressionColumn column,\n+                                   Expression expression) {\n+    return new IndexCondition(compareType, column, expression);\n+  }\n+\n+  /**\n+   * Create an index condition with the compare type IN_LIST and with the\n+   * given parameters.\n+   *\n+   * @param column the column\n+   * @param list   the expression list\n+   * @return the index condition\n+   */\n+  public static IndexCondition getInList(ExpressionColumn column,\n+                                         List<Expression> list) {\n+    IndexCondition cond = new IndexCondition(Comparison.IN_LIST, column,\n+        null);\n+    cond.expressionList = list;\n+    return cond;\n+  }\n+\n+  /**\n+   * Create an index condition with the compare type IN_QUERY and with the\n+   * given parameters.\n+   *\n+   * @param column the column\n+   * @param query  the select statement\n+   * @return the index condition\n+   */\n+  public static IndexCondition getInQuery(ExpressionColumn column,\n+                                          Query query) {\n+    assert query.isRandomAccessResult();\n+    IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column, null);\n+    cond.expressionQuery = query;\n+    return cond;\n+  }\n+\n+  /**\n+   * Get the current value of the expression.\n+   *\n+   * @param session the session\n+   * @return the value\n+   */\n+  public Value getCurrentValue(Session session) {\n+    return expression.getValue(session);\n+  }\n+\n+  /**\n+   * Get the current value list of the expression. The value list is of the\n+   * same type as the column, distinct, and sorted.\n+   *\n+   * @param session the session\n+   * @return the value list\n+   */\n+  public Value[] getCurrentValueList(Session session) {\n+    TreeSet<Value> valueSet =\n+        new TreeSet<>(session.getDatabase().getCompareMode());\n+    for (Expression e : expressionList) {\n+      Value v = e.getValue(session);\n+      v = column.convert(v, true);\n+      valueSet.add(v);\n     }\n-\n-    /**\n-     * Create an index condition with the compare type IN_QUERY and with the\n-     * given parameters.\n-     *\n-     * @param column the column\n-     * @param query the select statement\n-     * @return the index condition\n-     */\n-    public static IndexCondition getInQuery(ExpressionColumn column, Query query) {\n-        assert query.isRandomAccessResult();\n-        IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column, null);\n-        cond.expressionQuery = query;\n-        return cond;\n-    }\n-\n-    /**\n-     * Get the current value of the expression.\n-     *\n-     * @param session the session\n-     * @return the value\n-     */\n-    public Value getCurrentValue(Session session) {\n-        return expression.getValue(session);\n+    Value[] array = valueSet.toArray(new Value[valueSet.size()]);\n+    Arrays.sort(array, session.getDatabase().getCompareMode());\n+    return array;\n+  }\n+\n+  /**\n+   * Get the current result of the expression. The rows may not be of the same\n+   * type, therefore the rows may not be unique.\n+   *\n+   * @return the result\n+   */\n+  public ResultInterface getCurrentResult() {\n+    return expressionQuery.query(0);\n+  }\n+\n+  /**\n+   * Get the SQL snippet of this comparison.\n+   *\n+   * @param alwaysQuote quote all identifiers\n+   * @return the SQL snippet\n+   */\n+  public String getSQL(boolean alwaysQuote) {\n+    if (compareType == Comparison.FALSE) {\n+      return \"FALSE\";\n     }\n-\n-    /**\n-     * Get the current value list of the expression. The value list is of the\n-     * same type as the column, distinct, and sorted.\n-     *\n-     * @param session the session\n-     * @return the value list\n-     */\n-    public Value[] getCurrentValueList(Session session) {\n-        TreeSet<Value> valueSet = new TreeSet<>(session.getDatabase().getCompareMode());\n-        for (Expression e : expressionList) {\n-            Value v = e.getValue(session);\n-            v = column.convert(v, true);\n-            valueSet.add(v);\n-        }\n-        Value[] array = valueSet.toArray(new Value[valueSet.size()]);\n-        Arrays.sort(array, session.getDatabase().getCompareMode());\n-        return array;\n+    StringBuilder builder = new StringBuilder();\n+    column.getSQL(builder, alwaysQuote);\n+    switch (compareType) {\n+      case Comparison.EQUAL:\n+        builder.append(\" = \");\n+        break;\n+      case Comparison.EQUAL_NULL_SAFE:\n+        builder.append(expression.isNullConstant()\n+            || column.getType().getValueType() == Value.BOOLEAN &&\n+            expression.isConstant() //\n+            ? \" IS \"\n+            : \" IS NOT DISTINCT FROM \");\n+        break;\n+      case Comparison.BIGGER_EQUAL:\n+        builder.append(\" >= \");\n+        break;\n+      case Comparison.BIGGER:\n+        builder.append(\" > \");\n+        break;\n+      case Comparison.SMALLER_EQUAL:\n+        builder.append(\" <= \");\n+        break;\n+      case Comparison.SMALLER:\n+        builder.append(\" < \");\n+        break;\n+      case Comparison.IN_LIST:\n+        builder.append(\" IN(\");\n+        Expression.writeExpressions(builder, expressionList, alwaysQuote);\n+        builder.append(')');\n+        break;\n+      case Comparison.IN_QUERY:\n+        builder.append(\" IN(\");\n+        builder.append(expressionQuery.getPlanSQL(alwaysQuote));\n+        builder.append(')');\n+        break;\n+      case Comparison.SPATIAL_INTERSECTS:\n+        builder.append(\" && \");\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + compareType);\n     }\n-\n-    /**\n-     * Get the current result of the expression. The rows may not be of the same\n-     * type, therefore the rows may not be unique.\n-     *\n-     * @return the result\n-     */\n-    public ResultInterface getCurrentResult() {\n-        return expressionQuery.query(0);\n+    if (expression != null) {\n+      expression.getSQL(builder, alwaysQuote);\n     }\n-\n-    /**\n-     * Get the SQL snippet of this comparison.\n-     *\n-     * @param alwaysQuote quote all identifiers\n-     * @return the SQL snippet\n-     */\n-    public String getSQL(boolean alwaysQuote) {\n-        if (compareType == Comparison.FALSE) {\n-            return \"FALSE\";\n-        }\n-        StringBuilder builder = new StringBuilder();\n-        column.getSQL(builder, alwaysQuote);\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-            builder.append(\" = \");\n-            break;\n-        case Comparison.EQUAL_NULL_SAFE:\n-            builder.append(expression.isNullConstant()\n-                    || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n-                            ? \" IS \"\n-                            : \" IS NOT DISTINCT FROM \");\n-            break;\n-        case Comparison.BIGGER_EQUAL:\n-            builder.append(\" >= \");\n-            break;\n-        case Comparison.BIGGER:\n-            builder.append(\" > \");\n-            break;\n-        case Comparison.SMALLER_EQUAL:\n-            builder.append(\" <= \");\n-            break;\n-        case Comparison.SMALLER:\n-            builder.append(\" < \");\n-            break;\n-        case Comparison.IN_LIST:\n-            builder.append(\" IN(\");\n-            Expression.writeExpressions(builder, expressionList, alwaysQuote);\n-            builder.append(')');\n-            break;\n-        case Comparison.IN_QUERY:\n-            builder.append(\" IN(\");\n-            builder.append(expressionQuery.getPlanSQL(alwaysQuote));\n-            builder.append(')');\n-            break;\n-        case Comparison.SPATIAL_INTERSECTS:\n-            builder.append(\" && \");\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + compareType);\n+    return builder.toString();\n+  }\n+\n+  /**\n+   * Get the comparison bit mask.\n+   *\n+   * @param indexConditions all index conditions\n+   * @return the mask\n+   */\n+  public int getMask(ArrayList<IndexCondition> indexConditions) {\n+    switch (compareType) {\n+      case Comparison.FALSE:\n+        return ALWAYS_FALSE;\n+      case Comparison.EQUAL:\n+      case Comparison.EQUAL_NULL_SAFE:\n+        return EQUALITY;\n+      case Comparison.IN_LIST:\n+      case Comparison.IN_QUERY:\n+        if (indexConditions.size() > 1) {\n+          if (TableType.TABLE != column.getTable().getTableType()) {\n+            // if combined with other conditions,\n+            // IN(..) can only be used for regular tables\n+            // test case:\n+            // create table test(a int, b int, primary key(id, name));\n+            // create unique index c on test(b, a);\n+            // insert into test values(1, 10), (2, 20);\n+            // select * from (select * from test)\n+            // where a=1 and b in(10, 20);\n+            return 0;\n+          }\n         }\n-        if (expression != null) {\n-            expression.getSQL(builder, alwaysQuote);\n-        }\n-        return builder.toString();\n+        return EQUALITY;\n+      case Comparison.BIGGER_EQUAL:\n+      case Comparison.BIGGER:\n+        return START;\n+      case Comparison.SMALLER_EQUAL:\n+      case Comparison.SMALLER:\n+        return END;\n+      case Comparison.SPATIAL_INTERSECTS:\n+        return SPATIAL_INTERSECTS;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n     }\n-\n-    /**\n-     * Get the comparison bit mask.\n-     *\n-     * @param indexConditions all index conditions\n-     * @return the mask\n-     */\n-    public int getMask(ArrayList<IndexCondition> indexConditions) {\n-        switch (compareType) {\n-        case Comparison.FALSE:\n-            return ALWAYS_FALSE;\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-            return EQUALITY;\n-        case Comparison.IN_LIST:\n-        case Comparison.IN_QUERY:\n-            if (indexConditions.size() > 1) {\n-                if (TableType.TABLE != column.getTable().getTableType()) {\n-                    // if combined with other conditions,\n-                    // IN(..) can only be used for regular tables\n-                    // test case:\n-                    // create table test(a int, b int, primary key(id, name));\n-                    // create unique index c on test(b, a);\n-                    // insert into test values(1, 10), (2, 20);\n-                    // select * from (select * from test)\n-                    // where a=1 and b in(10, 20);\n-                    return 0;\n-                }\n-            }\n-            return EQUALITY;\n-        case Comparison.BIGGER_EQUAL:\n-        case Comparison.BIGGER:\n-            return START;\n-        case Comparison.SMALLER_EQUAL:\n-        case Comparison.SMALLER:\n-            return END;\n-        case Comparison.SPATIAL_INTERSECTS:\n-            return SPATIAL_INTERSECTS;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n-        }\n+  }\n+\n+  /**\n+   * Check if the result is always false.\n+   *\n+   * @return true if the result will always be false\n+   */\n+  public boolean isAlwaysFalse() {\n+    return compareType == Comparison.FALSE;\n+  }\n+\n+  /**\n+   * Check if this index condition is of the type column larger or equal to\n+   * value.\n+   *\n+   * @return true if this is a start condition\n+   */\n+  public boolean isStart() {\n+    switch (compareType) {\n+      case Comparison.EQUAL:\n+      case Comparison.EQUAL_NULL_SAFE:\n+      case Comparison.BIGGER_EQUAL:\n+      case Comparison.BIGGER:\n+        return true;\n+      default:\n+        return false;\n     }\n-\n-    /**\n-     * Check if the result is always false.\n-     *\n-     * @return true if the result will always be false\n-     */\n-    public boolean isAlwaysFalse() {\n-        return compareType == Comparison.FALSE;\n+  }\n+\n+  /**\n+   * Check if this index condition is of the type column smaller or equal to\n+   * value.\n+   *\n+   * @return true if this is a end condition\n+   */\n+  public boolean isEnd() {\n+    switch (compareType) {\n+      case Comparison.EQUAL:\n+      case Comparison.EQUAL_NULL_SAFE:\n+      case Comparison.SMALLER_EQUAL:\n+      case Comparison.SMALLER:\n+        return true;\n+      default:\n+        return false;\n     }\n-\n-    /**\n-     * Check if this index condition is of the type column larger or equal to\n-     * value.\n-     *\n-     * @return true if this is a start condition\n-     */\n-    public boolean isStart() {\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-        case Comparison.BIGGER_EQUAL:\n-        case Comparison.BIGGER:\n-            return true;\n-        default:\n-            return false;\n-        }\n+  }\n+\n+  /**\n+   * Check if this index condition is of the type spatial column intersects\n+   * value.\n+   *\n+   * @return true if this is a spatial intersects condition\n+   */\n+  public boolean isSpatialIntersects() {\n+    switch (compareType) {\n+      case Comparison.SPATIAL_INTERSECTS:\n+        return true;\n+      default:\n+        return false;\n     }\n-\n-    /**\n-     * Check if this index condition is of the type column smaller or equal to\n-     * value.\n-     *\n-     * @return true if this is a end condition\n-     */\n-    public boolean isEnd() {\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-        case Comparison.SMALLER_EQUAL:\n-        case Comparison.SMALLER:\n-            return true;\n-        default:\n-            return false;\n-        }\n+  }\n+\n+  public int getCompareType() {\n+    return compareType;\n+  }\n+\n+  /**\n+   * Get the referenced column.\n+   *\n+   * @return the column\n+   */\n+  public Column getColumn() {\n+    return column;\n+  }\n+\n+  /**\n+   * Get expression.\n+   *\n+   * @return Expression.\n+   */\n+  public Expression getExpression() {\n+    return expression;\n+  }\n+\n+  /**\n+   * Get expression list.\n+   *\n+   * @return Expression list.\n+   */\n+  public List<Expression> getExpressionList() {\n+    return expressionList;\n+  }\n+\n+  /**\n+   * Get expression query.\n+   *\n+   * @return Expression query.\n+   */\n+  public Query getExpressionQuery() {\n+    return expressionQuery;\n+  }\n+\n+  /**\n+   * Check if the expression can be evaluated.\n+   *\n+   * @return true if it can be evaluated\n+   */\n+  public boolean isEvaluatable() {\n+    if (expression != null) {\n+      return expression\n+          .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n     }\n-\n-    /**\n-     * Check if this index condition is of the type spatial column intersects\n-     * value.\n-     *\n-     * @return true if this is a spatial intersects condition\n-     */\n-    public boolean isSpatialIntersects() {\n-        switch (compareType) {\n-        case Comparison.SPATIAL_INTERSECTS:\n-            return true;\n-        default:\n-            return false;\n+    if (expressionList != null) {\n+      for (Expression e : expressionList) {\n+        if (!e.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR)) {\n+          return false;\n         }\n+      }\n+      return true;\n     }\n-\n-    public int getCompareType() {\n-        return compareType;\n-    }\n-\n-    /**\n-     * Get the referenced column.\n-     *\n-     * @return the column\n-     */\n-    public Column getColumn() {\n-        return column;\n-    }\n-\n-    /**\n-     * Get expression.\n-     *\n-     * @return Expression.\n-     */\n-    public Expression getExpression() {\n-        return expression;\n+    return expressionQuery\n+        .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder builder =\n+        new StringBuilder(\"column=\").append(column).append(\", compareType=\");\n+    return compareTypeToString(builder, compareType)\n+        .append(\", expression=\").append(expression)\n+        .append(\", expressionList=\").append(expressionList)\n+        .append(\", expressionQuery=\").append(expressionQuery).toString();\n+  }\n+\n+  private static StringBuilder compareTypeToString(StringBuilder builder,\n+                                                   int i) {\n+    boolean f = false;\n+    if ((i & EQUALITY) == EQUALITY) {\n+      f = true;\n+      builder.append(\"EQUALITY\");\n     }\n-\n-    /**\n-     * Get expression list.\n-     *\n-     * @return Expression list.\n-     */\n-    public List<Expression> getExpressionList() {\n-        return expressionList;\n-    }\n-\n-    /**\n-     * Get expression query.\n-     *\n-     * @return Expression query.\n-     */\n-    public Query getExpressionQuery() {\n-        return expressionQuery;\n+    if ((i & START) == START) {\n+      if (f) {\n+        builder.append(\", \");\n+      }\n+      f = true;\n+      builder.append(\"START\");\n     }\n-\n-    /**\n-     * Check if the expression can be evaluated.\n-     *\n-     * @return true if it can be evaluated\n-     */\n-    public boolean isEvaluatable() {\n-        if (expression != null) {\n-            return expression\n-                    .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n-        }\n-        if (expressionList != null) {\n-            for (Expression e : expressionList) {\n-                if (!e.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return expressionQuery\n-                .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+    if ((i & END) == END) {\n+      if (f) {\n+        builder.append(\", \");\n+      }\n+      f = true;\n+      builder.append(\"END\");\n     }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder(\"column=\").append(column).append(\", compareType=\");\n-        return compareTypeToString(builder, compareType)\n-            .append(\", expression=\").append(expression)\n-            .append(\", expressionList=\").append(expressionList)\n-            .append(\", expressionQuery=\").append(expressionQuery).toString();\n+    if ((i & ALWAYS_FALSE) == ALWAYS_FALSE) {\n+      if (f) {\n+        builder.append(\", \");\n+      }\n+      f = true;\n+      builder.append(\"ALWAYS_FALSE\");\n     }\n-\n-    private static StringBuilder compareTypeToString(StringBuilder builder, int i) {\n-        boolean f = false;\n-        if ((i & EQUALITY) == EQUALITY) {\n-            f = true;\n-            builder.append(\"EQUALITY\");\n-        }\n-        if ((i & START) == START) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            f = true;\n-            builder.append(\"START\");\n-        }\n-        if ((i & END) == END) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            f = true;\n-            builder.append(\"END\");\n-        }\n-        if ((i & ALWAYS_FALSE) == ALWAYS_FALSE) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            f = true;\n-            builder.append(\"ALWAYS_FALSE\");\n-        }\n-        if ((i & SPATIAL_INTERSECTS) == SPATIAL_INTERSECTS) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            builder.append(\"SPATIAL_INTERSECTS\");\n-        }\n-        return builder;\n+    if ((i & SPATIAL_INTERSECTS) == SPATIAL_INTERSECTS) {\n+      if (f) {\n+        builder.append(\", \");\n+      }\n+      builder.append(\"SPATIAL_INTERSECTS\");\n     }\n+    return builder;\n+  }\n \n }\n",
            "diff_size": 501
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "188",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/65/IndexCondition.java\nindex 9daa91e1c8..6e56b2eb2c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/65/IndexCondition.java\n@@ -185,7 +185,7 @@ public class IndexCondition {\n             break;\n         case Comparison.EQUAL_NULL_SAFE:\n             builder.append(expression.isNullConstant()\n-                    || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n+                || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n                             ? \" IS \"\n                             : \" IS NOT DISTINCT FROM \");\n             break;\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "188",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/65/IndexCondition.java\nindex 9daa91e1c8..bf69a9911f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/65/IndexCondition.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/65/IndexCondition.java\n@@ -184,252 +184,252 @@ public class IndexCondition {\n             builder.append(\" = \");\n             break;\n         case Comparison.EQUAL_NULL_SAFE:\n-            builder.append(expression.isNullConstant()\n-                    || column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n-                            ? \" IS \"\n-                            : \" IS NOT DISTINCT FROM \");\n-            break;\n-        case Comparison.BIGGER_EQUAL:\n-            builder.append(\" >= \");\n-            break;\n-        case Comparison.BIGGER:\n-            builder.append(\" > \");\n-            break;\n-        case Comparison.SMALLER_EQUAL:\n-            builder.append(\" <= \");\n-            break;\n-        case Comparison.SMALLER:\n-            builder.append(\" < \");\n-            break;\n-        case Comparison.IN_LIST:\n-            builder.append(\" IN(\");\n-            Expression.writeExpressions(builder, expressionList, alwaysQuote);\n-            builder.append(')');\n-            break;\n-        case Comparison.IN_QUERY:\n-            builder.append(\" IN(\");\n-            builder.append(expressionQuery.getPlanSQL(alwaysQuote));\n-            builder.append(')');\n-            break;\n-        case Comparison.SPATIAL_INTERSECTS:\n-            builder.append(\" && \");\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + compareType);\n-        }\n-        if (expression != null) {\n-            expression.getSQL(builder, alwaysQuote);\n-        }\n-        return builder.toString();\n-    }\n+            builder.append(expression.isNullConstant() ||\n+            column.getType().getValueType() == Value.BOOLEAN && expression.isConstant() //\n+                     ? \" IS \"\n+                     : \" IS NOT DISTINCT FROM \");\n+     break;\n+ case Comparison.BIGGER_EQUAL:\n+     builder.append(\" >= \");\n+     break;\n+ case Comparison.BIGGER:\n+     builder.append(\" > \");\n+     break;\n+ case Comparison.SMALLER_EQUAL:\n+     builder.append(\" <= \");\n+     break;\n+ case Comparison.SMALLER:\n+     builder.append(\" < \");\n+     break;\n+ case Comparison.IN_LIST:\n+     builder.append(\" IN(\");\n+     Expression.writeExpressions(builder, expressionList, alwaysQuote);\n+     builder.append(')');\n+     break;\n+ case Comparison.IN_QUERY:\n+     builder.append(\" IN(\");\n+     builder.append(expressionQuery.getPlanSQL(alwaysQuote));\n+     builder.append(')');\n+     break;\n+ case Comparison.SPATIAL_INTERSECTS:\n+     builder.append(\" && \");\n+     break;\n+ default:\n+     DbException.throwInternalError(\"type=\" + compareType);\n+ }\n+ if (expression != null) {\n+     expression.getSQL(builder, alwaysQuote);\n+ }\n+ return builder.toString();\n+}\n \n-    /**\n+/**\n      * Get the comparison bit mask.\n      *\n      * @param indexConditions all index conditions\n      * @return the mask\n      */\n-    public int getMask(ArrayList<IndexCondition> indexConditions) {\n-        switch (compareType) {\n-        case Comparison.FALSE:\n-            return ALWAYS_FALSE;\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-            return EQUALITY;\n-        case Comparison.IN_LIST:\n-        case Comparison.IN_QUERY:\n-            if (indexConditions.size() > 1) {\n-                if (TableType.TABLE != column.getTable().getTableType()) {\n-                    // if combined with other conditions,\n-                    // IN(..) can only be used for regular tables\n-                    // test case:\n-                    // create table test(a int, b int, primary key(id, name));\n-                    // create unique index c on test(b, a);\n-                    // insert into test values(1, 10), (2, 20);\n-                    // select * from (select * from test)\n-                    // where a=1 and b in(10, 20);\n-                    return 0;\n-                }\n+public int getMask(ArrayList<IndexCondition> indexConditions) {\n+    switch (compareType) {\n+    case Comparison.FALSE:\n+        return ALWAYS_FALSE;\n+    case Comparison.EQUAL:\n+    case Comparison.EQUAL_NULL_SAFE:\n+        return EQUALITY;\n+    case Comparison.IN_LIST:\n+    case Comparison.IN_QUERY:\n+        if (indexConditions.size() > 1) {\n+            if (TableType.TABLE != column.getTable().getTableType()) {\n+                // if combined with other conditions,\n+                // IN(..) can only be used for regular tables\n+                // test case:\n+                // create table test(a int, b int, primary key(id, name));\n+                // create unique index c on test(b, a);\n+                // insert into test values(1, 10), (2, 20);\n+                // select * from (select * from test)\n+                // where a=1 and b in(10, 20);\n+                return 0;\n             }\n-            return EQUALITY;\n-        case Comparison.BIGGER_EQUAL:\n-        case Comparison.BIGGER:\n-            return START;\n-        case Comparison.SMALLER_EQUAL:\n-        case Comparison.SMALLER:\n-            return END;\n-        case Comparison.SPATIAL_INTERSECTS:\n-            return SPATIAL_INTERSECTS;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n         }\n+        return EQUALITY;\n+    case Comparison.BIGGER_EQUAL:\n+    case Comparison.BIGGER:\n+        return START;\n+    case Comparison.SMALLER_EQUAL:\n+    case Comparison.SMALLER:\n+        return END;\n+    case Comparison.SPATIAL_INTERSECTS:\n+        return SPATIAL_INTERSECTS;\n+    default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n     }\n+}\n \n-    /**\n+/**\n      * Check if the result is always false.\n      *\n      * @return true if the result will always be false\n      */\n-    public boolean isAlwaysFalse() {\n-        return compareType == Comparison.FALSE;\n-    }\n+public boolean isAlwaysFalse() {\n+    return compareType == Comparison.FALSE;\n+}\n \n-    /**\n+/**\n      * Check if this index condition is of the type column larger or equal to\n      * value.\n      *\n      * @return true if this is a start condition\n      */\n-    public boolean isStart() {\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-        case Comparison.BIGGER_EQUAL:\n-        case Comparison.BIGGER:\n-            return true;\n-        default:\n-            return false;\n-        }\n+public boolean isStart() {\n+    switch (compareType) {\n+    case Comparison.EQUAL:\n+    case Comparison.EQUAL_NULL_SAFE:\n+    case Comparison.BIGGER_EQUAL:\n+    case Comparison.BIGGER:\n+        return true;\n+    default:\n+        return false;\n     }\n+}\n \n-    /**\n+/**\n      * Check if this index condition is of the type column smaller or equal to\n      * value.\n      *\n      * @return true if this is a end condition\n      */\n-    public boolean isEnd() {\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-        case Comparison.SMALLER_EQUAL:\n-        case Comparison.SMALLER:\n-            return true;\n-        default:\n-            return false;\n-        }\n+public boolean isEnd() {\n+    switch (compareType) {\n+    case Comparison.EQUAL:\n+    case Comparison.EQUAL_NULL_SAFE:\n+    case Comparison.SMALLER_EQUAL:\n+    case Comparison.SMALLER:\n+        return true;\n+    default:\n+        return false;\n     }\n+}\n \n-    /**\n+/**\n      * Check if this index condition is of the type spatial column intersects\n      * value.\n      *\n      * @return true if this is a spatial intersects condition\n      */\n-    public boolean isSpatialIntersects() {\n-        switch (compareType) {\n-        case Comparison.SPATIAL_INTERSECTS:\n-            return true;\n-        default:\n-            return false;\n-        }\n+public boolean isSpatialIntersects() {\n+    switch (compareType) {\n+    case Comparison.SPATIAL_INTERSECTS:\n+        return true;\n+    default:\n+        return false;\n     }\n+}\n \n-    public int getCompareType() {\n-        return compareType;\n-    }\n+public int getCompareType() {\n+    return compareType;\n+}\n \n-    /**\n+/**\n      * Get the referenced column.\n      *\n      * @return the column\n      */\n-    public Column getColumn() {\n-        return column;\n-    }\n+public Column getColumn() {\n+    return column;\n+}\n \n-    /**\n+/**\n      * Get expression.\n      *\n      * @return Expression.\n      */\n-    public Expression getExpression() {\n-        return expression;\n-    }\n+public Expression getExpression() {\n+    return expression;\n+}\n \n-    /**\n+/**\n      * Get expression list.\n      *\n      * @return Expression list.\n      */\n-    public List<Expression> getExpressionList() {\n-        return expressionList;\n-    }\n+public List<Expression> getExpressionList() {\n+    return expressionList;\n+}\n \n-    /**\n+/**\n      * Get expression query.\n      *\n      * @return Expression query.\n      */\n-    public Query getExpressionQuery() {\n-        return expressionQuery;\n-    }\n+public Query getExpressionQuery() {\n+    return expressionQuery;\n+}\n \n-    /**\n+/**\n      * Check if the expression can be evaluated.\n      *\n      * @return true if it can be evaluated\n      */\n-    public boolean isEvaluatable() {\n-        if (expression != null) {\n-            return expression\n-                    .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n-        }\n-        if (expressionList != null) {\n-            for (Expression e : expressionList) {\n-                if (!e.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR)) {\n-                    return false;\n-                }\n+public boolean isEvaluatable() {\n+    if (expression != null) {\n+        return expression\n+                .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+    }\n+    if (expressionList != null) {\n+        for (Expression e : expressionList) {\n+            if (!e.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR)) {\n+                return false;\n             }\n-            return true;\n         }\n-        return expressionQuery\n-                .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+        return true;\n     }\n+    return expressionQuery\n+            .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+}\n \n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder(\"column=\").append(column).append(\", compareType=\");\n-        return compareTypeToString(builder, compareType)\n-            .append(\", expression=\").append(expression)\n-            .append(\", expressionList=\").append(expressionList)\n-            .append(\", expressionQuery=\").append(expressionQuery).toString();\n-    }\n+@Override\n+public String toString() {\n+    StringBuilder builder = new StringBuilder(\"column=\").append(column).append(\", compareType=\");\n+    return compareTypeToString(builder, compareType)\n+        .append(\", expression=\").append(expression)\n+        .append(\", expressionList=\").append(expressionList)\n+        .append(\", expressionQuery=\").append(expressionQuery).toString();\n+}\n \n-    private static StringBuilder compareTypeToString(StringBuilder builder, int i) {\n-        boolean f = false;\n-        if ((i & EQUALITY) == EQUALITY) {\n-            f = true;\n-            builder.append(\"EQUALITY\");\n-        }\n-        if ((i & START) == START) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            f = true;\n-            builder.append(\"START\");\n+private static StringBuilder compareTypeToString(StringBuilder builder, int i) {\n+    boolean f = false;\n+    if ((i & EQUALITY) == EQUALITY) {\n+        f = true;\n+        builder.append(\"EQUALITY\");\n+    }\n+    if ((i & START) == START) {\n+        if (f) {\n+            builder.append(\", \");\n         }\n-        if ((i & END) == END) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            f = true;\n-            builder.append(\"END\");\n+        f = true;\n+        builder.append(\"START\");\n+    }\n+    if ((i & END) == END) {\n+        if (f) {\n+            builder.append(\", \");\n         }\n-        if ((i & ALWAYS_FALSE) == ALWAYS_FALSE) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            f = true;\n-            builder.append(\"ALWAYS_FALSE\");\n+        f = true;\n+        builder.append(\"END\");\n+    }\n+    if ((i & ALWAYS_FALSE) == ALWAYS_FALSE) {\n+        if (f) {\n+            builder.append(\", \");\n         }\n-        if ((i & SPATIAL_INTERSECTS) == SPATIAL_INTERSECTS) {\n-            if (f) {\n-                builder.append(\", \");\n-            }\n-            builder.append(\"SPATIAL_INTERSECTS\");\n+        f = true;\n+        builder.append(\"ALWAYS_FALSE\");\n+    }\n+    if ((i & SPATIAL_INTERSECTS) == SPATIAL_INTERSECTS) {\n+        if (f) {\n+            builder.append(\", \");\n         }\n-        return builder;\n+        builder.append(\"SPATIAL_INTERSECTS\");\n     }\n+    return builder;\n+}\n \n }\n",
            "diff_size": 197
        }
    ]
}