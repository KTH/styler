{
    "error_id": "803",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/803/ColumnFormat.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/803/ColumnFormat.java\nindex 74447d6d82..f07889e484 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/803/ColumnFormat.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/803/ColumnFormat.java\n@@ -46,631 +46,655 @@ import java.util.Map;\n  * Column first format for matrix\n  */\n public abstract class ColumnFormat extends MatrixFormatImpl {\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for int key float value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(IntFloatsCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for int key double value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(IntDoublesCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for int key int value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(IntIntsCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for int key long value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(IntLongsCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for long key float value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(LongFloatsCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for long key float double matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(LongDoublesCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for long key int value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(LongIntsCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Write a matrix column to output stream\n-   *\n-   * @param col    matrix column for long key long value matrix\n-   * @param output output stream\n-   * @throws IOException\n-   */\n-  public abstract void save(LongLongsCol col, DataOutputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for int key float value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(IntFloatsCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for int key double value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(IntDoublesCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for int key int value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(IntIntsCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for int key long value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(IntLongsCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for long key float value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(LongFloatsCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for long key float value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(LongDoublesCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for long key int value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(LongIntsCol col, DataInputStream output) throws IOException;\n-\n-  /**\n-   * Read a matrix column to input stream\n-   *\n-   * @param col    matrix column for long key long value matrix\n-   * @param output input stream\n-   * @throws IOException\n-   */\n-  public abstract void load(LongLongsCol col, DataInputStream output) throws IOException;\n-\n-\n-  @Override public void save(ServerPartition part, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n-    List<Integer> rowIds = saveContext.getRowIndexes();\n-    PartitionSource rows = part.getRows();\n-    if (rowIds == null || rowIds.isEmpty()) {\n-      Iterator<Map.Entry<Integer, ServerRow>> iter = part.getRows().iterator();\n-      rowIds = new ArrayList<>();\n-      while (iter.hasNext()) {\n-        rowIds.add(iter.next().getKey());\n-      }\n-    } else {\n-      rowIds = filter(part, rowIds);\n-    }\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for int key float value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(IntFloatsCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for int key double value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(IntDoublesCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for int key int value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(IntIntsCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for int key long value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(IntLongsCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for long key float value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(LongFloatsCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for long key float double matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(LongDoublesCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for long key int value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(LongIntsCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Write a matrix column to output stream\n+     *\n+     * @param col    matrix column for long key long value matrix\n+     * @param output output stream\n+     * @throws IOException\n+     */\n+    public abstract void save(LongLongsCol col, DataOutputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for int key float value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(IntFloatsCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for int key double value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(IntDoublesCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for int key int value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(IntIntsCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for int key long value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(IntLongsCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for long key float value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(LongFloatsCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for long key float value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(LongDoublesCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for long key int value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(LongIntsCol col, DataInputStream output) throws IOException;\n+\n+    /**\n+     * Read a matrix column to input stream\n+     *\n+     * @param col    matrix column for long key long value matrix\n+     * @param output input stream\n+     * @throws IOException\n+     */\n+    public abstract void load(LongLongsCol col, DataInputStream output) throws IOException;\n+\n+\n+    @Override\n+    public void save(ServerPartition part, MatrixPartitionMeta partMeta,\n+                     PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n+        List<Integer> rowIds = saveContext.getRowIndexes();\n+        PartitionSource rows = part.getRows();\n+        if (rowIds == null || rowIds.isEmpty()) {\n+            Iterator<Map.Entry<Integer, ServerRow>> iter = part.getRows().iterator();\n+            rowIds = new ArrayList<>();\n+            while (iter.hasNext()) {\n+                rowIds.add(iter.next().getKey());\n+            }\n+        } else {\n+            rowIds = filter(part, rowIds);\n+        }\n \n-    int size = rowIds.size();\n-    ServerRow[] rowList = new ServerRow[size];\n-    for (int i = 0; i < size; i++) {\n-      rowList[i] = rows.getRow(rowIds.get(i));\n-    }\n+        int size = rowIds.size();\n+        ServerRow[] rowList = new ServerRow[size];\n+        for (int i = 0; i < size; i++) {\n+            rowList[i] = rows.getRow(rowIds.get(i));\n+        }\n \n \n-    ServerRow row0 = rowList[0];\n-\n-    if (row0 instanceof ServerIntFloatRow) {\n-      saveIntFloatRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerIntDoubleRow) {\n-      saveIntDoubleRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerIntIntRow) {\n-      saveIntIntRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerIntLongRow) {\n-      saveIntLongRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongFloatRow) {\n-      saveLongFloatRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongDoubleRow) {\n-      saveLongDoubleRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongIntRow) {\n-      saveLongIntRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongLongRow) {\n-      saveLongLongRows(part, rowList, partMeta, saveContext, output);\n-    } else {\n-      throw new UnsupportedOperationException(\n-        \"Unknown server row type \" + row0.getClass().getName());\n-    }\n-  }\n-\n-  @Override public void load(ServerPartition part, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    Map<Integer, RowPartitionMeta> rowMetas = partMeta.getRowMetas();\n-    int[] rowIds = new int[rowMetas.size()];\n-    ServerRow[] rows = new ServerRow[rowMetas.size()];\n-    int i = 0;\n-    for (int rowId : rowMetas.keySet()) {\n-      rowIds[i] = rowId;\n-      rows[i] = part.getRow(rowId);\n-      i++;\n+        ServerRow row0 = rowList[0];\n+\n+        if (row0 instanceof ServerIntFloatRow) {\n+            saveIntFloatRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerIntDoubleRow) {\n+            saveIntDoubleRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerIntIntRow) {\n+            saveIntIntRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerIntLongRow) {\n+            saveIntLongRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerLongFloatRow) {\n+            saveLongFloatRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerLongDoubleRow) {\n+            saveLongDoubleRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerLongIntRow) {\n+            saveLongIntRows(part, rowList, partMeta, saveContext, output);\n+        } else if (row0 instanceof ServerLongLongRow) {\n+            saveLongLongRows(part, rowList, partMeta, saveContext, output);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown server row type \" + row0.getClass().getName());\n+        }\n     }\n \n-    ServerRow row0 = part.getRow(rowIds[0]);\n-    if (row0 instanceof ServerIntFloatRow) {\n-      loadIntFloatRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerIntDoubleRow) {\n-      loadIntDoubleRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerIntIntRow) {\n-      loadIntIntRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerIntLongRow) {\n-      loadIntLongRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongFloatRow) {\n-      loadLongFloatRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongDoubleRow) {\n-      loadLongDoubleRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongIntRow) {\n-      loadLongIntRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongLongRow) {\n-      loadLongLongRows(part, rows, partMeta, loadContext, input);\n-    } else {\n-      throw new UnsupportedOperationException(\n-        \"Unknown server row type \" + row0.getClass().getName());\n-    }\n-  }\n-\n-  private void saveIntFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.length;\n-    int indexOffset = (int) part.getPartitionKey().getStartCol();\n-    IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n-\n-    IntFloatsCol col = new IntFloatsCol(0, new float[rows.length]);\n-    if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+    @Override\n+    public void load(ServerPartition part, MatrixPartitionMeta partMeta,\n+                     PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n+        Map<Integer, RowPartitionMeta> rowMetas = partMeta.getRowMetas();\n+        int[] rowIds = new int[rowMetas.size()];\n+        ServerRow[] rows = new ServerRow[rowMetas.size()];\n+        int i = 0;\n+        for (int rowId : rowMetas.keySet()) {\n+            rowIds[i] = rowId;\n+            rows[i] = part.getRow(rowId);\n+            i++;\n         }\n-        save(col, output);\n-      }\n-    } else {\n-      ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+\n+        ServerRow row0 = part.getRow(rowIds[0]);\n+        if (row0 instanceof ServerIntFloatRow) {\n+            loadIntFloatRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerIntDoubleRow) {\n+            loadIntDoubleRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerIntIntRow) {\n+            loadIntIntRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerIntLongRow) {\n+            loadIntLongRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerLongFloatRow) {\n+            loadLongFloatRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerLongDoubleRow) {\n+            loadLongDoubleRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerLongIntRow) {\n+            loadLongIntRows(part, rows, partMeta, loadContext, input);\n+        } else if (row0 instanceof ServerLongLongRow) {\n+            loadLongLongRows(part, rows, partMeta, loadContext, input);\n+        } else {\n+            throw new UnsupportedOperationException(\n+                    \"Unknown server row type \" + row0.getClass().getName());\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-\n-  private void saveIntDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.length;\n-    int indexOffset = (int) part.getPartitionKey().getStartCol();\n-    IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n-\n-    IntDoublesCol col = new IntDoublesCol(0, new double[rows.length]);\n-    if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n-      }\n-    } else {\n-      ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n+\n+    private void saveIntFloatRows(ServerPartition part, ServerRow[] rows,\n+                                  MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext,\n+                                  DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.length;\n+        int indexOffset = (int) part.getPartitionKey().getStartCol();\n+        IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n+\n+        IntFloatsCol col = new IntFloatsCol(0, new float[rows.length]);\n+        if (storage.isDense()) {\n+            int[] indices = storage.getIndices();\n+            for (int i = 0; i < indices.length; i++) {\n+                col.colId = indices[i] + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n+        } else {\n+            ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getIntKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void saveIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.size();\n-    int indexOffset = (int) part.getPartitionKey().getStartCol();\n-    IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n-\n-    IntIntsCol col = new IntIntsCol(0, new int[rows.length]);\n-    if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n-      }\n-    } else {\n-      ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n+\n+\n+    private void saveIntDoubleRows(ServerPartition part, ServerRow[] rows,\n+                                   MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext,\n+                                   DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.length;\n+        int indexOffset = (int) part.getPartitionKey().getStartCol();\n+        IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n+\n+        IntDoublesCol col = new IntDoublesCol(0, new double[rows.length]);\n+        if (storage.isDense()) {\n+            int[] indices = storage.getIndices();\n+            for (int i = 0; i < indices.length; i++) {\n+                col.colId = indices[i] + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n+        } else {\n+            ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getIntKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void saveIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.size();\n-    int indexOffset = (int) part.getPartitionKey().getStartCol();\n-    IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n-\n-    IntLongsCol col = new IntLongsCol(0, new long[rows.length]);\n-    if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n-      }\n-    } else {\n-      ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n+\n+    private void saveIntIntRows(ServerPartition part, ServerRow[] rows,\n+                                MatrixPartitionMeta partMeta,\n+                                PSMatrixSaveContext saveContext, DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.size();\n+        int indexOffset = (int) part.getPartitionKey().getStartCol();\n+        IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n+\n+        IntIntsCol col = new IntIntsCol(0, new int[rows.length]);\n+        if (storage.isDense()) {\n+            int[] indices = storage.getIndices();\n+            for (int i = 0; i < indices.length; i++) {\n+                col.colId = indices[i] + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n+        } else {\n+            ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getIntKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void saveLongFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.size();\n-    long indexOffset = part.getPartitionKey().getStartCol();\n-\n-    LongFloatsCol col = new LongFloatsCol(0, new float[rows.length]);\n-    if (vec instanceof IntFloatVector) {\n-      IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      }\n-    } else {\n-      LongFloatVectorStorage storage = ((LongFloatVector) vec).getStorage();\n-      ObjectIterator<Long2FloatMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+\n+    private void saveIntLongRows(ServerPartition part, ServerRow[] rows,\n+                                 MatrixPartitionMeta partMeta,\n+                                 PSMatrixSaveContext saveContext, DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.size();\n+        int indexOffset = (int) part.getPartitionKey().getStartCol();\n+        IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n+\n+        IntLongsCol col = new IntLongsCol(0, new long[rows.length]);\n+        if (storage.isDense()) {\n+            int[] indices = storage.getIndices();\n+            for (int i = 0; i < indices.length; i++) {\n+                col.colId = indices[i] + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n+        } else {\n+            ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getIntKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void saveLongDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.size();\n-    long indexOffset = part.getPartitionKey().getStartCol();\n-\n-    LongDoublesCol col = new LongDoublesCol(0, new double[rows.length]);\n-    if (vec instanceof IntDoubleVector) {\n-      IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      }\n-    } else {\n-      LongDoubleVectorStorage storage = ((LongDoubleVector) vec).getStorage();\n-      ObjectIterator<Long2DoubleMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+\n+    private void saveLongFloatRows(ServerPartition part, ServerRow[] rows,\n+                                   MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext,\n+                                   DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.size();\n+        long indexOffset = part.getPartitionKey().getStartCol();\n+\n+        LongFloatsCol col = new LongFloatsCol(0, new float[rows.length]);\n+        if (vec instanceof IntFloatVector) {\n+            IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n+            if (storage.isDense()) {\n+                int[] indices = storage.getIndices();\n+                for (int i = 0; i < indices.length; i++) {\n+                    col.colId = indices[i] + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            } else {\n+                ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n+                while (iter.hasNext()) {\n+                    col.colId = iter.next().getIntKey() + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            }\n+        } else {\n+            LongFloatVectorStorage storage = ((LongFloatVector) vec).getStorage();\n+            ObjectIterator<Long2FloatMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getLongKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void saveLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.size();\n-    long indexOffset = part.getPartitionKey().getStartCol();\n-\n-    LongIntsCol col = new LongIntsCol(0, new int[rows.length]);\n-    if (vec instanceof IntIntVector) {\n-      IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      }\n-    } else {\n-      LongIntVectorStorage storage = ((LongIntVector) vec).getStorage();\n-      ObjectIterator<Long2IntMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+\n+    private void saveLongDoubleRows(ServerPartition part, ServerRow[] rows,\n+                                    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext,\n+                                    DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.size();\n+        long indexOffset = part.getPartitionKey().getStartCol();\n+\n+        LongDoublesCol col = new LongDoublesCol(0, new double[rows.length]);\n+        if (vec instanceof IntDoubleVector) {\n+            IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n+            if (storage.isDense()) {\n+                int[] indices = storage.getIndices();\n+                for (int i = 0; i < indices.length; i++) {\n+                    col.colId = indices[i] + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            } else {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n+                while (iter.hasNext()) {\n+                    col.colId = iter.next().getIntKey() + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            }\n+        } else {\n+            LongDoubleVectorStorage storage = ((LongDoubleVector) vec).getStorage();\n+            ObjectIterator<Long2DoubleMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getLongKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void saveLongLongRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n-    Vector vec = rows[0].getSplit();\n-    //int size = rows.size();\n-    long indexOffset = part.getPartitionKey().getStartCol();\n-\n-    LongLongsCol col = new LongLongsCol(0, new long[rows.length]);\n-    if (vec instanceof IntLongVector) {\n-      IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n+\n+    private void saveLongIntRows(ServerPartition part, ServerRow[] rows,\n+                                 MatrixPartitionMeta partMeta,\n+                                 PSMatrixSaveContext saveContext, DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.size();\n+        long indexOffset = part.getPartitionKey().getStartCol();\n+\n+        LongIntsCol col = new LongIntsCol(0, new int[rows.length]);\n+        if (vec instanceof IntIntVector) {\n+            IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n+            if (storage.isDense()) {\n+                int[] indices = storage.getIndices();\n+                for (int i = 0; i < indices.length; i++) {\n+                    col.colId = indices[i] + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            } else {\n+                ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n+                while (iter.hasNext()) {\n+                    col.colId = iter.next().getIntKey() + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            }\n+        } else {\n+            LongIntVectorStorage storage = ((LongIntVector) vec).getStorage();\n+            ObjectIterator<Long2IntMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getLongKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-      }\n-    } else {\n-      LongLongVectorStorage storage = ((LongLongVector) vec).getStorage();\n-      ObjectIterator<Long2LongMap.Entry> iter = storage.entryIterator();\n-      while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+    }\n+\n+    private void saveLongLongRows(ServerPartition part, ServerRow[] rows,\n+                                  MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext,\n+                                  DataOutputStream output)\n+            throws IOException {\n+        Vector vec = rows[0].getSplit();\n+        //int size = rows.size();\n+        long indexOffset = part.getPartitionKey().getStartCol();\n+\n+        LongLongsCol col = new LongLongsCol(0, new long[rows.length]);\n+        if (vec instanceof IntLongVector) {\n+            IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n+            if (storage.isDense()) {\n+                int[] indices = storage.getIndices();\n+                for (int i = 0; i < indices.length; i++) {\n+                    col.colId = indices[i] + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            } else {\n+                ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n+                while (iter.hasNext()) {\n+                    col.colId = iter.next().getIntKey() + indexOffset;\n+                    for (int j = 0; j < rows.length; j++) {\n+                        col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+                    }\n+                    save(col, output);\n+                }\n+            }\n+        } else {\n+            LongLongVectorStorage storage = ((LongLongVector) vec).getStorage();\n+            ObjectIterator<Long2LongMap.Entry> iter = storage.entryIterator();\n+            while (iter.hasNext()) {\n+                col.colId = iter.next().getLongKey() + indexOffset;\n+                for (int j = 0; j < rows.length; j++) {\n+                    col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+                }\n+                save(col, output);\n+            }\n         }\n-        save(col, output);\n-      }\n     }\n-  }\n-\n-  private void loadIntFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    IntFloatsCol col = new IntFloatsCol(0, new float[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadIntFloatRows(ServerPartition part, ServerRow[] rows,\n+                                  MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext,\n+                                  DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        IntFloatsCol col = new IntFloatsCol(0, new float[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerIntFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadIntDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    IntDoublesCol col = new IntDoublesCol(0, new double[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadIntDoubleRows(ServerPartition part, ServerRow[] rows,\n+                                   MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext,\n+                                   DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        IntDoublesCol col = new IntDoublesCol(0, new double[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerIntDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    IntIntsCol col = new IntIntsCol(0, new int[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntIntRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadIntIntRows(ServerPartition part, ServerRow[] rows,\n+                                MatrixPartitionMeta partMeta,\n+                                PSMatrixLoadContext loadContext, DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        IntIntsCol col = new IntIntsCol(0, new int[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerIntIntRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    IntLongsCol col = new IntLongsCol(0, new long[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntLongRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadIntLongRows(ServerPartition part, ServerRow[] rows,\n+                                 MatrixPartitionMeta partMeta,\n+                                 PSMatrixLoadContext loadContext, DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        IntLongsCol col = new IntLongsCol(0, new long[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerIntLongRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadLongFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    LongFloatsCol col = new LongFloatsCol(0, new float[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadLongFloatRows(ServerPartition part, ServerRow[] rows,\n+                                   MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext,\n+                                   DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        LongFloatsCol col = new LongFloatsCol(0, new float[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerLongFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadLongDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    LongDoublesCol col = new LongDoublesCol(0, new double[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadLongDoubleRows(ServerPartition part, ServerRow[] rows,\n+                                    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext,\n+                                    DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        LongDoublesCol col = new LongDoublesCol(0, new double[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerLongDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    LongIntsCol col = new LongIntsCol(0, new int[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongIntRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadLongIntRows(ServerPartition part, ServerRow[] rows,\n+                                 MatrixPartitionMeta partMeta,\n+                                 PSMatrixLoadContext loadContext, DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        LongIntsCol col = new LongIntsCol(0, new int[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerLongIntRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n-\n-  private void loadLongLongRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n-    int saveElemNum = partMeta.getSaveColElemNum();\n-    LongLongsCol col = new LongLongsCol(0, new long[saveElemNum]);\n-\n-    for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongLongRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+\n+    private void loadLongLongRows(ServerPartition part, ServerRow[] rows,\n+                                  MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext,\n+                                  DataInputStream input)\n+            throws IOException {\n+        int saveColNum = partMeta.getSaveColNum();\n+        int saveElemNum = partMeta.getSaveColElemNum();\n+        LongLongsCol col = new LongLongsCol(0, new long[saveElemNum]);\n+\n+        for (int i = 0; i < saveColNum; i++) {\n+            load(col, input);\n+            for (int j = 0; j < saveElemNum; j++) {\n+                ((ServerLongLongRow) rows[j]).set(col.colId, col.colElems[j]);\n+            }\n+        }\n     }\n-  }\n }\n",
            "diff_size": 685
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "194",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "233",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "238",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "267",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "271",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "301",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 160).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "330",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 178).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "358",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "386",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 160).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "427",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "468",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "508",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "549",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 157).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "563",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 158).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "577",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 176).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "590",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 177).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "603",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 158).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "617",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "631",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 177).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "644",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 157).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/803/ColumnFormat.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/803/ColumnFormat.java\nindex 74447d6d82..532cc396c4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/803/ColumnFormat.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/803/ColumnFormat.java\n@@ -190,9 +190,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    */\n   public abstract void load(LongLongsCol col, DataInputStream output) throws IOException;\n \n-\n-  @Override public void save(ServerPartition part, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n+@Override\n+public void save(ServerPartition part, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     List<Integer> rowIds = saveContext.getRowIndexes();\n     PartitionSource rows = part.getRows();\n     if (rowIds == null || rowIds.isEmpty()) {\n@@ -231,13 +230,12 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     } else if (row0 instanceof ServerLongLongRow) {\n       saveLongLongRows(part, rowList, partMeta, saveContext, output);\n     } else {\n-      throw new UnsupportedOperationException(\n-        \"Unknown server row type \" + row0.getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown server row type \" + row0.getClass().getName());\n     }\n   }\n \n-  @Override public void load(ServerPartition part, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n+  @Override\n+public void load(ServerPartition part, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     Map<Integer, RowPartitionMeta> rowMetas = partMeta.getRowMetas();\n     int[] rowIds = new int[rowMetas.size()];\n     ServerRow[] rows = new ServerRow[rowMetas.size()];\n@@ -266,13 +264,11 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     } else if (row0 instanceof ServerLongLongRow) {\n       loadLongLongRows(part, rows, partMeta, loadContext, input);\n     } else {\n-      throw new UnsupportedOperationException(\n-        \"Unknown server row type \" + row0.getClass().getName());\n+      throw new UnsupportedOperationException(\"Unknown server row type \" + row0.getClass().getName());\n     }\n   }\n \n-  private void saveIntFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n+  private void saveIntFloatRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n     throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.length;\n@@ -302,8 +298,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n   }\n \n \n-  private void saveIntDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n+  private void saveIntDoubleRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n     throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.length;\n@@ -332,8 +327,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void saveIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n+  private void saveIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     int indexOffset = (int) part.getPartitionKey().getStartCol();\n@@ -361,8 +355,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void saveIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n+  private void saveIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     int indexOffset = (int) part.getPartitionKey().getStartCol();\n@@ -390,8 +383,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void saveLongFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n+  private void saveLongFloatRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n     throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n@@ -432,8 +424,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void saveLongDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n+  private void saveLongDoubleRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n     throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n@@ -474,8 +465,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void saveLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n+  private void saveLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     long indexOffset = part.getPartitionKey().getStartCol();\n@@ -515,8 +505,7 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void saveLongLongRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n+  private void saveLongLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n     throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n@@ -557,10 +546,9 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadIntFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n+  private void loadIntFloatRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n     throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntFloatsCol col = new IntFloatsCol(0, new float[saveElemNum]);\n \n@@ -572,10 +560,9 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadIntDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n+  private void loadIntDoubleRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n     throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntDoublesCol col = new IntDoublesCol(0, new double[saveElemNum]);\n \n@@ -587,9 +574,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  private void loadIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntIntsCol col = new IntIntsCol(0, new int[saveElemNum]);\n \n@@ -601,9 +587,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  private void loadIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntLongsCol col = new IntLongsCol(0, new long[saveElemNum]);\n \n@@ -615,10 +600,9 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadLongFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n+  private void loadLongFloatRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n     throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongFloatsCol col = new LongFloatsCol(0, new float[saveElemNum]);\n \n@@ -630,10 +614,9 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadLongDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n+  private void loadLongDoubleRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n     throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongDoublesCol col = new LongDoublesCol(0, new double[saveElemNum]);\n \n@@ -645,9 +628,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  private void loadLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongIntsCol col = new LongIntsCol(0, new int[saveElemNum]);\n \n@@ -659,10 +641,9 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     }\n   }\n \n-  private void loadLongLongRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n+  private void loadLongLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n     throws IOException {\n-    int saveColNum = partMeta.getSaveColNum();\n+  int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongLongsCol col = new LongLongsCol(0, new long[saveElemNum]);\n \n@@ -673,4 +654,4 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 50
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "49",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 57.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "59",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 67.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 77.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 87.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "89",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 97.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "99",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 107.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 117.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "119",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 127.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "129",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 137.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "139",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 147.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "149",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 157.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "159",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 167.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "169",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 177.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "179",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 187.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "189",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 197.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "199",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 207.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "236",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "272",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 160).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "286",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "304",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "334",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "364",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "394",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "425",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 154).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "434",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "467",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "476",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "509",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 150).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "518",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "551",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 152).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "560",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "588",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "603",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "618",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "633",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "648",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "663",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "678",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "693",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/803/ColumnFormat.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/803/ColumnFormat.java\nindex 74447d6d82..30227511af 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/803/ColumnFormat.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/803/ColumnFormat.java\n@@ -33,7 +33,6 @@ import it.unimi.dsi.fastutil.longs.Long2FloatMap;\n import it.unimi.dsi.fastutil.longs.Long2IntMap;\n import it.unimi.dsi.fastutil.longs.Long2LongMap;\n import it.unimi.dsi.fastutil.objects.ObjectIterator;\n-\n import java.io.DataInputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n@@ -45,6 +44,7 @@ import java.util.Map;\n /**\n  * Column first format for matrix\n  */\n+\n public abstract class ColumnFormat extends MatrixFormatImpl {\n   /**\n    * Write a matrix column to output stream\n@@ -53,7 +53,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(IntFloatsCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(IntFloatsCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -62,7 +63,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(IntDoublesCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(IntDoublesCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -71,7 +73,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(IntIntsCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(IntIntsCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -80,7 +83,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(IntLongsCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(IntLongsCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -89,7 +93,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(LongFloatsCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(LongFloatsCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -98,7 +103,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(LongDoublesCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(LongDoublesCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -107,7 +113,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(LongIntsCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(LongIntsCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Write a matrix column to output stream\n@@ -116,7 +123,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output output stream\n    * @throws IOException\n    */\n-  public abstract void save(LongLongsCol col, DataOutputStream output) throws IOException;\n+\n+    public abstract void save(LongLongsCol col, DataOutputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -125,7 +133,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(IntFloatsCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(IntFloatsCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -134,7 +143,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(IntDoublesCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(IntDoublesCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -143,7 +153,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(IntIntsCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(IntIntsCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -152,7 +163,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(IntLongsCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(IntLongsCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -161,7 +173,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(LongFloatsCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(LongFloatsCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -170,7 +183,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(LongDoublesCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(LongDoublesCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -179,7 +193,8 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(LongIntsCol col, DataInputStream output) throws IOException;\n+\n+    public abstract void load(LongIntsCol col, DataInputStream output) throws IOException;\n \n   /**\n    * Read a matrix column to input stream\n@@ -188,19 +203,22 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n    * @param output input stream\n    * @throws IOException\n    */\n-  public abstract void load(LongLongsCol col, DataInputStream output) throws IOException;\n \n+    public abstract void load(LongLongsCol col, DataInputStream output) throws IOException;\n \n-  @Override public void save(ServerPartition part, MatrixPartitionMeta partMeta,\n-    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n+    @Override\n+    public void save(ServerPartition part,\n+                     MatrixPartitionMeta partMeta,\n+                     PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     List<Integer> rowIds = saveContext.getRowIndexes();\n     PartitionSource rows = part.getRows();\n     if (rowIds == null || rowIds.isEmpty()) {\n-      Iterator<Map.Entry<Integer, ServerRow>> iter = part.getRows().iterator();\n-      rowIds = new ArrayList<>();\n-      while (iter.hasNext()) {\n-        rowIds.add(iter.next().getKey());\n-      }\n+        Iterator<Map.Entry<Integer, ServerRow>> iter = part.getRows().iterator();\n+        rowIds = new ArrayList<>();\n+\n+        while (iter.hasNext()) {\n+                                                rowIds.add(iter.next().getKey());\n+        }\n     } else {\n       rowIds = filter(part, rowIds);\n     }\n@@ -208,469 +226,473 @@ public abstract class ColumnFormat extends MatrixFormatImpl {\n     int size = rowIds.size();\n     ServerRow[] rowList = new ServerRow[size];\n     for (int i = 0; i < size; i++) {\n-      rowList[i] = rows.getRow(rowIds.get(i));\n+        rowList[i] = rows.getRow(rowIds.get(i));\n     }\n \n-\n     ServerRow row0 = rowList[0];\n-\n     if (row0 instanceof ServerIntFloatRow) {\n-      saveIntFloatRows(part, rowList, partMeta, saveContext, output);\n+        saveIntFloatRows(part, rowList, partMeta, saveContext, output);\n     } else if (row0 instanceof ServerIntDoubleRow) {\n-      saveIntDoubleRows(part, rowList, partMeta, saveContext, output);\n+                                                                                                      saveIntDoubleRows(part, rowList, partMeta, saveContext, output);\n     } else if (row0 instanceof ServerIntIntRow) {\n-      saveIntIntRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerIntLongRow) {\n-      saveIntLongRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongFloatRow) {\n-      saveLongFloatRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongDoubleRow) {\n-      saveLongDoubleRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongIntRow) {\n-      saveLongIntRows(part, rowList, partMeta, saveContext, output);\n-    } else if (row0 instanceof ServerLongLongRow) {\n-      saveLongLongRows(part, rowList, partMeta, saveContext, output);\n-    } else {\n-      throw new UnsupportedOperationException(\n-        \"Unknown server row type \" + row0.getClass().getName());\n+        saveIntIntRows(part, rowList, partMeta, saveContext, output);\n+           } else if (row0 instanceof ServerIntLongRow) {\n+        saveIntLongRows(part, rowList, partMeta, saveContext, output);\n+           } else if (row0 instanceof ServerLongFloatRow) {\n+               saveLongFloatRows(part, rowList, partMeta, saveContext, output);\n+                  } else if (row0 instanceof ServerLongDoubleRow) {\n+               saveLongDoubleRows(part, rowList, partMeta, saveContext, output);\n+                  } else if (row0 instanceof ServerLongIntRow) {\n+                      saveLongIntRows(part, rowList, partMeta, saveContext, output);\n+                         } else if (row0 instanceof ServerLongLongRow) {\n+                      saveLongLongRows(part, rowList, partMeta, saveContext, output);\n+                         } else {\n+                           throw new UnsupportedOperationException(\"Unknown server row type \" + row0.getClass().getName());\n+                         }\n     }\n-  }\n \n-  @Override public void load(ServerPartition part, MatrixPartitionMeta partMeta,\n-    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n+    @Override\n+    public void load(ServerPartition part,\n+                     MatrixPartitionMeta partMeta,\n+                     PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     Map<Integer, RowPartitionMeta> rowMetas = partMeta.getRowMetas();\n     int[] rowIds = new int[rowMetas.size()];\n     ServerRow[] rows = new ServerRow[rowMetas.size()];\n     int i = 0;\n     for (int rowId : rowMetas.keySet()) {\n-      rowIds[i] = rowId;\n-      rows[i] = part.getRow(rowId);\n-      i++;\n+        rowIds[i] = rowId;\n+        rows[i] = part.getRow(rowId);\n+        i++;\n     }\n \n     ServerRow row0 = part.getRow(rowIds[0]);\n     if (row0 instanceof ServerIntFloatRow) {\n-      loadIntFloatRows(part, rows, partMeta, loadContext, input);\n+        loadIntFloatRows(part, rows, partMeta, loadContext, input);\n     } else if (row0 instanceof ServerIntDoubleRow) {\n-      loadIntDoubleRows(part, rows, partMeta, loadContext, input);\n+                                                                                                    loadIntDoubleRows(part, rows, partMeta, loadContext, input);\n     } else if (row0 instanceof ServerIntIntRow) {\n-      loadIntIntRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerIntLongRow) {\n-      loadIntLongRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongFloatRow) {\n-      loadLongFloatRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongDoubleRow) {\n-      loadLongDoubleRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongIntRow) {\n-      loadLongIntRows(part, rows, partMeta, loadContext, input);\n-    } else if (row0 instanceof ServerLongLongRow) {\n-      loadLongLongRows(part, rows, partMeta, loadContext, input);\n-    } else {\n-      throw new UnsupportedOperationException(\n-        \"Unknown server row type \" + row0.getClass().getName());\n+        loadIntIntRows(part, rows, partMeta, loadContext, input);\n+           } else if (row0 instanceof ServerIntLongRow) {\n+        loadIntLongRows(part, rows, partMeta, loadContext, input);\n+           } else if (row0 instanceof ServerLongFloatRow) {\n+               loadLongFloatRows(part, rows, partMeta, loadContext, input);\n+                  } else if (row0 instanceof ServerLongDoubleRow) {\n+               loadLongDoubleRows(part, rows, partMeta, loadContext, input);\n+                  } else if (row0 instanceof ServerLongIntRow) {\n+                      loadLongIntRows(part, rows, partMeta, loadContext, input);\n+                         } else if (row0 instanceof ServerLongLongRow) {\n+                      loadLongLongRows(part, rows, partMeta, loadContext, input);\n+                         } else {\n+                           throw new UnsupportedOperationException(\"Unknown server row type \" + row0.getClass().getName());\n+                         }\n     }\n-  }\n \n-  private void saveIntFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n+    private void saveIntFloatRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.length;\n     int indexOffset = (int) part.getPartitionKey().getStartCol();\n     IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n-\n     IntFloatsCol col = new IntFloatsCol(0, new float[rows.length]);\n     if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+        int[] indices = storage.getIndices();\n+        for (int i = 0; i < indices.length; i++) {\n+                               col.colId = indices[i] + indexOffset;\n+                               for (int j = 0; j < rows.length; j++) {\n+                                                     col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+                               }\n+                               save(col, output);\n         }\n-        save(col, output);\n-      }\n     } else {\n       ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getIntKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerIntFloatRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n-\n+    }\n \n-  private void saveIntDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n+    private void saveIntDoubleRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.length;\n     int indexOffset = (int) part.getPartitionKey().getStartCol();\n     IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n-\n     IntDoublesCol col = new IntDoublesCol(0, new double[rows.length]);\n     if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n+        int[] indices = storage.getIndices();\n+        for (int i = 0; i < indices.length; i++) {\n+                               col.colId = indices[i] + indexOffset;\n+                               for (int j = 0; j < rows.length; j++) {\n+                                                     col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n+                               }\n+                               save(col, output);\n         }\n-        save(col, output);\n-      }\n     } else {\n       ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getIntKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerIntDoubleRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void saveIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n+    private void saveIntIntRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n     PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     int indexOffset = (int) part.getPartitionKey().getStartCol();\n     IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n-\n     IntIntsCol col = new IntIntsCol(0, new int[rows.length]);\n     if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n+        int[] indices = storage.getIndices();\n+        for (int i = 0; i < indices.length; i++) {\n+                               col.colId = indices[i] + indexOffset;\n+                               for (int j = 0; j < rows.length; j++) {\n+                                                     col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n+                               }\n+                               save(col, output);\n         }\n-        save(col, output);\n-      }\n     } else {\n       ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getIntKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerIntIntRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void saveIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n+    private void saveIntLongRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n     PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     int indexOffset = (int) part.getPartitionKey().getStartCol();\n     IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n-\n     IntLongsCol col = new IntLongsCol(0, new long[rows.length]);\n     if (storage.isDense()) {\n-      int[] indices = storage.getIndices();\n-      for (int i = 0; i < indices.length; i++) {\n-        col.colId = indices[i] + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n+        int[] indices = storage.getIndices();\n+        for (int i = 0; i < indices.length; i++) {\n+                               col.colId = indices[i] + indexOffset;\n+                               for (int j = 0; j < rows.length; j++) {\n+                                                     col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n+                               }\n+                               save(col, output);\n         }\n-        save(col, output);\n-      }\n     } else {\n       ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getIntKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getIntKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerIntLongRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void saveLongFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n+    private void saveLongFloatRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     long indexOffset = part.getPartitionKey().getStartCol();\n-\n     LongFloatsCol col = new LongFloatsCol(0, new float[rows.length]);\n     if (vec instanceof IntFloatVector) {\n-      IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+        IntFloatVectorStorage storage = ((IntFloatVector) vec).getStorage();\n+        if (storage.isDense()) {\n+                                           int[] indices = storage.getIndices();\n+                                           for (int i = 0; i < indices.length; i++) {\n+                                   col.colId = indices[i] + indexOffset;\n+                                   for (int j = 0; j < rows.length; j++) {\n+                                                                                        col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+                                   }\n+                                   save(col, output);\n+                                           }\n+        } else {\n+          ObjectIterator<Int2FloatMap.Entry> iter = storage.entryIterator();\n+          while (iter.hasNext()) {\n+                   col.colId = iter.next().getIntKey() + indexOffset;\n+                   for (int j = 0; j < rows.length; j++) {\n+                                     col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+                   }\n+                   save(col, output);\n           }\n-          save(col, output);\n         }\n-      }\n     } else {\n       LongFloatVectorStorage storage = ((LongFloatVector) vec).getStorage();\n       ObjectIterator<Long2FloatMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getLongKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerLongFloatRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void saveLongDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n+    private void saveLongDoubleRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     long indexOffset = part.getPartitionKey().getStartCol();\n-\n     LongDoublesCol col = new LongDoublesCol(0, new double[rows.length]);\n     if (vec instanceof IntDoubleVector) {\n-      IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+        IntDoubleVectorStorage storage = ((IntDoubleVector) vec).getStorage();\n+        if (storage.isDense()) {\n+                                            int[] indices = storage.getIndices();\n+                                            for (int i = 0; i < indices.length; i++) {\n+                                   col.colId = indices[i] + indexOffset;\n+                                   for (int j = 0; j < rows.length; j++) {\n+                                                                                         col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+                                   }\n+                                   save(col, output);\n+                                            }\n+        } else {\n+          ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n+          while (iter.hasNext()) {\n+                   col.colId = iter.next().getIntKey() + indexOffset;\n+                   for (int j = 0; j < rows.length; j++) {\n+                                     col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+                   }\n+                   save(col, output);\n           }\n-          save(col, output);\n         }\n-      } else {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      }\n     } else {\n       LongDoubleVectorStorage storage = ((LongDoubleVector) vec).getStorage();\n       ObjectIterator<Long2DoubleMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getLongKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerLongDoubleRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void saveLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n+    private void saveLongIntRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n     PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     long indexOffset = part.getPartitionKey().getStartCol();\n-\n     LongIntsCol col = new LongIntsCol(0, new int[rows.length]);\n     if (vec instanceof IntIntVector) {\n-      IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+        IntIntVectorStorage storage = ((IntIntVector) vec).getStorage();\n+        if (storage.isDense()) {\n+                                         int[] indices = storage.getIndices();\n+                                         for (int i = 0; i < indices.length; i++) {\n+                                   col.colId = indices[i] + indexOffset;\n+                                   for (int j = 0; j < rows.length; j++) {\n+                                                                                      col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+                                   }\n+                                   save(col, output);\n+                                         }\n+        } else {\n+          ObjectIterator<Int2IntMap.Entry> iter = storage.entryIterator();\n+          while (iter.hasNext()) {\n+                   col.colId = iter.next().getIntKey() + indexOffset;\n+                   for (int j = 0; j < rows.length; j++) {\n+                                     col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+                   }\n+                   save(col, output);\n           }\n-          save(col, output);\n         }\n-      }\n     } else {\n       LongIntVectorStorage storage = ((LongIntVector) vec).getStorage();\n       ObjectIterator<Long2IntMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getLongKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerLongIntRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void saveLongLongRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixSaveContext saveContext, DataOutputStream output)\n-    throws IOException {\n+    private void saveLongLongRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixSaveContext saveContext, DataOutputStream output) throws IOException {\n     Vector vec = rows[0].getSplit();\n     //int size = rows.size();\n     long indexOffset = part.getPartitionKey().getStartCol();\n-\n     LongLongsCol col = new LongLongsCol(0, new long[rows.length]);\n     if (vec instanceof IntLongVector) {\n-      IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n-      if (storage.isDense()) {\n-        int[] indices = storage.getIndices();\n-        for (int i = 0; i < indices.length; i++) {\n-          col.colId = indices[i] + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n-          }\n-          save(col, output);\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n-        while (iter.hasNext()) {\n-          col.colId = iter.next().getIntKey() + indexOffset;\n-          for (int j = 0; j < rows.length; j++) {\n-            col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+        IntLongVectorStorage storage = ((IntLongVector) vec).getStorage();\n+        if (storage.isDense()) {\n+                                          int[] indices = storage.getIndices();\n+                                          for (int i = 0; i < indices.length; i++) {\n+                                   col.colId = indices[i] + indexOffset;\n+                                   for (int j = 0; j < rows.length; j++) {\n+                                                                                       col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+                                   }\n+                                   save(col, output);\n+                                          }\n+        } else {\n+          ObjectIterator<Int2LongMap.Entry> iter = storage.entryIterator();\n+          while (iter.hasNext()) {\n+                   col.colId = iter.next().getIntKey() + indexOffset;\n+                   for (int j = 0; j < rows.length; j++) {\n+                                     col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+                   }\n+                   save(col, output);\n           }\n-          save(col, output);\n         }\n-      }\n     } else {\n       LongLongVectorStorage storage = ((LongLongVector) vec).getStorage();\n       ObjectIterator<Long2LongMap.Entry> iter = storage.entryIterator();\n       while (iter.hasNext()) {\n-        col.colId = iter.next().getLongKey() + indexOffset;\n-        for (int j = 0; j < rows.length; j++) {\n-          col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n-        }\n-        save(col, output);\n+               col.colId = iter.next().getLongKey() + indexOffset;\n+               for (int j = 0; j < rows.length; j++) {\n+                                 col.colElems[j] = ((ServerLongLongRow) (rows[j])).get(col.colId);\n+               }\n+               save(col, output);\n       }\n     }\n-  }\n+    }\n \n-  private void loadIntFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n+    private void loadIntFloatRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntFloatsCol col = new IntFloatsCol(0, new float[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerIntFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadIntDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n+    private void loadIntDoubleRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntDoublesCol col = new IntDoublesCol(0, new double[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerIntDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadIntIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n+    private void loadIntIntRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n     PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntIntsCol col = new IntIntsCol(0, new int[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntIntRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerIntIntRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadIntLongRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n+    private void loadIntLongRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n     PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     IntLongsCol col = new IntLongsCol(0, new long[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerIntLongRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerIntLongRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadLongFloatRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n+    private void loadLongFloatRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongFloatsCol col = new LongFloatsCol(0, new float[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerLongFloatRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadLongDoubleRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n+    private void loadLongDoubleRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongDoublesCol col = new LongDoublesCol(0, new double[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerLongDoubleRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadLongIntRows(ServerPartition part, ServerRow[] rows, MatrixPartitionMeta partMeta,\n+    private void loadLongIntRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n     PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongIntsCol col = new LongIntsCol(0, new int[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongIntRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerLongIntRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n+    }\n     }\n-  }\n \n-  private void loadLongLongRows(ServerPartition part, ServerRow[] rows,\n-    MatrixPartitionMeta partMeta, PSMatrixLoadContext loadContext, DataInputStream input)\n-    throws IOException {\n+    private void loadLongLongRows(ServerPartition part,\n+    ServerRow[] rows,\n+    MatrixPartitionMeta partMeta,\n+    PSMatrixLoadContext loadContext, DataInputStream input) throws IOException {\n     int saveColNum = partMeta.getSaveColNum();\n     int saveElemNum = partMeta.getSaveColElemNum();\n     LongLongsCol col = new LongLongsCol(0, new long[saveElemNum]);\n-\n     for (int i = 0; i < saveColNum; i++) {\n-      load(col, input);\n-      for (int j = 0; j < saveElemNum; j++) {\n-        ((ServerLongLongRow) rows[j]).set(col.colId, col.colElems[j]);\n-      }\n+        load(col, input);\n+        for (int j = 0; j < saveElemNum; j++) {\n+                                             ((ServerLongLongRow) rows[j]).set(col.colId, col.colElems[j]);\n+        }\n     }\n-  }\n-}\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 385
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}