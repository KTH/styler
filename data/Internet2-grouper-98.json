{
    "error_id": "98",
    "information": {
        "errors": [
            {
                "line": "105",
                "severity": "warning",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\n    /**\n     * Unwraps the cause of a throwable due to reflection. \n     * @param xthrow the throwable\n     * @return the cause\n     */",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "105",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/98/JexlException.java\nindex c1792e85ed..e628c0d633 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/98/JexlException.java\n@@ -1,419 +1,419 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\r\n-\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.UndeclaredThrowableException;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.JexlNode;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.ParseException;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.TokenMgrError;\r\n-\r\n-/**\r\n- * Wraps any error that might occur during interpretation of a script or expression.\r\n- * @since 2.0\r\n- */\r\n-public class JexlException extends RuntimeException {\r\n-    /** The point of origin for this exception. */\r\n-    protected final transient JexlNode mark;\r\n-    /** The debug info. */\r\n-    protected final transient JexlInfo info;\r\n-    /** A marker to use in NPEs stating a null operand error. */\r\n-    public static final String NULL_OPERAND = \"jexl.null\";\r\n-    /** Minimum number of characters around exception location. */\r\n-    private static final int MIN_EXCHARLOC = 5;\r\n-    /** Maximum number of characters around exception location. */\r\n-    private static final int MAX_EXCHARLOC = 10;\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param node the node causing the error\r\n-     * @param msg the error message\r\n-     */\r\n-    public JexlException(JexlNode node, String msg) {\r\n-        super(msg);\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n-\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param node the node causing the error\r\n-     * @param msg the error message\r\n-     * @param cause the exception causing the error\r\n-     */\r\n-    public JexlException(JexlNode node, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param dbg the debugging information associated\r\n-     * @param msg the error message\r\n-     */\r\n-    public JexlException(JexlInfo dbg, String msg) {\r\n-        super(msg);\r\n-        mark = null;\r\n-        info = dbg;\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param dbg the debugging information associated\r\n-     * @param msg the error message\r\n-     * @param cause the exception causing the error\r\n-     */\r\n-    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = null;\r\n-        info = dbg;\r\n-    }\r\n-\r\n-    /**\r\n-     * Unwraps the cause of a throwable due to reflection. \r\n-     * @param xthrow the throwable\r\n-     * @return the cause\r\n-     */\r\n-    private static Throwable unwrap(Throwable xthrow) {\r\n-        if (xthrow instanceof InvocationTargetException) {\r\n-            return ((InvocationTargetException) xthrow).getTargetException();\r\n-        } else if (xthrow instanceof UndeclaredThrowableException) {\r\n-            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\r\n-        } else {\r\n-            return xthrow;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Accesses detailed message.\r\n-     * @return  the message\r\n-     * @since 2.1\r\n-     */\r\n-    protected String detailedMessage() {\r\n-        return super.getMessage();\r\n-    }\r\n-\r\n-    /**\r\n-     * Formats an error message from the parser.\r\n-     * @param prefix the prefix to the message\r\n-     * @param expr the expression in error\r\n-     * @return the formatted message\r\n-     * @since 2.1\r\n-     */\r\n-    protected String parserError(String prefix, String expr) {\r\n-        int begin = info.debugInfo().getColumn();\r\n-        int end = begin + MIN_EXCHARLOC;\r\n-        begin -= MIN_EXCHARLOC;\r\n-        if (begin < 0) {\r\n-            end += MIN_EXCHARLOC;\r\n-            begin = 0;\r\n-        }\r\n-        int length = expr.length();\r\n-        if (length < MAX_EXCHARLOC) {\r\n-            return prefix + \" error in '\" + expr + \"'\";\r\n-        } else {\r\n-            return prefix + \" error near '... \"\r\n-                    + expr.substring(begin, end > length ? length : end) + \" ...'\";\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when tokenization fails.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Tokenization extends JexlException {\r\n-        /**\r\n-         * Creates a new Tokenization exception instance.\r\n-         * @param node the location info\r\n-         * @param expr the expression\r\n-         * @param cause the javacc cause\r\n-         */\r\n-        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n-        }\r\n-\r\n-        /**\r\n-         * Merge the node info and the cause info to obtain best possible location.\r\n-         * @param node the node\r\n-         * @param cause the cause\r\n-         * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"tokenization\", getExpression());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when parsing fails.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Parsing extends JexlException {\r\n-        /**\r\n-         * Creates a new Variable exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param expr the offending source\r\n-         * @param cause the javacc cause\r\n-         */\r\n-        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n-        }\r\n-\r\n-        /**\r\n-         * Merge the node info and the cause info to obtain best possible location.\r\n-         * @param node the node\r\n-         * @param cause the cause\r\n-         * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, ParseException cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"parsing\", getExpression());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when a variable is unknown.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Variable extends JexlException {\r\n-        /**\r\n-         * Creates a new Variable exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param var the unknown variable\r\n-         */\r\n-        public Variable(JexlNode node, String var) {\r\n-            super(node, var);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the variable name\r\n-         */\r\n-        public String getVariable() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"undefined variable \" + getVariable();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when a property is unknown.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Property extends JexlException {\r\n-        /**\r\n-         * Creates a new Property exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param var the unknown variable\r\n-         */\r\n-        public Property(JexlNode node, String var) {\r\n-            super(node, var);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the property name\r\n-         */\r\n-        public String getProperty() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"inaccessible or unknown property \" + getProperty();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Method extends JexlException {\r\n-        /**\r\n-         * Creates a new Method exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param name the unknown method\r\n-         */\r\n-        public Method(JexlNode node, String name) {\r\n-            super(node, name);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the method name\r\n-         */\r\n-        public String getMethod() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"unknown, ambiguous or inaccessible method \" + getMethod();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown to return a value.\r\n-     * @since 2.1\r\n-     */\r\n-    protected static class Return extends JexlException {\r\n-        /** The returned value. */\r\n-        private final Object result;\r\n-\r\n-        /**\r\n-         * Creates a new instance of Return.\r\n-         * @param node the return node\r\n-         * @param msg the message\r\n-         * @param value the returned value\r\n-         */\r\n-        protected Return(JexlNode node, String msg, Object value) {\r\n-            super(node, msg);\r\n-            this.result = value;\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the returned value\r\n-         */\r\n-        public Object getValue() {\r\n-            return result;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown to cancel a script execution.\r\n-     * @since 2.1\r\n-     */\r\n-    protected static class Cancel extends JexlException {\r\n-        /**\r\n-         * Creates a new instance of Cancel.\r\n-         * @param node the node where the interruption was detected\r\n-         */\r\n-        protected Cancel(JexlNode node) {\r\n-            super(node, \"execution cancelled\", null);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets information about the cause of this error.\r\n-     * <p>\r\n-     * The returned string represents the outermost expression in error.\r\n-     * The info parameter, an int[2] optionally provided by the caller, will be filled with the begin/end offset\r\n-     * characters of the precise error's trigger.\r\n-     * </p>\r\n-     * @param offsets character offset interval of the precise node triggering the error\r\n-     * @return a string representation of the offending expression, the empty string if it could not be determined\r\n-     */\r\n-    public String getInfo(int[] offsets) {\r\n-        Debugger dbg = new Debugger();\r\n-        if (dbg.debug(mark)) {\r\n-            if (offsets != null && offsets.length >= 2) {\r\n-                offsets[0] = dbg.start();\r\n-                offsets[1] = dbg.end();\r\n-            }\r\n-            return dbg.data();\r\n-        }\r\n-        return \"\";\r\n-    }\r\n-\r\n-    /**\r\n-     * Detailed info message about this error.\r\n-     * Format is \"debug![begin,end]: string \\n msg\" where:\r\n-     * - debug is the debugging information if it exists (@link JexlEngine.setDebug)\r\n-     * - begin, end are character offsets in the string for the precise location of the error\r\n-     * - string is the string representation of the offending expression\r\n-     * - msg is the actual explanation message for this error\r\n-     * @return this error as a string\r\n-     */\r\n-    @Override\r\n-    public String getMessage() {\r\n-        Debugger dbg = new Debugger();\r\n-        StringBuilder msg = new StringBuilder();\r\n-        if (info != null) {\r\n-            msg.append(info.debugString());\r\n-        }\r\n-        if (dbg.debug(mark)) {\r\n-            msg.append(\"![\");\r\n-            msg.append(dbg.start());\r\n-            msg.append(\",\");\r\n-            msg.append(dbg.end());\r\n-            msg.append(\"]: '\");\r\n-            msg.append(dbg.data());\r\n-            msg.append(\"'\");\r\n-        }\r\n-        msg.append(' ');\r\n-        msg.append(detailedMessage());\r\n-        Throwable cause = getCause();\r\n-        if (cause != null && NULL_OPERAND == cause.getMessage()) {\r\n-            msg.append(\" caused by null operand\");\r\n-        }\r\n-        return msg.toString();\r\n-    }\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.JexlNode;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.ParseException;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.TokenMgrError;\n+\n+/**\n+ * Wraps any error that might occur during interpretation of a script or expression.\n+ * @since 2.0\n+ */\n+public class JexlException extends RuntimeException {\n+    /** The point of origin for this exception. */\n+    protected final transient JexlNode mark;\n+    /** The debug info. */\n+    protected final transient JexlInfo info;\n+    /** A marker to use in NPEs stating a null operand error. */\n+    public static final String NULL_OPERAND = \"jexl.null\";\n+    /** Minimum number of characters around exception location. */\n+    private static final int MIN_EXCHARLOC = 5;\n+    /** Maximum number of characters around exception location. */\n+    private static final int MAX_EXCHARLOC = 10;\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param node the node causing the error\n+     * @param msg the error message\n+     */\n+    public JexlException(JexlNode node, String msg) {\n+        super(msg);\n+        mark = node;\n+        info = node != null ? node.debugInfo() : null;\n+\n+    }\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param node the node causing the error\n+     * @param msg the error message\n+     * @param cause the exception causing the error\n+     */\n+    public JexlException(JexlNode node, String msg, Throwable cause) {\n+        super(msg, unwrap(cause));\n+        mark = node;\n+        info = node != null ? node.debugInfo() : null;\n+    }\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param dbg the debugging information associated\n+     * @param msg the error message\n+     */\n+    public JexlException(JexlInfo dbg, String msg) {\n+        super(msg);\n+        mark = null;\n+        info = dbg;\n+    }\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param dbg the debugging information associated\n+     * @param msg the error message\n+     * @param cause the exception causing the error\n+     */\n+    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\n+        super(msg, unwrap(cause));\n+        mark = null;\n+        info = dbg;\n+    }\n+\n+    /**\n+     * Unwraps the cause of a throwable due to reflection. \n+     * @param xthrow the throwable\n+     * @return the cause\n+     */\n+    private static Throwable unwrap(Throwable xthrow) {\n+        if (xthrow instanceof InvocationTargetException) {\n+            return ((InvocationTargetException) xthrow).getTargetException();\n+        } else if (xthrow instanceof UndeclaredThrowableException) {\n+            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\n+        } else {\n+            return xthrow;\n+        }\n+    }\n+\n+    /**\n+     * Accesses detailed message.\n+     * @return  the message\n+     * @since 2.1\n+     */\n+    protected String detailedMessage() {\n+        return super.getMessage();\n+    }\n+\n+    /**\n+     * Formats an error message from the parser.\n+     * @param prefix the prefix to the message\n+     * @param expr the expression in error\n+     * @return the formatted message\n+     * @since 2.1\n+     */\n+    protected String parserError(String prefix, String expr) {\n+        int begin = info.debugInfo().getColumn();\n+        int end = begin + MIN_EXCHARLOC;\n+        begin -= MIN_EXCHARLOC;\n+        if (begin < 0) {\n+            end += MIN_EXCHARLOC;\n+            begin = 0;\n+        }\n+        int length = expr.length();\n+        if (length < MAX_EXCHARLOC) {\n+            return prefix + \" error in '\" + expr + \"'\";\n+        } else {\n+            return prefix + \" error near '... \"\n+                    + expr.substring(begin, end > length ? length : end) + \" ...'\";\n+        }\n+    }\n+\n+    /**\n+     * Thrown when tokenization fails.\n+     * @since 2.1\n+     */\n+    public static class Tokenization extends JexlException {\n+        /**\n+         * Creates a new Tokenization exception instance.\n+         * @param node the location info\n+         * @param expr the expression\n+         * @param cause the javacc cause\n+         */\n+        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\n+            super(merge(node, cause), expr.toString(), cause);\n+        }\n+\n+        /**\n+         * Merge the node info and the cause info to obtain best possible location.\n+         * @param node the node\n+         * @param cause the cause\n+         * @return the info to use\n+         */\n+        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\n+            DebugInfo dbgn = node != null ? node.debugInfo() : null;\n+            if (cause == null) {\n+                return dbgn;\n+            } else if (dbgn == null) {\n+                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\n+            } else {\n+                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\n+            }\n+        }\n+\n+        /**\n+         * @return the expression\n+         */\n+        public String getExpression() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return parserError(\"tokenization\", getExpression());\n+        }\n+    }\n+\n+    /**\n+     * Thrown when parsing fails.\n+     * @since 2.1\n+     */\n+    public static class Parsing extends JexlException {\n+        /**\n+         * Creates a new Variable exception instance.\n+         * @param node the offending ASTnode\n+         * @param expr the offending source\n+         * @param cause the javacc cause\n+         */\n+        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\n+            super(merge(node, cause), expr.toString(), cause);\n+        }\n+\n+        /**\n+         * Merge the node info and the cause info to obtain best possible location.\n+         * @param node the node\n+         * @param cause the cause\n+         * @return the info to use\n+         */\n+        private static DebugInfo merge(JexlInfo node, ParseException cause) {\n+            DebugInfo dbgn = node != null ? node.debugInfo() : null;\n+            if (cause == null) {\n+                return dbgn;\n+            } else if (dbgn == null) {\n+                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\n+            } else {\n+                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\n+            }\n+        }\n+\n+        /**\n+         * @return the expression\n+         */\n+        public String getExpression() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return parserError(\"parsing\", getExpression());\n+        }\n+    }\n+\n+    /**\n+     * Thrown when a variable is unknown.\n+     * @since 2.1\n+     */\n+    public static class Variable extends JexlException {\n+        /**\n+         * Creates a new Variable exception instance.\n+         * @param node the offending ASTnode\n+         * @param var the unknown variable\n+         */\n+        public Variable(JexlNode node, String var) {\n+            super(node, var);\n+        }\n+\n+        /**\n+         * @return the variable name\n+         */\n+        public String getVariable() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"undefined variable \" + getVariable();\n+        }\n+    }\n+\n+    /**\n+     * Thrown when a property is unknown.\n+     * @since 2.1\n+     */\n+    public static class Property extends JexlException {\n+        /**\n+         * Creates a new Property exception instance.\n+         * @param node the offending ASTnode\n+         * @param var the unknown variable\n+         */\n+        public Property(JexlNode node, String var) {\n+            super(node, var);\n+        }\n+\n+        /**\n+         * @return the property name\n+         */\n+        public String getProperty() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"inaccessible or unknown property \" + getProperty();\n+        }\n+    }\n+\n+    /**\n+     * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\n+     * @since 2.1\n+     */\n+    public static class Method extends JexlException {\n+        /**\n+         * Creates a new Method exception instance.\n+         * @param node the offending ASTnode\n+         * @param name the unknown method\n+         */\n+        public Method(JexlNode node, String name) {\n+            super(node, name);\n+        }\n+\n+        /**\n+         * @return the method name\n+         */\n+        public String getMethod() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"unknown, ambiguous or inaccessible method \" + getMethod();\n+        }\n+    }\n+\n+    /**\n+     * Thrown to return a value.\n+     * @since 2.1\n+     */\n+    protected static class Return extends JexlException {\n+        /** The returned value. */\n+        private final Object result;\n+\n+        /**\n+         * Creates a new instance of Return.\n+         * @param node the return node\n+         * @param msg the message\n+         * @param value the returned value\n+         */\n+        protected Return(JexlNode node, String msg, Object value) {\n+            super(node, msg);\n+            this.result = value;\n+        }\n+\n+        /**\n+         * @return the returned value\n+         */\n+        public Object getValue() {\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Thrown to cancel a script execution.\n+     * @since 2.1\n+     */\n+    protected static class Cancel extends JexlException {\n+        /**\n+         * Creates a new instance of Cancel.\n+         * @param node the node where the interruption was detected\n+         */\n+        protected Cancel(JexlNode node) {\n+            super(node, \"execution cancelled\", null);\n+        }\n+    }\n+\n+    /**\n+     * Gets information about the cause of this error.\n+     * <p>\n+     * The returned string represents the outermost expression in error.\n+     * The info parameter, an int[2] optionally provided by the caller, will be filled with the begin/end offset\n+     * characters of the precise error's trigger.\n+     * </p>\n+     * @param offsets character offset interval of the precise node triggering the error\n+     * @return a string representation of the offending expression, the empty string if it could not be determined\n+     */\n+    public String getInfo(int[] offsets) {\n+        Debugger dbg = new Debugger();\n+        if (dbg.debug(mark)) {\n+            if (offsets != null && offsets.length >= 2) {\n+                offsets[0] = dbg.start();\n+                offsets[1] = dbg.end();\n+            }\n+            return dbg.data();\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Detailed info message about this error.\n+     * Format is \"debug![begin,end]: string \\n msg\" where:\n+     * - debug is the debugging information if it exists (@link JexlEngine.setDebug)\n+     * - begin, end are character offsets in the string for the precise location of the error\n+     * - string is the string representation of the offending expression\n+     * - msg is the actual explanation message for this error\n+     * @return this error as a string\n+     */\n+    @Override\n+    public String getMessage() {\n+        Debugger dbg = new Debugger();\n+        StringBuilder msg = new StringBuilder();\n+        if (info != null) {\n+            msg.append(info.debugString());\n+        }\n+        if (dbg.debug(mark)) {\n+            msg.append(\"![\");\n+            msg.append(dbg.start());\n+            msg.append(\",\");\n+            msg.append(dbg.end());\n+            msg.append(\"]: '\");\n+            msg.append(dbg.data());\n+            msg.append(\"'\");\n+        }\n+        msg.append(' ');\n+        msg.append(detailedMessage());\n+        Throwable cause = getCause();\n+        if (cause != null && NULL_OPERAND == cause.getMessage()) {\n+            msg.append(\" caused by null operand\");\n+        }\n+        return msg.toString();\n+    }\n+}\n",
            "diff_size": 419
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/98/JexlException.java\nindex c1792e85ed..59f13655a4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/98/JexlException.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -29,6 +29,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\r\n \r\n import java.lang.reflect.InvocationTargetException;\r\n@@ -43,377 +44,377 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser\n  * @since 2.0\r\n  */\r\n public class JexlException extends RuntimeException {\r\n-    /** The point of origin for this exception. */\r\n-    protected final transient JexlNode mark;\r\n-    /** The debug info. */\r\n-    protected final transient JexlInfo info;\r\n-    /** A marker to use in NPEs stating a null operand error. */\r\n-    public static final String NULL_OPERAND = \"jexl.null\";\r\n-    /** Minimum number of characters around exception location. */\r\n-    private static final int MIN_EXCHARLOC = 5;\r\n-    /** Maximum number of characters around exception location. */\r\n-    private static final int MAX_EXCHARLOC = 10;\r\n+  /** The point of origin for this exception. */\r\n+  protected final transient JexlNode mark;\r\n+  /** The debug info. */\r\n+  protected final transient JexlInfo info;\r\n+  /** A marker to use in NPEs stating a null operand error. */\r\n+  public static final String NULL_OPERAND = \"jexl.null\";\r\n+  /** Minimum number of characters around exception location. */\r\n+  private static final int MIN_EXCHARLOC = 5;\r\n+  /** Maximum number of characters around exception location. */\r\n+  private static final int MAX_EXCHARLOC = 10;\r\n+\r\n+  /**\r\n+   * Creates a new JexlException.\r\n+   * @param node the node causing the error\r\n+   * @param msg the error message\r\n+   */\r\n+  public JexlException(JexlNode node, String msg) {\r\n+    super(msg);\r\n+    mark = node;\r\n+    info = node != null ? node.debugInfo() : null;\r\n+\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates a new JexlException.\r\n+   * @param node the node causing the error\r\n+   * @param msg the error message\r\n+   * @param cause the exception causing the error\r\n+   */\r\n+  public JexlException(JexlNode node, String msg, Throwable cause) {\r\n+    super(msg, unwrap(cause));\r\n+    mark = node;\r\n+    info = node != null ? node.debugInfo() : null;\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates a new JexlException.\r\n+   * @param dbg the debugging information associated\r\n+   * @param msg the error message\r\n+   */\r\n+  public JexlException(JexlInfo dbg, String msg) {\r\n+    super(msg);\r\n+    mark = null;\r\n+    info = dbg;\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates a new JexlException.\r\n+   * @param dbg the debugging information associated\r\n+   * @param msg the error message\r\n+   * @param cause the exception causing the error\r\n+   */\r\n+  public JexlException(JexlInfo dbg, String msg, Throwable cause) {\r\n+    super(msg, unwrap(cause));\r\n+    mark = null;\r\n+    info = dbg;\r\n+  }\r\n+\r\n+  /**\r\n+   * Unwraps the cause of a throwable due to reflection.\r\n+   * @param xthrow the throwable\r\n+   * @return the cause\r\n+   */\r\n+  private static Throwable unwrap(Throwable xthrow) {\r\n+    if (xthrow instanceof InvocationTargetException) {\r\n+      return ((InvocationTargetException) xthrow).getTargetException();\r\n+    } else if (xthrow instanceof UndeclaredThrowableException) {\r\n+      return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\r\n+    } else {\r\n+      return xthrow;\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Accesses detailed message.\r\n+   * @return the message\r\n+   * @since 2.1\r\n+   */\r\n+  protected String detailedMessage() {\r\n+    return super.getMessage();\r\n+  }\r\n+\r\n+  /**\r\n+   * Formats an error message from the parser.\r\n+   * @param prefix the prefix to the message\r\n+   * @param expr the expression in error\r\n+   * @return the formatted message\r\n+   * @since 2.1\r\n+   */\r\n+  protected String parserError(String prefix, String expr) {\r\n+    int begin = info.debugInfo().getColumn();\r\n+    int end = begin + MIN_EXCHARLOC;\r\n+    begin -= MIN_EXCHARLOC;\r\n+    if (begin < 0) {\r\n+      end += MIN_EXCHARLOC;\r\n+      begin = 0;\r\n+    }\r\n+    int length = expr.length();\r\n+    if (length < MAX_EXCHARLOC) {\r\n+      return prefix + \" error in '\" + expr + \"'\";\r\n+    } else {\r\n+      return prefix + \" error near '... \"\r\n+        + expr.substring(begin, end > length ? length : end) + \" ...'\";\r\n+    }\r\n+  }\r\n \r\n+  /**\r\n+   * Thrown when tokenization fails.\r\n+   * @since 2.1\r\n+   */\r\n+  public static class Tokenization extends JexlException {\r\n     /**\r\n-     * Creates a new JexlException.\r\n-     * @param node the node causing the error\r\n-     * @param msg the error message\r\n+     * Creates a new Tokenization exception instance.\r\n+     * @param node the location info\r\n+     * @param expr the expression\r\n+     * @param cause the javacc cause\r\n      */\r\n-    public JexlException(JexlNode node, String msg) {\r\n-        super(msg);\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n-\r\n+    public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\r\n+      super(merge(node, cause), expr.toString(), cause);\r\n     }\r\n \r\n     /**\r\n-     * Creates a new JexlException.\r\n-     * @param node the node causing the error\r\n-     * @param msg the error message\r\n-     * @param cause the exception causing the error\r\n+     * Merge the node info and the cause info to obtain best possible location.\r\n+     * @param node the node\r\n+     * @param cause the cause\r\n+     * @return the info to use\r\n      */\r\n-    public JexlException(JexlNode node, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n+    private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\r\n+      DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n+      if (cause == null) {\r\n+        return dbgn;\r\n+      } else if (dbgn == null) {\r\n+        return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n+      } else {\r\n+        return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n+      }\r\n     }\r\n \r\n     /**\r\n-     * Creates a new JexlException.\r\n-     * @param dbg the debugging information associated\r\n-     * @param msg the error message\r\n+     * @return the expression\r\n      */\r\n-    public JexlException(JexlInfo dbg, String msg) {\r\n-        super(msg);\r\n-        mark = null;\r\n-        info = dbg;\r\n+    public String getExpression() {\r\n+      return super.detailedMessage();\r\n     }\r\n \r\n+    @Override\r\n+    protected String detailedMessage() {\r\n+      return parserError(\"tokenization\", getExpression());\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Thrown when parsing fails.\r\n+   * @since 2.1\r\n+   */\r\n+  public static class Parsing extends JexlException {\r\n     /**\r\n-     * Creates a new JexlException.\r\n-     * @param dbg the debugging information associated\r\n-     * @param msg the error message\r\n-     * @param cause the exception causing the error\r\n+     * Creates a new Variable exception instance.\r\n+     * @param node the offending ASTnode\r\n+     * @param expr the offending source\r\n+     * @param cause the javacc cause\r\n      */\r\n-    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = null;\r\n-        info = dbg;\r\n+    public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\r\n+      super(merge(node, cause), expr.toString(), cause);\r\n     }\r\n \r\n     /**\r\n-     * Unwraps the cause of a throwable due to reflection. \r\n-     * @param xthrow the throwable\r\n-     * @return the cause\r\n+     * Merge the node info and the cause info to obtain best possible location.\r\n+     * @param node the node\r\n+     * @param cause the cause\r\n+     * @return the info to use\r\n      */\r\n-    private static Throwable unwrap(Throwable xthrow) {\r\n-        if (xthrow instanceof InvocationTargetException) {\r\n-            return ((InvocationTargetException) xthrow).getTargetException();\r\n-        } else if (xthrow instanceof UndeclaredThrowableException) {\r\n-            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\r\n-        } else {\r\n-            return xthrow;\r\n-        }\r\n+    private static DebugInfo merge(JexlInfo node, ParseException cause) {\r\n+      DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n+      if (cause == null) {\r\n+        return dbgn;\r\n+      } else if (dbgn == null) {\r\n+        return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n+      } else {\r\n+        return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n+      }\r\n     }\r\n \r\n     /**\r\n-     * Accesses detailed message.\r\n-     * @return  the message\r\n-     * @since 2.1\r\n+     * @return the expression\r\n      */\r\n+    public String getExpression() {\r\n+      return super.detailedMessage();\r\n+    }\r\n+\r\n+    @Override\r\n     protected String detailedMessage() {\r\n-        return super.getMessage();\r\n+      return parserError(\"parsing\", getExpression());\r\n     }\r\n+  }\r\n \r\n+  /**\r\n+   * Thrown when a variable is unknown.\r\n+   * @since 2.1\r\n+   */\r\n+  public static class Variable extends JexlException {\r\n     /**\r\n-     * Formats an error message from the parser.\r\n-     * @param prefix the prefix to the message\r\n-     * @param expr the expression in error\r\n-     * @return the formatted message\r\n-     * @since 2.1\r\n+     * Creates a new Variable exception instance.\r\n+     * @param node the offending ASTnode\r\n+     * @param var the unknown variable\r\n      */\r\n-    protected String parserError(String prefix, String expr) {\r\n-        int begin = info.debugInfo().getColumn();\r\n-        int end = begin + MIN_EXCHARLOC;\r\n-        begin -= MIN_EXCHARLOC;\r\n-        if (begin < 0) {\r\n-            end += MIN_EXCHARLOC;\r\n-            begin = 0;\r\n-        }\r\n-        int length = expr.length();\r\n-        if (length < MAX_EXCHARLOC) {\r\n-            return prefix + \" error in '\" + expr + \"'\";\r\n-        } else {\r\n-            return prefix + \" error near '... \"\r\n-                    + expr.substring(begin, end > length ? length : end) + \" ...'\";\r\n-        }\r\n+    public Variable(JexlNode node, String var) {\r\n+      super(node, var);\r\n     }\r\n \r\n     /**\r\n-     * Thrown when tokenization fails.\r\n-     * @since 2.1\r\n+     * @return the variable name\r\n      */\r\n-    public static class Tokenization extends JexlException {\r\n-        /**\r\n-         * Creates a new Tokenization exception instance.\r\n-         * @param node the location info\r\n-         * @param expr the expression\r\n-         * @param cause the javacc cause\r\n-         */\r\n-        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n-        }\r\n-\r\n-        /**\r\n-         * Merge the node info and the cause info to obtain best possible location.\r\n-         * @param node the node\r\n-         * @param cause the cause\r\n-         * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"tokenization\", getExpression());\r\n-        }\r\n+    public String getVariable() {\r\n+      return super.detailedMessage();\r\n     }\r\n \r\n-    /**\r\n-     * Thrown when parsing fails.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Parsing extends JexlException {\r\n-        /**\r\n-         * Creates a new Variable exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param expr the offending source\r\n-         * @param cause the javacc cause\r\n-         */\r\n-        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n-        }\r\n-\r\n-        /**\r\n-         * Merge the node info and the cause info to obtain best possible location.\r\n-         * @param node the node\r\n-         * @param cause the cause\r\n-         * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, ParseException cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"parsing\", getExpression());\r\n-        }\r\n+    @Override\r\n+    protected String detailedMessage() {\r\n+      return \"undefined variable \" + getVariable();\r\n     }\r\n+  }\r\n \r\n+  /**\r\n+   * Thrown when a property is unknown.\r\n+   * @since 2.1\r\n+   */\r\n+  public static class Property extends JexlException {\r\n     /**\r\n-     * Thrown when a variable is unknown.\r\n-     * @since 2.1\r\n+     * Creates a new Property exception instance.\r\n+     * @param node the offending ASTnode\r\n+     * @param var the unknown variable\r\n      */\r\n-    public static class Variable extends JexlException {\r\n-        /**\r\n-         * Creates a new Variable exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param var the unknown variable\r\n-         */\r\n-        public Variable(JexlNode node, String var) {\r\n-            super(node, var);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the variable name\r\n-         */\r\n-        public String getVariable() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"undefined variable \" + getVariable();\r\n-        }\r\n+    public Property(JexlNode node, String var) {\r\n+      super(node, var);\r\n     }\r\n \r\n     /**\r\n-     * Thrown when a property is unknown.\r\n-     * @since 2.1\r\n+     * @return the property name\r\n      */\r\n-    public static class Property extends JexlException {\r\n-        /**\r\n-         * Creates a new Property exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param var the unknown variable\r\n-         */\r\n-        public Property(JexlNode node, String var) {\r\n-            super(node, var);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the property name\r\n-         */\r\n-        public String getProperty() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"inaccessible or unknown property \" + getProperty();\r\n-        }\r\n+    public String getProperty() {\r\n+      return super.detailedMessage();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String detailedMessage() {\r\n+      return \"inaccessible or unknown property \" + getProperty();\r\n     }\r\n+  }\r\n \r\n+  /**\r\n+   * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\r\n+   * @since 2.1\r\n+   */\r\n+  public static class Method extends JexlException {\r\n     /**\r\n-     * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\r\n-     * @since 2.1\r\n+     * Creates a new Method exception instance.\r\n+     * @param node the offending ASTnode\r\n+     * @param name the unknown method\r\n      */\r\n-    public static class Method extends JexlException {\r\n-        /**\r\n-         * Creates a new Method exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param name the unknown method\r\n-         */\r\n-        public Method(JexlNode node, String name) {\r\n-            super(node, name);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the method name\r\n-         */\r\n-        public String getMethod() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"unknown, ambiguous or inaccessible method \" + getMethod();\r\n-        }\r\n+    public Method(JexlNode node, String name) {\r\n+      super(node, name);\r\n     }\r\n \r\n     /**\r\n-     * Thrown to return a value.\r\n-     * @since 2.1\r\n+     * @return the method name\r\n      */\r\n-    protected static class Return extends JexlException {\r\n-        /** The returned value. */\r\n-        private final Object result;\r\n-\r\n-        /**\r\n-         * Creates a new instance of Return.\r\n-         * @param node the return node\r\n-         * @param msg the message\r\n-         * @param value the returned value\r\n-         */\r\n-        protected Return(JexlNode node, String msg, Object value) {\r\n-            super(node, msg);\r\n-            this.result = value;\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the returned value\r\n-         */\r\n-        public Object getValue() {\r\n-            return result;\r\n-        }\r\n+    public String getMethod() {\r\n+      return super.detailedMessage();\r\n+    }\r\n+\r\n+    @Override\r\n+    protected String detailedMessage() {\r\n+      return \"unknown, ambiguous or inaccessible method \" + getMethod();\r\n     }\r\n+  }\r\n+\r\n+  /**\r\n+   * Thrown to return a value.\r\n+   * @since 2.1\r\n+   */\r\n+  protected static class Return extends JexlException {\r\n+    /** The returned value. */\r\n+    private final Object result;\r\n \r\n     /**\r\n-     * Thrown to cancel a script execution.\r\n-     * @since 2.1\r\n+     * Creates a new instance of Return.\r\n+     * @param node the return node\r\n+     * @param msg the message\r\n+     * @param value the returned value\r\n      */\r\n-    protected static class Cancel extends JexlException {\r\n-        /**\r\n-         * Creates a new instance of Cancel.\r\n-         * @param node the node where the interruption was detected\r\n-         */\r\n-        protected Cancel(JexlNode node) {\r\n-            super(node, \"execution cancelled\", null);\r\n-        }\r\n+    protected Return(JexlNode node, String msg, Object value) {\r\n+      super(node, msg);\r\n+      this.result = value;\r\n     }\r\n \r\n     /**\r\n-     * Gets information about the cause of this error.\r\n-     * <p>\r\n-     * The returned string represents the outermost expression in error.\r\n-     * The info parameter, an int[2] optionally provided by the caller, will be filled with the begin/end offset\r\n-     * characters of the precise error's trigger.\r\n-     * </p>\r\n-     * @param offsets character offset interval of the precise node triggering the error\r\n-     * @return a string representation of the offending expression, the empty string if it could not be determined\r\n+     * @return the returned value\r\n      */\r\n-    public String getInfo(int[] offsets) {\r\n-        Debugger dbg = new Debugger();\r\n-        if (dbg.debug(mark)) {\r\n-            if (offsets != null && offsets.length >= 2) {\r\n-                offsets[0] = dbg.start();\r\n-                offsets[1] = dbg.end();\r\n-            }\r\n-            return dbg.data();\r\n-        }\r\n-        return \"\";\r\n+    public Object getValue() {\r\n+      return result;\r\n     }\r\n+  }\r\n \r\n+  /**\r\n+   * Thrown to cancel a script execution.\r\n+   * @since 2.1\r\n+   */\r\n+  protected static class Cancel extends JexlException {\r\n     /**\r\n-     * Detailed info message about this error.\r\n-     * Format is \"debug![begin,end]: string \\n msg\" where:\r\n-     * - debug is the debugging information if it exists (@link JexlEngine.setDebug)\r\n-     * - begin, end are character offsets in the string for the precise location of the error\r\n-     * - string is the string representation of the offending expression\r\n-     * - msg is the actual explanation message for this error\r\n-     * @return this error as a string\r\n+     * Creates a new instance of Cancel.\r\n+     * @param node the node where the interruption was detected\r\n      */\r\n-    @Override\r\n-    public String getMessage() {\r\n-        Debugger dbg = new Debugger();\r\n-        StringBuilder msg = new StringBuilder();\r\n-        if (info != null) {\r\n-            msg.append(info.debugString());\r\n-        }\r\n-        if (dbg.debug(mark)) {\r\n-            msg.append(\"![\");\r\n-            msg.append(dbg.start());\r\n-            msg.append(\",\");\r\n-            msg.append(dbg.end());\r\n-            msg.append(\"]: '\");\r\n-            msg.append(dbg.data());\r\n-            msg.append(\"'\");\r\n-        }\r\n-        msg.append(' ');\r\n-        msg.append(detailedMessage());\r\n-        Throwable cause = getCause();\r\n-        if (cause != null && NULL_OPERAND == cause.getMessage()) {\r\n-            msg.append(\" caused by null operand\");\r\n-        }\r\n-        return msg.toString();\r\n+    protected Cancel(JexlNode node) {\r\n+      super(node, \"execution cancelled\", null);\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Gets information about the cause of this error.\r\n+   * <p>\r\n+   * The returned string represents the outermost expression in error.\r\n+   * The info parameter, an int[2] optionally provided by the caller, will be filled with the begin/end offset\r\n+   * characters of the precise error's trigger.\r\n+   * </p>\r\n+   * @param offsets character offset interval of the precise node triggering the error\r\n+   * @return a string representation of the offending expression, the empty string if it could not be determined\r\n+   */\r\n+  public String getInfo(int[] offsets) {\r\n+    Debugger dbg = new Debugger();\r\n+    if (dbg.debug(mark)) {\r\n+      if (offsets != null && offsets.length >= 2) {\r\n+        offsets[0] = dbg.start();\r\n+        offsets[1] = dbg.end();\r\n+      }\r\n+      return dbg.data();\r\n+    }\r\n+    return \"\";\r\n+  }\r\n+\r\n+  /**\r\n+   * Detailed info message about this error.\r\n+   * Format is \"debug![begin,end]: string \\n msg\" where:\r\n+   * - debug is the debugging information if it exists (@link JexlEngine.setDebug)\r\n+   * - begin, end are character offsets in the string for the precise location of the error\r\n+   * - string is the string representation of the offending expression\r\n+   * - msg is the actual explanation message for this error\r\n+   * @return this error as a string\r\n+   */\r\n+  @Override\r\n+  public String getMessage() {\r\n+    Debugger dbg = new Debugger();\r\n+    StringBuilder msg = new StringBuilder();\r\n+    if (info != null) {\r\n+      msg.append(info.debugString());\r\n+    }\r\n+    if (dbg.debug(mark)) {\r\n+      msg.append(\"![\");\r\n+      msg.append(dbg.start());\r\n+      msg.append(\",\");\r\n+      msg.append(dbg.end());\r\n+      msg.append(\"]: '\");\r\n+      msg.append(dbg.data());\r\n+      msg.append(\"'\");\r\n+    }\r\n+    msg.append(' ');\r\n+    msg.append(detailedMessage());\r\n+    Throwable cause = getCause();\r\n+    if (cause != null && NULL_OPERAND == cause.getMessage()) {\r\n+      msg.append(\" caused by null operand\");\r\n     }\r\n+    return msg.toString();\r\n+  }\r\n }\r\n",
            "diff_size": 512
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "105",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/98/JexlException.java\nindex c1792e85ed..495d2f13d3 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/98/JexlException.java\n@@ -416,4 +416,4 @@ public class JexlException extends RuntimeException {\n         }\r\n         return msg.toString();\r\n     }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "114",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/98/JexlException.java\nindex c1792e85ed..0089c17b2c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/98/JexlException.java\n@@ -29,41 +29,47 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\r\n-\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.UndeclaredThrowableException;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.JexlNode;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.ParseException;\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.JexlNode;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.ParseException;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.TokenMgrError;\r\n \r\n /**\r\n  * Wraps any error that might occur during interpretation of a script or expression.\r\n  * @since 2.0\r\n- */\r\n+ */\n+\n+\n public class JexlException extends RuntimeException {\r\n-    /** The point of origin for this exception. */\r\n+    /** The point of origin for this exception. */\n+\n     protected final transient JexlNode mark;\r\n-    /** The debug info. */\r\n+    /** The debug info. */\n+\n     protected final transient JexlInfo info;\r\n-    /** A marker to use in NPEs stating a null operand error. */\r\n+    /** A marker to use in NPEs stating a null operand error. */\n+\n+\n     public static final String NULL_OPERAND = \"jexl.null\";\r\n-    /** Minimum number of characters around exception location. */\r\n+    /** Minimum number of characters around exception location. */\n     private static final int MIN_EXCHARLOC = 5;\r\n-    /** Maximum number of characters around exception location. */\r\n+    /** Maximum number of characters around exception location. */\n     private static final int MAX_EXCHARLOC = 10;\r\n \r\n     /**\r\n      * Creates a new JexlException.\r\n      * @param node the node causing the error\r\n      * @param msg the error message\r\n-     */\r\n-    public JexlException(JexlNode node, String msg) {\r\n-        super(msg);\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n-\r\n+     */\n+\n+\n+    public JexlException(JexlNode node, String msg) {\n+    super(msg);\n+    mark = node;\n+    info = node != null ? node.debugInfo() : null;\n     }\r\n \r\n     /**\r\n@@ -71,22 +77,24 @@ public class JexlException extends RuntimeException {\n      * @param node the node causing the error\r\n      * @param msg the error message\r\n      * @param cause the exception causing the error\r\n-     */\r\n-    public JexlException(JexlNode node, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n+     */\n+\n+    public JexlException(JexlNode node, String msg, Throwable cause) {\n+    super(msg, unwrap(cause));\n+    mark = node;\n+    info = node != null ? node.debugInfo() : null;\n     }\r\n \r\n     /**\r\n      * Creates a new JexlException.\r\n      * @param dbg the debugging information associated\r\n      * @param msg the error message\r\n-     */\r\n-    public JexlException(JexlInfo dbg, String msg) {\r\n-        super(msg);\r\n-        mark = null;\r\n-        info = dbg;\r\n+     */\n+\n+    public JexlException(JexlInfo dbg, String msg) {\n+    super(msg);\n+    mark = null;\n+    info = dbg;\n     }\r\n \r\n     /**\r\n@@ -94,35 +102,39 @@ public class JexlException extends RuntimeException {\n      * @param dbg the debugging information associated\r\n      * @param msg the error message\r\n      * @param cause the exception causing the error\r\n-     */\r\n-    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = null;\r\n-        info = dbg;\r\n+     */\n+\n+    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\n+    super(msg, unwrap(cause));\n+    mark = null;\n+    info = dbg;\n     }\r\n \r\n     /**\r\n      * Unwraps the cause of a throwable due to reflection. \r\n      * @param xthrow the throwable\r\n      * @return the cause\r\n-     */\r\n-    private static Throwable unwrap(Throwable xthrow) {\r\n-        if (xthrow instanceof InvocationTargetException) {\r\n-            return ((InvocationTargetException) xthrow).getTargetException();\r\n-        } else if (xthrow instanceof UndeclaredThrowableException) {\r\n-            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\r\n-        } else {\r\n-            return xthrow;\r\n-        }\r\n+     */\n+\n+    private static Throwable unwrap(Throwable xthrow) {\n+        if (xthrow instanceof InvocationTargetException) {\n+            return ((InvocationTargetException) xthrow).getTargetException();\n+        } else if (xthrow instanceof UndeclaredThrowableException) {\n+            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\n+        } else {\n+                   return xthrow;\n+        }\n     }\r\n \r\n     /**\r\n      * Accesses detailed message.\r\n      * @return  the message\r\n      * @since 2.1\r\n-     */\r\n-    protected String detailedMessage() {\r\n-        return super.getMessage();\r\n+     */\n+\n+\n+    protected String detailedMessage() {\n+    return super.getMessage();\n     }\r\n \r\n     /**\r\n@@ -131,37 +143,42 @@ public class JexlException extends RuntimeException {\n      * @param expr the expression in error\r\n      * @return the formatted message\r\n      * @since 2.1\r\n-     */\r\n-    protected String parserError(String prefix, String expr) {\r\n-        int begin = info.debugInfo().getColumn();\r\n-        int end = begin + MIN_EXCHARLOC;\r\n-        begin -= MIN_EXCHARLOC;\r\n-        if (begin < 0) {\r\n-            end += MIN_EXCHARLOC;\r\n-            begin = 0;\r\n-        }\r\n-        int length = expr.length();\r\n-        if (length < MAX_EXCHARLOC) {\r\n-            return prefix + \" error in '\" + expr + \"'\";\r\n-        } else {\r\n-            return prefix + \" error near '... \"\r\n-                    + expr.substring(begin, end > length ? length : end) + \" ...'\";\r\n-        }\r\n+     */\n+\n+\n+    protected String parserError(String prefix, String expr) {\n+        int begin = info.debugInfo().getColumn();\n+        int end = begin + MIN_EXCHARLOC;\n+        begin -= MIN_EXCHARLOC;\n+\n+        if (begin < 0) {\n+            end += MIN_EXCHARLOC;\n+            begin = 0;\n+        }\n+\n+        int length = expr.length();\n+        if (length < MAX_EXCHARLOC) {\n+            return prefix + \" error in '\" + expr + \"'\";\n+        } else {\n+            return prefix + \" error near '... \" + expr.substring(begin, end > length ? length : end) + \" ...'\";\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown when tokenization fails.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     public static class Tokenization extends JexlException {\r\n         /**\r\n          * Creates a new Tokenization exception instance.\r\n          * @param node the location info\r\n          * @param expr the expression\r\n          * @param cause the javacc cause\r\n-         */\r\n-        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n+         */\n+        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\n+        super(merge(node, cause), expr.toString(), cause);\n         }\r\n \r\n         /**\r\n@@ -169,44 +186,52 @@ public class JexlException extends RuntimeException {\n          * @param node the node\r\n          * @param cause the cause\r\n          * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n+         */\n+\n+        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\n+            DebugInfo dbgn = node != null ? node.debugInfo() : null;\n+            if (cause == null) {\n+                return dbgn;\n+            } else if (dbgn == null) {\n+                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\n+            } else {\n+                       return new DebugInfo(dbgn.getName(),\n+                                            cause.getLine(),\n+                                            cause.getColumn());\n+            }\n         }\r\n \r\n         /**\r\n          * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"tokenization\", getExpression());\r\n-        }\r\n+         */\n+\n+\n+        public String getExpression() {\n+        return super.detailedMessage();\n+        }\n+\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return parserError(\"tokenization\", getExpression());\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown when parsing fails.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     public static class Parsing extends JexlException {\r\n         /**\r\n          * Creates a new Variable exception instance.\r\n          * @param node the offending ASTnode\r\n          * @param expr the offending source\r\n          * @param cause the javacc cause\r\n-         */\r\n-        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n+         */\n+        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\n+        super(merge(node, cause), expr.toString(), cause);\n         }\r\n \r\n         /**\r\n@@ -214,118 +239,142 @@ public class JexlException extends RuntimeException {\n          * @param node the node\r\n          * @param cause the cause\r\n          * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, ParseException cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n+         */\n+\n+        private static DebugInfo merge(JexlInfo node, ParseException cause) {\n+            DebugInfo dbgn = node != null ? node.debugInfo() : null;\n+            if (cause == null) {\n+                return dbgn;\n+            } else if (dbgn == null) {\n+                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\n+            } else {\n+                       return new DebugInfo(dbgn.getName(),\n+                                            cause.getLine(),\n+                                            cause.getColumn());\n+            }\n         }\r\n \r\n         /**\r\n          * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"parsing\", getExpression());\r\n-        }\r\n+         */\n+\n+\n+        public String getExpression() {\n+        return super.detailedMessage();\n+        }\n+\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return parserError(\"parsing\", getExpression());\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown when a variable is unknown.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     public static class Variable extends JexlException {\r\n         /**\r\n          * Creates a new Variable exception instance.\r\n          * @param node the offending ASTnode\r\n          * @param var the unknown variable\r\n-         */\r\n-        public Variable(JexlNode node, String var) {\r\n-            super(node, var);\r\n+         */\n+        public Variable(JexlNode node, String var) {\n+        super(node, var);\n         }\r\n \r\n         /**\r\n          * @return the variable name\r\n-         */\r\n-        public String getVariable() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"undefined variable \" + getVariable();\r\n-        }\r\n+         */\n+\n+\n+        public String getVariable() {\n+        return super.detailedMessage();\n+        }\n+\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"undefined variable \" + getVariable();\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown when a property is unknown.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     public static class Property extends JexlException {\r\n         /**\r\n          * Creates a new Property exception instance.\r\n          * @param node the offending ASTnode\r\n          * @param var the unknown variable\r\n-         */\r\n-        public Property(JexlNode node, String var) {\r\n-            super(node, var);\r\n+         */\n+        public Property(JexlNode node, String var) {\n+        super(node, var);\n         }\r\n \r\n         /**\r\n          * @return the property name\r\n-         */\r\n-        public String getProperty() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"inaccessible or unknown property \" + getProperty();\r\n-        }\r\n+         */\n+\n+\n+        public String getProperty() {\n+        return super.detailedMessage();\n+        }\n+\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"inaccessible or unknown property \" + getProperty();\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     public static class Method extends JexlException {\r\n         /**\r\n          * Creates a new Method exception instance.\r\n          * @param node the offending ASTnode\r\n          * @param name the unknown method\r\n-         */\r\n-        public Method(JexlNode node, String name) {\r\n-            super(node, name);\r\n+         */\n+        public Method(JexlNode node, String name) {\n+        super(node, name);\n         }\r\n \r\n         /**\r\n          * @return the method name\r\n-         */\r\n-        public String getMethod() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"unknown, ambiguous or inaccessible method \" + getMethod();\r\n-        }\r\n+         */\n+\n+\n+        public String getMethod() {\n+        return super.detailedMessage();\n+        }\n+\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"unknown, ambiguous or inaccessible method \" + getMethod();\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown to return a value.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     protected static class Return extends JexlException {\r\n-        /** The returned value. */\r\n+        /** The returned value. */\n+\n         private final Object result;\r\n \r\n         /**\r\n@@ -333,32 +382,38 @@ public class JexlException extends RuntimeException {\n          * @param node the return node\r\n          * @param msg the message\r\n          * @param value the returned value\r\n-         */\r\n-        protected Return(JexlNode node, String msg, Object value) {\r\n-            super(node, msg);\r\n-            this.result = value;\r\n+         */\n+\n+\n+        protected Return(JexlNode node, String msg, Object value) {\n+            super(node, msg);\n+            this.result = value;\n         }\r\n \r\n         /**\r\n          * @return the returned value\r\n-         */\r\n-        public Object getValue() {\r\n-            return result;\r\n-        }\r\n+         */\n+\n+\n+        public Object getValue() {\n+        return result;\n+        }\n     }\r\n \r\n     /**\r\n      * Thrown to cancel a script execution.\r\n      * @since 2.1\r\n-     */\r\n+     */\n+\n+\n     protected static class Cancel extends JexlException {\r\n         /**\r\n          * Creates a new instance of Cancel.\r\n          * @param node the node where the interruption was detected\r\n-         */\r\n-        protected Cancel(JexlNode node) {\r\n-            super(node, \"execution cancelled\", null);\r\n-        }\r\n+         */\n+        protected Cancel(JexlNode node) {\n+        super(node, \"execution cancelled\", null);\n+        }\n     }\r\n \r\n     /**\r\n@@ -370,17 +425,19 @@ public class JexlException extends RuntimeException {\n      * </p>\r\n      * @param offsets character offset interval of the precise node triggering the error\r\n      * @return a string representation of the offending expression, the empty string if it could not be determined\r\n-     */\r\n-    public String getInfo(int[] offsets) {\r\n-        Debugger dbg = new Debugger();\r\n-        if (dbg.debug(mark)) {\r\n-            if (offsets != null && offsets.length >= 2) {\r\n-                offsets[0] = dbg.start();\r\n-                offsets[1] = dbg.end();\r\n-            }\r\n-            return dbg.data();\r\n-        }\r\n-        return \"\";\r\n+     */\n+\n+\n+    public String getInfo(int[] offsets) {\n+        Debugger dbg = new Debugger();\n+        if (dbg.debug(mark)) {\n+            if (offsets != null && offsets.length >= 2) {\n+                offsets[0] = dbg.start();\n+                offsets[1] = dbg.end();\n+            }\n+            return dbg.data();\n+        }\n+        return \"\";\n     }\r\n \r\n     /**\r\n@@ -391,29 +448,33 @@ public class JexlException extends RuntimeException {\n      * - string is the string representation of the offending expression\r\n      * - msg is the actual explanation message for this error\r\n      * @return this error as a string\r\n-     */\r\n-    @Override\r\n-    public String getMessage() {\r\n-        Debugger dbg = new Debugger();\r\n-        StringBuilder msg = new StringBuilder();\r\n-        if (info != null) {\r\n-            msg.append(info.debugString());\r\n-        }\r\n-        if (dbg.debug(mark)) {\r\n-            msg.append(\"![\");\r\n-            msg.append(dbg.start());\r\n-            msg.append(\",\");\r\n-            msg.append(dbg.end());\r\n-            msg.append(\"]: '\");\r\n-            msg.append(dbg.data());\r\n-            msg.append(\"'\");\r\n-        }\r\n-        msg.append(' ');\r\n-        msg.append(detailedMessage());\r\n-        Throwable cause = getCause();\r\n-        if (cause != null && NULL_OPERAND == cause.getMessage()) {\r\n-            msg.append(\" caused by null operand\");\r\n-        }\r\n-        return msg.toString();\r\n-    }\r\n-}\r\n+     */\n+\n+\n+    @Override\n+    public String getMessage() {\n+        Debugger dbg = new Debugger();\n+        StringBuilder msg = new StringBuilder();\n+        if (info != null) {\n+            msg.append(info.debugString());\n+        }\n+\n+        if (dbg.debug(mark)) {\n+            msg.append(\"![\");\n+            msg.append(dbg.start());\n+            msg.append(\",\");\n+            msg.append(dbg.end());\n+            msg.append(\"]: '\");\n+            msg.append(dbg.data());\n+            msg.append(\"'\");\n+        }\n+\n+        msg.append(' ');\n+        msg.append(detailedMessage());\n+        Throwable cause = getCause();\n+        if (cause != null && NULL_OPERAND == cause.getMessage()) {\n+            msg.append(\" caused by null operand\");\n+        }\n+        return msg.toString();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 261
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "105",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/98/JexlException.java\nindex c1792e85ed..e628c0d633 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/98/JexlException.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/98/JexlException.java\n@@ -1,419 +1,419 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\r\n-\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.UndeclaredThrowableException;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.JexlNode;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.ParseException;\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.TokenMgrError;\r\n-\r\n-/**\r\n- * Wraps any error that might occur during interpretation of a script or expression.\r\n- * @since 2.0\r\n- */\r\n-public class JexlException extends RuntimeException {\r\n-    /** The point of origin for this exception. */\r\n-    protected final transient JexlNode mark;\r\n-    /** The debug info. */\r\n-    protected final transient JexlInfo info;\r\n-    /** A marker to use in NPEs stating a null operand error. */\r\n-    public static final String NULL_OPERAND = \"jexl.null\";\r\n-    /** Minimum number of characters around exception location. */\r\n-    private static final int MIN_EXCHARLOC = 5;\r\n-    /** Maximum number of characters around exception location. */\r\n-    private static final int MAX_EXCHARLOC = 10;\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param node the node causing the error\r\n-     * @param msg the error message\r\n-     */\r\n-    public JexlException(JexlNode node, String msg) {\r\n-        super(msg);\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n-\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param node the node causing the error\r\n-     * @param msg the error message\r\n-     * @param cause the exception causing the error\r\n-     */\r\n-    public JexlException(JexlNode node, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = node;\r\n-        info = node != null ? node.debugInfo() : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param dbg the debugging information associated\r\n-     * @param msg the error message\r\n-     */\r\n-    public JexlException(JexlInfo dbg, String msg) {\r\n-        super(msg);\r\n-        mark = null;\r\n-        info = dbg;\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new JexlException.\r\n-     * @param dbg the debugging information associated\r\n-     * @param msg the error message\r\n-     * @param cause the exception causing the error\r\n-     */\r\n-    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\r\n-        super(msg, unwrap(cause));\r\n-        mark = null;\r\n-        info = dbg;\r\n-    }\r\n-\r\n-    /**\r\n-     * Unwraps the cause of a throwable due to reflection. \r\n-     * @param xthrow the throwable\r\n-     * @return the cause\r\n-     */\r\n-    private static Throwable unwrap(Throwable xthrow) {\r\n-        if (xthrow instanceof InvocationTargetException) {\r\n-            return ((InvocationTargetException) xthrow).getTargetException();\r\n-        } else if (xthrow instanceof UndeclaredThrowableException) {\r\n-            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\r\n-        } else {\r\n-            return xthrow;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Accesses detailed message.\r\n-     * @return  the message\r\n-     * @since 2.1\r\n-     */\r\n-    protected String detailedMessage() {\r\n-        return super.getMessage();\r\n-    }\r\n-\r\n-    /**\r\n-     * Formats an error message from the parser.\r\n-     * @param prefix the prefix to the message\r\n-     * @param expr the expression in error\r\n-     * @return the formatted message\r\n-     * @since 2.1\r\n-     */\r\n-    protected String parserError(String prefix, String expr) {\r\n-        int begin = info.debugInfo().getColumn();\r\n-        int end = begin + MIN_EXCHARLOC;\r\n-        begin -= MIN_EXCHARLOC;\r\n-        if (begin < 0) {\r\n-            end += MIN_EXCHARLOC;\r\n-            begin = 0;\r\n-        }\r\n-        int length = expr.length();\r\n-        if (length < MAX_EXCHARLOC) {\r\n-            return prefix + \" error in '\" + expr + \"'\";\r\n-        } else {\r\n-            return prefix + \" error near '... \"\r\n-                    + expr.substring(begin, end > length ? length : end) + \" ...'\";\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when tokenization fails.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Tokenization extends JexlException {\r\n-        /**\r\n-         * Creates a new Tokenization exception instance.\r\n-         * @param node the location info\r\n-         * @param expr the expression\r\n-         * @param cause the javacc cause\r\n-         */\r\n-        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n-        }\r\n-\r\n-        /**\r\n-         * Merge the node info and the cause info to obtain best possible location.\r\n-         * @param node the node\r\n-         * @param cause the cause\r\n-         * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"tokenization\", getExpression());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when parsing fails.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Parsing extends JexlException {\r\n-        /**\r\n-         * Creates a new Variable exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param expr the offending source\r\n-         * @param cause the javacc cause\r\n-         */\r\n-        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\r\n-            super(merge(node, cause), expr.toString(), cause);\r\n-        }\r\n-\r\n-        /**\r\n-         * Merge the node info and the cause info to obtain best possible location.\r\n-         * @param node the node\r\n-         * @param cause the cause\r\n-         * @return the info to use\r\n-         */\r\n-        private static DebugInfo merge(JexlInfo node, ParseException cause) {\r\n-            DebugInfo dbgn = node != null ? node.debugInfo() : null;\r\n-            if (cause == null) {\r\n-                return dbgn;\r\n-            } else if (dbgn == null) {\r\n-                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\r\n-            } else {\r\n-                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the expression\r\n-         */\r\n-        public String getExpression() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return parserError(\"parsing\", getExpression());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when a variable is unknown.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Variable extends JexlException {\r\n-        /**\r\n-         * Creates a new Variable exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param var the unknown variable\r\n-         */\r\n-        public Variable(JexlNode node, String var) {\r\n-            super(node, var);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the variable name\r\n-         */\r\n-        public String getVariable() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"undefined variable \" + getVariable();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when a property is unknown.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Property extends JexlException {\r\n-        /**\r\n-         * Creates a new Property exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param var the unknown variable\r\n-         */\r\n-        public Property(JexlNode node, String var) {\r\n-            super(node, var);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the property name\r\n-         */\r\n-        public String getProperty() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"inaccessible or unknown property \" + getProperty();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\r\n-     * @since 2.1\r\n-     */\r\n-    public static class Method extends JexlException {\r\n-        /**\r\n-         * Creates a new Method exception instance.\r\n-         * @param node the offending ASTnode\r\n-         * @param name the unknown method\r\n-         */\r\n-        public Method(JexlNode node, String name) {\r\n-            super(node, name);\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the method name\r\n-         */\r\n-        public String getMethod() {\r\n-            return super.detailedMessage();\r\n-        }\r\n-\r\n-        @Override\r\n-        protected String detailedMessage() {\r\n-            return \"unknown, ambiguous or inaccessible method \" + getMethod();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown to return a value.\r\n-     * @since 2.1\r\n-     */\r\n-    protected static class Return extends JexlException {\r\n-        /** The returned value. */\r\n-        private final Object result;\r\n-\r\n-        /**\r\n-         * Creates a new instance of Return.\r\n-         * @param node the return node\r\n-         * @param msg the message\r\n-         * @param value the returned value\r\n-         */\r\n-        protected Return(JexlNode node, String msg, Object value) {\r\n-            super(node, msg);\r\n-            this.result = value;\r\n-        }\r\n-\r\n-        /**\r\n-         * @return the returned value\r\n-         */\r\n-        public Object getValue() {\r\n-            return result;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Thrown to cancel a script execution.\r\n-     * @since 2.1\r\n-     */\r\n-    protected static class Cancel extends JexlException {\r\n-        /**\r\n-         * Creates a new instance of Cancel.\r\n-         * @param node the node where the interruption was detected\r\n-         */\r\n-        protected Cancel(JexlNode node) {\r\n-            super(node, \"execution cancelled\", null);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Gets information about the cause of this error.\r\n-     * <p>\r\n-     * The returned string represents the outermost expression in error.\r\n-     * The info parameter, an int[2] optionally provided by the caller, will be filled with the begin/end offset\r\n-     * characters of the precise error's trigger.\r\n-     * </p>\r\n-     * @param offsets character offset interval of the precise node triggering the error\r\n-     * @return a string representation of the offending expression, the empty string if it could not be determined\r\n-     */\r\n-    public String getInfo(int[] offsets) {\r\n-        Debugger dbg = new Debugger();\r\n-        if (dbg.debug(mark)) {\r\n-            if (offsets != null && offsets.length >= 2) {\r\n-                offsets[0] = dbg.start();\r\n-                offsets[1] = dbg.end();\r\n-            }\r\n-            return dbg.data();\r\n-        }\r\n-        return \"\";\r\n-    }\r\n-\r\n-    /**\r\n-     * Detailed info message about this error.\r\n-     * Format is \"debug![begin,end]: string \\n msg\" where:\r\n-     * - debug is the debugging information if it exists (@link JexlEngine.setDebug)\r\n-     * - begin, end are character offsets in the string for the precise location of the error\r\n-     * - string is the string representation of the offending expression\r\n-     * - msg is the actual explanation message for this error\r\n-     * @return this error as a string\r\n-     */\r\n-    @Override\r\n-    public String getMessage() {\r\n-        Debugger dbg = new Debugger();\r\n-        StringBuilder msg = new StringBuilder();\r\n-        if (info != null) {\r\n-            msg.append(info.debugString());\r\n-        }\r\n-        if (dbg.debug(mark)) {\r\n-            msg.append(\"![\");\r\n-            msg.append(dbg.start());\r\n-            msg.append(\",\");\r\n-            msg.append(dbg.end());\r\n-            msg.append(\"]: '\");\r\n-            msg.append(dbg.data());\r\n-            msg.append(\"'\");\r\n-        }\r\n-        msg.append(' ');\r\n-        msg.append(detailedMessage());\r\n-        Throwable cause = getCause();\r\n-        if (cause != null && NULL_OPERAND == cause.getMessage()) {\r\n-            msg.append(\" caused by null operand\");\r\n-        }\r\n-        return msg.toString();\r\n-    }\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.JexlNode;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.ParseException;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.parser.TokenMgrError;\n+\n+/**\n+ * Wraps any error that might occur during interpretation of a script or expression.\n+ * @since 2.0\n+ */\n+public class JexlException extends RuntimeException {\n+    /** The point of origin for this exception. */\n+    protected final transient JexlNode mark;\n+    /** The debug info. */\n+    protected final transient JexlInfo info;\n+    /** A marker to use in NPEs stating a null operand error. */\n+    public static final String NULL_OPERAND = \"jexl.null\";\n+    /** Minimum number of characters around exception location. */\n+    private static final int MIN_EXCHARLOC = 5;\n+    /** Maximum number of characters around exception location. */\n+    private static final int MAX_EXCHARLOC = 10;\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param node the node causing the error\n+     * @param msg the error message\n+     */\n+    public JexlException(JexlNode node, String msg) {\n+        super(msg);\n+        mark = node;\n+        info = node != null ? node.debugInfo() : null;\n+\n+    }\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param node the node causing the error\n+     * @param msg the error message\n+     * @param cause the exception causing the error\n+     */\n+    public JexlException(JexlNode node, String msg, Throwable cause) {\n+        super(msg, unwrap(cause));\n+        mark = node;\n+        info = node != null ? node.debugInfo() : null;\n+    }\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param dbg the debugging information associated\n+     * @param msg the error message\n+     */\n+    public JexlException(JexlInfo dbg, String msg) {\n+        super(msg);\n+        mark = null;\n+        info = dbg;\n+    }\n+\n+    /**\n+     * Creates a new JexlException.\n+     * @param dbg the debugging information associated\n+     * @param msg the error message\n+     * @param cause the exception causing the error\n+     */\n+    public JexlException(JexlInfo dbg, String msg, Throwable cause) {\n+        super(msg, unwrap(cause));\n+        mark = null;\n+        info = dbg;\n+    }\n+\n+    /**\n+     * Unwraps the cause of a throwable due to reflection. \n+     * @param xthrow the throwable\n+     * @return the cause\n+     */\n+    private static Throwable unwrap(Throwable xthrow) {\n+        if (xthrow instanceof InvocationTargetException) {\n+            return ((InvocationTargetException) xthrow).getTargetException();\n+        } else if (xthrow instanceof UndeclaredThrowableException) {\n+            return ((UndeclaredThrowableException) xthrow).getUndeclaredThrowable();\n+        } else {\n+            return xthrow;\n+        }\n+    }\n+\n+    /**\n+     * Accesses detailed message.\n+     * @return  the message\n+     * @since 2.1\n+     */\n+    protected String detailedMessage() {\n+        return super.getMessage();\n+    }\n+\n+    /**\n+     * Formats an error message from the parser.\n+     * @param prefix the prefix to the message\n+     * @param expr the expression in error\n+     * @return the formatted message\n+     * @since 2.1\n+     */\n+    protected String parserError(String prefix, String expr) {\n+        int begin = info.debugInfo().getColumn();\n+        int end = begin + MIN_EXCHARLOC;\n+        begin -= MIN_EXCHARLOC;\n+        if (begin < 0) {\n+            end += MIN_EXCHARLOC;\n+            begin = 0;\n+        }\n+        int length = expr.length();\n+        if (length < MAX_EXCHARLOC) {\n+            return prefix + \" error in '\" + expr + \"'\";\n+        } else {\n+            return prefix + \" error near '... \"\n+                    + expr.substring(begin, end > length ? length : end) + \" ...'\";\n+        }\n+    }\n+\n+    /**\n+     * Thrown when tokenization fails.\n+     * @since 2.1\n+     */\n+    public static class Tokenization extends JexlException {\n+        /**\n+         * Creates a new Tokenization exception instance.\n+         * @param node the location info\n+         * @param expr the expression\n+         * @param cause the javacc cause\n+         */\n+        public Tokenization(JexlInfo node, CharSequence expr, TokenMgrError cause) {\n+            super(merge(node, cause), expr.toString(), cause);\n+        }\n+\n+        /**\n+         * Merge the node info and the cause info to obtain best possible location.\n+         * @param node the node\n+         * @param cause the cause\n+         * @return the info to use\n+         */\n+        private static DebugInfo merge(JexlInfo node, TokenMgrError cause) {\n+            DebugInfo dbgn = node != null ? node.debugInfo() : null;\n+            if (cause == null) {\n+                return dbgn;\n+            } else if (dbgn == null) {\n+                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\n+            } else {\n+                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\n+            }\n+        }\n+\n+        /**\n+         * @return the expression\n+         */\n+        public String getExpression() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return parserError(\"tokenization\", getExpression());\n+        }\n+    }\n+\n+    /**\n+     * Thrown when parsing fails.\n+     * @since 2.1\n+     */\n+    public static class Parsing extends JexlException {\n+        /**\n+         * Creates a new Variable exception instance.\n+         * @param node the offending ASTnode\n+         * @param expr the offending source\n+         * @param cause the javacc cause\n+         */\n+        public Parsing(JexlInfo node, CharSequence expr, ParseException cause) {\n+            super(merge(node, cause), expr.toString(), cause);\n+        }\n+\n+        /**\n+         * Merge the node info and the cause info to obtain best possible location.\n+         * @param node the node\n+         * @param cause the cause\n+         * @return the info to use\n+         */\n+        private static DebugInfo merge(JexlInfo node, ParseException cause) {\n+            DebugInfo dbgn = node != null ? node.debugInfo() : null;\n+            if (cause == null) {\n+                return dbgn;\n+            } else if (dbgn == null) {\n+                return new DebugInfo(\"\", cause.getLine(), cause.getColumn());\n+            } else {\n+                return new DebugInfo(dbgn.getName(), cause.getLine(), cause.getColumn());\n+            }\n+        }\n+\n+        /**\n+         * @return the expression\n+         */\n+        public String getExpression() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return parserError(\"parsing\", getExpression());\n+        }\n+    }\n+\n+    /**\n+     * Thrown when a variable is unknown.\n+     * @since 2.1\n+     */\n+    public static class Variable extends JexlException {\n+        /**\n+         * Creates a new Variable exception instance.\n+         * @param node the offending ASTnode\n+         * @param var the unknown variable\n+         */\n+        public Variable(JexlNode node, String var) {\n+            super(node, var);\n+        }\n+\n+        /**\n+         * @return the variable name\n+         */\n+        public String getVariable() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"undefined variable \" + getVariable();\n+        }\n+    }\n+\n+    /**\n+     * Thrown when a property is unknown.\n+     * @since 2.1\n+     */\n+    public static class Property extends JexlException {\n+        /**\n+         * Creates a new Property exception instance.\n+         * @param node the offending ASTnode\n+         * @param var the unknown variable\n+         */\n+        public Property(JexlNode node, String var) {\n+            super(node, var);\n+        }\n+\n+        /**\n+         * @return the property name\n+         */\n+        public String getProperty() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"inaccessible or unknown property \" + getProperty();\n+        }\n+    }\n+\n+    /**\n+     * Thrown when a method or ctor is unknown, ambiguous or inaccessible.\n+     * @since 2.1\n+     */\n+    public static class Method extends JexlException {\n+        /**\n+         * Creates a new Method exception instance.\n+         * @param node the offending ASTnode\n+         * @param name the unknown method\n+         */\n+        public Method(JexlNode node, String name) {\n+            super(node, name);\n+        }\n+\n+        /**\n+         * @return the method name\n+         */\n+        public String getMethod() {\n+            return super.detailedMessage();\n+        }\n+\n+        @Override\n+        protected String detailedMessage() {\n+            return \"unknown, ambiguous or inaccessible method \" + getMethod();\n+        }\n+    }\n+\n+    /**\n+     * Thrown to return a value.\n+     * @since 2.1\n+     */\n+    protected static class Return extends JexlException {\n+        /** The returned value. */\n+        private final Object result;\n+\n+        /**\n+         * Creates a new instance of Return.\n+         * @param node the return node\n+         * @param msg the message\n+         * @param value the returned value\n+         */\n+        protected Return(JexlNode node, String msg, Object value) {\n+            super(node, msg);\n+            this.result = value;\n+        }\n+\n+        /**\n+         * @return the returned value\n+         */\n+        public Object getValue() {\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Thrown to cancel a script execution.\n+     * @since 2.1\n+     */\n+    protected static class Cancel extends JexlException {\n+        /**\n+         * Creates a new instance of Cancel.\n+         * @param node the node where the interruption was detected\n+         */\n+        protected Cancel(JexlNode node) {\n+            super(node, \"execution cancelled\", null);\n+        }\n+    }\n+\n+    /**\n+     * Gets information about the cause of this error.\n+     * <p>\n+     * The returned string represents the outermost expression in error.\n+     * The info parameter, an int[2] optionally provided by the caller, will be filled with the begin/end offset\n+     * characters of the precise error's trigger.\n+     * </p>\n+     * @param offsets character offset interval of the precise node triggering the error\n+     * @return a string representation of the offending expression, the empty string if it could not be determined\n+     */\n+    public String getInfo(int[] offsets) {\n+        Debugger dbg = new Debugger();\n+        if (dbg.debug(mark)) {\n+            if (offsets != null && offsets.length >= 2) {\n+                offsets[0] = dbg.start();\n+                offsets[1] = dbg.end();\n+            }\n+            return dbg.data();\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Detailed info message about this error.\n+     * Format is \"debug![begin,end]: string \\n msg\" where:\n+     * - debug is the debugging information if it exists (@link JexlEngine.setDebug)\n+     * - begin, end are character offsets in the string for the precise location of the error\n+     * - string is the string representation of the offending expression\n+     * - msg is the actual explanation message for this error\n+     * @return this error as a string\n+     */\n+    @Override\n+    public String getMessage() {\n+        Debugger dbg = new Debugger();\n+        StringBuilder msg = new StringBuilder();\n+        if (info != null) {\n+            msg.append(info.debugString());\n+        }\n+        if (dbg.debug(mark)) {\n+            msg.append(\"![\");\n+            msg.append(dbg.start());\n+            msg.append(\",\");\n+            msg.append(dbg.end());\n+            msg.append(\"]: '\");\n+            msg.append(dbg.data());\n+            msg.append(\"'\");\n+        }\n+        msg.append(' ');\n+        msg.append(detailedMessage());\n+        Throwable cause = getCause();\n+        if (cause != null && NULL_OPERAND == cause.getMessage()) {\n+            msg.append(\" caused by null operand\");\n+        }\n+        return msg.toString();\n+    }\n+}\n",
            "diff_size": 419
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}