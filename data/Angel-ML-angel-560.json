{
    "error_id": "560",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler/560/MatrixCache.java\nindex 88a2dd9216..290e776125 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler/560/MatrixCache.java\n@@ -1,166 +1,166 @@\n-/*\r\n- * Tencent is pleased to support the open source community by making Angel available.\r\n- *\r\n- * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- *\r\n- * https://opensource.org/licenses/Apache-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n- * or implied. See the License for the specific language governing permissions and limitations under\r\n- * the License.\r\n- *\r\n- */\r\n-\r\n-\r\n-package com.tencent.angel.psagent.matrix.cache;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.MatrixMeta;\r\n-import com.tencent.angel.ps.storage.partition.RowBasedPartition;\r\n-import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\r\n-import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\r\n-import com.tencent.angel.ps.storage.vector.ServerRow;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-\r\n-import java.util.List;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-\r\n-/**\r\n- * Cache for a single matrix.\r\n- */\r\n-public class MatrixCache {\r\n-\r\n-  /**\r\n-   * matrix id\r\n-   */\r\n-  private final int matrixId;\r\n-\r\n-  /**\r\n-   * partition key to partition map\r\n-   */\r\n-  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n-\r\n-  /**\r\n-   * Create a new MatrixCache.\r\n-   *\r\n-   * @param matrixId matrix id\r\n-   */\r\n-  public MatrixCache(int matrixId) {\r\n-    this.matrixId = matrixId;\r\n-    this.partitionCacheMap = new ConcurrentHashMap<>();\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a partition from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @return matrix partition\r\n-   */\r\n-  public RowBasedPartition getPartition(PartitionKey partKey) {\r\n-    return partitionCacheMap.get(partKey);\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a row split from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndex row index\r\n-   * @return the row split\r\n-   */\r\n-  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n-    }\r\n-    return partCache.getRow(rowIndex);\r\n-  }\r\n-\r\n-  public int getMatrixId() {\r\n-    return matrixId;\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a batch of row splits that belong to a matrix partition\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndexes row indexes\r\n-   * @return a batch of row splits\r\n-   */\r\n-  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n-    }\r\n-    return partCache.getRows(rowIndexes);\r\n-  }\r\n-\r\n-  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\r\n-    return partitionCacheMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a matrix partition in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param part matrix partition\r\n-   */\r\n-  public void update(PartitionKey partKey, RowBasedPartition part) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null || partCache.getClock() <= part.getClock()) {\r\n-      partitionCacheMap.put(partKey, part);\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a row split in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowSplit row split\r\n-   */\r\n-  public void update(PartitionKey partKey, ServerRow rowSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n-    }\r\n-\r\n-    partCache.putRow(rowSplit);\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a batch row splits in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowsSplit a batch row splits\r\n-   */\r\n-  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n-    }\r\n-\r\n-    partCache.putRows(rowsSplit);\r\n-  }\r\n-\r\n-  private void initPart(PartitionKey partKey) {\r\n-    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n-    partitionCacheMap\r\n-        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n-            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n-                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n-  }\r\n-\r\n-  /**\r\n-   * Clean a matrix partition from cache\r\n-   *\r\n-   * @param partitionKey partition key\r\n-   */\r\n-  public void clear(PartitionKey partitionKey) {\r\n-    partitionCacheMap.remove(partitionKey);\r\n-  }\r\n-}\r\n+/*\n+ * Tencent is pleased to support the open source community by making Angel available.\n+ *\n+ * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * https://opensource.org/licenses/Apache-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+\n+package com.tencent.angel.psagent.matrix.cache;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.MatrixMeta;\n+import com.tencent.angel.ps.storage.partition.RowBasedPartition;\n+import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\n+import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\n+import com.tencent.angel.ps.storage.vector.ServerRow;\n+import com.tencent.angel.psagent.PSAgentContext;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Cache for a single matrix.\n+ */\n+public class MatrixCache {\n+\n+  /**\n+   * matrix id\n+   */\n+  private final int matrixId;\n+\n+  /**\n+   * partition key to partition map\n+   */\n+  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\n+\n+  /**\n+   * Create a new MatrixCache.\n+   *\n+   * @param matrixId matrix id\n+   */\n+  public MatrixCache(int matrixId) {\n+    this.matrixId = matrixId;\n+    this.partitionCacheMap = new ConcurrentHashMap<>();\n+  }\n+\n+  /**\n+   * Get a partition from cache\n+   *\n+   * @param partKey partition key\n+   * @return matrix partition\n+   */\n+  public RowBasedPartition getPartition(PartitionKey partKey) {\n+    return partitionCacheMap.get(partKey);\n+  }\n+\n+  /**\n+   * Get a row split from cache\n+   *\n+   * @param partKey partition key\n+   * @param rowIndex row index\n+   * @return the row split\n+   */\n+  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      return null;\n+    }\n+    return partCache.getRow(rowIndex);\n+  }\n+\n+  public int getMatrixId() {\n+    return matrixId;\n+  }\n+\n+  /**\n+   * Get a batch of row splits that belong to a matrix partition\n+   *\n+   * @param partKey partition key\n+   * @param rowIndexes row indexes\n+   * @return a batch of row splits\n+   */\n+  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      return null;\n+    }\n+    return partCache.getRows(rowIndexes);\n+  }\n+\n+  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\n+    return partitionCacheMap;\n+  }\n+\n+  /**\n+   * Update a matrix partition in the cache\n+   *\n+   * @param partKey partition key\n+   * @param part matrix partition\n+   */\n+  public void update(PartitionKey partKey, RowBasedPartition part) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null || partCache.getClock() <= part.getClock()) {\n+      partitionCacheMap.put(partKey, part);\n+    }\n+  }\n+\n+  /**\n+   * Update a row split in the cache\n+   *\n+   * @param partKey partition key\n+   * @param rowSplit row split\n+   */\n+  public void update(PartitionKey partKey, ServerRow rowSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      initPart(partKey);\n+      partCache = partitionCacheMap.get(partKey);\n+    }\n+\n+    partCache.putRow(rowSplit);\n+  }\n+\n+  /**\n+   * Update a batch row splits in the cache\n+   *\n+   * @param partKey partition key\n+   * @param rowsSplit a batch row splits\n+   */\n+  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      initPart(partKey);\n+      partCache = partitionCacheMap.get(partKey);\n+    }\n+\n+    partCache.putRows(rowsSplit);\n+  }\n+\n+  private void initPart(PartitionKey partKey) {\n+    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\n+    partitionCacheMap\n+        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\n+            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\n+                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\n+  }\n+\n+  /**\n+   * Clean a matrix partition from cache\n+   *\n+   * @param partitionKey partition key\n+   */\n+  public void clear(PartitionKey partitionKey) {\n+    partitionCacheMap.remove(partitionKey);\n+  }\n+}\n",
            "diff_size": 166
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/560/MatrixCache.java\nindex 88a2dd9216..aafcf49110 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/560/MatrixCache.java\n@@ -34,133 +34,134 @@ import java.util.concurrent.ConcurrentHashMap;\n  */\r\n public class MatrixCache {\r\n \r\n-  /**\r\n-   * matrix id\r\n-   */\r\n-  private final int matrixId;\r\n-\r\n-  /**\r\n-   * partition key to partition map\r\n-   */\r\n-  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n-\r\n-  /**\r\n-   * Create a new MatrixCache.\r\n-   *\r\n-   * @param matrixId matrix id\r\n-   */\r\n-  public MatrixCache(int matrixId) {\r\n-    this.matrixId = matrixId;\r\n-    this.partitionCacheMap = new ConcurrentHashMap<>();\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a partition from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @return matrix partition\r\n-   */\r\n-  public RowBasedPartition getPartition(PartitionKey partKey) {\r\n-    return partitionCacheMap.get(partKey);\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a row split from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndex row index\r\n-   * @return the row split\r\n-   */\r\n-  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n+    /**\r\n+     * matrix id\r\n+     */\r\n+    private final int matrixId;\r\n+\r\n+    /**\r\n+     * partition key to partition map\r\n+     */\r\n+    private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n+\r\n+    /**\r\n+     * Create a new MatrixCache.\r\n+     *\r\n+     * @param matrixId matrix id\r\n+     */\r\n+    public MatrixCache(int matrixId) {\r\n+        this.matrixId = matrixId;\r\n+        this.partitionCacheMap = new ConcurrentHashMap<>();\r\n     }\r\n-    return partCache.getRow(rowIndex);\r\n-  }\r\n-\r\n-  public int getMatrixId() {\r\n-    return matrixId;\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a batch of row splits that belong to a matrix partition\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndexes row indexes\r\n-   * @return a batch of row splits\r\n-   */\r\n-  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n+\r\n+    /**\r\n+     * Get a partition from cache\r\n+     *\r\n+     * @param partKey partition key\r\n+     * @return matrix partition\r\n+     */\r\n+    public RowBasedPartition getPartition(PartitionKey partKey) {\r\n+        return partitionCacheMap.get(partKey);\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a row split from cache\r\n+     *\r\n+     * @param partKey  partition key\r\n+     * @param rowIndex row index\r\n+     * @return the row split\r\n+     */\r\n+    public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\r\n+        RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n+        if (partCache == null) {\r\n+            return null;\r\n+        }\r\n+        return partCache.getRow(rowIndex);\r\n+    }\r\n+\r\n+    public int getMatrixId() {\r\n+        return matrixId;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a batch of row splits that belong to a matrix partition\r\n+     *\r\n+     * @param partKey    partition key\r\n+     * @param rowIndexes row indexes\r\n+     * @return a batch of row splits\r\n+     */\r\n+    public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\r\n+        RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n+        if (partCache == null) {\r\n+            return null;\r\n+        }\r\n+        return partCache.getRows(rowIndexes);\r\n     }\r\n-    return partCache.getRows(rowIndexes);\r\n-  }\r\n-\r\n-  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\r\n-    return partitionCacheMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a matrix partition in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param part matrix partition\r\n-   */\r\n-  public void update(PartitionKey partKey, RowBasedPartition part) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null || partCache.getClock() <= part.getClock()) {\r\n-      partitionCacheMap.put(partKey, part);\r\n+\r\n+    public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\r\n+        return partitionCacheMap;\r\n+    }\r\n+\r\n+    /**\r\n+     * Update a matrix partition in the cache\r\n+     *\r\n+     * @param partKey partition key\r\n+     * @param part    matrix partition\r\n+     */\r\n+    public void update(PartitionKey partKey, RowBasedPartition part) {\r\n+        RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n+        if (partCache == null || partCache.getClock() <= part.getClock()) {\r\n+            partitionCacheMap.put(partKey, part);\r\n+        }\r\n     }\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a row split in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowSplit row split\r\n-   */\r\n-  public void update(PartitionKey partKey, ServerRow rowSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n+\r\n+    /**\r\n+     * Update a row split in the cache\r\n+     *\r\n+     * @param partKey  partition key\r\n+     * @param rowSplit row split\r\n+     */\r\n+    public void update(PartitionKey partKey, ServerRow rowSplit) {\r\n+        RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n+        if (partCache == null) {\r\n+            initPart(partKey);\r\n+            partCache = partitionCacheMap.get(partKey);\r\n+        }\r\n+\r\n+        partCache.putRow(rowSplit);\r\n     }\r\n \r\n-    partCache.putRow(rowSplit);\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a batch row splits in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowsSplit a batch row splits\r\n-   */\r\n-  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n+    /**\r\n+     * Update a batch row splits in the cache\r\n+     *\r\n+     * @param partKey   partition key\r\n+     * @param rowsSplit a batch row splits\r\n+     */\r\n+    public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\r\n+        RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n+        if (partCache == null) {\r\n+            initPart(partKey);\r\n+            partCache = partitionCacheMap.get(partKey);\r\n+        }\r\n+\r\n+        partCache.putRows(rowsSplit);\r\n     }\r\n \r\n-    partCache.putRows(rowsSplit);\r\n-  }\r\n-\r\n-  private void initPart(PartitionKey partKey) {\r\n-    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n-    partitionCacheMap\r\n-        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n-            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n-                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n-  }\r\n-\r\n-  /**\r\n-   * Clean a matrix partition from cache\r\n-   *\r\n-   * @param partitionKey partition key\r\n-   */\r\n-  public void clear(PartitionKey partitionKey) {\r\n-    partitionCacheMap.remove(partitionKey);\r\n-  }\r\n+    private void initPart(PartitionKey partKey) {\r\n+        MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n+        partitionCacheMap\r\n+                .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n+                        .getPartition(partKey, RowBasedPartition.class,\r\n+                                SparseServerRowsStorage.class,\r\n+                                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n+    }\r\n+\r\n+    /**\r\n+     * Clean a matrix partition from cache\r\n+     *\r\n+     * @param partitionKey partition key\r\n+     */\r\n+    public void clear(PartitionKey partitionKey) {\r\n+        partitionCacheMap.remove(partitionKey);\r\n+    }\r\n }\r\n",
            "diff_size": 149
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "151",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 163).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/560/MatrixCache.java\nindex 88a2dd9216..afeeab7bfa 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/560/MatrixCache.java\n@@ -13,9 +13,8 @@\n  * or implied. See the License for the specific language governing permissions and limitations under\r\n  * the License.\r\n  *\r\n- */\r\n-\r\n-\r\n+ */\n+\n package com.tencent.angel.psagent.matrix.cache;\r\n \r\n import com.tencent.angel.PartitionKey;\r\n@@ -148,11 +147,9 @@ public class MatrixCache {\n   }\r\n \r\n   private void initPart(PartitionKey partKey) {\r\n-    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n-    partitionCacheMap\r\n-        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n-            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n-                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n+    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\n+    partitionCacheMap.putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory.getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n+                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\n   }\r\n \r\n   /**\r\n@@ -163,4 +160,4 @@ public class MatrixCache {\n   public void clear(PartitionKey partitionKey) {\r\n     partitionCacheMap.remove(partitionKey);\r\n   }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "37",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 40.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "42",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 45.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "47",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 53.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "58",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 65.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 77.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "89",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 97.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 116.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "123",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 130.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "139",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 146.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "157",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 225).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "160",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 166.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/560/MatrixCache.java\nindex 88a2dd9216..392e64b20e 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/560/MatrixCache.java\n@@ -16,53 +16,55 @@\n  */\r\n \r\n \r\n-package com.tencent.angel.psagent.matrix.cache;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.MatrixMeta;\r\n-import com.tencent.angel.ps.storage.partition.RowBasedPartition;\r\n-import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\r\n-import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\r\n-import com.tencent.angel.ps.storage.vector.ServerRow;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-\r\n-import java.util.List;\r\n+package com.tencent.angel.psagent.matrix.cache;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.MatrixMeta;\n+import com.tencent.angel.ps.storage.partition.RowBasedPartition;\n+import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\n+import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\n+import com.tencent.angel.ps.storage.vector.ServerRow;\n+import com.tencent.angel.psagent.PSAgentContext;\n+import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\r\n \r\n /**\r\n  * Cache for a single matrix.\r\n- */\r\n+ */\n+\n public class MatrixCache {\r\n \r\n   /**\r\n    * matrix id\r\n-   */\r\n-  private final int matrixId;\r\n+   */\n+    private final int matrixId;\r\n \r\n   /**\r\n    * partition key to partition map\r\n-   */\r\n-  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n+   */\n+    private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n \r\n   /**\r\n    * Create a new MatrixCache.\r\n    *\r\n    * @param matrixId matrix id\r\n-   */\r\n-  public MatrixCache(int matrixId) {\r\n-    this.matrixId = matrixId;\r\n-    this.partitionCacheMap = new ConcurrentHashMap<>();\r\n-  }\r\n+   */\n+\n+    public MatrixCache(int matrixId) {\n+    this.matrixId = matrixId;\n+    this.partitionCacheMap = new ConcurrentHashMap<>();\n+    }\r\n \r\n   /**\r\n    * Get a partition from cache\r\n    *\r\n    * @param partKey partition key\r\n    * @return matrix partition\r\n-   */\r\n-  public RowBasedPartition getPartition(PartitionKey partKey) {\r\n-    return partitionCacheMap.get(partKey);\r\n-  }\r\n+   */\n+\n+    public RowBasedPartition getPartition(PartitionKey partKey) {\n+    return partitionCacheMap.get(partKey);\n+    }\r\n \r\n   /**\r\n    * Get a row split from cache\r\n@@ -70,18 +72,19 @@ public class MatrixCache {\n    * @param partKey partition key\r\n    * @param rowIndex row index\r\n    * @return the row split\r\n-   */\r\n-  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n+   */\n+\n+    public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+        return null;\n+    }\n+    return partCache.getRow(rowIndex);\n+    }\n+\n+    public int getMatrixId() {\n+    return matrixId;\n     }\r\n-    return partCache.getRow(rowIndex);\r\n-  }\r\n-\r\n-  public int getMatrixId() {\r\n-    return matrixId;\r\n-  }\r\n \r\n   /**\r\n    * Get a batch of row splits that belong to a matrix partition\r\n@@ -89,78 +92,78 @@ public class MatrixCache {\n    * @param partKey partition key\r\n    * @param rowIndexes row indexes\r\n    * @return a batch of row splits\r\n-   */\r\n-  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n+   */\n+\n+    public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+        return null;\n+    }\n+    return partCache.getRows(rowIndexes);\n+    }\n+\n+    public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\n+    return partitionCacheMap;\n     }\r\n-    return partCache.getRows(rowIndexes);\r\n-  }\r\n-\r\n-  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\r\n-    return partitionCacheMap;\r\n-  }\r\n \r\n   /**\r\n    * Update a matrix partition in the cache\r\n    *\r\n    * @param partKey partition key\r\n    * @param part matrix partition\r\n-   */\r\n-  public void update(PartitionKey partKey, RowBasedPartition part) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null || partCache.getClock() <= part.getClock()) {\r\n-      partitionCacheMap.put(partKey, part);\r\n+   */\n+\n+    public void update(PartitionKey partKey, RowBasedPartition part) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null || partCache.getClock() <= part.getClock()) {\n+        partitionCacheMap.put(partKey, part);\n+    }\n     }\r\n-  }\r\n \r\n   /**\r\n    * Update a row split in the cache\r\n    *\r\n    * @param partKey partition key\r\n    * @param rowSplit row split\r\n-   */\r\n-  public void update(PartitionKey partKey, ServerRow rowSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n+   */\n+\n+    public void update(PartitionKey partKey, ServerRow rowSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+        initPart(partKey);\n+        partCache = partitionCacheMap.get(partKey);\n+    }\n+    partCache.putRow(rowSplit);\n     }\r\n \r\n-    partCache.putRow(rowSplit);\r\n-  }\r\n-\r\n   /**\r\n    * Update a batch row splits in the cache\r\n    *\r\n    * @param partKey partition key\r\n    * @param rowsSplit a batch row splits\r\n-   */\r\n-  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n+   */\n+\n+    public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+        initPart(partKey);\n+        partCache = partitionCacheMap.get(partKey);\n+    }\n+    partCache.putRows(rowsSplit);\n+    }\n+\n+    private void initPart(PartitionKey partKey) {\n+    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\n+    partitionCacheMap.putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory.getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class, matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\n     }\r\n \r\n-    partCache.putRows(rowsSplit);\r\n-  }\r\n-\r\n-  private void initPart(PartitionKey partKey) {\r\n-    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n-    partitionCacheMap\r\n-        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n-            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n-                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n-  }\r\n-\r\n   /**\r\n    * Clean a matrix partition from cache\r\n    *\r\n    * @param partitionKey partition key\r\n-   */\r\n-  public void clear(PartitionKey partitionKey) {\r\n-    partitionCacheMap.remove(partitionKey);\r\n-  }\r\n-}\r\n+   */\n+\n+    public void clear(PartitionKey partitionKey) {\n+    partitionCacheMap.remove(partitionKey);\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 115
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_random/560/MatrixCache.java\nindex 88a2dd9216..290e776125 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_random/560/MatrixCache.java\n@@ -1,166 +1,166 @@\n-/*\r\n- * Tencent is pleased to support the open source community by making Angel available.\r\n- *\r\n- * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- *\r\n- * https://opensource.org/licenses/Apache-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n- * or implied. See the License for the specific language governing permissions and limitations under\r\n- * the License.\r\n- *\r\n- */\r\n-\r\n-\r\n-package com.tencent.angel.psagent.matrix.cache;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.MatrixMeta;\r\n-import com.tencent.angel.ps.storage.partition.RowBasedPartition;\r\n-import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\r\n-import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\r\n-import com.tencent.angel.ps.storage.vector.ServerRow;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-\r\n-import java.util.List;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-\r\n-/**\r\n- * Cache for a single matrix.\r\n- */\r\n-public class MatrixCache {\r\n-\r\n-  /**\r\n-   * matrix id\r\n-   */\r\n-  private final int matrixId;\r\n-\r\n-  /**\r\n-   * partition key to partition map\r\n-   */\r\n-  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n-\r\n-  /**\r\n-   * Create a new MatrixCache.\r\n-   *\r\n-   * @param matrixId matrix id\r\n-   */\r\n-  public MatrixCache(int matrixId) {\r\n-    this.matrixId = matrixId;\r\n-    this.partitionCacheMap = new ConcurrentHashMap<>();\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a partition from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @return matrix partition\r\n-   */\r\n-  public RowBasedPartition getPartition(PartitionKey partKey) {\r\n-    return partitionCacheMap.get(partKey);\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a row split from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndex row index\r\n-   * @return the row split\r\n-   */\r\n-  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n-    }\r\n-    return partCache.getRow(rowIndex);\r\n-  }\r\n-\r\n-  public int getMatrixId() {\r\n-    return matrixId;\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a batch of row splits that belong to a matrix partition\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndexes row indexes\r\n-   * @return a batch of row splits\r\n-   */\r\n-  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n-    }\r\n-    return partCache.getRows(rowIndexes);\r\n-  }\r\n-\r\n-  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\r\n-    return partitionCacheMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a matrix partition in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param part matrix partition\r\n-   */\r\n-  public void update(PartitionKey partKey, RowBasedPartition part) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null || partCache.getClock() <= part.getClock()) {\r\n-      partitionCacheMap.put(partKey, part);\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a row split in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowSplit row split\r\n-   */\r\n-  public void update(PartitionKey partKey, ServerRow rowSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n-    }\r\n-\r\n-    partCache.putRow(rowSplit);\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a batch row splits in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowsSplit a batch row splits\r\n-   */\r\n-  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n-    }\r\n-\r\n-    partCache.putRows(rowsSplit);\r\n-  }\r\n-\r\n-  private void initPart(PartitionKey partKey) {\r\n-    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n-    partitionCacheMap\r\n-        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n-            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n-                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n-  }\r\n-\r\n-  /**\r\n-   * Clean a matrix partition from cache\r\n-   *\r\n-   * @param partitionKey partition key\r\n-   */\r\n-  public void clear(PartitionKey partitionKey) {\r\n-    partitionCacheMap.remove(partitionKey);\r\n-  }\r\n-}\r\n+/*\n+ * Tencent is pleased to support the open source community by making Angel available.\n+ *\n+ * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * https://opensource.org/licenses/Apache-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+\n+package com.tencent.angel.psagent.matrix.cache;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.MatrixMeta;\n+import com.tencent.angel.ps.storage.partition.RowBasedPartition;\n+import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\n+import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\n+import com.tencent.angel.ps.storage.vector.ServerRow;\n+import com.tencent.angel.psagent.PSAgentContext;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Cache for a single matrix.\n+ */\n+public class MatrixCache {\n+\n+  /**\n+   * matrix id\n+   */\n+  private final int matrixId;\n+\n+  /**\n+   * partition key to partition map\n+   */\n+  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\n+\n+  /**\n+   * Create a new MatrixCache.\n+   *\n+   * @param matrixId matrix id\n+   */\n+  public MatrixCache(int matrixId) {\n+    this.matrixId = matrixId;\n+    this.partitionCacheMap = new ConcurrentHashMap<>();\n+  }\n+\n+  /**\n+   * Get a partition from cache\n+   *\n+   * @param partKey partition key\n+   * @return matrix partition\n+   */\n+  public RowBasedPartition getPartition(PartitionKey partKey) {\n+    return partitionCacheMap.get(partKey);\n+  }\n+\n+  /**\n+   * Get a row split from cache\n+   *\n+   * @param partKey partition key\n+   * @param rowIndex row index\n+   * @return the row split\n+   */\n+  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      return null;\n+    }\n+    return partCache.getRow(rowIndex);\n+  }\n+\n+  public int getMatrixId() {\n+    return matrixId;\n+  }\n+\n+  /**\n+   * Get a batch of row splits that belong to a matrix partition\n+   *\n+   * @param partKey partition key\n+   * @param rowIndexes row indexes\n+   * @return a batch of row splits\n+   */\n+  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      return null;\n+    }\n+    return partCache.getRows(rowIndexes);\n+  }\n+\n+  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\n+    return partitionCacheMap;\n+  }\n+\n+  /**\n+   * Update a matrix partition in the cache\n+   *\n+   * @param partKey partition key\n+   * @param part matrix partition\n+   */\n+  public void update(PartitionKey partKey, RowBasedPartition part) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null || partCache.getClock() <= part.getClock()) {\n+      partitionCacheMap.put(partKey, part);\n+    }\n+  }\n+\n+  /**\n+   * Update a row split in the cache\n+   *\n+   * @param partKey partition key\n+   * @param rowSplit row split\n+   */\n+  public void update(PartitionKey partKey, ServerRow rowSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      initPart(partKey);\n+      partCache = partitionCacheMap.get(partKey);\n+    }\n+\n+    partCache.putRow(rowSplit);\n+  }\n+\n+  /**\n+   * Update a batch row splits in the cache\n+   *\n+   * @param partKey partition key\n+   * @param rowsSplit a batch row splits\n+   */\n+  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      initPart(partKey);\n+      partCache = partitionCacheMap.get(partKey);\n+    }\n+\n+    partCache.putRows(rowsSplit);\n+  }\n+\n+  private void initPart(PartitionKey partKey) {\n+    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\n+    partitionCacheMap\n+        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\n+            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\n+                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\n+  }\n+\n+  /**\n+   * Clean a matrix partition from cache\n+   *\n+   * @param partitionKey partition key\n+   */\n+  public void clear(PartitionKey partitionKey) {\n+    partitionCacheMap.remove(partitionKey);\n+  }\n+}\n",
            "diff_size": 166
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/560/MatrixCache.java\nindex 88a2dd9216..9f0db767d7 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/560/MatrixCache.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/560/MatrixCache.java\n@@ -1,166 +1,164 @@\n-/*\r\n- * Tencent is pleased to support the open source community by making Angel available.\r\n- *\r\n- * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\r\n- * compliance with the License. You may obtain a copy of the License at\r\n- *\r\n- * https://opensource.org/licenses/Apache-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\r\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\r\n- * or implied. See the License for the specific language governing permissions and limitations under\r\n- * the License.\r\n- *\r\n- */\r\n-\r\n-\r\n-package com.tencent.angel.psagent.matrix.cache;\r\n-\r\n-import com.tencent.angel.PartitionKey;\r\n-import com.tencent.angel.ml.matrix.MatrixMeta;\r\n-import com.tencent.angel.ps.storage.partition.RowBasedPartition;\r\n-import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\r\n-import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\r\n-import com.tencent.angel.ps.storage.vector.ServerRow;\r\n-import com.tencent.angel.psagent.PSAgentContext;\r\n-\r\n-import java.util.List;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-\r\n-/**\r\n- * Cache for a single matrix.\r\n- */\r\n-public class MatrixCache {\r\n-\r\n-  /**\r\n-   * matrix id\r\n-   */\r\n-  private final int matrixId;\r\n-\r\n-  /**\r\n-   * partition key to partition map\r\n-   */\r\n-  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\r\n-\r\n-  /**\r\n-   * Create a new MatrixCache.\r\n-   *\r\n-   * @param matrixId matrix id\r\n-   */\r\n-  public MatrixCache(int matrixId) {\r\n-    this.matrixId = matrixId;\r\n-    this.partitionCacheMap = new ConcurrentHashMap<>();\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a partition from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @return matrix partition\r\n-   */\r\n-  public RowBasedPartition getPartition(PartitionKey partKey) {\r\n-    return partitionCacheMap.get(partKey);\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a row split from cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndex row index\r\n-   * @return the row split\r\n-   */\r\n-  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n-    }\r\n-    return partCache.getRow(rowIndex);\r\n-  }\r\n-\r\n-  public int getMatrixId() {\r\n-    return matrixId;\r\n-  }\r\n-\r\n-  /**\r\n-   * Get a batch of row splits that belong to a matrix partition\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowIndexes row indexes\r\n-   * @return a batch of row splits\r\n-   */\r\n-  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      return null;\r\n-    }\r\n-    return partCache.getRows(rowIndexes);\r\n-  }\r\n-\r\n-  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\r\n-    return partitionCacheMap;\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a matrix partition in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param part matrix partition\r\n-   */\r\n-  public void update(PartitionKey partKey, RowBasedPartition part) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null || partCache.getClock() <= part.getClock()) {\r\n-      partitionCacheMap.put(partKey, part);\r\n-    }\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a row split in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowSplit row split\r\n-   */\r\n-  public void update(PartitionKey partKey, ServerRow rowSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n-    }\r\n-\r\n-    partCache.putRow(rowSplit);\r\n-  }\r\n-\r\n-  /**\r\n-   * Update a batch row splits in the cache\r\n-   *\r\n-   * @param partKey partition key\r\n-   * @param rowsSplit a batch row splits\r\n-   */\r\n-  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\r\n-    RowBasedPartition partCache = partitionCacheMap.get(partKey);\r\n-    if (partCache == null) {\r\n-      initPart(partKey);\r\n-      partCache = partitionCacheMap.get(partKey);\r\n-    }\r\n-\r\n-    partCache.putRows(rowsSplit);\r\n-  }\r\n-\r\n-  private void initPart(PartitionKey partKey) {\r\n-    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\r\n-    partitionCacheMap\r\n-        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\r\n-            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\r\n-                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\r\n-  }\r\n-\r\n-  /**\r\n-   * Clean a matrix partition from cache\r\n-   *\r\n-   * @param partitionKey partition key\r\n-   */\r\n-  public void clear(PartitionKey partitionKey) {\r\n-    partitionCacheMap.remove(partitionKey);\r\n-  }\r\n-}\r\n+/*\n+ * Tencent is pleased to support the open source community by making Angel available.\n+ *\n+ * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ *\n+ * https://opensource.org/licenses/Apache-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package com.tencent.angel.psagent.matrix.cache;\n+\n+import com.tencent.angel.PartitionKey;\n+import com.tencent.angel.ml.matrix.MatrixMeta;\n+import com.tencent.angel.ps.storage.partition.RowBasedPartition;\n+import com.tencent.angel.ps.storage.partition.ServerPartitionFactory;\n+import com.tencent.angel.ps.storage.partition.storage.SparseServerRowsStorage;\n+import com.tencent.angel.ps.storage.vector.ServerRow;\n+import com.tencent.angel.psagent.PSAgentContext;\n+\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Cache for a single matrix.\n+ */\n+public class MatrixCache {\n+\n+  /**\n+   * matrix id\n+   */\n+  private final int matrixId;\n+\n+  /**\n+   * partition key to partition map\n+   */\n+  private final ConcurrentHashMap<PartitionKey, RowBasedPartition> partitionCacheMap;\n+\n+  /**\n+   * Create a new MatrixCache.\n+   *\n+   * @param matrixId matrix id\n+   */\n+  public MatrixCache(int matrixId) {\n+    this.matrixId = matrixId;\n+    this.partitionCacheMap = new ConcurrentHashMap<>();\n+  }\n+\n+  /**\n+   * Get a partition from cache\n+   *\n+   * @param partKey partition key\n+   * @return matrix partition\n+   */\n+  public RowBasedPartition getPartition(PartitionKey partKey) {\n+    return partitionCacheMap.get(partKey);\n+  }\n+\n+  /**\n+   * Get a row split from cache\n+   *\n+   * @param partKey partition key\n+   * @param rowIndex row index\n+   * @return the row split\n+   */\n+  public ServerRow getRowSplit(PartitionKey partKey, int rowIndex) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      return null;\n+    }\n+    return partCache.getRow(rowIndex);\n+  }\n+\n+  public int getMatrixId() {\n+    return matrixId;\n+  }\n+\n+  /**\n+   * Get a batch of row splits that belong to a matrix partition\n+   *\n+   * @param partKey partition key\n+   * @param rowIndexes row indexes\n+   * @return a batch of row splits\n+   */\n+  public List<ServerRow> getRowsSplit(PartitionKey partKey, List<Integer> rowIndexes) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      return null;\n+    }\n+    return partCache.getRows(rowIndexes);\n+  }\n+\n+  public ConcurrentHashMap<PartitionKey, RowBasedPartition> getPartitionCacheMap() {\n+    return partitionCacheMap;\n+  }\n+\n+  /**\n+   * Update a matrix partition in the cache\n+   *\n+   * @param partKey partition key\n+   * @param part matrix partition\n+   */\n+  public void update(PartitionKey partKey, RowBasedPartition part) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null || partCache.getClock() <= part.getClock()) {\n+      partitionCacheMap.put(partKey, part);\n+    }\n+  }\n+\n+  /**\n+   * Update a row split in the cache\n+   *\n+   * @param partKey partition key\n+   * @param rowSplit row split\n+   */\n+  public void update(PartitionKey partKey, ServerRow rowSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      initPart(partKey);\n+      partCache = partitionCacheMap.get(partKey);\n+    }\n+\n+    partCache.putRow(rowSplit);\n+  }\n+\n+  /**\n+   * Update a batch row splits in the cache\n+   *\n+   * @param partKey partition key\n+   * @param rowsSplit a batch row splits\n+   */\n+  public void update(PartitionKey partKey, List<ServerRow> rowsSplit) {\n+    RowBasedPartition partCache = partitionCacheMap.get(partKey);\n+    if (partCache == null) {\n+      initPart(partKey);\n+      partCache = partitionCacheMap.get(partKey);\n+    }\n+\n+    partCache.putRows(rowsSplit);\n+  }\n+\n+  private void initPart(PartitionKey partKey) {\n+    MatrixMeta matrixMeta = PSAgentContext.get().getMatrixMetaManager().getMatrixMeta(matrixId);\n+    partitionCacheMap\n+        .putIfAbsent(partKey, (RowBasedPartition) ServerPartitionFactory\n+            .getPartition(partKey, RowBasedPartition.class, SparseServerRowsStorage.class,\n+                matrixMeta.getRowType(), null, matrixMeta.getEstSparsity()));\n+  }\n+\n+  /**\n+   * Clean a matrix partition from cache\n+   *\n+   * @param partitionKey partition key\n+   */\n+  public void clear(PartitionKey partitionKey) {\n+    partitionCacheMap.remove(partitionKey);\n+  }\n+}\n",
            "diff_size": 166
        }
    ]
}