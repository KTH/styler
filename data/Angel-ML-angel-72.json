{
    "error_id": "72",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/72/Histogram.java\nindex b6aa657f63..b7004e84ac 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/72/Histogram.java\n@@ -24,324 +24,324 @@ import java.util.Arrays;\n \n public class Histogram implements Serializable {\n \n-  private int numBin;\n-  private int numClass;\n-  private boolean fullHessian;\n-  private boolean multiClassMultiTree;\n-  private double[] gradients;\n-  private double[] hessians;\n+    private int numBin;\n+    private int numClass;\n+    private boolean fullHessian;\n+    private boolean multiClassMultiTree;\n+    private double[] gradients;\n+    private double[] hessians;\n \n-  public Histogram(int numBin, int numClass, boolean fullHessian, boolean multiClassMultiTree) {\n-    this.numBin = numBin;\n-    this.numClass = numClass;\n-    this.fullHessian = fullHessian;\n-    this.multiClassMultiTree = multiClassMultiTree;\n-    if (numClass == 2 || multiClassMultiTree) {\n-      this.gradients = new double[numBin];\n-      this.hessians = new double[numBin];\n-    } else if (!fullHessian) {\n-      this.gradients = new double[numBin * numClass];\n-      this.hessians = new double[numBin * numClass];\n-    } else {\n-      this.gradients = new double[numBin * numClass];\n-      this.hessians = new double[numBin * ((numClass * (numClass + 1)) >> 1)];\n+    public Histogram(int numBin, int numClass, boolean fullHessian, boolean multiClassMultiTree) {\n+        this.numBin = numBin;\n+        this.numClass = numClass;\n+        this.fullHessian = fullHessian;\n+        this.multiClassMultiTree = multiClassMultiTree;\n+        if (numClass == 2 || multiClassMultiTree) {\n+            this.gradients = new double[numBin];\n+            this.hessians = new double[numBin];\n+        } else if (!fullHessian) {\n+            this.gradients = new double[numBin * numClass];\n+            this.hessians = new double[numBin * numClass];\n+        } else {\n+            this.gradients = new double[numBin * numClass];\n+            this.hessians = new double[numBin * ((numClass * (numClass + 1)) >> 1)];\n+        }\n     }\n-  }\n-\n-  public void accumulate(int index, double grad, double hess) {\n-    gradients[index] += grad;\n-    hessians[index] += hess;\n-  }\n \n-  public void accumulate(int index, double[] grad, double[] hess) {\n-    if (!fullHessian) {\n-      accumulate(index, grad, hess, 0);\n-    } else {\n-      accumulate(index, grad, 0, hess, 0);\n+    public void accumulate(int index, double grad, double hess) {\n+        gradients[index] += grad;\n+        hessians[index] += hess;\n     }\n-  }\n \n-  public void accumulate(int index, double[] grad, double[] hess, int offset) {\n-    int binOffset = index * numClass;\n-    for (int i = 0; i < numClass; i++) {\n-      gradients[binOffset + i] += grad[offset + i];\n-      hessians[binOffset + i] += hess[offset + i];\n+    public void accumulate(int index, double[] grad, double[] hess) {\n+        if (!fullHessian) {\n+            accumulate(index, grad, hess, 0);\n+        } else {\n+            accumulate(index, grad, 0, hess, 0);\n+        }\n     }\n-  }\n \n-  public void accumulate(int index, double[] grad, int gradOffset,\n-      double[] hess, int hessOffset) {\n-    int gradBinOffset = index * numClass;\n-    int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n-    for (int i = 0; i < grad.length; i++) {\n-      gradients[gradBinOffset + i] += grad[gradOffset + i];\n+    public void accumulate(int index, double[] grad, double[] hess, int offset) {\n+        int binOffset = index * numClass;\n+        for (int i = 0; i < numClass; i++) {\n+            gradients[binOffset + i] += grad[offset + i];\n+            hessians[binOffset + i] += hess[offset + i];\n+        }\n     }\n-    for (int i = 0; i < hess.length; i++) {\n-      hessians[hessBinOffset + i] += hess[hessOffset + i];\n+\n+    public void accumulate(int index, double[] grad, int gradOffset,\n+                           double[] hess, int hessOffset) {\n+        int gradBinOffset = index * numClass;\n+        int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n+        for (int i = 0; i < grad.length; i++) {\n+            gradients[gradBinOffset + i] += grad[gradOffset + i];\n+        }\n+        for (int i = 0; i < hess.length; i++) {\n+            hessians[hessBinOffset + i] += hess[hessOffset + i];\n+        }\n     }\n-  }\n \n-  public void accumulate(int index, GradPair gradPair) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      BinaryGradPair binary = (BinaryGradPair) gradPair;\n-      gradients[index] += binary.getGrad();\n-      hessians[index] += binary.getHess();\n-    } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        gradients[offset + i] += grad[i];\n-        hessians[offset + i] += hess[i];\n-      }\n-    } else {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * numClass;\n-      int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n-      for (int i = 0; i < grad.length; i++) {\n-        gradients[gradOffset + i] += grad[i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hessians[hessOffset + i] += hess[i];\n-      }\n+    public void accumulate(int index, GradPair gradPair) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            BinaryGradPair binary = (BinaryGradPair) gradPair;\n+            gradients[index] += binary.getGrad();\n+            hessians[index] += binary.getHess();\n+        } else if (!fullHessian) {\n+            MultiGradPair multi = (MultiGradPair) gradPair;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                gradients[offset + i] += grad[i];\n+                hessians[offset + i] += hess[i];\n+            }\n+        } else {\n+            MultiGradPair multi = (MultiGradPair) gradPair;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int gradOffset = index * numClass;\n+            int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n+            for (int i = 0; i < grad.length; i++) {\n+                gradients[gradOffset + i] += grad[i];\n+            }\n+            for (int i = 0; i < hess.length; i++) {\n+                hessians[hessOffset + i] += hess[i];\n+            }\n+        }\n     }\n-  }\n \n-  public Histogram plus(Histogram other) {\n-    Histogram res = new Histogram(numBin, numClass, fullHessian, multiClassMultiTree);\n-    if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] + other.gradients[i];\n-        res.hessians[i] = this.hessians[i] + other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] + other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        res.hessians[i] = this.hessians[i] + other.hessians[i];\n-      }\n+    public Histogram plus(Histogram other) {\n+        Histogram res = new Histogram(numBin, numClass, fullHessian, multiClassMultiTree);\n+        if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] + other.gradients[i];\n+                res.hessians[i] = this.hessians[i] + other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] + other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                res.hessians[i] = this.hessians[i] + other.hessians[i];\n+            }\n+        }\n+        return res;\n     }\n-    return res;\n-  }\n \n-  public Histogram subtract(Histogram other) {\n-    Histogram res = new Histogram(numBin, numClass, fullHessian, multiClassMultiTree);\n-    if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] - other.gradients[i];\n-        res.hessians[i] = this.hessians[i] - other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] - other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        res.hessians[i] = this.hessians[i] - other.hessians[i];\n-      }\n+    public Histogram subtract(Histogram other) {\n+        Histogram res = new Histogram(numBin, numClass, fullHessian, multiClassMultiTree);\n+        if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] - other.gradients[i];\n+                res.hessians[i] = this.hessians[i] - other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                res.gradients[i] = this.gradients[i] - other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                res.hessians[i] = this.hessians[i] - other.hessians[i];\n+            }\n+        }\n+        return res;\n     }\n-    return res;\n-  }\n \n-  public void plusBy(Histogram other) {\n-    if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] += other.gradients[i];\n-        this.hessians[i] += other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] += other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        this.hessians[i] += other.hessians[i];\n-      }\n+    public void plusBy(Histogram other) {\n+        if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] += other.gradients[i];\n+                this.hessians[i] += other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] += other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                this.hessians[i] += other.hessians[i];\n+            }\n+        }\n     }\n-  }\n \n-  public void subtractBy(Histogram other) {\n-    if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] -= other.gradients[i];\n-        this.hessians[i] -= other.hessians[i];\n-      }\n-    } else {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] -= other.gradients[i];\n-      }\n-      for (int i = 0; i < this.hessians.length; i++) {\n-        this.hessians[i] -= other.hessians[i];\n-      }\n+    public void subtractBy(Histogram other) {\n+        if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] -= other.gradients[i];\n+                this.hessians[i] -= other.hessians[i];\n+            }\n+        } else {\n+            for (int i = 0; i < this.gradients.length; i++) {\n+                this.gradients[i] -= other.gradients[i];\n+            }\n+            for (int i = 0; i < this.hessians.length; i++) {\n+                this.hessians[i] -= other.hessians[i];\n+            }\n+        }\n     }\n-  }\n \n-  public GradPair sum() {\n-    return sum(0, numBin);\n-  }\n+    public GradPair sum() {\n+        return sum(0, numBin);\n+    }\n \n-  public GradPair sum(int start, int end) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      double sumGrad = 0.0;\n-      double sumHess = 0.0;\n-      for (int i = start; i < end; i++) {\n-        sumGrad += gradients[i];\n-        sumHess += hessians[i];\n-      }\n-      return new BinaryGradPair(sumGrad, sumHess);\n-    } else if (!fullHessian) {\n-      double[] sumGrad = new double[numClass];\n-      double[] sumHess = new double[numClass];\n-      for (int i = start * numClass; i < end * numClass; i += numClass) {\n-        for (int j = 0; j < numClass; j++) {\n-          sumGrad[j] += gradients[i + j];\n-          sumHess[j] += hessians[i + j];\n-        }\n-      }\n-      return new MultiGradPair(sumGrad, sumHess);\n-    } else {\n-      double[] sumGrad = new double[numClass];\n-      double[] sumHess = new double[(numClass * (numClass + 1)) >> 1];\n-      for (int i = start; i < end; i++) {\n-        int gradOffset = i * sumGrad.length;\n-        for (int j = 0; j < sumGrad.length; j++) {\n-          sumGrad[j] += gradients[gradOffset + j];\n+    public GradPair sum(int start, int end) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            double sumGrad = 0.0;\n+            double sumHess = 0.0;\n+            for (int i = start; i < end; i++) {\n+                sumGrad += gradients[i];\n+                sumHess += hessians[i];\n+            }\n+            return new BinaryGradPair(sumGrad, sumHess);\n+        } else if (!fullHessian) {\n+            double[] sumGrad = new double[numClass];\n+            double[] sumHess = new double[numClass];\n+            for (int i = start * numClass; i < end * numClass; i += numClass) {\n+                for (int j = 0; j < numClass; j++) {\n+                    sumGrad[j] += gradients[i + j];\n+                    sumHess[j] += hessians[i + j];\n+                }\n+            }\n+            return new MultiGradPair(sumGrad, sumHess);\n+        } else {\n+            double[] sumGrad = new double[numClass];\n+            double[] sumHess = new double[(numClass * (numClass + 1)) >> 1];\n+            for (int i = start; i < end; i++) {\n+                int gradOffset = i * sumGrad.length;\n+                for (int j = 0; j < sumGrad.length; j++) {\n+                    sumGrad[j] += gradients[gradOffset + j];\n+                }\n+                int hessOffset = i * sumHess.length;\n+                for (int j = 0; j < sumHess.length; j++) {\n+                    sumHess[j] += hessians[hessOffset + j];\n+                }\n+            }\n+            return new MultiGradPair(sumGrad, sumHess);\n         }\n-        int hessOffset = i * sumHess.length;\n-        for (int j = 0; j < sumHess.length; j++) {\n-          sumHess[j] += hessians[hessOffset + j];\n-        }\n-      }\n-      return new MultiGradPair(sumGrad, sumHess);\n     }\n-  }\n \n-  public int getNumBin() {\n-    return numBin;\n-  }\n+    public int getNumBin() {\n+        return numBin;\n+    }\n \n-  public GradPair get(int index) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      return new BinaryGradPair(gradients[index], hessians[index]);\n-    } else {\n-      double[] grad = Arrays.copyOfRange(gradients,\n-          index * numClass, (index + 1) * numClass);\n-      int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n-      double[] hess = Arrays.copyOfRange(hessians,\n-          index * size, (index + 1) * size);\n-      return new MultiGradPair(grad, hess);\n+    public GradPair get(int index) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            return new BinaryGradPair(gradients[index], hessians[index]);\n+        } else {\n+            double[] grad = Arrays.copyOfRange(gradients,\n+                    index * numClass, (index + 1) * numClass);\n+            int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n+            double[] hess = Arrays.copyOfRange(hessians,\n+                    index * size, (index + 1) * size);\n+            return new MultiGradPair(grad, hess);\n+        }\n     }\n-  }\n \n-  public void put(int index, GradPair gp) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) gp).set(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      ((MultiGradPair) gp).set(gradients, hessians, index * numClass);\n-    } else {\n-      int gradOffset = index * numClass;\n-      int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n-      ((MultiGradPair) gp).set(gradients, gradOffset, hessians, hessOffset);\n+    public void put(int index, GradPair gp) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            ((BinaryGradPair) gp).set(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            ((MultiGradPair) gp).set(gradients, hessians, index * numClass);\n+        } else {\n+            int gradOffset = index * numClass;\n+            int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n+            ((MultiGradPair) gp).set(gradients, gradOffset, hessians, hessOffset);\n+        }\n     }\n-  }\n \n-  public void plusTo(GradPair gp, int index) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] += gradients[offset + i];\n-        hess[i] += hessians[offset + i];\n-      }\n-    } else {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * grad.length;\n-      int hessOffset = index * hess.length;\n-      for (int i = 0; i < grad.length; i++) {\n-        grad[i] += gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hess[i] += hessians[hessOffset + i];\n-      }\n+    public void plusTo(GradPair gp, int index) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                grad[i] += gradients[offset + i];\n+                hess[i] += hessians[offset + i];\n+            }\n+        } else {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int gradOffset = index * grad.length;\n+            int hessOffset = index * hess.length;\n+            for (int i = 0; i < grad.length; i++) {\n+                grad[i] += gradients[gradOffset + i];\n+            }\n+            for (int i = 0; i < hess.length; i++) {\n+                hess[i] += hessians[hessOffset + i];\n+            }\n+        }\n     }\n-  }\n \n-  public void subtractTo(GradPair gp, int index) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] -= gradients[offset + i];\n-        hess[i] -= hessians[offset + i];\n-      }\n-    } else {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int gradOffset = index * grad.length;\n-      int hessOffset = index * hess.length;\n-      for (int i = 0; i < grad.length; i++) {\n-        grad[i] -= gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < hess.length; i++) {\n-        hess[i] -= hessians[hessOffset + i];\n-      }\n+    public void subtractTo(GradPair gp, int index) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                grad[i] -= gradients[offset + i];\n+                hess[i] -= hessians[offset + i];\n+            }\n+        } else {\n+            MultiGradPair multi = (MultiGradPair) gp;\n+            double[] grad = multi.getGrad();\n+            double[] hess = multi.getHess();\n+            int gradOffset = index * grad.length;\n+            int hessOffset = index * hess.length;\n+            for (int i = 0; i < grad.length; i++) {\n+                grad[i] -= gradients[gradOffset + i];\n+            }\n+            for (int i = 0; i < hess.length; i++) {\n+                hess[i] -= hessians[hessOffset + i];\n+            }\n+        }\n     }\n-  }\n \n-  public void scan(int index, GradPair left, GradPair right) {\n-    if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n-      ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n-    } else if (!fullHessian) {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        leftGrad[i] += gradients[offset + i];\n-        leftHess[i] += hessians[offset + i];\n-        rightGrad[i] -= gradients[offset + i];\n-        rightHess[i] -= hessians[offset + i];\n-      }\n-    } else {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int gradOffset = index * leftGrad.length;\n-      int hessOffset = index * leftHess.length;\n-      for (int i = 0; i < leftGrad.length; i++) {\n-        leftGrad[i] += gradients[gradOffset + i];\n-        rightGrad[i] -= gradients[gradOffset + i];\n-      }\n-      for (int i = 0; i < leftHess.length; i++) {\n-        leftHess[i] += hessians[hessOffset + i];\n-        rightHess[i] -= hessians[hessOffset + i];\n-      }\n+    public void scan(int index, GradPair left, GradPair right) {\n+        if (numClass == 2 || multiClassMultiTree) {\n+            ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n+            ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n+        } else if (!fullHessian) {\n+            MultiGradPair leftMulti = (MultiGradPair) left;\n+            double[] leftGrad = leftMulti.getGrad();\n+            double[] leftHess = leftMulti.getHess();\n+            MultiGradPair rightMulti = (MultiGradPair) right;\n+            double[] rightGrad = rightMulti.getGrad();\n+            double[] rightHess = rightMulti.getHess();\n+            int offset = index * numClass;\n+            for (int i = 0; i < numClass; i++) {\n+                leftGrad[i] += gradients[offset + i];\n+                leftHess[i] += hessians[offset + i];\n+                rightGrad[i] -= gradients[offset + i];\n+                rightHess[i] -= hessians[offset + i];\n+            }\n+        } else {\n+            MultiGradPair leftMulti = (MultiGradPair) left;\n+            double[] leftGrad = leftMulti.getGrad();\n+            double[] leftHess = leftMulti.getHess();\n+            MultiGradPair rightMulti = (MultiGradPair) right;\n+            double[] rightGrad = rightMulti.getGrad();\n+            double[] rightHess = rightMulti.getHess();\n+            int gradOffset = index * leftGrad.length;\n+            int hessOffset = index * leftHess.length;\n+            for (int i = 0; i < leftGrad.length; i++) {\n+                leftGrad[i] += gradients[gradOffset + i];\n+                rightGrad[i] -= gradients[gradOffset + i];\n+            }\n+            for (int i = 0; i < leftHess.length; i++) {\n+                leftHess[i] += hessians[hessOffset + i];\n+                rightHess[i] -= hessians[hessOffset + i];\n+            }\n+        }\n     }\n-  }\n \n-  public void clear() {\n-    Arrays.fill(gradients, 0.0);\n-    Arrays.fill(hessians, 0.0);\n-  }\n+    public void clear() {\n+        Arrays.fill(gradients, 0.0);\n+        Arrays.fill(hessians, 0.0);\n+    }\n \n }\n",
            "diff_size": 314
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/72/Histogram.java\nindex b6aa657f63..dca75d86a1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/72/Histogram.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n \n import java.io.Serializable;\n@@ -69,9 +68,8 @@ public class Histogram implements Serializable {\n     }\n   }\n \n-  public void accumulate(int index, double[] grad, int gradOffset,\n-      double[] hess, int hessOffset) {\n-    int gradBinOffset = index * numClass;\n+  public void accumulate(int index, double[] grad, int gradOffset, double[] hess, int hessOffset) {\n+  int gradBinOffset = index * numClass;\n     int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n     for (int i = 0; i < grad.length; i++) {\n       gradients[gradBinOffset + i] += grad[gradOffset + i];\n@@ -226,11 +224,9 @@ public class Histogram implements Serializable {\n     if (numClass == 2 || multiClassMultiTree) {\n       return new BinaryGradPair(gradients[index], hessians[index]);\n     } else {\n-      double[] grad = Arrays.copyOfRange(gradients,\n-          index * numClass, (index + 1) * numClass);\n+      double[] grad = Arrays.copyOfRange(gradients, index * numClass, (index + 1) * numClass);\n       int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n-      double[] hess = Arrays.copyOfRange(hessians,\n-          index * size, (index + 1) * size);\n+      double[] hess = Arrays.copyOfRange(hessians, index * size, (index + 1) * size);\n       return new MultiGradPair(grad, hess);\n     }\n   }\n@@ -344,4 +340,4 @@ public class Histogram implements Serializable {\n     Arrays.fill(hessians, 0.0);\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "41",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "42",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "70",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "116",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "117",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "135",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 124).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "136",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "153",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "154",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "170",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "171",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "202",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "203",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "313",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "314",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "315",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "316",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "317",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "318",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "320",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/72/Histogram.java\nindex b6aa657f63..a7954c8b0a 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/72/Histogram.java\n@@ -21,80 +21,78 @@ package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n import java.io.Serializable;\n import java.util.Arrays;\n \n-\n public class Histogram implements Serializable {\n+    private int numBin;\n+    private int numClass;\n+    private boolean fullHessian;\n+    private boolean multiClassMultiTree;\n+    private double[] gradients;\n+    private double[] hessians;\n \n-  private int numBin;\n-  private int numClass;\n-  private boolean fullHessian;\n-  private boolean multiClassMultiTree;\n-  private double[] gradients;\n-  private double[] hessians;\n-\n-  public Histogram(int numBin, int numClass, boolean fullHessian, boolean multiClassMultiTree) {\n+    public Histogram(int numBin, int numClass, boolean fullHessian, boolean multiClassMultiTree) {\n     this.numBin = numBin;\n     this.numClass = numClass;\n     this.fullHessian = fullHessian;\n     this.multiClassMultiTree = multiClassMultiTree;\n     if (numClass == 2 || multiClassMultiTree) {\n-      this.gradients = new double[numBin];\n-      this.hessians = new double[numBin];\n+        this.gradients = new double[numBin];\n+        this.hessians = new double[numBin];\n     } else if (!fullHessian) {\n-      this.gradients = new double[numBin * numClass];\n-      this.hessians = new double[numBin * numClass];\n+                                                                                                     this.gradients = new double[numBin * numClass];\n+                                                                                                     this.hessians = new double[numBin * numClass];\n     } else {\n       this.gradients = new double[numBin * numClass];\n       this.hessians = new double[numBin * ((numClass * (numClass + 1)) >> 1)];\n     }\n-  }\n+    }\n \n-  public void accumulate(int index, double grad, double hess) {\n+    public void accumulate(int index, double grad, double hess) {\n     gradients[index] += grad;\n     hessians[index] += hess;\n-  }\n+    }\n \n-  public void accumulate(int index, double[] grad, double[] hess) {\n+    public void accumulate(int index, double[] grad, double[] hess) {\n     if (!fullHessian) {\n-      accumulate(index, grad, hess, 0);\n+        accumulate(index, grad, hess, 0);\n     } else {\n       accumulate(index, grad, 0, hess, 0);\n     }\n-  }\n+    }\n \n-  public void accumulate(int index, double[] grad, double[] hess, int offset) {\n+    public void accumulate(int index, double[] grad, double[] hess, int offset) {\n     int binOffset = index * numClass;\n     for (int i = 0; i < numClass; i++) {\n-      gradients[binOffset + i] += grad[offset + i];\n-      hessians[binOffset + i] += hess[offset + i];\n+        gradients[binOffset + i] += grad[offset + i];\n+        hessians[binOffset + i] += hess[offset + i];\n+    }\n     }\n-  }\n \n-  public void accumulate(int index, double[] grad, int gradOffset,\n-      double[] hess, int hessOffset) {\n+    public void accumulate(int index, double[] grad, int gradOffset, double[] hess, int hessOffset) {\n     int gradBinOffset = index * numClass;\n     int hessBinOffset = index * ((numClass * (numClass + 1)) >> 1);\n     for (int i = 0; i < grad.length; i++) {\n-      gradients[gradBinOffset + i] += grad[gradOffset + i];\n+        gradients[gradBinOffset + i] += grad[gradOffset + i];\n     }\n+\n     for (int i = 0; i < hess.length; i++) {\n-      hessians[hessBinOffset + i] += hess[hessOffset + i];\n+        hessians[hessBinOffset + i] += hess[hessOffset + i];\n+    }\n     }\n-  }\n \n-  public void accumulate(int index, GradPair gradPair) {\n+    public void accumulate(int index, GradPair gradPair) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      BinaryGradPair binary = (BinaryGradPair) gradPair;\n-      gradients[index] += binary.getGrad();\n-      hessians[index] += binary.getHess();\n+        BinaryGradPair binary = (BinaryGradPair) gradPair;\n+        gradients[index] += binary.getGrad();\n+        hessians[index] += binary.getHess();\n     } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gradPair;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        gradients[offset + i] += grad[i];\n-        hessians[offset + i] += hess[i];\n-      }\n+                                                             MultiGradPair multi = (MultiGradPair) gradPair;\n+                                                             double[] grad = multi.getGrad();\n+                                                             double[] hess = multi.getHess();\n+                                                             int offset = index * numClass;\n+                                                             for (int i = 0; i < numClass; i++) {\n+                                 gradients[offset + i] += grad[i];\n+                                 hessians[offset + i] += hess[i];\n+                                                             }\n     } else {\n       MultiGradPair multi = (MultiGradPair) gradPair;\n       double[] grad = multi.getGrad();\n@@ -102,142 +100,146 @@ public class Histogram implements Serializable {\n       int gradOffset = index * numClass;\n       int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n       for (int i = 0; i < grad.length; i++) {\n-        gradients[gradOffset + i] += grad[i];\n+               gradients[gradOffset + i] += grad[i];\n       }\n+\n       for (int i = 0; i < hess.length; i++) {\n-        hessians[hessOffset + i] += hess[i];\n+               hessians[hessOffset + i] += hess[i];\n       }\n     }\n-  }\n+    }\n \n-  public Histogram plus(Histogram other) {\n+    public Histogram plus(Histogram other) {\n     Histogram res = new Histogram(numBin, numClass, fullHessian, multiClassMultiTree);\n     if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] + other.gradients[i];\n-        res.hessians[i] = this.hessians[i] + other.hessians[i];\n-      }\n+        for (int i = 0; i < this.gradients.length; i++) {\n+                                                                  res.gradients[i] = this.gradients[i] + other.gradients[i];\n+                                                                  res.hessians[i] = this.hessians[i] + other.hessians[i];\n+        }\n     } else {\n       for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] + other.gradients[i];\n+               res.gradients[i] = this.gradients[i] + other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n-        res.hessians[i] = this.hessians[i] + other.hessians[i];\n+               res.hessians[i] = this.hessians[i] + other.hessians[i];\n       }\n     }\n     return res;\n-  }\n+    }\n \n-  public Histogram subtract(Histogram other) {\n+    public Histogram subtract(Histogram other) {\n     Histogram res = new Histogram(numBin, numClass, fullHessian, multiClassMultiTree);\n     if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] - other.gradients[i];\n-        res.hessians[i] = this.hessians[i] - other.hessians[i];\n-      }\n+        for (int i = 0; i < this.gradients.length; i++) {\n+                                                                  res.gradients[i] = this.gradients[i] - other.gradients[i];\n+                                                                  res.hessians[i] = this.hessians[i] - other.hessians[i];\n+        }\n     } else {\n       for (int i = 0; i < this.gradients.length; i++) {\n-        res.gradients[i] = this.gradients[i] - other.gradients[i];\n+               res.gradients[i] = this.gradients[i] - other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n-        res.hessians[i] = this.hessians[i] - other.hessians[i];\n+               res.hessians[i] = this.hessians[i] - other.hessians[i];\n       }\n     }\n     return res;\n-  }\n+    }\n \n-  public void plusBy(Histogram other) {\n+    public void plusBy(Histogram other) {\n     if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] += other.gradients[i];\n-        this.hessians[i] += other.hessians[i];\n-      }\n+        for (int i = 0; i < this.gradients.length; i++) {\n+                                                                  this.gradients[i] += other.gradients[i];\n+                                                                  this.hessians[i] += other.hessians[i];\n+        }\n     } else {\n       for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] += other.gradients[i];\n+               this.gradients[i] += other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n-        this.hessians[i] += other.hessians[i];\n+               this.hessians[i] += other.hessians[i];\n       }\n     }\n-  }\n+    }\n \n-  public void subtractBy(Histogram other) {\n+    public void subtractBy(Histogram other) {\n     if (numClass == 2 || multiClassMultiTree || !fullHessian) {\n-      for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] -= other.gradients[i];\n-        this.hessians[i] -= other.hessians[i];\n-      }\n+        for (int i = 0; i < this.gradients.length; i++) {\n+                                                                  this.gradients[i] -= other.gradients[i];\n+                                                                  this.hessians[i] -= other.hessians[i];\n+        }\n     } else {\n       for (int i = 0; i < this.gradients.length; i++) {\n-        this.gradients[i] -= other.gradients[i];\n+               this.gradients[i] -= other.gradients[i];\n       }\n+\n       for (int i = 0; i < this.hessians.length; i++) {\n-        this.hessians[i] -= other.hessians[i];\n+               this.hessians[i] -= other.hessians[i];\n       }\n     }\n-  }\n+    }\n \n-  public GradPair sum() {\n+    public GradPair sum() {\n     return sum(0, numBin);\n-  }\n+    }\n \n-  public GradPair sum(int start, int end) {\n+    public GradPair sum(int start, int end) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      double sumGrad = 0.0;\n-      double sumHess = 0.0;\n-      for (int i = start; i < end; i++) {\n-        sumGrad += gradients[i];\n-        sumHess += hessians[i];\n-      }\n-      return new BinaryGradPair(sumGrad, sumHess);\n+        double sumGrad = 0.0;\n+        double sumHess = 0.0;\n+        for (int i = start; i < end; i++) {\n+                                                  sumGrad += gradients[i];\n+                                                  sumHess += hessians[i];\n+        }\n+        return new BinaryGradPair(sumGrad, sumHess);\n     } else if (!fullHessian) {\n       double[] sumGrad = new double[numClass];\n       double[] sumHess = new double[numClass];\n       for (int i = start * numClass; i < end * numClass; i += numClass) {\n-        for (int j = 0; j < numClass; j++) {\n-          sumGrad[j] += gradients[i + j];\n-          sumHess[j] += hessians[i + j];\n-        }\n+                                 for (int j = 0; j < numClass; j++) {\n+                                                                            sumGrad[j] += gradients[i + j];\n+                                                                            sumHess[j] += hessians[i + j];\n+                                 }\n       }\n       return new MultiGradPair(sumGrad, sumHess);\n     } else {\n       double[] sumGrad = new double[numClass];\n       double[] sumHess = new double[(numClass * (numClass + 1)) >> 1];\n       for (int i = start; i < end; i++) {\n-        int gradOffset = i * sumGrad.length;\n-        for (int j = 0; j < sumGrad.length; j++) {\n-          sumGrad[j] += gradients[gradOffset + j];\n-        }\n-        int hessOffset = i * sumHess.length;\n-        for (int j = 0; j < sumHess.length; j++) {\n-          sumHess[j] += hessians[hessOffset + j];\n-        }\n+               int gradOffset = i * sumGrad.length;\n+               for (int j = 0; j < sumGrad.length; j++) {\n+                                            sumGrad[j] += gradients[gradOffset + j];\n+               }\n+\n+               int hessOffset = i * sumHess.length;\n+               for (int j = 0; j < sumHess.length; j++) {\n+                                            sumHess[j] += hessians[hessOffset + j];\n+               }\n       }\n       return new MultiGradPair(sumGrad, sumHess);\n     }\n-  }\n+    }\n \n-  public int getNumBin() {\n+    public int getNumBin() {\n     return numBin;\n-  }\n+    }\n \n-  public GradPair get(int index) {\n+    public GradPair get(int index) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      return new BinaryGradPair(gradients[index], hessians[index]);\n+        return new BinaryGradPair(gradients[index], hessians[index]);\n     } else {\n-      double[] grad = Arrays.copyOfRange(gradients,\n-          index * numClass, (index + 1) * numClass);\n+      double[] grad = Arrays.copyOfRange(gradients, index * numClass, (index + 1) * numClass);\n       int size = fullHessian ? ((numClass * (numClass + 1)) >> 1) : numClass;\n-      double[] hess = Arrays.copyOfRange(hessians,\n-          index * size, (index + 1) * size);\n+      double[] hess = Arrays.copyOfRange(hessians, index * size, (index + 1) * size);\n       return new MultiGradPair(grad, hess);\n     }\n-  }\n+    }\n \n-  public void put(int index, GradPair gp) {\n+    public void put(int index, GradPair gp) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) gp).set(gradients[index], hessians[index]);\n+        ((BinaryGradPair) gp).set(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n       ((MultiGradPair) gp).set(gradients, hessians, index * numClass);\n     } else {\n@@ -245,20 +247,20 @@ public class Histogram implements Serializable {\n       int hessOffset = index * ((numClass * (numClass + 1)) >> 1);\n       ((MultiGradPair) gp).set(gradients, gradOffset, hessians, hessOffset);\n     }\n-  }\n+    }\n \n-  public void plusTo(GradPair gp, int index) {\n+    public void plusTo(GradPair gp, int index) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n+        ((BinaryGradPair) gp).plusBy(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] += gradients[offset + i];\n-        hess[i] += hessians[offset + i];\n-      }\n+                                                   MultiGradPair multi = (MultiGradPair) gp;\n+                                                   double[] grad = multi.getGrad();\n+                                                   double[] hess = multi.getHess();\n+                                                   int offset = index * numClass;\n+                                                   for (int i = 0; i < numClass; i++) {\n+                                 grad[i] += gradients[offset + i];\n+                                 hess[i] += hessians[offset + i];\n+                                                   }\n     } else {\n       MultiGradPair multi = (MultiGradPair) gp;\n       double[] grad = multi.getGrad();\n@@ -266,26 +268,27 @@ public class Histogram implements Serializable {\n       int gradOffset = index * grad.length;\n       int hessOffset = index * hess.length;\n       for (int i = 0; i < grad.length; i++) {\n-        grad[i] += gradients[gradOffset + i];\n+               grad[i] += gradients[gradOffset + i];\n       }\n+\n       for (int i = 0; i < hess.length; i++) {\n-        hess[i] += hessians[hessOffset + i];\n+               hess[i] += hessians[hessOffset + i];\n       }\n     }\n-  }\n+    }\n \n-  public void subtractTo(GradPair gp, int index) {\n+    public void subtractTo(GradPair gp, int index) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n+        ((BinaryGradPair) gp).subtractBy(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n-      MultiGradPair multi = (MultiGradPair) gp;\n-      double[] grad = multi.getGrad();\n-      double[] hess = multi.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        grad[i] -= gradients[offset + i];\n-        hess[i] -= hessians[offset + i];\n-      }\n+                                                       MultiGradPair multi = (MultiGradPair) gp;\n+                                                       double[] grad = multi.getGrad();\n+                                                       double[] hess = multi.getHess();\n+                                                       int offset = index * numClass;\n+                                                       for (int i = 0; i < numClass; i++) {\n+                                 grad[i] -= gradients[offset + i];\n+                                 hess[i] -= hessians[offset + i];\n+                                                       }\n     } else {\n       MultiGradPair multi = (MultiGradPair) gp;\n       double[] grad = multi.getGrad();\n@@ -293,32 +296,33 @@ public class Histogram implements Serializable {\n       int gradOffset = index * grad.length;\n       int hessOffset = index * hess.length;\n       for (int i = 0; i < grad.length; i++) {\n-        grad[i] -= gradients[gradOffset + i];\n+               grad[i] -= gradients[gradOffset + i];\n       }\n+\n       for (int i = 0; i < hess.length; i++) {\n-        hess[i] -= hessians[hessOffset + i];\n+               hess[i] -= hessians[hessOffset + i];\n       }\n     }\n-  }\n+    }\n \n-  public void scan(int index, GradPair left, GradPair right) {\n+    public void scan(int index, GradPair left, GradPair right) {\n     if (numClass == 2 || multiClassMultiTree) {\n-      ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n-      ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n+        ((BinaryGradPair) left).plusBy(gradients[index], hessians[index]);\n+        ((BinaryGradPair) right).subtractBy(gradients[index], hessians[index]);\n     } else if (!fullHessian) {\n-      MultiGradPair leftMulti = (MultiGradPair) left;\n-      double[] leftGrad = leftMulti.getGrad();\n-      double[] leftHess = leftMulti.getHess();\n-      MultiGradPair rightMulti = (MultiGradPair) right;\n-      double[] rightGrad = rightMulti.getGrad();\n-      double[] rightHess = rightMulti.getHess();\n-      int offset = index * numClass;\n-      for (int i = 0; i < numClass; i++) {\n-        leftGrad[i] += gradients[offset + i];\n-        leftHess[i] += hessians[offset + i];\n-        rightGrad[i] -= gradients[offset + i];\n-        rightHess[i] -= hessians[offset + i];\n-      }\n+                                                                   MultiGradPair leftMulti = (MultiGradPair) left;\n+                                                                   double[] leftGrad = leftMulti.getGrad();\n+                                                                   double[] leftHess = leftMulti.getHess();\n+                                                                   MultiGradPair rightMulti = (MultiGradPair) right;\n+                                                                   double[] rightGrad = rightMulti.getGrad();\n+                                                                   double[] rightHess = rightMulti.getHess();\n+                                                                   int offset = index * numClass;\n+                                                                   for (int i = 0; i < numClass; i++) {\n+                                 leftGrad[i] += gradients[offset + i];\n+                                 leftHess[i] += hessians[offset + i];\n+                                 rightGrad[i] -= gradients[offset + i];\n+                                 rightHess[i] -= hessians[offset + i];\n+                                                                   }\n     } else {\n       MultiGradPair leftMulti = (MultiGradPair) left;\n       double[] leftGrad = leftMulti.getGrad();\n@@ -329,19 +333,20 @@ public class Histogram implements Serializable {\n       int gradOffset = index * leftGrad.length;\n       int hessOffset = index * leftHess.length;\n       for (int i = 0; i < leftGrad.length; i++) {\n-        leftGrad[i] += gradients[gradOffset + i];\n-        rightGrad[i] -= gradients[gradOffset + i];\n+               leftGrad[i] += gradients[gradOffset + i];\n+               rightGrad[i] -= gradients[gradOffset + i];\n       }\n+\n       for (int i = 0; i < leftHess.length; i++) {\n-        leftHess[i] += hessians[hessOffset + i];\n-        rightHess[i] -= hessians[hessOffset + i];\n+               leftHess[i] += hessians[hessOffset + i];\n+               rightHess[i] -= hessians[hessOffset + i];\n       }\n     }\n-  }\n+    }\n \n-  public void clear() {\n+    public void clear() {\n     Arrays.fill(gradients, 0.0);\n     Arrays.fill(hessians, 0.0);\n-  }\n+    }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 178
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/72/Histogram.java\nindex b6aa657f63..57810acfa0 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/72/Histogram.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/72/Histogram.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.spark.ml.tree.gbdt.histogram;\n \n import java.io.Serializable;\n",
            "diff_size": 1
        }
    ]
}