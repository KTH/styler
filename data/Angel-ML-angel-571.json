{
    "error_id": "571",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/571/SimpleDotExecutor.java\nindex c17d34f942..34c7026b92 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/571/SimpleDotExecutor.java\n@@ -33,2384 +33,2384 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;\n \n public class SimpleDotExecutor {\n \n-  public static double apply(Vector v1, Vector v2) {\n-    if (v1 instanceof IntDoubleVector && v2 instanceof IntDoubleVector) {\n-      return apply((IntDoubleVector) v1, (IntDoubleVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntFloatVector) {\n-      return apply((IntDoubleVector) v1, (IntFloatVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntLongVector) {\n-      return apply((IntDoubleVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntIntVector) {\n-      return apply((IntDoubleVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntDummyVector) {\n-      return apply((IntDoubleVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntFloatVector) {\n-      return apply((IntFloatVector) v1, (IntFloatVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntLongVector) {\n-      return apply((IntFloatVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntIntVector) {\n-      return apply((IntFloatVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntDummyVector) {\n-      return apply((IntFloatVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntLongVector) {\n-      return apply((IntLongVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntIntVector) {\n-      return apply((IntLongVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntDummyVector) {\n-      return apply((IntLongVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntIntVector && v2 instanceof IntIntVector) {\n-      return apply((IntIntVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntIntVector && v2 instanceof IntDummyVector) {\n-      return apply((IntIntVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntDummyVector && v2 instanceof IntDummyVector) {\n-      return apply((IntDummyVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDoubleVector) {\n-      return apply((LongDoubleVector) v1, (LongDoubleVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongFloatVector) {\n-      return apply((LongDoubleVector) v1, (LongFloatVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongLongVector) {\n-      return apply((LongDoubleVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongIntVector) {\n-      return apply((LongDoubleVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDummyVector) {\n-      return apply((LongDoubleVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongFloatVector) {\n-      return apply((LongFloatVector) v1, (LongFloatVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongLongVector) {\n-      return apply((LongFloatVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongIntVector) {\n-      return apply((LongFloatVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongDummyVector) {\n-      return apply((LongFloatVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongLongVector) {\n-      return apply((LongLongVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongIntVector) {\n-      return apply((LongLongVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongDummyVector) {\n-      return apply((LongLongVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongIntVector && v2 instanceof LongIntVector) {\n-      return apply((LongIntVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongIntVector && v2 instanceof LongDummyVector) {\n-      return apply((LongIntVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongDummyVector && v2 instanceof LongDummyVector) {\n-      return apply((LongDummyVector) v1, (LongDummyVector) v2);\n-    } else {\n-      throw new AngelException(\"Vector type is not support!\");\n+    public static double apply(Vector v1, Vector v2) {\n+        if (v1 instanceof IntDoubleVector && v2 instanceof IntDoubleVector) {\n+            return apply((IntDoubleVector) v1, (IntDoubleVector) v2);\n+        } else if (v1 instanceof IntDoubleVector && v2 instanceof IntFloatVector) {\n+            return apply((IntDoubleVector) v1, (IntFloatVector) v2);\n+        } else if (v1 instanceof IntDoubleVector && v2 instanceof IntLongVector) {\n+            return apply((IntDoubleVector) v1, (IntLongVector) v2);\n+        } else if (v1 instanceof IntDoubleVector && v2 instanceof IntIntVector) {\n+            return apply((IntDoubleVector) v1, (IntIntVector) v2);\n+        } else if (v1 instanceof IntDoubleVector && v2 instanceof IntDummyVector) {\n+            return apply((IntDoubleVector) v1, (IntDummyVector) v2);\n+        } else if (v1 instanceof IntFloatVector && v2 instanceof IntFloatVector) {\n+            return apply((IntFloatVector) v1, (IntFloatVector) v2);\n+        } else if (v1 instanceof IntFloatVector && v2 instanceof IntLongVector) {\n+            return apply((IntFloatVector) v1, (IntLongVector) v2);\n+        } else if (v1 instanceof IntFloatVector && v2 instanceof IntIntVector) {\n+            return apply((IntFloatVector) v1, (IntIntVector) v2);\n+        } else if (v1 instanceof IntFloatVector && v2 instanceof IntDummyVector) {\n+            return apply((IntFloatVector) v1, (IntDummyVector) v2);\n+        } else if (v1 instanceof IntLongVector && v2 instanceof IntLongVector) {\n+            return apply((IntLongVector) v1, (IntLongVector) v2);\n+        } else if (v1 instanceof IntLongVector && v2 instanceof IntIntVector) {\n+            return apply((IntLongVector) v1, (IntIntVector) v2);\n+        } else if (v1 instanceof IntLongVector && v2 instanceof IntDummyVector) {\n+            return apply((IntLongVector) v1, (IntDummyVector) v2);\n+        } else if (v1 instanceof IntIntVector && v2 instanceof IntIntVector) {\n+            return apply((IntIntVector) v1, (IntIntVector) v2);\n+        } else if (v1 instanceof IntIntVector && v2 instanceof IntDummyVector) {\n+            return apply((IntIntVector) v1, (IntDummyVector) v2);\n+        } else if (v1 instanceof IntDummyVector && v2 instanceof IntDummyVector) {\n+            return apply((IntDummyVector) v1, (IntDummyVector) v2);\n+        } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDoubleVector) {\n+            return apply((LongDoubleVector) v1, (LongDoubleVector) v2);\n+        } else if (v1 instanceof LongDoubleVector && v2 instanceof LongFloatVector) {\n+            return apply((LongDoubleVector) v1, (LongFloatVector) v2);\n+        } else if (v1 instanceof LongDoubleVector && v2 instanceof LongLongVector) {\n+            return apply((LongDoubleVector) v1, (LongLongVector) v2);\n+        } else if (v1 instanceof LongDoubleVector && v2 instanceof LongIntVector) {\n+            return apply((LongDoubleVector) v1, (LongIntVector) v2);\n+        } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDummyVector) {\n+            return apply((LongDoubleVector) v1, (LongDummyVector) v2);\n+        } else if (v1 instanceof LongFloatVector && v2 instanceof LongFloatVector) {\n+            return apply((LongFloatVector) v1, (LongFloatVector) v2);\n+        } else if (v1 instanceof LongFloatVector && v2 instanceof LongLongVector) {\n+            return apply((LongFloatVector) v1, (LongLongVector) v2);\n+        } else if (v1 instanceof LongFloatVector && v2 instanceof LongIntVector) {\n+            return apply((LongFloatVector) v1, (LongIntVector) v2);\n+        } else if (v1 instanceof LongFloatVector && v2 instanceof LongDummyVector) {\n+            return apply((LongFloatVector) v1, (LongDummyVector) v2);\n+        } else if (v1 instanceof LongLongVector && v2 instanceof LongLongVector) {\n+            return apply((LongLongVector) v1, (LongLongVector) v2);\n+        } else if (v1 instanceof LongLongVector && v2 instanceof LongIntVector) {\n+            return apply((LongLongVector) v1, (LongIntVector) v2);\n+        } else if (v1 instanceof LongLongVector && v2 instanceof LongDummyVector) {\n+            return apply((LongLongVector) v1, (LongDummyVector) v2);\n+        } else if (v1 instanceof LongIntVector && v2 instanceof LongIntVector) {\n+            return apply((LongIntVector) v1, (LongIntVector) v2);\n+        } else if (v1 instanceof LongIntVector && v2 instanceof LongDummyVector) {\n+            return apply((LongIntVector) v1, (LongDummyVector) v2);\n+        } else if (v1 instanceof LongDummyVector && v2 instanceof LongDummyVector) {\n+            return apply((LongDummyVector) v1, (LongDummyVector) v2);\n+        } else {\n+            throw new AngelException(\"Vector type is not support!\");\n+        }\n     }\n-  }\n-\n-  private static double apply(IntDummyVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] keys1 = v1.getIndices();\n-    int[] keys2 = v2.getIndices();\n-    int v1Pointor = 0;\n-    int v2Pointor = 0;\n-\n-    while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n-      if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-        dot += 1.0;\n-        v2Pointor++;\n-        v1Pointor++;\n-      } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-        v2Pointor++;\n-      } else {\n-        v1Pointor++;\n-      }\n+\n+    private static double apply(IntDummyVector v1, IntDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        int[] keys1 = v1.getIndices();\n+        int[] keys2 = v2.getIndices();\n+        int v1Pointor = 0;\n+        int v2Pointor = 0;\n+\n+        while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n+            if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                dot += 1.0;\n+                v2Pointor++;\n+                v1Pointor++;\n+            } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                v2Pointor++;\n+            } else {\n+                v1Pointor++;\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(IntDoubleVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(IntDoubleVector v1, IntDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        int[] idxs = v2.getIndices();\n+        if (v1.isDense()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[idxs[i]];\n+            }\n+        } else if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            int[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(IntDoubleVector v1, IntDoubleVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      double[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        double[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(IntDoubleVector v1, IntDoubleVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            double[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2DoubleMap.Entry entry = iter.next();\n+                dot += entry.getDoubleValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            double[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            double[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2DoubleMap.Entry entry = iter.next();\n+                dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            double[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                double[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            double[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntDoubleVector v1, IntFloatVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      float[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntDoubleVector v1, IntFloatVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            float[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2FloatMap.Entry entry = iter.next();\n+                dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            float[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            float[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2DoubleMap.Entry entry = iter.next();\n+                dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            float[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                float[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            float[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntDoubleVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntDoubleVector v1, IntLongVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2LongMap.Entry entry = iter.next();\n+                dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            long[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2DoubleMap.Entry entry = iter.next();\n+                dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                long[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntDoubleVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntDoubleVector v1, IntIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2IntMap.Entry entry = iter.next();\n+                dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            int[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2DoubleMap.Entry entry = iter.next();\n+                dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntFloatVector v1, IntDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        int[] idxs = v2.getIndices();\n+        if (v1.isDense()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[idxs[i]];\n+            }\n+        } else if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            int[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntFloatVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      float[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(IntFloatVector v1, IntFloatVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            float[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2FloatMap.Entry entry = iter.next();\n+                dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            float[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            float[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2FloatMap.Entry entry = iter.next();\n+                dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            float[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                float[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                float[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            float[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntFloatVector v1, IntLongVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2LongMap.Entry entry = iter.next();\n+                dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            long[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2FloatMap.Entry entry = iter.next();\n+                dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                long[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                float[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntFloatVector v1, IntIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2IntMap.Entry entry = iter.next();\n+                dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            int[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2FloatMap.Entry entry = iter.next();\n+                dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                float[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntLongVector v1, IntDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        int[] idxs = v2.getIndices();\n+        if (v1.isDense()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[idxs[i]];\n+            }\n+        } else if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            int[] keys1 = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(IntLongVector v1, IntLongVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2LongMap.Entry entry = iter.next();\n+                dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            long[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2LongMap.Entry entry = iter.next();\n+                dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+            long[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                long[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                long[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntLongVector v1, IntIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2IntMap.Entry entry = iter.next();\n+                dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            long[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            int[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2LongMap.Entry entry = iter.next();\n+                dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                long[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(IntIntVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(IntIntVector v1, IntDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        int[] idxs = v2.getIndices();\n+        if (v1.isDense()) {\n+            int[] v1Values = v1.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[idxs[i]];\n+            }\n+        } else if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            int[] keys1 = v1.getStorage().getIndices();\n+            int[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(IntIntVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        int[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(IntIntVector v1, IntIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isDense() && v2.isDense()) {\n+            int[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int length = v1Values.length;\n+            for (int i = 0; i < length; i++) {\n+                dot += v1Values[i] * v2Values[i];\n+            }\n+        } else if (v1.isDense() && v2.isSparse()) {\n+            int[] v1Values = v1.getStorage().getValues();\n+            ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2IntMap.Entry entry = iter.next();\n+                dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isDense() && v2.isSorted()) {\n+            int[] v1Values = v1.getStorage().getValues();\n+            int[] keys = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v2.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v2Values[i] * v1Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isDense()) {\n+            int[] v2Values = v2.getStorage().getValues();\n+            ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+            while (iter.hasNext()) {\n+                Int2IntMap.Entry entry = iter.next();\n+                dot += entry.getIntValue() * v2Values[entry.getIntKey()];\n+            }\n+        } else if (v1.isSorted() && v2.isDense()) {\n+            int[] keys = v1.getStorage().getIndices();\n+            int[] v1Values = v1.getStorage().getValues();\n+            int[] v2Values = v2.getStorage().getValues();\n+            int size = v1.size();\n+            for (int i = 0; i < size; i++) {\n+                dot += v1Values[i] * v2Values[keys[i]];\n+            }\n+        } else if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                int size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Int2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                }\n+            } else {\n+                int[] keys = v1.getStorage().getIndices();\n+                int[] v1Values = v1.getStorage().getValues();\n+                int size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            int[] keys1 = v1.getStorage().getIndices();\n+            int[] v1Values = v1.getStorage().getValues();\n+            int[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            int size1 = v1.size();\n+            int size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongDummyVector v1, LongDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    long[] keys1 = v1.getIndices();\n-    long[] keys2 = v2.getIndices();\n-    int v1Pointor = 0;\n-    int v2Pointor = 0;\n-\n-    while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n-      if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-        dot += 1.0;\n-        v2Pointor++;\n-        v1Pointor++;\n-      } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-        v2Pointor++;\n-      } else {\n-        v1Pointor++;\n-      }\n+    private static double apply(LongDummyVector v1, LongDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        long[] keys1 = v1.getIndices();\n+        long[] keys2 = v2.getIndices();\n+        int v1Pointor = 0;\n+        int v2Pointor = 0;\n+\n+        while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n+            if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                dot += 1.0;\n+                v2Pointor++;\n+                v1Pointor++;\n+            } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                v2Pointor++;\n+            } else {\n+                v1Pointor++;\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(LongDoubleVector v1, LongDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    long[] idxs = v2.getIndices();\n-    if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(LongDoubleVector v1, LongDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        long[] idxs = v2.getIndices();\n+        if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            long[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(LongDoubleVector v1, LongDoubleVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        double[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(LongDoubleVector v1, LongDoubleVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                double[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            double[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongDoubleVector v1, LongFloatVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongDoubleVector v1, LongFloatVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                float[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            float[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongDoubleVector v1, LongLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongDoubleVector v1, LongLongVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                long[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongDoubleVector v1, LongIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongDoubleVector v1, LongIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2DoubleMap.Entry entry = iter.next();\n+                    dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                double[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            double[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongFloatVector v1, LongDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    long[] idxs = v2.getIndices();\n-    if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongFloatVector v1, LongDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        long[] idxs = v2.getIndices();\n+        if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            long[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(LongFloatVector v1, LongFloatVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(LongFloatVector v1, LongFloatVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                float[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                float[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            float[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongFloatVector v1, LongLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongFloatVector v1, LongLongVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                long[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                float[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongFloatVector v1, LongIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongFloatVector v1, LongIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2FloatMap.Entry entry = iter.next();\n+                    dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                float[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            float[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongLongVector v1, LongDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    long[] idxs = v2.getIndices();\n-    if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongLongVector v1, LongDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        long[] idxs = v2.getIndices();\n+        if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            long[] keys1 = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(LongLongVector v1, LongLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(LongLongVector v1, LongLongVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                long[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                long[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            long[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongLongVector v1, LongIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongLongVector v1, LongIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2LongMap.Entry entry = iter.next();\n+                    dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                long[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            long[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n+\n+        return dot;\n     }\n \n-    return dot;\n-  }\n-\n-  private static double apply(LongIntVector v1, LongDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    long[] idxs = v2.getIndices();\n-    if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n+    private static double apply(LongIntVector v1, LongDummyVector v2) {\n+        assert v1.getDim() == v2.getDim();\n+        double dot = 0.0;\n+        long[] idxs = v2.getIndices();\n+        if (v1.isSparse()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1.get(idxs[i]);\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n-        }\n-      }\n+            long[] keys1 = v1.getStorage().getIndices();\n+            int[] v1Values = v1.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+                    dot += v1Values[v1Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n+        }\n+        return dot;\n     }\n-    return dot;\n-  }\n-\n-  private static double apply(LongIntVector v1, LongIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        int[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n+\n+    private static double apply(LongIntVector v1, LongIntVector v2) {\n+        double dot = 0.0;\n+        if (v1.isSparse() && v2.isSparse()) {\n+            if (v1.size() < v2.size()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            }\n+        } else if (v1.isSparse() && v2.isSorted()) {\n+            if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n+                    && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v2.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v2.getStorage().getIndices();\n+                int[] v2Values = v2.getStorage().getValues();\n+                long size = v2.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v2Values[i] * v1.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSparse()) {\n+            if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n+                    && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                while (iter.hasNext()) {\n+                    Long2IntMap.Entry entry = iter.next();\n+                    dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                }\n+            } else {\n+                long[] keys = v1.getStorage().getIndices();\n+                int[] v1Values = v1.getStorage().getValues();\n+                long size = v1.size();\n+                for (int i = 0; i < size; i++) {\n+                    dot += v1Values[i] * v2.get(keys[i]);\n+                }\n+            }\n+        } else if (v1.isSorted() && v2.isSorted()) {\n+            long[] keys1 = v1.getStorage().getIndices();\n+            int[] v1Values = v1.getStorage().getValues();\n+            long[] keys2 = v2.getStorage().getIndices();\n+            int[] v2Values = v2.getStorage().getValues();\n+\n+            int v1Pointor = 0;\n+            int v2Pointor = 0;\n+            long size1 = v1.size();\n+            long size2 = v2.size();\n+\n+            while (v1Pointor < size1 && v2Pointor < size2) {\n+                if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                    dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                    v2Pointor++;\n+                    v1Pointor++;\n+                } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                    v2Pointor++;\n+                } else {\n+                    v1Pointor++;\n+                }\n+            }\n         } else {\n-          v1Pointor++;\n+            throw new AngelException(\"the operation is not support!\");\n         }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n \n-    return dot;\n-  }\n+        return dot;\n+    }\n \n }\n",
            "diff_size": 2455
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "224",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "337",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "450",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "563",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "633",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "723",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "836",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "949",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1019",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1109",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1222",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1292",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1382",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1468",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1521",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1597",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1673",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1749",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1813",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1866",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1942",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2018",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2082",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2135",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2211",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2275",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2328",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/571/SimpleDotExecutor.java\nindex c17d34f942..e353ea2688 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/naturalize/571/SimpleDotExecutor.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.ml.math2.ufuncs.executor.simple;\n \n import com.tencent.angel.exception.AngelException;\n@@ -132,9 +131,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -223,9 +221,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -241,7 +238,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n@@ -337,9 +334,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -355,7 +351,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n@@ -451,9 +447,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -469,7 +464,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getIntKey());\n@@ -565,9 +560,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n@@ -583,7 +577,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -636,9 +630,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -727,9 +720,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -745,7 +737,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n@@ -841,9 +833,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -859,7 +850,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getIntKey());\n@@ -955,9 +946,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n@@ -973,7 +963,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -1026,9 +1016,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n@@ -1117,9 +1106,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n@@ -1135,7 +1123,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getIntKey());\n@@ -1231,9 +1219,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getIntKey());\n@@ -1249,7 +1236,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -1302,9 +1289,8 @@ public class SimpleDotExecutor {\n         dot += v1Values[idxs[i]];\n       }\n     } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getIntKey());\n@@ -1393,9 +1379,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getIntKey());\n@@ -1411,7 +1396,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Int2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getIntKey());\n@@ -1480,9 +1465,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1534,9 +1518,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1552,7 +1535,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n@@ -1611,9 +1594,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1629,7 +1611,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n@@ -1688,9 +1670,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1706,7 +1687,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getLongKey());\n@@ -1765,9 +1746,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2DoubleMap.Entry entry = iter.next();\n           dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n@@ -1783,7 +1763,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -1830,9 +1810,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -1884,9 +1863,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -1902,7 +1880,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n@@ -1961,9 +1939,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -1979,7 +1956,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getLongKey());\n@@ -2038,9 +2015,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2FloatMap.Entry entry = iter.next();\n           dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n@@ -2056,7 +2032,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -2103,9 +2079,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getLongKey());\n@@ -2157,9 +2132,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getLongKey());\n@@ -2175,7 +2149,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v1.get(entry.getLongKey());\n@@ -2234,9 +2208,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2LongMap.Entry entry = iter.next();\n           dot += entry.getLongValue() * v2.get(entry.getLongKey());\n@@ -2252,7 +2225,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -2299,9 +2272,8 @@ public class SimpleDotExecutor {\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getLongKey());\n@@ -2353,9 +2325,8 @@ public class SimpleDotExecutor {\n         }\n       }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+  ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v2.get(entry.getLongKey());\n@@ -2371,7 +2342,7 @@ public class SimpleDotExecutor {\n     } else if (v1.isSorted() && v2.isSparse()) {\n       if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n           && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+  ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n         while (iter.hasNext()) {\n           Long2IntMap.Entry entry = iter.next();\n           dot += entry.getIntValue() * v1.get(entry.getLongKey());\n@@ -2413,4 +2384,4 @@ public class SimpleDotExecutor {\n     return dot;\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 106
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "40",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "55",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "57",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "59",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "61",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "63",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "65",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "66",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "67",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "70",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "71",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 136).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "72",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "73",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "74",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "75",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "76",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "77",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 149).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "80",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "81",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "82",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "83",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 157).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "84",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "85",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 155).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "86",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 140).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "87",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "89",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 163).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "90",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "91",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "92",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "93",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "94",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 154).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "95",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 178).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "96",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "97",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "98",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 160).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "99",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "137",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "138",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "182",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "197",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "209",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "212",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "222",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "223",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "225",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 182).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "226",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 200).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "237",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "238",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 111).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "240",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 189).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "241",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 207).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "261",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "265",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "291",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "306",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "318",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "321",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "331",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "332",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "334",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 182).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "335",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 200).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "346",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "347",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "349",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 188).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "350",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 206).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "370",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "374",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "400",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "415",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "427",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "430",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "440",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "441",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "443",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 182).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "444",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 200).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "455",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "456",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "458",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "459",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 205).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "479",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "483",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "509",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "524",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "536",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "539",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "549",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "550",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "552",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 182).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "553",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 200).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "564",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "565",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "567",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "568",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 204).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "588",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "592",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "615",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "618",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "619",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "663",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "678",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "690",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "693",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "703",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "704",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "706",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "707",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 199).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "718",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "719",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "721",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 188).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "722",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 206).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "742",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "746",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "772",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "787",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "799",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "802",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "812",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "813",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "815",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "816",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 199).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "827",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "828",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "830",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "831",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 205).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "851",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "855",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "881",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "896",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "908",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "911",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "921",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "922",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "924",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "925",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 199).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "936",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "937",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "939",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "940",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 204).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "960",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "964",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "987",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "990",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "991",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1035",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1050",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1062",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1065",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1075",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1076",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1078",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 180).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1079",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 198).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1090",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1091",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 109).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1093",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1094",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 205).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1114",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1118",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1144",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1159",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1171",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1174",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1184",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1185",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1187",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 180).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1188",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 198).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1199",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1200",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1202",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1203",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 204).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1223",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1227",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1253",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 165).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1254",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 183).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1298",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1313",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1325",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1328",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 106).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1338",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1339",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1341",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1342",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 197).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1353",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1354",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1356",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1357",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 204).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1377",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1381",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1419",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1422",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 171).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1423",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 189).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1470",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1473",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1474",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1485",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1488",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1489",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1509",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1513",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1542",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1545",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1546",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1557",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1560",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1561",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1581",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1585",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1614",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1617",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1618",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1629",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1632",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1633",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1653",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1657",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1686",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1689",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1690",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1701",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1704",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1705",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1725",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1729",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1746",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1749",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 170).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1750",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 188).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1797",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1800",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1801",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1812",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1815",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1816",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1836",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1840",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1869",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1872",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1873",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1884",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1887",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1888",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1908",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1912",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1941",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1944",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1945",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1956",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1959",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1960",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1980",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1984",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2001",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2004",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2005",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 187).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2052",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2055",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2056",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2067",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2070",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2071",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2091",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2095",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2124",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2127",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 167).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2128",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2139",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2142",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2143",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2163",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2167",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2184",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2187",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2188",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2235",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2238",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2239",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2250",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2253",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 166).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2254",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 184).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2274",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "2278",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/571/SimpleDotExecutor.java\nindex c17d34f942..8e85f05c4f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/571/SimpleDotExecutor.java\n@@ -33,157 +33,153 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;\n \n public class SimpleDotExecutor {\n \n-  public static double apply(Vector v1, Vector v2) {\n+    public static double apply(Vector v1, Vector v2) {\n     if (v1 instanceof IntDoubleVector && v2 instanceof IntDoubleVector) {\n-      return apply((IntDoubleVector) v1, (IntDoubleVector) v2);\n+        return apply((IntDoubleVector) v1, (IntDoubleVector) v2);\n     } else if (v1 instanceof IntDoubleVector && v2 instanceof IntFloatVector) {\n-      return apply((IntDoubleVector) v1, (IntFloatVector) v2);\n+                                                         return apply((IntDoubleVector) v1, (IntFloatVector) v2);\n     } else if (v1 instanceof IntDoubleVector && v2 instanceof IntLongVector) {\n-      return apply((IntDoubleVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntIntVector) {\n-      return apply((IntDoubleVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntDoubleVector && v2 instanceof IntDummyVector) {\n-      return apply((IntDoubleVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntFloatVector) {\n-      return apply((IntFloatVector) v1, (IntFloatVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntLongVector) {\n-      return apply((IntFloatVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntIntVector) {\n-      return apply((IntFloatVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntFloatVector && v2 instanceof IntDummyVector) {\n-      return apply((IntFloatVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntLongVector) {\n-      return apply((IntLongVector) v1, (IntLongVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntIntVector) {\n-      return apply((IntLongVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntLongVector && v2 instanceof IntDummyVector) {\n-      return apply((IntLongVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntIntVector && v2 instanceof IntIntVector) {\n-      return apply((IntIntVector) v1, (IntIntVector) v2);\n-    } else if (v1 instanceof IntIntVector && v2 instanceof IntDummyVector) {\n-      return apply((IntIntVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof IntDummyVector && v2 instanceof IntDummyVector) {\n-      return apply((IntDummyVector) v1, (IntDummyVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDoubleVector) {\n-      return apply((LongDoubleVector) v1, (LongDoubleVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongFloatVector) {\n-      return apply((LongDoubleVector) v1, (LongFloatVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongLongVector) {\n-      return apply((LongDoubleVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongIntVector) {\n-      return apply((LongDoubleVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDummyVector) {\n-      return apply((LongDoubleVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongFloatVector) {\n-      return apply((LongFloatVector) v1, (LongFloatVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongLongVector) {\n-      return apply((LongFloatVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongIntVector) {\n-      return apply((LongFloatVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongFloatVector && v2 instanceof LongDummyVector) {\n-      return apply((LongFloatVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongLongVector) {\n-      return apply((LongLongVector) v1, (LongLongVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongIntVector) {\n-      return apply((LongLongVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongLongVector && v2 instanceof LongDummyVector) {\n-      return apply((LongLongVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongIntVector && v2 instanceof LongIntVector) {\n-      return apply((LongIntVector) v1, (LongIntVector) v2);\n-    } else if (v1 instanceof LongIntVector && v2 instanceof LongDummyVector) {\n-      return apply((LongIntVector) v1, (LongDummyVector) v2);\n-    } else if (v1 instanceof LongDummyVector && v2 instanceof LongDummyVector) {\n-      return apply((LongDummyVector) v1, (LongDummyVector) v2);\n-    } else {\n-      throw new AngelException(\"Vector type is not support!\");\n+        return apply((IntDoubleVector) v1, (IntLongVector) v2);\n+           } else if (v1 instanceof IntDoubleVector && v2 instanceof IntIntVector) {\n+        return apply((IntDoubleVector) v1, (IntIntVector) v2);\n+           } else if (v1 instanceof IntDoubleVector && v2 instanceof IntDummyVector) {\n+               return apply((IntDoubleVector) v1, (IntDummyVector) v2);\n+                  } else if (v1 instanceof IntFloatVector && v2 instanceof IntFloatVector) {\n+               return apply((IntFloatVector) v1, (IntFloatVector) v2);\n+                  } else if (v1 instanceof IntFloatVector && v2 instanceof IntLongVector) {\n+                      return apply((IntFloatVector) v1, (IntLongVector) v2);\n+                         } else if (v1 instanceof IntFloatVector && v2 instanceof IntIntVector) {\n+                      return apply((IntFloatVector) v1, (IntIntVector) v2);\n+                         } else if (v1 instanceof IntFloatVector && v2 instanceof IntDummyVector) {\n+                             return apply((IntFloatVector) v1, (IntDummyVector) v2);\n+                                } else if (v1 instanceof IntLongVector && v2 instanceof IntLongVector) {\n+                             return apply((IntLongVector) v1, (IntLongVector) v2);\n+                                } else if (v1 instanceof IntLongVector && v2 instanceof IntIntVector) {\n+                                    return apply((IntLongVector) v1, (IntIntVector) v2);\n+                                       } else if (v1 instanceof IntLongVector && v2 instanceof IntDummyVector) {\n+                                    return apply((IntLongVector) v1, (IntDummyVector) v2);\n+                                       } else if (v1 instanceof IntIntVector && v2 instanceof IntIntVector) {\n+                                           return apply((IntIntVector) v1, (IntIntVector) v2);\n+                                              } else if (v1 instanceof IntIntVector && v2 instanceof IntDummyVector) {\n+                                           return apply((IntIntVector) v1, (IntDummyVector) v2);\n+                                              } else if (v1 instanceof IntDummyVector && v2 instanceof IntDummyVector) {\n+                                                  return apply((IntDummyVector) v1, (IntDummyVector) v2);\n+                                                     } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDoubleVector) {\n+                                                  return apply((LongDoubleVector) v1, (LongDoubleVector) v2);\n+                                                     } else if (v1 instanceof LongDoubleVector && v2 instanceof LongFloatVector) {\n+                                                         return apply((LongDoubleVector) v1, (LongFloatVector) v2);\n+                                                            } else if (v1 instanceof LongDoubleVector && v2 instanceof LongLongVector) {\n+                                                         return apply((LongDoubleVector) v1, (LongLongVector) v2);\n+                                                            } else if (v1 instanceof LongDoubleVector && v2 instanceof LongIntVector) {\n+                                                                return apply((LongDoubleVector) v1, (LongIntVector) v2);\n+                                                                   } else if (v1 instanceof LongDoubleVector && v2 instanceof LongDummyVector) {\n+                                                                return apply((LongDoubleVector) v1, (LongDummyVector) v2);\n+                                                                   } else if (v1 instanceof LongFloatVector && v2 instanceof LongFloatVector) {\n+                                                                       return apply((LongFloatVector) v1, (LongFloatVector) v2);\n+                                                                          } else if (v1 instanceof LongFloatVector && v2 instanceof LongLongVector) {\n+                                                                       return apply((LongFloatVector) v1, (LongLongVector) v2);\n+                                                                          } else if (v1 instanceof LongFloatVector && v2 instanceof LongIntVector) {\n+                                                                              return apply((LongFloatVector) v1, (LongIntVector) v2);\n+                                                                                 } else if (v1 instanceof LongFloatVector && v2 instanceof LongDummyVector) {\n+                                                                              return apply((LongFloatVector) v1, (LongDummyVector) v2);\n+                                                                                 } else if (v1 instanceof LongLongVector && v2 instanceof LongLongVector) {\n+                                                                                     return apply((LongLongVector) v1, (LongLongVector) v2);\n+                                                                                        } else if (v1 instanceof LongLongVector && v2 instanceof LongIntVector) {\n+                                                                                     return apply((LongLongVector) v1, (LongIntVector) v2);\n+                                                                                        } else if (v1 instanceof LongLongVector && v2 instanceof LongDummyVector) {\n+                                                                                            return apply((LongLongVector) v1, (LongDummyVector) v2);\n+                                                                                               } else if (v1 instanceof LongIntVector && v2 instanceof LongIntVector) {\n+                                                                                            return apply((LongIntVector) v1, (LongIntVector) v2);\n+                                                                                               } else if (v1 instanceof LongIntVector && v2 instanceof LongDummyVector) {\n+                                                                                                   return apply((LongIntVector) v1, (LongDummyVector) v2);\n+                                                                                                      } else if (v1 instanceof LongDummyVector && v2 instanceof LongDummyVector) {\n+                                                                                                   return apply((LongDummyVector) v1, (LongDummyVector) v2);\n+                                                                                                      } else {\n+                                                                                                        throw new AngelException(\"Vector type is not support!\");\n+                                                                                                      }\n     }\n-  }\n \n-  private static double apply(IntDummyVector v1, IntDummyVector v2) {\n+    private static double apply(IntDummyVector v1, IntDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     int[] keys1 = v1.getIndices();\n     int[] keys2 = v2.getIndices();\n     int v1Pointor = 0;\n     int v2Pointor = 0;\n-\n     while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n-      if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n         dot += 1.0;\n         v2Pointor++;\n         v1Pointor++;\n-      } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-        v2Pointor++;\n-      } else {\n-        v1Pointor++;\n-      }\n+        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                     v2Pointor++;\n+        } else {\n+          v1Pointor++;\n+        }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(IntDoubleVector v1, IntDummyVector v2) {\n+    private static double apply(IntDoubleVector v1, IntDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     int[] idxs = v2.getIndices();\n     if (v1.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+        double[] v1Values = v1.getStorage().getValues();\n+        int size = v2.size();\n+        for (int i = 0; i < size; i++) {\n+                          dot += v1Values[idxs[i]];\n         }\n+    } else if (v1.isSparse()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Int2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+               }\n       } else {\n         int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n+                 dot += v1.get(idxs[i]);\n         }\n       }\n     } else {\n       int[] keys1 = v1.getStorage().getIndices();\n       double[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(IntDoubleVector v1, IntDoubleVector v2) {\n+    private static double apply(IntDoubleVector v1, IntDoubleVector v2) {\n     double dot = 0.0;\n     if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n+        double[] v1Values = v1.getStorage().getValues();\n+        double[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n+        }\n     } else if (v1.isDense() && v2.isSparse()) {\n       double[] v1Values = v1.getStorage().getValues();\n       ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v1Values[entry.getIntKey()];\n+                                                  Int2DoubleMap.Entry entry = iter.next();\n+                                                  dot += entry.getDoubleValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n       double[] v1Values = v1.getStorage().getValues();\n@@ -191,1169 +187,1115 @@ public class SimpleDotExecutor {\n       double[] v2Values = v2.getStorage().getValues();\n       int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      double[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             double[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2DoubleMap.Entry entry = iter.next();\n+                                                         dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             double[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2DoubleMap.Entry entry = iter.next();\n+                                                   dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2DoubleMap.Entry entry = iter.next();\n+                               dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      double[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           double[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           double[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntDoubleVector v1, IntFloatVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+        double[] v1Values = v1.getStorage().getValues();\n+        float[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n+        }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      double[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+                                                  Int2FloatMap.Entry entry = iter.next();\n+                                                  dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n       }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n+    } else if (v1.isDense() && v2.isSorted()) {\n       double[] v1Values = v1.getStorage().getValues();\n-      double[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n+      int[] keys = v2.getStorage().getIndices();\n+      float[] v2Values = v2.getStorage().getValues();\n+      int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             float[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2DoubleMap.Entry entry = iter.next();\n+                                                         dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2DoubleMap.Entry entry = iter.next();\n+                                                   dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      float[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2FloatMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           double[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           float[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntDoubleVector v1, IntLongVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+        double[] v1Values = v1.getStorage().getValues();\n+        long[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n         }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      double[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+                                                  Int2LongMap.Entry entry = iter.next();\n+                                                  dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n       }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+    } else if (v1.isDense() && v2.isSorted()) {\n+      double[] v1Values = v1.getStorage().getValues();\n+      int[] keys = v2.getStorage().getIndices();\n+      long[] v2Values = v2.getStorage().getValues();\n+      int size = v2.size();\n+      for (int i = 0; i < size; i++) {\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             long[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2DoubleMap.Entry entry = iter.next();\n+                                                         dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2DoubleMap.Entry entry = iter.next();\n+                                                   dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      long[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2LongMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           double[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           long[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntDoubleVector v1, IntIntVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+        double[] v1Values = v1.getStorage().getValues();\n+        int[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n         }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        double[] v2Values = v2.getStorage().getValues();\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      double[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+                                                  Int2IntMap.Entry entry = iter.next();\n+                                                  dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+      }\n+    } else if (v1.isDense() && v2.isSorted()) {\n+      double[] v1Values = v1.getStorage().getValues();\n+      int[] keys = v2.getStorage().getIndices();\n+      int[] v2Values = v2.getStorage().getValues();\n+      int size = v2.size();\n+      for (int i = 0; i < size; i++) {\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2DoubleMap.Entry entry = iter.next();\n+                                                         dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2DoubleMap.Entry entry = iter.next();\n+                                                   dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      int[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2IntMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             double[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           double[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           int[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntFloatVector v1, IntDummyVector v2) {\n+    assert v1.getDim() == v2.getDim();\n+    double dot = 0.0;\n+    int[] idxs = v2.getIndices();\n+    if (v1.isDense()) {\n+        float[] v1Values = v1.getStorage().getValues();\n         int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getIntKey());\n+                          dot += v1Values[idxs[i]];\n         }\n+    } else if (v1.isSparse()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Int2FloatMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+               }\n       } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n+        int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n+                 dot += v1.get(idxs[i]);\n         }\n       }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n+    } else {\n       int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-\n+      float[] v1Values = v1.getStorage().getValues();\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+          dot += v1Values[v1Pointor];\n           v2Pointor++;\n-        } else {\n           v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n     }\n-\n     return dot;\n-  }\n+    }\n \n-  private static double apply(IntDoubleVector v1, IntFloatVector v2) {\n+    private static double apply(IntFloatVector v1, IntFloatVector v2) {\n     double dot = 0.0;\n     if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n+        float[] v1Values = v1.getStorage().getValues();\n+        float[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n+        }\n     } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n+      float[] v1Values = v1.getStorage().getValues();\n       ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n+                                                  Int2FloatMap.Entry entry = iter.next();\n+                                                  dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n+      float[] v1Values = v1.getStorage().getValues();\n       int[] keys = v2.getStorage().getIndices();\n       float[] v2Values = v2.getStorage().getValues();\n       int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      float[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             float[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2FloatMap.Entry entry = iter.next();\n+                                                         dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2FloatMap.Entry entry = iter.next();\n+                                                   dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2FloatMap.Entry entry = iter.next();\n+                               dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2FloatMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      float[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2FloatMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             float[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           float[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           float[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntFloatVector v1, IntLongVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+        float[] v1Values = v1.getStorage().getValues();\n+        long[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n+        }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n+                                                  Int2LongMap.Entry entry = iter.next();\n+                                                  dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n       }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n+    } else if (v1.isDense() && v2.isSorted()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      int[] keys = v2.getStorage().getIndices();\n+      long[] v2Values = v2.getStorage().getValues();\n+      int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             long[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2FloatMap.Entry entry = iter.next();\n+                                                         dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2FloatMap.Entry entry = iter.next();\n+                                                   dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2FloatMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      long[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2LongMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             float[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           float[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           long[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntFloatVector v1, IntIntVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+        float[] v1Values = v1.getStorage().getValues();\n+        int[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n         }\n+    } else if (v1.isDense() && v2.isSparse()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+                                                  Int2IntMap.Entry entry = iter.next();\n+                                                  dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n       }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n+    } else if (v1.isDense() && v2.isSorted()) {\n+      float[] v1Values = v1.getStorage().getValues();\n+      int[] keys = v2.getStorage().getIndices();\n+      int[] v2Values = v2.getStorage().getValues();\n+      int size = v2.size();\n+      for (int i = 0; i < size; i++) {\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2FloatMap.Entry entry = iter.next();\n+                                                         dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2FloatMap.Entry entry = iter.next();\n+                                                   dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2FloatMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      int[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2IntMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             float[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           float[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           int[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntLongVector v1, IntDummyVector v2) {\n+    assert v1.getDim() == v2.getDim();\n+    double dot = 0.0;\n+    int[] idxs = v2.getIndices();\n+    if (v1.isDense()) {\n+        long[] v1Values = v1.getStorage().getValues();\n         int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n+                          dot += v1Values[idxs[i]];\n         }\n+    } else if (v1.isSparse()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Int2LongMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+               }\n       } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n+        int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n+                 dot += v1.get(idxs[i]);\n         }\n       }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n+    } else {\n       int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n+      long[] v1Values = v1.getStorage().getValues();\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+          dot += v1Values[v1Pointor];\n           v2Pointor++;\n-        } else {\n           v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n     }\n-\n     return dot;\n-  }\n+    }\n \n-  private static double apply(IntDoubleVector v1, IntLongVector v2) {\n+    private static double apply(IntLongVector v1, IntLongVector v2) {\n     double dot = 0.0;\n     if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n+        long[] v1Values = v1.getStorage().getValues();\n+        long[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n+        }\n     } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n+      long[] v1Values = v1.getStorage().getValues();\n       ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n+                                                  Int2LongMap.Entry entry = iter.next();\n+                                                  dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n+      long[] v1Values = v1.getStorage().getValues();\n       int[] keys = v2.getStorage().getIndices();\n       long[] v2Values = v2.getStorage().getValues();\n       int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             long[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2LongMap.Entry entry = iter.next();\n+                                                         dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             long[] v1Values = v1.getStorage().getValues();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2LongMap.Entry entry = iter.next();\n+                                                   dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2LongMap.Entry entry = iter.next();\n+                               dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2LongMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      long[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2LongMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getLongValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             long[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           long[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           long[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n+    return dot;\n+    }\n+\n+    private static double apply(IntLongVector v1, IntIntVector v2) {\n+    double dot = 0.0;\n+    if (v1.isDense() && v2.isDense()) {\n+        long[] v1Values = v1.getStorage().getValues();\n+        int[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n         }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntDoubleVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2DoubleMap.Entry entry = iter.next();\n-        dot += entry.getDoubleValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    }\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntFloatVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      float[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      float[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        float[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntFloatVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2FloatMap.Entry entry = iter.next();\n-        dot += entry.getFloatValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        float[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntDummyVector v2) {\n-    assert v1.getDim() == v2.getDim();\n-    double dot = 0.0;\n-    int[] idxs = v2.getIndices();\n-    if (v1.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n-        }\n-      }\n-    } else {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n-          dot += v1Values[v1Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    }\n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntLongVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n-    } else if (v1.isDense() && v2.isSparse()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      long[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        long[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n-    return dot;\n-  }\n-\n-  private static double apply(IntLongVector v1, IntIntVector v2) {\n-    double dot = 0.0;\n-    if (v1.isDense() && v2.isDense()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n     } else if (v1.isDense() && v2.isSparse()) {\n       long[] v1Values = v1.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isDense() && v2.isSorted()) {\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2LongMap.Entry entry = iter.next();\n-        dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        long[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+      while (iter.hasNext()) {\n+                                                  Int2IntMap.Entry entry = iter.next();\n+                                                  dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+    } else if (v1.isDense() && v2.isSorted()) {\n+      long[] v1Values = v1.getStorage().getValues();\n+      int[] keys = v2.getStorage().getIndices();\n+      int[] v2Values = v2.getStorage().getValues();\n+      int size = v2.size();\n+      for (int i = 0; i < size; i++) {\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2LongMap.Entry entry = iter.next();\n+                                                         dot += entry.getLongValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             long[] v1Values = v1.getStorage().getValues();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2LongMap.Entry entry = iter.next();\n+                                                   dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2LongMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getLongValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      int[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2IntMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             long[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           long[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           int[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(IntIntVector v1, IntDummyVector v2) {\n+    private static double apply(IntIntVector v1, IntDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     int[] idxs = v2.getIndices();\n     if (v1.isDense()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      int size = v2.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[idxs[i]];\n-      }\n-    } else if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+        int[] v1Values = v1.getStorage().getValues();\n+        int size = v2.size();\n+        for (int i = 0; i < size; i++) {\n+                          dot += v1Values[idxs[i]];\n         }\n+    } else if (v1.isSparse()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Int2IntMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+               }\n       } else {\n         int size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n+                 dot += v1.get(idxs[i]);\n         }\n       }\n     } else {\n       int[] keys1 = v1.getStorage().getIndices();\n       int[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       int size1 = v1.size();\n       int size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(IntIntVector v1, IntIntVector v2) {\n+    private static double apply(IntIntVector v1, IntIntVector v2) {\n     double dot = 0.0;\n     if (v1.isDense() && v2.isDense()) {\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int length = v1Values.length;\n-      for (int i = 0; i < length; i++) {\n-        dot += v1Values[i] * v2Values[i];\n-      }\n+        int[] v1Values = v1.getStorage().getValues();\n+        int[] v2Values = v2.getStorage().getValues();\n+        int length = v1Values.length;\n+        for (int i = 0; i < length; i++) {\n+                                          dot += v1Values[i] * v2Values[i];\n+        }\n     } else if (v1.isDense() && v2.isSparse()) {\n       int[] v1Values = v1.getStorage().getValues();\n       ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n       while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n+                                                  Int2IntMap.Entry entry = iter.next();\n+                                                  dot += entry.getIntValue() * v1Values[entry.getIntKey()];\n       }\n     } else if (v1.isDense() && v2.isSorted()) {\n       int[] v1Values = v1.getStorage().getValues();\n@@ -1361,1056 +1303,988 @@ public class SimpleDotExecutor {\n       int[] v2Values = v2.getStorage().getValues();\n       int size = v2.size();\n       for (int i = 0; i < size; i++) {\n-        dot += v2Values[i] * v1Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isDense()) {\n-      int[] v2Values = v2.getStorage().getValues();\n-      ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-      while (iter.hasNext()) {\n-        Int2IntMap.Entry entry = iter.next();\n-        dot += entry.getIntValue() * v2Values[entry.getIntKey()];\n-      }\n-    } else if (v1.isSorted() && v2.isDense()) {\n-      int[] keys = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] v2Values = v2.getStorage().getValues();\n-      int size = v1.size();\n-      for (int i = 0; i < size; i++) {\n-        dot += v1Values[i] * v2Values[keys[i]];\n-      }\n-    } else if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        int size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Int2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getIntKey());\n-        }\n-      } else {\n-        int[] keys = v1.getStorage().getIndices();\n-        int[] v1Values = v1.getStorage().getValues();\n-        int size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      int[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      int[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      int size1 = v1.size();\n-      int size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                                                  dot += v2Values[i] * v1Values[keys[i]];\n+      }\n+           } else if (v1.isSparse() && v2.isDense()) {\n+             int[] v2Values = v2.getStorage().getValues();\n+             ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+             while (iter.hasNext()) {\n+                                                         Int2IntMap.Entry entry = iter.next();\n+                                                         dot += entry.getIntValue() * v2Values[entry.getIntKey()];\n+             }\n+           } else if (v1.isSorted() && v2.isDense()) {\n+             int[] keys = v1.getStorage().getIndices();\n+             int[] v1Values = v1.getStorage().getValues();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int size = v1.size();\n+             for (int i = 0; i < size; i++) {\n+                                                         dot += v1Values[i] * v2Values[keys[i]];\n+             }\n+                  } else if (v1.isSparse() && v2.isSparse()) {\n+                    if (v1.size() < v2.size()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                   Int2IntMap.Entry entry = iter.next();\n+                                                   dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                      while (iter.hasNext()) {\n+                               Int2IntMap.Entry entry = iter.next();\n+                               dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                      }\n+                    }\n+                  } else if (v1.isSparse() && v2.isSorted()) {\n+                    if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+                             ObjectIterator<Int2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+                             while (iter.hasNext()) {\n+                                                                                                                                              Int2IntMap.Entry entry = iter.next();\n+                                                                                                                                              dot += entry.getIntValue() * v2.get(entry.getIntKey());\n+                             }\n+                    } else {\n+                      int[] keys = v2.getStorage().getIndices();\n+                      int[] v2Values = v2.getStorage().getValues();\n+                      int size = v2.size();\n+                      for (int i = 0; i < size; i++) {\n+                               dot += v2Values[i] * v1.get(keys[i]);\n+                      }\n+                    }\n+                         } else if (v1.isSorted() && v2.isSparse()) {\n+                           if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+                                    ObjectIterator<Int2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+                                    while (iter.hasNext()) {\n+                                                                                                                                                     Int2IntMap.Entry entry = iter.next();\n+                                                                                                                                                     dot += entry.getIntValue() * v1.get(entry.getIntKey());\n+                                    }\n+                           } else {\n+                             int[] keys = v1.getStorage().getIndices();\n+                             int[] v1Values = v1.getStorage().getValues();\n+                             int size = v1.size();\n+                             for (int i = 0; i < size; i++) {\n+                                      dot += v1Values[i] * v2.get(keys[i]);\n+                             }\n+                           }\n+                         } else if (v1.isSorted() && v2.isSorted()) {\n+                           int[] keys1 = v1.getStorage().getIndices();\n+                           int[] v1Values = v1.getStorage().getValues();\n+                           int[] keys2 = v2.getStorage().getIndices();\n+                           int[] v2Values = v2.getStorage().getValues();\n+                           int v1Pointor = 0;\n+                           int v2Pointor = 0;\n+                           int size1 = v1.size();\n+                           int size2 = v2.size();\n+                           while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                                        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                               dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                               v2Pointor++;\n+                               v1Pointor++;\n+                                                                        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                              v2Pointor++;\n+                                                                        } else {\n+                                                                          v1Pointor++;\n+                                                                        }\n+                           }\n+                                } else {\n+                                  throw new AngelException(\"the operation is not support!\");\n+                                }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongDummyVector v1, LongDummyVector v2) {\n+    private static double apply(LongDummyVector v1, LongDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     long[] keys1 = v1.getIndices();\n     long[] keys2 = v2.getIndices();\n     int v1Pointor = 0;\n     int v2Pointor = 0;\n-\n     while (v1Pointor < keys1.length && v2Pointor < keys2.length) {\n-      if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n         dot += 1.0;\n         v2Pointor++;\n         v1Pointor++;\n-      } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-        v2Pointor++;\n-      } else {\n-        v1Pointor++;\n-      }\n+        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                     v2Pointor++;\n+        } else {\n+          v1Pointor++;\n+        }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongDoubleVector v1, LongDummyVector v2) {\n+    private static double apply(LongDoubleVector v1, LongDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+        if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                                                                                                                                  Long2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                  dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n+        } else {\n+          long size = v2.size();\n+          for (int i = 0; i < size; i++) {\n+                   dot += v1.get(idxs[i]);\n+          }\n         }\n-      }\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       double[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongDoubleVector v1, LongDoubleVector v2) {\n+    private static double apply(LongDoubleVector v1, LongDoubleVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                                       Long2DoubleMap.Entry entry = iter.next();\n+                                       dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2DoubleMap.Entry entry = iter.next();\n+                   dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         double[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2DoubleMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getDoubleValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         double[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      double[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             double[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongDoubleVector v1, LongFloatVector v2) {\n+    private static double apply(LongDoubleVector v1, LongFloatVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                                       Long2DoubleMap.Entry entry = iter.next();\n+                                       dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2FloatMap.Entry entry = iter.next();\n+                   dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         float[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2FloatMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         double[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongDoubleVector v1, LongLongVector v2) {\n+    private static double apply(LongDoubleVector v1, LongLongVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+                                       Long2DoubleMap.Entry entry = iter.next();\n+                                       dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2LongMap.Entry entry = iter.next();\n+                   dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         long[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2LongMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         double[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongDoubleVector v1, LongIntVector v2) {\n+    private static double apply(LongDoubleVector v1, LongIntVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n-        ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n-      }\n-    } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2DoubleMap.Entry entry = iter.next();\n-          dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n-        }\n-      } else {\n-        long[] keys = v2.getStorage().getIndices();\n-        int[] v2Values = v2.getStorage().getValues();\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+                                       Long2DoubleMap.Entry entry = iter.next();\n+                                       dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        long[] keys = v1.getStorage().getIndices();\n-        double[] v1Values = v1.getStorage().getValues();\n-        long size = v1.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      double[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n         } else {\n-          v1Pointor++;\n+          ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2IntMap.Entry entry = iter.next();\n+                   dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+          }\n+        }\n+    } else if (v1.isSparse() && v2.isSorted()) {\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2DoubleMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2DoubleMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getDoubleValue() * v2.get(entry.getLongKey());\n+               }\n+      } else {\n+        long[] keys = v2.getStorage().getIndices();\n+        int[] v2Values = v2.getStorage().getValues();\n+        long size = v2.size();\n+        for (int i = 0; i < size; i++) {\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+    } else if (v1.isSorted() && v2.isSparse()) {\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2IntMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n+      } else {\n+        long[] keys = v1.getStorage().getIndices();\n+        double[] v1Values = v1.getStorage().getValues();\n+        long size = v1.size();\n+        for (int i = 0; i < size; i++) {\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             double[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongFloatVector v1, LongDummyVector v2) {\n+    private static double apply(LongFloatVector v1, LongDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+        if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                                                                                                                                  Long2FloatMap.Entry entry = iter.next();\n+                                                                                                                                  dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n+        } else {\n+          long size = v2.size();\n+          for (int i = 0; i < size; i++) {\n+                   dot += v1.get(idxs[i]);\n+          }\n         }\n-      }\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       float[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongFloatVector v1, LongFloatVector v2) {\n+    private static double apply(LongFloatVector v1, LongFloatVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                                       Long2FloatMap.Entry entry = iter.next();\n+                                       dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2FloatMap.Entry entry = iter.next();\n+                   dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2FloatMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         float[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2FloatMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getFloatValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         float[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      float[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             float[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongFloatVector v1, LongLongVector v2) {\n+    private static double apply(LongFloatVector v1, LongLongVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                                       Long2FloatMap.Entry entry = iter.next();\n+                                       dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2LongMap.Entry entry = iter.next();\n+                   dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2FloatMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         long[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2LongMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         float[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongFloatVector v1, LongIntVector v2) {\n+    private static double apply(LongFloatVector v1, LongIntVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+                                       Long2FloatMap.Entry entry = iter.next();\n+                                       dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2IntMap.Entry entry = iter.next();\n+                   dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2FloatMap.Entry entry = iter.next();\n-          dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2FloatMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2FloatMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getFloatValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         int[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2IntMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         float[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      float[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             float[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongLongVector v1, LongDummyVector v2) {\n+    private static double apply(LongLongVector v1, LongDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+        if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                                                                                                                                  Long2LongMap.Entry entry = iter.next();\n+                                                                                                                                  dot += entry.getLongValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n+        } else {\n+          long size = v2.size();\n+          for (int i = 0; i < size; i++) {\n+                   dot += v1.get(idxs[i]);\n+          }\n         }\n-      }\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       long[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongLongVector v1, LongLongVector v2) {\n+    private static double apply(LongLongVector v1, LongLongVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                                       Long2LongMap.Entry entry = iter.next();\n+                                       dot += entry.getLongValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2LongMap.Entry entry = iter.next();\n+                   dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2LongMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         long[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2LongMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getLongValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         long[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      long[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             long[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             long[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongLongVector v1, LongIntVector v2) {\n+    private static double apply(LongLongVector v1, LongIntVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+                                       Long2LongMap.Entry entry = iter.next();\n+                                       dot += entry.getLongValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2IntMap.Entry entry = iter.next();\n+                   dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2LongMap.Entry entry = iter.next();\n-          dot += entry.getLongValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2LongMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2LongMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getLongValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         int[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2IntMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         long[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      long[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             long[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongIntVector v1, LongDummyVector v2) {\n+    private static double apply(LongIntVector v1, LongDummyVector v2) {\n     assert v1.getDim() == v2.getDim();\n     double dot = 0.0;\n     long[] idxs = v2.getIndices();\n     if (v1.isSparse()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+        if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n         ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getLongKey());\n+                                                                                                                                  Long2IntMap.Entry entry = iter.next();\n+                                                                                                                                  dot += entry.getIntValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        long size = v2.size();\n-        for (int i = 0; i < size; i++) {\n-          dot += v1.get(idxs[i]);\n+        } else {\n+          long size = v2.size();\n+          for (int i = 0; i < size; i++) {\n+                   dot += v1.get(idxs[i]);\n+          }\n         }\n-      }\n     } else {\n       long[] keys1 = v1.getStorage().getIndices();\n       int[] v1Values = v1.getStorage().getValues();\n-\n       int v1Pointor = 0;\n       int v2Pointor = 0;\n       long size1 = v1.size();\n       long size2 = v2.size();\n-\n       while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == idxs[v2Pointor]) {\n+               if (keys1[v1Pointor] == idxs[v2Pointor]) {\n           dot += v1Values[v1Pointor];\n           v2Pointor++;\n           v1Pointor++;\n-        } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n+               } else if (keys1[v1Pointor] > idxs[v2Pointor]) {\n+                                                         v2Pointor++;\n+               } else {\n+                 v1Pointor++;\n+               }\n       }\n     }\n     return dot;\n-  }\n+    }\n \n-  private static double apply(LongIntVector v1, LongIntVector v2) {\n+    private static double apply(LongIntVector v1, LongIntVector v2) {\n     double dot = 0.0;\n     if (v1.isSparse() && v2.isSparse()) {\n-      if (v1.size() < v2.size()) {\n+        if (v1.size() < v2.size()) {\n         ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n         while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getLongKey());\n+                                       Long2IntMap.Entry entry = iter.next();\n+                                       dot += entry.getIntValue() * v2.get(entry.getLongKey());\n         }\n-      } else {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+        } else {\n+          ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+          while (iter.hasNext()) {\n+                   Long2IntMap.Entry entry = iter.next();\n+                   dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+          }\n         }\n-      }\n     } else if (v1.isSparse() && v2.isSorted()) {\n-      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold\n-          && v2.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v2.get(entry.getLongKey());\n-        }\n+      if (v1.size() < v2.size() * Constant.sparseSortedStorageThreshold && v2.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v1.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2IntMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getIntValue() * v2.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v2.getStorage().getIndices();\n         int[] v2Values = v2.getStorage().getValues();\n         long size = v2.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v2Values[i] * v1.get(keys[i]);\n+                 dot += v2Values[i] * v1.get(keys[i]);\n         }\n       }\n     } else if (v1.isSorted() && v2.isSparse()) {\n-      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size()\n-          && v1.size() > Constant.sortedThreshold * v1.dim()) {\n-        ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n-        while (iter.hasNext()) {\n-          Long2IntMap.Entry entry = iter.next();\n-          dot += entry.getIntValue() * v1.get(entry.getLongKey());\n-        }\n+      if (v1.size() * Constant.sparseSortedStorageThreshold > v2.size() && v1.size() > Constant.sortedThreshold * v1.dim()) {\n+               ObjectIterator<Long2IntMap.Entry> iter = v2.getStorage().entryIterator();\n+               while (iter.hasNext()) {\n+                                                                                                                                Long2IntMap.Entry entry = iter.next();\n+                                                                                                                                dot += entry.getIntValue() * v1.get(entry.getLongKey());\n+               }\n       } else {\n         long[] keys = v1.getStorage().getIndices();\n         int[] v1Values = v1.getStorage().getValues();\n         long size = v1.size();\n         for (int i = 0; i < size; i++) {\n-          dot += v1Values[i] * v2.get(keys[i]);\n-        }\n-      }\n-    } else if (v1.isSorted() && v2.isSorted()) {\n-      long[] keys1 = v1.getStorage().getIndices();\n-      int[] v1Values = v1.getStorage().getValues();\n-      long[] keys2 = v2.getStorage().getIndices();\n-      int[] v2Values = v2.getStorage().getValues();\n-\n-      int v1Pointor = 0;\n-      int v2Pointor = 0;\n-      long size1 = v1.size();\n-      long size2 = v2.size();\n-\n-      while (v1Pointor < size1 && v2Pointor < size2) {\n-        if (keys1[v1Pointor] == keys2[v2Pointor]) {\n-          dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n-          v2Pointor++;\n-          v1Pointor++;\n-        } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n-          v2Pointor++;\n-        } else {\n-          v1Pointor++;\n-        }\n-      }\n-    } else {\n-      throw new AngelException(\"the operation is not support!\");\n-    }\n-\n+                 dot += v1Values[i] * v2.get(keys[i]);\n+        }\n+      }\n+           } else if (v1.isSorted() && v2.isSorted()) {\n+             long[] keys1 = v1.getStorage().getIndices();\n+             int[] v1Values = v1.getStorage().getValues();\n+             long[] keys2 = v2.getStorage().getIndices();\n+             int[] v2Values = v2.getStorage().getValues();\n+             int v1Pointor = 0;\n+             int v2Pointor = 0;\n+             long size1 = v1.size();\n+             long size2 = v2.size();\n+             while (v1Pointor < size1 && v2Pointor < size2) {\n+                                                          if (keys1[v1Pointor] == keys2[v2Pointor]) {\n+                 dot += v1Values[v1Pointor] * v2Values[v2Pointor];\n+                 v2Pointor++;\n+                 v1Pointor++;\n+                                                          } else if (keys1[v1Pointor] > keys2[v2Pointor]) {\n+                                                                v2Pointor++;\n+                                                          } else {\n+                                                            v1Pointor++;\n+                                                          }\n+             }\n+           } else {\n+             throw new AngelException(\"the operation is not support!\");\n+           }\n     return dot;\n-  }\n+    }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2780
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/571/SimpleDotExecutor.java\nindex c17d34f942..1d81fb3a0f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/571/SimpleDotExecutor.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/styler_three_grams/571/SimpleDotExecutor.java\n@@ -15,7 +15,6 @@\n  *\n  */\n \n-\n package com.tencent.angel.ml.math2.ufuncs.executor.simple;\n \n import com.tencent.angel.exception.AngelException;\n",
            "diff_size": 1
        }
    ]
}