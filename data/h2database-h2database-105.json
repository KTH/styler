{
    "error_id": "105",
    "information": {
        "errors": [
            {
                "line": "162",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                        newModified = true;\n                    } else if (dependentTable.getSchema() != this) {\n                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n                                obj.getTraceSQL(), dependentTable.getTraceSQL());\n                    } else if (!modified) {\n                        dependentTable.removeColumnExpressionsDependencies(session);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "161",
                    "column": "68",
                    "severity": "warning",
                    "message": "'{' at column 68 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "161",
                    "column": "68",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "162",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/105/Schema.java\nindex 242e4f750f..845beb70c5 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/105/Schema.java\n@@ -158,151 +158,151 @@ public class Schema extends DbObjectBase {\n                     if (dependentTable == null) {\n                         database.removeSchemaObject(session, obj);\n                         newModified = true;\n-                    } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getTraceSQL(), dependentTable.getTraceSQL());\n-                    } else if (!modified) {\n-                        dependentTable.removeColumnExpressionsDependencies(session);\n-                        dependentTable.setModified();\n-                        database.updateMeta(session, dependentTable);\n-                    }\n-                }\n-            }\n-            modified = newModified;\n-        }\n-        removeChildrenFromMap(session, domains);\n-        removeChildrenFromMap(session, indexes);\n-        removeChildrenFromMap(session, sequences);\n-        removeChildrenFromMap(session, constants);\n-        removeChildrenFromMap(session, functions);\n-        for (Right right : database.getAllRights()) {\n-            if (right.getGrantedObject() == this) {\n-                database.removeDatabaseObject(session, right);\n-            }\n-        }\n-        database.removeMeta(session, getId());\n-        owner = null;\n-        invalidate();\n-    }\n-\n-    private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n-        if (!map.isEmpty()) {\n-            for (SchemaObject obj : map.values()) {\n-                // Database.removeSchemaObject() removes the object from\n-                // the map too, but it is safe for ConcurrentHashMap.\n-                database.removeSchemaObject(session, obj);\n-            }\n-        }\n-    }\n-\n-    /**\n+                    } else if (dependentTable.getSchema() != this) {throw\n+                            DbException.get(ErrorCode.CANNOT_DROP_2, //\n+                             obj.getTraceSQL(), dependentTable.getTraceSQL());\n+                 } else if (!modified) {\n+                     dependentTable.removeColumnExpressionsDependencies(session);\n+                     dependentTable.setModified();\n+                     database.updateMeta(session, dependentTable);\n+                 }\n+             }\n+         }\n+         modified = newModified;\n+     }\n+     removeChildrenFromMap(session, domains);\n+     removeChildrenFromMap(session, indexes);\n+     removeChildrenFromMap(session, sequences);\n+     removeChildrenFromMap(session, constants);\n+     removeChildrenFromMap(session, functions);\n+     for (Right right : database.getAllRights()) {\n+         if (right.getGrantedObject() == this) {\n+             database.removeDatabaseObject(session, right);\n+         }\n+     }\n+     database.removeMeta(session, getId());\n+     owner = null;\n+     invalidate();\n+ }\n+\n+ private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n+     if (!map.isEmpty()) {\n+         for (SchemaObject obj : map.values()) {\n+             // Database.removeSchemaObject() removes the object from\n+             // the map too, but it is safe for ConcurrentHashMap.\n+             database.removeSchemaObject(session, obj);\n+         }\n+     }\n+ }\n+\n+ /**\n      * Get the owner of this schema.\n      *\n      * @return the owner\n      */\n-    public User getOwner() {\n-        return owner;\n-    }\n+ public User getOwner() {\n+     return owner;\n+ }\n \n-    /**\n+ /**\n      * Get table engine params of this schema.\n      *\n      * @return default table engine params\n      */\n-    public ArrayList<String> getTableEngineParams() {\n-        return tableEngineParams;\n-    }\n+ public ArrayList<String> getTableEngineParams() {\n+     return tableEngineParams;\n+ }\n \n-    /**\n+ /**\n      * Set table engine params of this schema.\n      * @param tableEngineParams default table engine params\n      */\n-    public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n-        this.tableEngineParams = tableEngineParams;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String, SchemaObject> getMap(int type) {\n-        Map<String, ? extends SchemaObject> result;\n-        switch (type) {\n-        case DbObject.TABLE_OR_VIEW:\n-            result = tablesAndViews;\n-            break;\n-        case DbObject.DOMAIN:\n-            result = domains;\n-            break;\n-        case DbObject.SYNONYM:\n-            result = synonyms;\n-            break;\n-        case DbObject.SEQUENCE:\n-            result = sequences;\n-            break;\n-        case DbObject.INDEX:\n-            result = indexes;\n-            break;\n-        case DbObject.TRIGGER:\n-            result = triggers;\n-            break;\n-        case DbObject.CONSTRAINT:\n-            result = constraints;\n-            break;\n-        case DbObject.CONSTANT:\n-            result = constants;\n-            break;\n-        case DbObject.FUNCTION_ALIAS:\n-            result = functions;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        return (Map<String, SchemaObject>) result;\n-    }\n-\n-    /**\n+ public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n+     this.tableEngineParams = tableEngineParams;\n+ }\n+\n+ @SuppressWarnings(\"unchecked\")\n+ private Map<String, SchemaObject> getMap(int type) {\n+     Map<String, ? extends SchemaObject> result;\n+     switch (type) {\n+     case DbObject.TABLE_OR_VIEW:\n+         result = tablesAndViews;\n+         break;\n+     case DbObject.DOMAIN:\n+         result = domains;\n+         break;\n+     case DbObject.SYNONYM:\n+         result = synonyms;\n+         break;\n+     case DbObject.SEQUENCE:\n+         result = sequences;\n+         break;\n+     case DbObject.INDEX:\n+         result = indexes;\n+         break;\n+     case DbObject.TRIGGER:\n+         result = triggers;\n+         break;\n+     case DbObject.CONSTRAINT:\n+         result = constraints;\n+         break;\n+     case DbObject.CONSTANT:\n+         result = constants;\n+         break;\n+     case DbObject.FUNCTION_ALIAS:\n+         result = functions;\n+         break;\n+     default:\n+         throw DbException.throwInternalError(\"type=\" + type);\n+     }\n+     return (Map<String, SchemaObject>) result;\n+ }\n+\n+ /**\n      * Add an object to this schema.\n      * This method must not be called within CreateSchemaObject;\n      * use Database.addSchemaObject() instead\n      *\n      * @param obj the object to add\n      */\n-    public void add(SchemaObject obj) {\n-        if (obj.getSchema() != this) {\n-            DbException.throwInternalError(\"wrong schema\");\n-        }\n-        String name = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.putIfAbsent(name, obj) != null) {\n-            DbException.throwInternalError(\"object already exists: \" + name);\n-        }\n-        freeUniqueName(name);\n-    }\n-\n-    /**\n+ public void add(SchemaObject obj) {\n+     if (obj.getSchema() != this) {\n+         DbException.throwInternalError(\"wrong schema\");\n+     }\n+     String name = obj.getName();\n+     Map<String, SchemaObject> map = getMap(obj.getType());\n+     if (map.putIfAbsent(name, obj) != null) {\n+         DbException.throwInternalError(\"object already exists: \" + name);\n+     }\n+     freeUniqueName(name);\n+ }\n+\n+ /**\n      * Rename an object.\n      *\n      * @param obj the object to rename\n      * @param newName the new name\n      */\n-    public void rename(SchemaObject obj, String newName) {\n-        int type = obj.getType();\n-        Map<String, SchemaObject> map = getMap(type);\n-        if (SysProperties.CHECK) {\n-            if (!map.containsKey(obj.getName())) {\n-                DbException.throwInternalError(\"not found: \" + obj.getName());\n-            }\n-            if (obj.getName().equals(newName) || map.containsKey(newName)) {\n-                DbException.throwInternalError(\"object already exists: \" + newName);\n-            }\n-        }\n-        obj.checkRename();\n-        map.remove(obj.getName());\n-        freeUniqueName(obj.getName());\n-        obj.rename(newName);\n-        map.put(newName, obj);\n-        freeUniqueName(newName);\n-    }\n-\n-    /**\n+ public void rename(SchemaObject obj, String newName) {\n+     int type = obj.getType();\n+     Map<String, SchemaObject> map = getMap(type);\n+     if (SysProperties.CHECK) {\n+         if (!map.containsKey(obj.getName())) {\n+             DbException.throwInternalError(\"not found: \" + obj.getName());\n+         }\n+         if (obj.getName().equals(newName) || map.containsKey(newName)) {\n+             DbException.throwInternalError(\"object already exists: \" + newName);\n+         }\n+     }\n+     obj.checkRename();\n+     map.remove(obj.getName());\n+     freeUniqueName(obj.getName());\n+     obj.rename(newName);\n+     map.put(newName, obj);\n+     freeUniqueName(newName);\n+ }\n+\n+ /**\n      * Try to find a table or view with this name. This method returns null if\n      * no object with this name exists. Local temporary tables are also\n      * returned. Synonyms are not returned or resolved.\n@@ -311,15 +311,15 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Table findTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null && session != null) {\n-            table = session.findLocalTempTable(name);\n-        }\n-        return table;\n-    }\n+ public Table findTableOrView(Session session, String name) {\n+     Table table = tablesAndViews.get(name);\n+     if (table == null && session != null) {\n+         table = session.findLocalTempTable(name);\n+     }\n+     return table;\n+ }\n \n-    /**\n+ /**\n      * Try to find a table or view with this name. This method returns null if\n      * no object with this name exists. Local temporary tables are also\n      * returned. If a synonym with this name exists, the backing table of the\n@@ -329,39 +329,39 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Table resolveTableOrView(Session session, String name) {\n-        Table table = findTableOrView(session, name);\n-        if (table == null) {\n-            TableSynonym synonym = synonyms.get(name);\n-            if (synonym != null) {\n-                return synonym.getSynonymFor();\n-            }\n-        }\n-        return table;\n-    }\n-\n-    /**\n+ public Table resolveTableOrView(Session session, String name) {\n+     Table table = findTableOrView(session, name);\n+     if (table == null) {\n+         TableSynonym synonym = synonyms.get(name);\n+         if (synonym != null) {\n+             return synonym.getSynonymFor();\n+         }\n+     }\n+     return table;\n+ }\n+\n+ /**\n      * Try to find a synonym with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param name the object name\n      * @return the object or null\n      */\n-    public TableSynonym getSynonym(String name) {\n-        return synonyms.get(name);\n-    }\n+ public TableSynonym getSynonym(String name) {\n+     return synonyms.get(name);\n+ }\n \n-    /**\n+ /**\n      * Get the domain if it exists, or null if not.\n      *\n      * @param name the name of the domain\n      * @return the domain or null\n      */\n-    public Domain findDomain(String name) {\n-        return domains.get(name);\n-    }\n+ public Domain findDomain(String name) {\n+     return domains.get(name);\n+ }\n \n-    /**\n+ /**\n      * Try to find an index with this name. This method returns null if\n      * no object with this name exists.\n      *\n@@ -369,37 +369,37 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Index findIndex(Session session, String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            index = session.findLocalTempTableIndex(name);\n-        }\n-        return index;\n-    }\n+ public Index findIndex(Session session, String name) {\n+     Index index = indexes.get(name);\n+     if (index == null) {\n+         index = session.findLocalTempTableIndex(name);\n+     }\n+     return index;\n+ }\n \n-    /**\n+ /**\n      * Try to find a trigger with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param name the object name\n      * @return the object or null\n      */\n-    public TriggerObject findTrigger(String name) {\n-        return triggers.get(name);\n-    }\n+ public TriggerObject findTrigger(String name) {\n+     return triggers.get(name);\n+ }\n \n-    /**\n+ /**\n      * Try to find a sequence with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param sequenceName the object name\n      * @return the object or null\n      */\n-    public Sequence findSequence(String sequenceName) {\n-        return sequences.get(sequenceName);\n-    }\n+ public Sequence findSequence(String sequenceName) {\n+     return sequences.get(sequenceName);\n+ }\n \n-    /**\n+ /**\n      * Try to find a constraint with this name. This method returns null if no\n      * object with this name exists.\n      *\n@@ -407,104 +407,104 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Constraint findConstraint(Session session, String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            constraint = session.findLocalTempTableConstraint(name);\n-        }\n-        return constraint;\n-    }\n+ public Constraint findConstraint(Session session, String name) {\n+     Constraint constraint = constraints.get(name);\n+     if (constraint == null) {\n+         constraint = session.findLocalTempTableConstraint(name);\n+     }\n+     return constraint;\n+ }\n \n-    /**\n+ /**\n      * Try to find a user defined constant with this name. This method returns\n      * null if no object with this name exists.\n      *\n      * @param constantName the object name\n      * @return the object or null\n      */\n-    public Constant findConstant(String constantName) {\n-        return constants.get(constantName);\n-    }\n+ public Constant findConstant(String constantName) {\n+     return constants.get(constantName);\n+ }\n \n-    /**\n+ /**\n      * Try to find a user defined function with this name. This method returns\n      * null if no object with this name exists.\n      *\n      * @param functionAlias the object name\n      * @return the object or null\n      */\n-    public FunctionAlias findFunction(String functionAlias) {\n-        return functions.get(functionAlias);\n-    }\n+ public FunctionAlias findFunction(String functionAlias) {\n+     return functions.get(functionAlias);\n+ }\n \n-    /**\n+ /**\n      * Release a unique object name.\n      *\n      * @param name the object name\n      */\n-    public void freeUniqueName(String name) {\n-        if (name != null) {\n-            synchronized (temporaryUniqueNames) {\n-                temporaryUniqueNames.remove(name);\n-            }\n-        }\n-    }\n-\n-    private String getUniqueName(DbObject obj,\n-            Map<String, ? extends SchemaObject> map, String prefix) {\n-        String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n-        String name = null;\n-        synchronized (temporaryUniqueNames) {\n-            for (int i = 1, len = hash.length(); i < len; i++) {\n-                name = prefix + hash.substring(0, i);\n-                if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                    break;\n-                }\n-                name = null;\n-            }\n-            if (name == null) {\n-                prefix = prefix + hash + \"_\";\n-                for (int i = 0;; i++) {\n-                    name = prefix + i;\n-                    if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                        break;\n-                    }\n-                }\n-            }\n-            temporaryUniqueNames.add(name);\n-        }\n-        return name;\n-    }\n-\n-    /**\n+ public void freeUniqueName(String name) {\n+     if (name != null) {\n+         synchronized (temporaryUniqueNames) {\n+             temporaryUniqueNames.remove(name);\n+         }\n+     }\n+ }\n+\n+ private String getUniqueName(DbObject obj,\n+         Map<String, ? extends SchemaObject> map, String prefix) {\n+     String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n+     String name = null;\n+     synchronized (temporaryUniqueNames) {\n+         for (int i = 1, len = hash.length(); i < len; i++) {\n+             name = prefix + hash.substring(0, i);\n+             if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+                 break;\n+             }\n+             name = null;\n+         }\n+         if (name == null) {\n+             prefix = prefix + hash + \"_\";\n+             for (int i = 0;; i++) {\n+                 name = prefix + i;\n+                 if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+                     break;\n+                 }\n+             }\n+         }\n+         temporaryUniqueNames.add(name);\n+     }\n+     return name;\n+ }\n+\n+ /**\n      * Create a unique constraint name.\n      *\n      * @param session the session\n      * @param table the constraint table\n      * @return the unique name\n      */\n-    public String getUniqueConstraintName(Session session, Table table) {\n-        Map<String, Constraint> tableConstraints;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableConstraints = session.getLocalTempTableConstraints();\n-        } else {\n-            tableConstraints = constraints;\n-        }\n-        return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n-    }\n-\n-    /**\n+ public String getUniqueConstraintName(Session session, Table table) {\n+     Map<String, Constraint> tableConstraints;\n+     if (table.isTemporary() && !table.isGlobalTemporary()) {\n+         tableConstraints = session.getLocalTempTableConstraints();\n+     } else {\n+         tableConstraints = constraints;\n+     }\n+     return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n+ }\n+\n+ /**\n      * Create a unique constraint name.\n      *\n      * @param session the session\n      * @param domain the constraint domain\n      * @return the unique name\n      */\n-    public String getUniqueDomainConstraintName(Session session, Domain domain) {\n-        return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n-    }\n+ public String getUniqueDomainConstraintName(Session session, Domain domain) {\n+     return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n+ }\n \n-    /**\n+ /**\n      * Create a unique index name.\n      *\n      * @param session the session\n@@ -512,17 +512,17 @@ public class Schema extends DbObjectBase {\n      * @param prefix the index name prefix\n      * @return the unique name\n      */\n-    public String getUniqueIndexName(Session session, Table table, String prefix) {\n-        Map<String, Index> tableIndexes;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableIndexes = session.getLocalTempTableIndexes();\n-        } else {\n-            tableIndexes = indexes;\n-        }\n-        return getUniqueName(table, tableIndexes, prefix);\n-    }\n-\n-    /**\n+ public String getUniqueIndexName(Session session, Table table, String prefix) {\n+     Map<String, Index> tableIndexes;\n+     if (table.isTemporary() && !table.isGlobalTemporary()) {\n+         tableIndexes = session.getLocalTempTableIndexes();\n+     } else {\n+         tableIndexes = indexes;\n+     }\n+     return getUniqueName(table, tableIndexes, prefix);\n+ }\n+\n+ /**\n      * Get the table or view with the given name.\n      * Local temporary tables are also returned.\n      *\n@@ -531,95 +531,95 @@ public class Schema extends DbObjectBase {\n      * @return the table or view\n      * @throws DbException if no such object exists\n      */\n-    public Table getTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null) {\n-            if (session != null) {\n-                table = session.findLocalTempTable(name);\n-            }\n-            if (table == null) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n-            }\n-        }\n-        return table;\n-    }\n-\n-    /**\n+ public Table getTableOrView(Session session, String name) {\n+     Table table = tablesAndViews.get(name);\n+     if (table == null) {\n+         if (session != null) {\n+             table = session.findLocalTempTable(name);\n+         }\n+         if (table == null) {\n+             throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n+         }\n+     }\n+     return table;\n+ }\n+\n+ /**\n      * Get the domain with the given name.\n      *\n      * @param name the domain name\n      * @return the domain\n      * @throws DbException if no such object exists\n      */\n-    public Domain getDomain(String name) {\n-        Domain domain = domains.get(name);\n-        if (domain == null) {\n-            throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n-        }\n-        return domain;\n-    }\n+ public Domain getDomain(String name) {\n+     Domain domain = domains.get(name);\n+     if (domain == null) {\n+         throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n+     }\n+     return domain;\n+ }\n \n-    /**\n+ /**\n      * Get the index with the given name.\n      *\n      * @param name the index name\n      * @return the index\n      * @throws DbException if no such object exists\n      */\n-    public Index getIndex(String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n-        }\n-        return index;\n-    }\n+ public Index getIndex(String name) {\n+     Index index = indexes.get(name);\n+     if (index == null) {\n+         throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n+     }\n+     return index;\n+ }\n \n-    /**\n+ /**\n      * Get the constraint with the given name.\n      *\n      * @param name the constraint name\n      * @return the constraint\n      * @throws DbException if no such object exists\n      */\n-    public Constraint getConstraint(String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n-        }\n-        return constraint;\n-    }\n+ public Constraint getConstraint(String name) {\n+     Constraint constraint = constraints.get(name);\n+     if (constraint == null) {\n+         throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n+     }\n+     return constraint;\n+ }\n \n-    /**\n+ /**\n      * Get the user defined constant with the given name.\n      *\n      * @param constantName the constant name\n      * @return the constant\n      * @throws DbException if no such object exists\n      */\n-    public Constant getConstant(String constantName) {\n-        Constant constant = constants.get(constantName);\n-        if (constant == null) {\n-            throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n-        }\n-        return constant;\n-    }\n+ public Constant getConstant(String constantName) {\n+     Constant constant = constants.get(constantName);\n+     if (constant == null) {\n+         throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n+     }\n+     return constant;\n+ }\n \n-    /**\n+ /**\n      * Get the sequence with the given name.\n      *\n      * @param sequenceName the sequence name\n      * @return the sequence\n      * @throws DbException if no such object exists\n      */\n-    public Sequence getSequence(String sequenceName) {\n-        Sequence sequence = sequences.get(sequenceName);\n-        if (sequence == null) {\n-            throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n-        }\n-        return sequence;\n-    }\n+ public Sequence getSequence(String sequenceName) {\n+     Sequence sequence = sequences.get(sequenceName);\n+     if (sequence == null) {\n+         throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n+     }\n+     return sequence;\n+ }\n \n-    /**\n+ /**\n      * Get all objects.\n      *\n      * @param addTo\n@@ -628,23 +628,23 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with all objects\n      */\n-    public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n-        if (addTo == null) {\n-            addTo = Utils.newSmallArrayList();\n-        }\n-        addTo.addAll(tablesAndViews.values());\n-        addTo.addAll(domains.values());\n-        addTo.addAll(synonyms.values());\n-        addTo.addAll(sequences.values());\n-        addTo.addAll(indexes.values());\n-        addTo.addAll(triggers.values());\n-        addTo.addAll(constraints.values());\n-        addTo.addAll(constants.values());\n-        addTo.addAll(functions.values());\n-        return addTo;\n-    }\n-\n-    /**\n+ public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n+     if (addTo == null) {\n+         addTo = Utils.newSmallArrayList();\n+     }\n+     addTo.addAll(tablesAndViews.values());\n+     addTo.addAll(domains.values());\n+     addTo.addAll(synonyms.values());\n+     addTo.addAll(sequences.values());\n+     addTo.addAll(indexes.values());\n+     addTo.addAll(triggers.values());\n+     addTo.addAll(constraints.values());\n+     addTo.addAll(constants.values());\n+     addTo.addAll(functions.values());\n+     return addTo;\n+ }\n+\n+ /**\n      * Get all objects of the given type.\n      *\n      * @param type\n@@ -655,103 +655,103 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with objects of the given type\n      */\n-    public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n-        Collection<SchemaObject> values = getMap(type).values();\n-        if (addTo != null) {\n-            addTo.addAll(values);\n-        } else {\n-            addTo = new ArrayList<>(values);\n-        }\n-        return addTo;\n-    }\n-\n-    /**\n+ public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n+     Collection<SchemaObject> values = getMap(type).values();\n+     if (addTo != null) {\n+         addTo.addAll(values);\n+     } else {\n+         addTo = new ArrayList<>(values);\n+     }\n+     return addTo;\n+ }\n+\n+ /**\n      * Get all tables and views.\n      *\n      * @return a (possible empty) list of all objects\n      */\n-    public Collection<Table> getAllTablesAndViews() {\n-        return tablesAndViews.values();\n-    }\n+ public Collection<Table> getAllTablesAndViews() {\n+     return tablesAndViews.values();\n+ }\n \n \n-    public Collection<TableSynonym> getAllSynonyms() {\n-        return synonyms.values();\n-    }\n+ public Collection<TableSynonym> getAllSynonyms() {\n+     return synonyms.values();\n+ }\n \n-    public Collection<FunctionAlias> getAllFunctionAliases() {\n-        return functions.values();\n-    }\n+ public Collection<FunctionAlias> getAllFunctionAliases() {\n+     return functions.values();\n+ }\n \n-    /**\n+ /**\n      * Get the table with the given name, if any.\n      *\n      * @param name the table name\n      * @return the table or null if not found\n      */\n-    public Table getTableOrViewByName(String name) {\n-        return tablesAndViews.get(name);\n-    }\n+ public Table getTableOrViewByName(String name) {\n+     return tablesAndViews.get(name);\n+ }\n \n-    /**\n+ /**\n      * Remove an object from this schema.\n      *\n      * @param obj the object to remove\n      */\n-    public void remove(SchemaObject obj) {\n-        String objName = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.remove(objName) == null) {\n-            DbException.throwInternalError(\"not found: \" + objName);\n-        }\n-        freeUniqueName(objName);\n-    }\n+ public void remove(SchemaObject obj) {\n+     String objName = obj.getName();\n+     Map<String, SchemaObject> map = getMap(obj.getType());\n+     if (map.remove(objName) == null) {\n+         DbException.throwInternalError(\"not found: \" + objName);\n+     }\n+     freeUniqueName(objName);\n+ }\n \n-    /**\n+ /**\n      * Add a table to the schema.\n      *\n      * @param data the create table information\n      * @return the created {@link Table} object\n      */\n-    public Table createTable(CreateTableData data) {\n-        synchronized (database) {\n-            if (!data.temporary || data.globalTemporary) {\n-                database.lockMeta(data.session);\n-            }\n-            data.schema = this;\n-            if (data.tableEngine == null) {\n-                DbSettings s = database.getSettings();\n-                if (s.defaultTableEngine != null) {\n-                    data.tableEngine = s.defaultTableEngine;\n-                } else if (s.mvStore) {\n-                    data.tableEngine = MVTableEngine.class.getName();\n-                }\n-            }\n-            if (data.tableEngine != null) {\n-                if (data.tableEngineParams == null) {\n-                    data.tableEngineParams = this.tableEngineParams;\n-                }\n-                return database.getTableEngine(data.tableEngine).createTable(data);\n-            }\n-            return new PageStoreTable(data);\n-        }\n-    }\n-\n-    /**\n+ public Table createTable(CreateTableData data) {\n+     synchronized (database) {\n+         if (!data.temporary || data.globalTemporary) {\n+             database.lockMeta(data.session);\n+         }\n+         data.schema = this;\n+         if (data.tableEngine == null) {\n+             DbSettings s = database.getSettings();\n+             if (s.defaultTableEngine != null) {\n+                 data.tableEngine = s.defaultTableEngine;\n+             } else if (s.mvStore) {\n+                 data.tableEngine = MVTableEngine.class.getName();\n+             }\n+         }\n+         if (data.tableEngine != null) {\n+             if (data.tableEngineParams == null) {\n+                 data.tableEngineParams = this.tableEngineParams;\n+             }\n+             return database.getTableEngine(data.tableEngine).createTable(data);\n+         }\n+         return new PageStoreTable(data);\n+     }\n+ }\n+\n+ /**\n      * Add a table synonym to the schema.\n      *\n      * @param data the create synonym information\n      * @return the created {@link TableSynonym} object\n      */\n-    public TableSynonym createSynonym(CreateSynonymData data) {\n-        synchronized (database) {\n-            database.lockMeta(data.session);\n-            data.schema = this;\n-            return new TableSynonym(data);\n-        }\n-    }\n+ public TableSynonym createSynonym(CreateSynonymData data) {\n+     synchronized (database) {\n+         database.lockMeta(data.session);\n+         data.schema = this;\n+         return new TableSynonym(data);\n+     }\n+ }\n \n-    /**\n+ /**\n      * Add a linked table to the schema.\n      *\n      * @param id the object id\n@@ -766,14 +766,14 @@ public class Schema extends DbObjectBase {\n      * @param force create the object even if the database can not be accessed\n      * @return the {@link TableLink} object\n      */\n-    public TableLink createTableLink(int id, String tableName, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n-        synchronized (database) {\n-            return new TableLink(this, id, tableName,\n-                    driver, url, user, password,\n-                    originalSchema, originalTable, emitUpdates, force);\n-        }\n-    }\n+ public TableLink createTableLink(int id, String tableName, String driver,\n+         String url, String user, String password, String originalSchema,\n+         String originalTable, boolean emitUpdates, boolean force) {\n+     synchronized (database) {\n+         return new TableLink(this, id, tableName,\n+                 driver, url, user, password,\n+                 originalSchema, originalTable, emitUpdates, force);\n+     }\n+ }\n \n }\n",
            "diff_size": 389
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "165",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/105/Schema.java\nindex 242e4f750f..b354d77fd4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/105/Schema.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.schema;\n \n import java.util.ArrayList;\n@@ -41,739 +42,746 @@ import org.h2.util.Utils;\n  */\n public class Schema extends DbObjectBase {\n \n-    private User owner;\n-    private final boolean system;\n-    private ArrayList<String> tableEngineParams;\n-\n-    private final ConcurrentHashMap<String, Table> tablesAndViews;\n-    private final ConcurrentHashMap<String, Domain> domains;\n-    private final ConcurrentHashMap<String, TableSynonym> synonyms;\n-    private final ConcurrentHashMap<String, Index> indexes;\n-    private final ConcurrentHashMap<String, Sequence> sequences;\n-    private final ConcurrentHashMap<String, TriggerObject> triggers;\n-    private final ConcurrentHashMap<String, Constraint> constraints;\n-    private final ConcurrentHashMap<String, Constant> constants;\n-    private final ConcurrentHashMap<String, FunctionAlias> functions;\n-\n-    /**\n-     * The set of returned unique names that are not yet stored. It is used to\n-     * avoid returning the same unique name twice when multiple threads\n-     * concurrently create objects.\n-     */\n-    private final HashSet<String> temporaryUniqueNames = new HashSet<>();\n-\n-    /**\n-     * Create a new schema object.\n-     *\n-     * @param database the database\n-     * @param id the object id\n-     * @param schemaName the schema name\n-     * @param owner the owner of the schema\n-     * @param system if this is a system schema (such a schema can not be\n-     *            dropped)\n-     */\n-    public Schema(Database database, int id, String schemaName, User owner,\n-            boolean system) {\n-        super(database, id, schemaName, Trace.SCHEMA);\n-        tablesAndViews = database.newConcurrentStringMap();\n-        domains = database.newConcurrentStringMap();\n-        synonyms = database.newConcurrentStringMap();\n-        indexes = database.newConcurrentStringMap();\n-        sequences = database.newConcurrentStringMap();\n-        triggers = database.newConcurrentStringMap();\n-        constraints = database.newConcurrentStringMap();\n-        constants = database.newConcurrentStringMap();\n-        functions = database.newConcurrentStringMap();\n-        this.owner = owner;\n-        this.system = system;\n-    }\n-\n-    /**\n-     * Check if this schema can be dropped. System schemas can not be dropped.\n-     *\n-     * @return true if it can be dropped\n-     */\n-    public boolean canDrop() {\n-        return !system;\n-    }\n-\n-    @Override\n-    public String getCreateSQLForCopy(Table table, String quotedName) {\n-        throw DbException.throwInternalError(toString());\n-    }\n-\n-    @Override\n-    public String getCreateSQL() {\n-        if (system) {\n-            return null;\n-        }\n-        StringBuilder builder = new StringBuilder(\"CREATE SCHEMA IF NOT EXISTS \");\n-        getSQL(builder, DEFAULT_SQL_FLAGS).append(\" AUTHORIZATION \");\n-        owner.getSQL(builder, DEFAULT_SQL_FLAGS);\n-        return builder.toString();\n-    }\n-\n-    @Override\n-    public int getType() {\n-        return DbObject.SCHEMA;\n-    }\n-\n-    /**\n-     * Return whether is this schema is empty (does not contain any objects).\n-     *\n-     * @return {@code true} if this schema is empty, {@code false} otherwise\n-     */\n-    public boolean isEmpty() {\n-        return tablesAndViews.isEmpty() && domains.isEmpty() && synonyms.isEmpty() && indexes.isEmpty()\n-                && sequences.isEmpty() && triggers.isEmpty() && constraints.isEmpty() && constants.isEmpty()\n-                && functions.isEmpty();\n-    }\n-\n-    @Override\n-    public ArrayList<DbObject> getChildren() {\n-        ArrayList<DbObject> children = Utils.newSmallArrayList();\n-        ArrayList<Right> rights = database.getAllRights();\n-        for (Right right : rights) {\n-            if (right.getGrantedObject() == this) {\n-                children.add(right);\n-            }\n-        }\n-        return children;\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        removeChildrenFromMap(session, triggers);\n-        removeChildrenFromMap(session, constraints);\n-        // There can be dependencies between tables e.g. using computed columns,\n-        // so we might need to loop over them multiple times.\n-        boolean modified = true;\n-        while (!tablesAndViews.isEmpty()) {\n-            boolean newModified = false;\n-            for (Table obj : tablesAndViews.values()) {\n-                if (obj.getName() != null) {\n-                    // Database.removeSchemaObject() removes the object from\n-                    // the map too, but it is safe for ConcurrentHashMap.\n-                    Table dependentTable = database.getDependentTable(obj, obj);\n-                    if (dependentTable == null) {\n-                        database.removeSchemaObject(session, obj);\n-                        newModified = true;\n-                    } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getTraceSQL(), dependentTable.getTraceSQL());\n-                    } else if (!modified) {\n-                        dependentTable.removeColumnExpressionsDependencies(session);\n-                        dependentTable.setModified();\n-                        database.updateMeta(session, dependentTable);\n-                    }\n-                }\n-            }\n-            modified = newModified;\n-        }\n-        removeChildrenFromMap(session, domains);\n-        removeChildrenFromMap(session, indexes);\n-        removeChildrenFromMap(session, sequences);\n-        removeChildrenFromMap(session, constants);\n-        removeChildrenFromMap(session, functions);\n-        for (Right right : database.getAllRights()) {\n-            if (right.getGrantedObject() == this) {\n-                database.removeDatabaseObject(session, right);\n-            }\n+  private User owner;\n+  private final boolean system;\n+  private ArrayList<String> tableEngineParams;\n+\n+  private final ConcurrentHashMap<String, Table> tablesAndViews;\n+  private final ConcurrentHashMap<String, Domain> domains;\n+  private final ConcurrentHashMap<String, TableSynonym> synonyms;\n+  private final ConcurrentHashMap<String, Index> indexes;\n+  private final ConcurrentHashMap<String, Sequence> sequences;\n+  private final ConcurrentHashMap<String, TriggerObject> triggers;\n+  private final ConcurrentHashMap<String, Constraint> constraints;\n+  private final ConcurrentHashMap<String, Constant> constants;\n+  private final ConcurrentHashMap<String, FunctionAlias> functions;\n+\n+  /**\n+   * The set of returned unique names that are not yet stored. It is used to\n+   * avoid returning the same unique name twice when multiple threads\n+   * concurrently create objects.\n+   */\n+  private final HashSet<String> temporaryUniqueNames = new HashSet<>();\n+\n+  /**\n+   * Create a new schema object.\n+   *\n+   * @param database   the database\n+   * @param id         the object id\n+   * @param schemaName the schema name\n+   * @param owner      the owner of the schema\n+   * @param system     if this is a system schema (such a schema can not be\n+   *                   dropped)\n+   */\n+  public Schema(Database database, int id, String schemaName, User owner,\n+                boolean system) {\n+    super(database, id, schemaName, Trace.SCHEMA);\n+    tablesAndViews = database.newConcurrentStringMap();\n+    domains = database.newConcurrentStringMap();\n+    synonyms = database.newConcurrentStringMap();\n+    indexes = database.newConcurrentStringMap();\n+    sequences = database.newConcurrentStringMap();\n+    triggers = database.newConcurrentStringMap();\n+    constraints = database.newConcurrentStringMap();\n+    constants = database.newConcurrentStringMap();\n+    functions = database.newConcurrentStringMap();\n+    this.owner = owner;\n+    this.system = system;\n+  }\n+\n+  /**\n+   * Check if this schema can be dropped. System schemas can not be dropped.\n+   *\n+   * @return true if it can be dropped\n+   */\n+  public boolean canDrop() {\n+    return !system;\n+  }\n+\n+  @Override\n+  public String getCreateSQLForCopy(Table table, String quotedName) {\n+    throw DbException.throwInternalError(toString());\n+  }\n+\n+  @Override\n+  public String getCreateSQL() {\n+    if (system) {\n+      return null;\n+    }\n+    StringBuilder builder = new StringBuilder(\"CREATE SCHEMA IF NOT EXISTS \");\n+    getSQL(builder, DEFAULT_SQL_FLAGS).append(\" AUTHORIZATION \");\n+    owner.getSQL(builder, DEFAULT_SQL_FLAGS);\n+    return builder.toString();\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return DbObject.SCHEMA;\n+  }\n+\n+  /**\n+   * Return whether is this schema is empty (does not contain any objects).\n+   *\n+   * @return {@code true} if this schema is empty, {@code false} otherwise\n+   */\n+  public boolean isEmpty() {\n+    return tablesAndViews.isEmpty() && domains.isEmpty() &&\n+        synonyms.isEmpty() && indexes.isEmpty()\n+        && sequences.isEmpty() && triggers.isEmpty() && constraints.isEmpty() &&\n+        constants.isEmpty()\n+        && functions.isEmpty();\n+  }\n+\n+  @Override\n+  public ArrayList<DbObject> getChildren() {\n+    ArrayList<DbObject> children = Utils.newSmallArrayList();\n+    ArrayList<Right> rights = database.getAllRights();\n+    for (Right right : rights) {\n+      if (right.getGrantedObject() == this) {\n+        children.add(right);\n+      }\n+    }\n+    return children;\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    removeChildrenFromMap(session, triggers);\n+    removeChildrenFromMap(session, constraints);\n+    // There can be dependencies between tables e.g. using computed columns,\n+    // so we might need to loop over them multiple times.\n+    boolean modified = true;\n+    while (!tablesAndViews.isEmpty()) {\n+      boolean newModified = false;\n+      for (Table obj : tablesAndViews.values()) {\n+        if (obj.getName() != null) {\n+          // Database.removeSchemaObject() removes the object from\n+          // the map too, but it is safe for ConcurrentHashMap.\n+          Table dependentTable = database.getDependentTable(obj, obj);\n+          if (dependentTable == null) {\n+            database.removeSchemaObject(session, obj);\n+            newModified = true;\n+          } else if (dependentTable.getSchema() != this) {\n+            throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n+                obj.getTraceSQL(), dependentTable.getTraceSQL());\n+          } else if (!modified) {\n+            dependentTable.removeColumnExpressionsDependencies(session);\n+            dependentTable.setModified();\n+            database.updateMeta(session, dependentTable);\n+          }\n         }\n-        database.removeMeta(session, getId());\n-        owner = null;\n-        invalidate();\n-    }\n-\n-    private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n-        if (!map.isEmpty()) {\n-            for (SchemaObject obj : map.values()) {\n-                // Database.removeSchemaObject() removes the object from\n-                // the map too, but it is safe for ConcurrentHashMap.\n-                database.removeSchemaObject(session, obj);\n-            }\n+      }\n+      modified = newModified;\n+    }\n+    removeChildrenFromMap(session, domains);\n+    removeChildrenFromMap(session, indexes);\n+    removeChildrenFromMap(session, sequences);\n+    removeChildrenFromMap(session, constants);\n+    removeChildrenFromMap(session, functions);\n+    for (Right right : database.getAllRights()) {\n+      if (right.getGrantedObject() == this) {\n+        database.removeDatabaseObject(session, right);\n+      }\n+    }\n+    database.removeMeta(session, getId());\n+    owner = null;\n+    invalidate();\n+  }\n+\n+  private void removeChildrenFromMap(Session session,\n+                                     ConcurrentHashMap<String, ? extends SchemaObject> map) {\n+    if (!map.isEmpty()) {\n+      for (SchemaObject obj : map.values()) {\n+        // Database.removeSchemaObject() removes the object from\n+        // the map too, but it is safe for ConcurrentHashMap.\n+        database.removeSchemaObject(session, obj);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get the owner of this schema.\n+   *\n+   * @return the owner\n+   */\n+  public User getOwner() {\n+    return owner;\n+  }\n+\n+  /**\n+   * Get table engine params of this schema.\n+   *\n+   * @return default table engine params\n+   */\n+  public ArrayList<String> getTableEngineParams() {\n+    return tableEngineParams;\n+  }\n+\n+  /**\n+   * Set table engine params of this schema.\n+   *\n+   * @param tableEngineParams default table engine params\n+   */\n+  public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n+    this.tableEngineParams = tableEngineParams;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map<String, SchemaObject> getMap(int type) {\n+    Map<String, ? extends SchemaObject> result;\n+    switch (type) {\n+      case DbObject.TABLE_OR_VIEW:\n+        result = tablesAndViews;\n+        break;\n+      case DbObject.DOMAIN:\n+        result = domains;\n+        break;\n+      case DbObject.SYNONYM:\n+        result = synonyms;\n+        break;\n+      case DbObject.SEQUENCE:\n+        result = sequences;\n+        break;\n+      case DbObject.INDEX:\n+        result = indexes;\n+        break;\n+      case DbObject.TRIGGER:\n+        result = triggers;\n+        break;\n+      case DbObject.CONSTRAINT:\n+        result = constraints;\n+        break;\n+      case DbObject.CONSTANT:\n+        result = constants;\n+        break;\n+      case DbObject.FUNCTION_ALIAS:\n+        result = functions;\n+        break;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + type);\n+    }\n+    return (Map<String, SchemaObject>) result;\n+  }\n+\n+  /**\n+   * Add an object to this schema.\n+   * This method must not be called within CreateSchemaObject;\n+   * use Database.addSchemaObject() instead\n+   *\n+   * @param obj the object to add\n+   */\n+  public void add(SchemaObject obj) {\n+    if (obj.getSchema() != this) {\n+      DbException.throwInternalError(\"wrong schema\");\n+    }\n+    String name = obj.getName();\n+    Map<String, SchemaObject> map = getMap(obj.getType());\n+    if (map.putIfAbsent(name, obj) != null) {\n+      DbException.throwInternalError(\"object already exists: \" + name);\n+    }\n+    freeUniqueName(name);\n+  }\n+\n+  /**\n+   * Rename an object.\n+   *\n+   * @param obj     the object to rename\n+   * @param newName the new name\n+   */\n+  public void rename(SchemaObject obj, String newName) {\n+    int type = obj.getType();\n+    Map<String, SchemaObject> map = getMap(type);\n+    if (SysProperties.CHECK) {\n+      if (!map.containsKey(obj.getName())) {\n+        DbException.throwInternalError(\"not found: \" + obj.getName());\n+      }\n+      if (obj.getName().equals(newName) || map.containsKey(newName)) {\n+        DbException.throwInternalError(\"object already exists: \" + newName);\n+      }\n+    }\n+    obj.checkRename();\n+    map.remove(obj.getName());\n+    freeUniqueName(obj.getName());\n+    obj.rename(newName);\n+    map.put(newName, obj);\n+    freeUniqueName(newName);\n+  }\n+\n+  /**\n+   * Try to find a table or view with this name. This method returns null if\n+   * no object with this name exists. Local temporary tables are also\n+   * returned. Synonyms are not returned or resolved.\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Table findTableOrView(Session session, String name) {\n+    Table table = tablesAndViews.get(name);\n+    if (table == null && session != null) {\n+      table = session.findLocalTempTable(name);\n+    }\n+    return table;\n+  }\n+\n+  /**\n+   * Try to find a table or view with this name. This method returns null if\n+   * no object with this name exists. Local temporary tables are also\n+   * returned. If a synonym with this name exists, the backing table of the\n+   * synonym is returned\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Table resolveTableOrView(Session session, String name) {\n+    Table table = findTableOrView(session, name);\n+    if (table == null) {\n+      TableSynonym synonym = synonyms.get(name);\n+      if (synonym != null) {\n+        return synonym.getSynonymFor();\n+      }\n+    }\n+    return table;\n+  }\n+\n+  /**\n+   * Try to find a synonym with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param name the object name\n+   * @return the object or null\n+   */\n+  public TableSynonym getSynonym(String name) {\n+    return synonyms.get(name);\n+  }\n+\n+  /**\n+   * Get the domain if it exists, or null if not.\n+   *\n+   * @param name the name of the domain\n+   * @return the domain or null\n+   */\n+  public Domain findDomain(String name) {\n+    return domains.get(name);\n+  }\n+\n+  /**\n+   * Try to find an index with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Index findIndex(Session session, String name) {\n+    Index index = indexes.get(name);\n+    if (index == null) {\n+      index = session.findLocalTempTableIndex(name);\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Try to find a trigger with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param name the object name\n+   * @return the object or null\n+   */\n+  public TriggerObject findTrigger(String name) {\n+    return triggers.get(name);\n+  }\n+\n+  /**\n+   * Try to find a sequence with this name. This method returns null if\n+   * no object with this name exists.\n+   *\n+   * @param sequenceName the object name\n+   * @return the object or null\n+   */\n+  public Sequence findSequence(String sequenceName) {\n+    return sequences.get(sequenceName);\n+  }\n+\n+  /**\n+   * Try to find a constraint with this name. This method returns null if no\n+   * object with this name exists.\n+   *\n+   * @param session the session\n+   * @param name    the object name\n+   * @return the object or null\n+   */\n+  public Constraint findConstraint(Session session, String name) {\n+    Constraint constraint = constraints.get(name);\n+    if (constraint == null) {\n+      constraint = session.findLocalTempTableConstraint(name);\n+    }\n+    return constraint;\n+  }\n+\n+  /**\n+   * Try to find a user defined constant with this name. This method returns\n+   * null if no object with this name exists.\n+   *\n+   * @param constantName the object name\n+   * @return the object or null\n+   */\n+  public Constant findConstant(String constantName) {\n+    return constants.get(constantName);\n+  }\n+\n+  /**\n+   * Try to find a user defined function with this name. This method returns\n+   * null if no object with this name exists.\n+   *\n+   * @param functionAlias the object name\n+   * @return the object or null\n+   */\n+  public FunctionAlias findFunction(String functionAlias) {\n+    return functions.get(functionAlias);\n+  }\n+\n+  /**\n+   * Release a unique object name.\n+   *\n+   * @param name the object name\n+   */\n+  public void freeUniqueName(String name) {\n+    if (name != null) {\n+      synchronized (temporaryUniqueNames) {\n+        temporaryUniqueNames.remove(name);\n+      }\n+    }\n+  }\n+\n+  private String getUniqueName(DbObject obj,\n+                               Map<String, ? extends SchemaObject> map,\n+                               String prefix) {\n+    String hash = StringUtils\n+        .toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n+    String name = null;\n+    synchronized (temporaryUniqueNames) {\n+      for (int i = 1, len = hash.length(); i < len; i++) {\n+        name = prefix + hash.substring(0, i);\n+        if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+          break;\n         }\n-    }\n-\n-    /**\n-     * Get the owner of this schema.\n-     *\n-     * @return the owner\n-     */\n-    public User getOwner() {\n-        return owner;\n-    }\n-\n-    /**\n-     * Get table engine params of this schema.\n-     *\n-     * @return default table engine params\n-     */\n-    public ArrayList<String> getTableEngineParams() {\n-        return tableEngineParams;\n-    }\n-\n-    /**\n-     * Set table engine params of this schema.\n-     * @param tableEngineParams default table engine params\n-     */\n-    public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n-        this.tableEngineParams = tableEngineParams;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String, SchemaObject> getMap(int type) {\n-        Map<String, ? extends SchemaObject> result;\n-        switch (type) {\n-        case DbObject.TABLE_OR_VIEW:\n-            result = tablesAndViews;\n-            break;\n-        case DbObject.DOMAIN:\n-            result = domains;\n-            break;\n-        case DbObject.SYNONYM:\n-            result = synonyms;\n-            break;\n-        case DbObject.SEQUENCE:\n-            result = sequences;\n-            break;\n-        case DbObject.INDEX:\n-            result = indexes;\n+        name = null;\n+      }\n+      if (name == null) {\n+        prefix = prefix + hash + \"_\";\n+        for (int i = 0; ; i++) {\n+          name = prefix + i;\n+          if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n             break;\n-        case DbObject.TRIGGER:\n-            result = triggers;\n-            break;\n-        case DbObject.CONSTRAINT:\n-            result = constraints;\n-            break;\n-        case DbObject.CONSTANT:\n-            result = constants;\n-            break;\n-        case DbObject.FUNCTION_ALIAS:\n-            result = functions;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        return (Map<String, SchemaObject>) result;\n-    }\n-\n-    /**\n-     * Add an object to this schema.\n-     * This method must not be called within CreateSchemaObject;\n-     * use Database.addSchemaObject() instead\n-     *\n-     * @param obj the object to add\n-     */\n-    public void add(SchemaObject obj) {\n-        if (obj.getSchema() != this) {\n-            DbException.throwInternalError(\"wrong schema\");\n-        }\n-        String name = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.putIfAbsent(name, obj) != null) {\n-            DbException.throwInternalError(\"object already exists: \" + name);\n+          }\n         }\n-        freeUniqueName(name);\n-    }\n-\n-    /**\n-     * Rename an object.\n-     *\n-     * @param obj the object to rename\n-     * @param newName the new name\n-     */\n-    public void rename(SchemaObject obj, String newName) {\n-        int type = obj.getType();\n-        Map<String, SchemaObject> map = getMap(type);\n-        if (SysProperties.CHECK) {\n-            if (!map.containsKey(obj.getName())) {\n-                DbException.throwInternalError(\"not found: \" + obj.getName());\n-            }\n-            if (obj.getName().equals(newName) || map.containsKey(newName)) {\n-                DbException.throwInternalError(\"object already exists: \" + newName);\n-            }\n-        }\n-        obj.checkRename();\n-        map.remove(obj.getName());\n-        freeUniqueName(obj.getName());\n-        obj.rename(newName);\n-        map.put(newName, obj);\n-        freeUniqueName(newName);\n-    }\n-\n-    /**\n-     * Try to find a table or view with this name. This method returns null if\n-     * no object with this name exists. Local temporary tables are also\n-     * returned. Synonyms are not returned or resolved.\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Table findTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null && session != null) {\n-            table = session.findLocalTempTable(name);\n+      }\n+      temporaryUniqueNames.add(name);\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * Create a unique constraint name.\n+   *\n+   * @param session the session\n+   * @param table   the constraint table\n+   * @return the unique name\n+   */\n+  public String getUniqueConstraintName(Session session, Table table) {\n+    Map<String, Constraint> tableConstraints;\n+    if (table.isTemporary() && !table.isGlobalTemporary()) {\n+      tableConstraints = session.getLocalTempTableConstraints();\n+    } else {\n+      tableConstraints = constraints;\n+    }\n+    return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n+  }\n+\n+  /**\n+   * Create a unique constraint name.\n+   *\n+   * @param session the session\n+   * @param domain  the constraint domain\n+   * @return the unique name\n+   */\n+  public String getUniqueDomainConstraintName(Session session, Domain domain) {\n+    return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n+  }\n+\n+  /**\n+   * Create a unique index name.\n+   *\n+   * @param session the session\n+   * @param table   the indexed table\n+   * @param prefix  the index name prefix\n+   * @return the unique name\n+   */\n+  public String getUniqueIndexName(Session session, Table table,\n+                                   String prefix) {\n+    Map<String, Index> tableIndexes;\n+    if (table.isTemporary() && !table.isGlobalTemporary()) {\n+      tableIndexes = session.getLocalTempTableIndexes();\n+    } else {\n+      tableIndexes = indexes;\n+    }\n+    return getUniqueName(table, tableIndexes, prefix);\n+  }\n+\n+  /**\n+   * Get the table or view with the given name.\n+   * Local temporary tables are also returned.\n+   *\n+   * @param session the session\n+   * @param name    the table or view name\n+   * @return the table or view\n+   * @throws DbException if no such object exists\n+   */\n+  public Table getTableOrView(Session session, String name) {\n+    Table table = tablesAndViews.get(name);\n+    if (table == null) {\n+      if (session != null) {\n+        table = session.findLocalTempTable(name);\n+      }\n+      if (table == null) {\n+        throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n+      }\n+    }\n+    return table;\n+  }\n+\n+  /**\n+   * Get the domain with the given name.\n+   *\n+   * @param name the domain name\n+   * @return the domain\n+   * @throws DbException if no such object exists\n+   */\n+  public Domain getDomain(String name) {\n+    Domain domain = domains.get(name);\n+    if (domain == null) {\n+      throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n+    }\n+    return domain;\n+  }\n+\n+  /**\n+   * Get the index with the given name.\n+   *\n+   * @param name the index name\n+   * @return the index\n+   * @throws DbException if no such object exists\n+   */\n+  public Index getIndex(String name) {\n+    Index index = indexes.get(name);\n+    if (index == null) {\n+      throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n+    }\n+    return index;\n+  }\n+\n+  /**\n+   * Get the constraint with the given name.\n+   *\n+   * @param name the constraint name\n+   * @return the constraint\n+   * @throws DbException if no such object exists\n+   */\n+  public Constraint getConstraint(String name) {\n+    Constraint constraint = constraints.get(name);\n+    if (constraint == null) {\n+      throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n+    }\n+    return constraint;\n+  }\n+\n+  /**\n+   * Get the user defined constant with the given name.\n+   *\n+   * @param constantName the constant name\n+   * @return the constant\n+   * @throws DbException if no such object exists\n+   */\n+  public Constant getConstant(String constantName) {\n+    Constant constant = constants.get(constantName);\n+    if (constant == null) {\n+      throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n+    }\n+    return constant;\n+  }\n+\n+  /**\n+   * Get the sequence with the given name.\n+   *\n+   * @param sequenceName the sequence name\n+   * @return the sequence\n+   * @throws DbException if no such object exists\n+   */\n+  public Sequence getSequence(String sequenceName) {\n+    Sequence sequence = sequences.get(sequenceName);\n+    if (sequence == null) {\n+      throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n+    }\n+    return sequence;\n+  }\n+\n+  /**\n+   * Get all objects.\n+   *\n+   * @param addTo list to add objects to, or {@code null} to allocate a new\n+   *              list\n+   * @return the specified list with added objects, or a new (possibly empty) list\n+   * with all objects\n+   */\n+  public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n+    if (addTo == null) {\n+      addTo = Utils.newSmallArrayList();\n+    }\n+    addTo.addAll(tablesAndViews.values());\n+    addTo.addAll(domains.values());\n+    addTo.addAll(synonyms.values());\n+    addTo.addAll(sequences.values());\n+    addTo.addAll(indexes.values());\n+    addTo.addAll(triggers.values());\n+    addTo.addAll(constraints.values());\n+    addTo.addAll(constants.values());\n+    addTo.addAll(functions.values());\n+    return addTo;\n+  }\n+\n+  /**\n+   * Get all objects of the given type.\n+   *\n+   * @param type  the object type\n+   * @param addTo list to add objects to, or {@code null} to allocate a new\n+   *              list\n+   * @return the specified list with added objects, or a new (possibly empty) list\n+   * with objects of the given type\n+   */\n+  public ArrayList<SchemaObject> getAll(int type,\n+                                        ArrayList<SchemaObject> addTo) {\n+    Collection<SchemaObject> values = getMap(type).values();\n+    if (addTo != null) {\n+      addTo.addAll(values);\n+    } else {\n+      addTo = new ArrayList<>(values);\n+    }\n+    return addTo;\n+  }\n+\n+  /**\n+   * Get all tables and views.\n+   *\n+   * @return a (possible empty) list of all objects\n+   */\n+  public Collection<Table> getAllTablesAndViews() {\n+    return tablesAndViews.values();\n+  }\n+\n+\n+  public Collection<TableSynonym> getAllSynonyms() {\n+    return synonyms.values();\n+  }\n+\n+  public Collection<FunctionAlias> getAllFunctionAliases() {\n+    return functions.values();\n+  }\n+\n+  /**\n+   * Get the table with the given name, if any.\n+   *\n+   * @param name the table name\n+   * @return the table or null if not found\n+   */\n+  public Table getTableOrViewByName(String name) {\n+    return tablesAndViews.get(name);\n+  }\n+\n+  /**\n+   * Remove an object from this schema.\n+   *\n+   * @param obj the object to remove\n+   */\n+  public void remove(SchemaObject obj) {\n+    String objName = obj.getName();\n+    Map<String, SchemaObject> map = getMap(obj.getType());\n+    if (map.remove(objName) == null) {\n+      DbException.throwInternalError(\"not found: \" + objName);\n+    }\n+    freeUniqueName(objName);\n+  }\n+\n+  /**\n+   * Add a table to the schema.\n+   *\n+   * @param data the create table information\n+   * @return the created {@link Table} object\n+   */\n+  public Table createTable(CreateTableData data) {\n+    synchronized (database) {\n+      if (!data.temporary || data.globalTemporary) {\n+        database.lockMeta(data.session);\n+      }\n+      data.schema = this;\n+      if (data.tableEngine == null) {\n+        DbSettings s = database.getSettings();\n+        if (s.defaultTableEngine != null) {\n+          data.tableEngine = s.defaultTableEngine;\n+        } else if (s.mvStore) {\n+          data.tableEngine = MVTableEngine.class.getName();\n         }\n-        return table;\n-    }\n-\n-    /**\n-     * Try to find a table or view with this name. This method returns null if\n-     * no object with this name exists. Local temporary tables are also\n-     * returned. If a synonym with this name exists, the backing table of the\n-     * synonym is returned\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Table resolveTableOrView(Session session, String name) {\n-        Table table = findTableOrView(session, name);\n-        if (table == null) {\n-            TableSynonym synonym = synonyms.get(name);\n-            if (synonym != null) {\n-                return synonym.getSynonymFor();\n-            }\n+      }\n+      if (data.tableEngine != null) {\n+        if (data.tableEngineParams == null) {\n+          data.tableEngineParams = this.tableEngineParams;\n         }\n-        return table;\n-    }\n-\n-    /**\n-     * Try to find a synonym with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public TableSynonym getSynonym(String name) {\n-        return synonyms.get(name);\n-    }\n-\n-    /**\n-     * Get the domain if it exists, or null if not.\n-     *\n-     * @param name the name of the domain\n-     * @return the domain or null\n-     */\n-    public Domain findDomain(String name) {\n-        return domains.get(name);\n-    }\n-\n-    /**\n-     * Try to find an index with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Index findIndex(Session session, String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            index = session.findLocalTempTableIndex(name);\n-        }\n-        return index;\n-    }\n-\n-    /**\n-     * Try to find a trigger with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public TriggerObject findTrigger(String name) {\n-        return triggers.get(name);\n-    }\n-\n-    /**\n-     * Try to find a sequence with this name. This method returns null if\n-     * no object with this name exists.\n-     *\n-     * @param sequenceName the object name\n-     * @return the object or null\n-     */\n-    public Sequence findSequence(String sequenceName) {\n-        return sequences.get(sequenceName);\n-    }\n-\n-    /**\n-     * Try to find a constraint with this name. This method returns null if no\n-     * object with this name exists.\n-     *\n-     * @param session the session\n-     * @param name the object name\n-     * @return the object or null\n-     */\n-    public Constraint findConstraint(Session session, String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            constraint = session.findLocalTempTableConstraint(name);\n-        }\n-        return constraint;\n-    }\n-\n-    /**\n-     * Try to find a user defined constant with this name. This method returns\n-     * null if no object with this name exists.\n-     *\n-     * @param constantName the object name\n-     * @return the object or null\n-     */\n-    public Constant findConstant(String constantName) {\n-        return constants.get(constantName);\n-    }\n-\n-    /**\n-     * Try to find a user defined function with this name. This method returns\n-     * null if no object with this name exists.\n-     *\n-     * @param functionAlias the object name\n-     * @return the object or null\n-     */\n-    public FunctionAlias findFunction(String functionAlias) {\n-        return functions.get(functionAlias);\n-    }\n-\n-    /**\n-     * Release a unique object name.\n-     *\n-     * @param name the object name\n-     */\n-    public void freeUniqueName(String name) {\n-        if (name != null) {\n-            synchronized (temporaryUniqueNames) {\n-                temporaryUniqueNames.remove(name);\n-            }\n-        }\n-    }\n-\n-    private String getUniqueName(DbObject obj,\n-            Map<String, ? extends SchemaObject> map, String prefix) {\n-        String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n-        String name = null;\n-        synchronized (temporaryUniqueNames) {\n-            for (int i = 1, len = hash.length(); i < len; i++) {\n-                name = prefix + hash.substring(0, i);\n-                if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                    break;\n-                }\n-                name = null;\n-            }\n-            if (name == null) {\n-                prefix = prefix + hash + \"_\";\n-                for (int i = 0;; i++) {\n-                    name = prefix + i;\n-                    if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                        break;\n-                    }\n-                }\n-            }\n-            temporaryUniqueNames.add(name);\n-        }\n-        return name;\n-    }\n-\n-    /**\n-     * Create a unique constraint name.\n-     *\n-     * @param session the session\n-     * @param table the constraint table\n-     * @return the unique name\n-     */\n-    public String getUniqueConstraintName(Session session, Table table) {\n-        Map<String, Constraint> tableConstraints;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableConstraints = session.getLocalTempTableConstraints();\n-        } else {\n-            tableConstraints = constraints;\n-        }\n-        return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n-    }\n-\n-    /**\n-     * Create a unique constraint name.\n-     *\n-     * @param session the session\n-     * @param domain the constraint domain\n-     * @return the unique name\n-     */\n-    public String getUniqueDomainConstraintName(Session session, Domain domain) {\n-        return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n-    }\n-\n-    /**\n-     * Create a unique index name.\n-     *\n-     * @param session the session\n-     * @param table the indexed table\n-     * @param prefix the index name prefix\n-     * @return the unique name\n-     */\n-    public String getUniqueIndexName(Session session, Table table, String prefix) {\n-        Map<String, Index> tableIndexes;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableIndexes = session.getLocalTempTableIndexes();\n-        } else {\n-            tableIndexes = indexes;\n-        }\n-        return getUniqueName(table, tableIndexes, prefix);\n-    }\n-\n-    /**\n-     * Get the table or view with the given name.\n-     * Local temporary tables are also returned.\n-     *\n-     * @param session the session\n-     * @param name the table or view name\n-     * @return the table or view\n-     * @throws DbException if no such object exists\n-     */\n-    public Table getTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null) {\n-            if (session != null) {\n-                table = session.findLocalTempTable(name);\n-            }\n-            if (table == null) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n-            }\n-        }\n-        return table;\n-    }\n-\n-    /**\n-     * Get the domain with the given name.\n-     *\n-     * @param name the domain name\n-     * @return the domain\n-     * @throws DbException if no such object exists\n-     */\n-    public Domain getDomain(String name) {\n-        Domain domain = domains.get(name);\n-        if (domain == null) {\n-            throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n-        }\n-        return domain;\n-    }\n-\n-    /**\n-     * Get the index with the given name.\n-     *\n-     * @param name the index name\n-     * @return the index\n-     * @throws DbException if no such object exists\n-     */\n-    public Index getIndex(String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n-        }\n-        return index;\n-    }\n-\n-    /**\n-     * Get the constraint with the given name.\n-     *\n-     * @param name the constraint name\n-     * @return the constraint\n-     * @throws DbException if no such object exists\n-     */\n-    public Constraint getConstraint(String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n-        }\n-        return constraint;\n-    }\n-\n-    /**\n-     * Get the user defined constant with the given name.\n-     *\n-     * @param constantName the constant name\n-     * @return the constant\n-     * @throws DbException if no such object exists\n-     */\n-    public Constant getConstant(String constantName) {\n-        Constant constant = constants.get(constantName);\n-        if (constant == null) {\n-            throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n-        }\n-        return constant;\n-    }\n-\n-    /**\n-     * Get the sequence with the given name.\n-     *\n-     * @param sequenceName the sequence name\n-     * @return the sequence\n-     * @throws DbException if no such object exists\n-     */\n-    public Sequence getSequence(String sequenceName) {\n-        Sequence sequence = sequences.get(sequenceName);\n-        if (sequence == null) {\n-            throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n-        }\n-        return sequence;\n-    }\n-\n-    /**\n-     * Get all objects.\n-     *\n-     * @param addTo\n-     *                  list to add objects to, or {@code null} to allocate a new\n-     *                  list\n-     * @return the specified list with added objects, or a new (possibly empty) list\n-     *         with all objects\n-     */\n-    public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n-        if (addTo == null) {\n-            addTo = Utils.newSmallArrayList();\n-        }\n-        addTo.addAll(tablesAndViews.values());\n-        addTo.addAll(domains.values());\n-        addTo.addAll(synonyms.values());\n-        addTo.addAll(sequences.values());\n-        addTo.addAll(indexes.values());\n-        addTo.addAll(triggers.values());\n-        addTo.addAll(constraints.values());\n-        addTo.addAll(constants.values());\n-        addTo.addAll(functions.values());\n-        return addTo;\n-    }\n-\n-    /**\n-     * Get all objects of the given type.\n-     *\n-     * @param type\n-     *                  the object type\n-     * @param addTo\n-     *                  list to add objects to, or {@code null} to allocate a new\n-     *                  list\n-     * @return the specified list with added objects, or a new (possibly empty) list\n-     *         with objects of the given type\n-     */\n-    public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n-        Collection<SchemaObject> values = getMap(type).values();\n-        if (addTo != null) {\n-            addTo.addAll(values);\n-        } else {\n-            addTo = new ArrayList<>(values);\n-        }\n-        return addTo;\n-    }\n-\n-    /**\n-     * Get all tables and views.\n-     *\n-     * @return a (possible empty) list of all objects\n-     */\n-    public Collection<Table> getAllTablesAndViews() {\n-        return tablesAndViews.values();\n-    }\n-\n-\n-    public Collection<TableSynonym> getAllSynonyms() {\n-        return synonyms.values();\n-    }\n-\n-    public Collection<FunctionAlias> getAllFunctionAliases() {\n-        return functions.values();\n-    }\n-\n-    /**\n-     * Get the table with the given name, if any.\n-     *\n-     * @param name the table name\n-     * @return the table or null if not found\n-     */\n-    public Table getTableOrViewByName(String name) {\n-        return tablesAndViews.get(name);\n-    }\n-\n-    /**\n-     * Remove an object from this schema.\n-     *\n-     * @param obj the object to remove\n-     */\n-    public void remove(SchemaObject obj) {\n-        String objName = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.remove(objName) == null) {\n-            DbException.throwInternalError(\"not found: \" + objName);\n-        }\n-        freeUniqueName(objName);\n-    }\n-\n-    /**\n-     * Add a table to the schema.\n-     *\n-     * @param data the create table information\n-     * @return the created {@link Table} object\n-     */\n-    public Table createTable(CreateTableData data) {\n-        synchronized (database) {\n-            if (!data.temporary || data.globalTemporary) {\n-                database.lockMeta(data.session);\n-            }\n-            data.schema = this;\n-            if (data.tableEngine == null) {\n-                DbSettings s = database.getSettings();\n-                if (s.defaultTableEngine != null) {\n-                    data.tableEngine = s.defaultTableEngine;\n-                } else if (s.mvStore) {\n-                    data.tableEngine = MVTableEngine.class.getName();\n-                }\n-            }\n-            if (data.tableEngine != null) {\n-                if (data.tableEngineParams == null) {\n-                    data.tableEngineParams = this.tableEngineParams;\n-                }\n-                return database.getTableEngine(data.tableEngine).createTable(data);\n-            }\n-            return new PageStoreTable(data);\n-        }\n-    }\n-\n-    /**\n-     * Add a table synonym to the schema.\n-     *\n-     * @param data the create synonym information\n-     * @return the created {@link TableSynonym} object\n-     */\n-    public TableSynonym createSynonym(CreateSynonymData data) {\n-        synchronized (database) {\n-            database.lockMeta(data.session);\n-            data.schema = this;\n-            return new TableSynonym(data);\n-        }\n-    }\n-\n-    /**\n-     * Add a linked table to the schema.\n-     *\n-     * @param id the object id\n-     * @param tableName the table name of the alias\n-     * @param driver the driver class name\n-     * @param url the database URL\n-     * @param user the user name\n-     * @param password the password\n-     * @param originalSchema the schema name of the target table\n-     * @param originalTable the table name of the target table\n-     * @param emitUpdates if updates should be emitted instead of delete/insert\n-     * @param force create the object even if the database can not be accessed\n-     * @return the {@link TableLink} object\n-     */\n-    public TableLink createTableLink(int id, String tableName, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n-        synchronized (database) {\n-            return new TableLink(this, id, tableName,\n-                    driver, url, user, password,\n-                    originalSchema, originalTable, emitUpdates, force);\n-        }\n-    }\n+        return database.getTableEngine(data.tableEngine).createTable(data);\n+      }\n+      return new PageStoreTable(data);\n+    }\n+  }\n+\n+  /**\n+   * Add a table synonym to the schema.\n+   *\n+   * @param data the create synonym information\n+   * @return the created {@link TableSynonym} object\n+   */\n+  public TableSynonym createSynonym(CreateSynonymData data) {\n+    synchronized (database) {\n+      database.lockMeta(data.session);\n+      data.schema = this;\n+      return new TableSynonym(data);\n+    }\n+  }\n+\n+  /**\n+   * Add a linked table to the schema.\n+   *\n+   * @param id             the object id\n+   * @param tableName      the table name of the alias\n+   * @param driver         the driver class name\n+   * @param url            the database URL\n+   * @param user           the user name\n+   * @param password       the password\n+   * @param originalSchema the schema name of the target table\n+   * @param originalTable  the table name of the target table\n+   * @param emitUpdates    if updates should be emitted instead of delete/insert\n+   * @param force          create the object even if the database can not be accessed\n+   * @return the {@link TableLink} object\n+   */\n+  public TableLink createTableLink(int id, String tableName, String driver,\n+                                   String url, String user, String password,\n+                                   String originalSchema,\n+                                   String originalTable, boolean emitUpdates,\n+                                   boolean force) {\n+    synchronized (database) {\n+      return new TableLink(this, id, tableName,\n+          driver, url, user, password,\n+          originalSchema, originalTable, emitUpdates, force);\n+    }\n+  }\n \n }\n",
            "diff_size": 1226
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "170",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/105/Schema.java\nindex 242e4f750f..87d798ddbc 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/105/Schema.java\n@@ -10,7 +10,6 @@ import java.util.Collection;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n-\n import org.h2.api.ErrorCode;\n import org.h2.command.ddl.CreateSynonymData;\n import org.h2.command.ddl.CreateTableData;\n@@ -39,12 +38,13 @@ import org.h2.util.Utils;\n  * A schema as created by the SQL statement\n  * CREATE SCHEMA\n  */\n+\n+\n public class Schema extends DbObjectBase {\n \n     private User owner;\n     private final boolean system;\n     private ArrayList<String> tableEngineParams;\n-\n     private final ConcurrentHashMap<String, Table> tablesAndViews;\n     private final ConcurrentHashMap<String, Domain> domains;\n     private final ConcurrentHashMap<String, TableSynonym> synonyms;\n@@ -60,7 +60,7 @@ public class Schema extends DbObjectBase {\n      * avoid returning the same unique name twice when multiple threads\n      * concurrently create objects.\n      */\n-    private final HashSet<String> temporaryUniqueNames = new HashSet<>();\n+    private final HashSet<String> temporaryUniqueNames = new HashSet< >();\n \n     /**\n      * Create a new schema object.\n@@ -72,8 +72,8 @@ public class Schema extends DbObjectBase {\n      * @param system if this is a system schema (such a schema can not be\n      *            dropped)\n      */\n-    public Schema(Database database, int id, String schemaName, User owner,\n-            boolean system) {\n+\n+    public Schema(Database database, int id, String schemaName, User owner, boolean system) {\n         super(database, id, schemaName, Trace.SCHEMA);\n         tablesAndViews = database.newConcurrentStringMap();\n         domains = database.newConcurrentStringMap();\n@@ -93,6 +93,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @return true if it can be dropped\n      */\n+\n+\n     public boolean canDrop() {\n         return !system;\n     }\n@@ -123,10 +125,16 @@ public class Schema extends DbObjectBase {\n      *\n      * @return {@code true} if this schema is empty, {@code false} otherwise\n      */\n+\n+\n     public boolean isEmpty() {\n-        return tablesAndViews.isEmpty() && domains.isEmpty() && synonyms.isEmpty() && indexes.isEmpty()\n-                && sequences.isEmpty() && triggers.isEmpty() && constraints.isEmpty() && constants.isEmpty()\n-                && functions.isEmpty();\n+        return tablesAndViews.isEmpty() && domains.isEmpty()\n+        && synonyms.isEmpty()\n+        && indexes.isEmpty()\n+        && sequences.isEmpty()\n+        && triggers.isEmpty()\n+        && constraints.isEmpty()\n+        && constants.isEmpty() && functions.isEmpty();\n     }\n \n     @Override\n@@ -160,12 +168,13 @@ public class Schema extends DbObjectBase {\n                         newModified = true;\n                     } else if (dependentTable.getSchema() != this) {\n                         throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getTraceSQL(), dependentTable.getTraceSQL());\n+                                              obj.getTraceSQL(),\n+                                              dependentTable.getTraceSQL());\n                     } else if (!modified) {\n-                        dependentTable.removeColumnExpressionsDependencies(session);\n-                        dependentTable.setModified();\n-                        database.updateMeta(session, dependentTable);\n-                    }\n+                               dependentTable.removeColumnExpressionsDependencies(session);\n+                               dependentTable.setModified();\n+                               database.updateMeta(session, dependentTable);\n+                           }\n                 }\n             }\n             modified = newModified;\n@@ -200,6 +209,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @return the owner\n      */\n+\n+\n     public User getOwner() {\n         return owner;\n     }\n@@ -209,6 +220,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @return default table engine params\n      */\n+\n+\n     public ArrayList<String> getTableEngineParams() {\n         return tableEngineParams;\n     }\n@@ -217,6 +230,8 @@ public class Schema extends DbObjectBase {\n      * Set table engine params of this schema.\n      * @param tableEngineParams default table engine params\n      */\n+\n+\n     public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n         this.tableEngineParams = tableEngineParams;\n     }\n@@ -265,6 +280,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @param obj the object to add\n      */\n+\n+\n     public void add(SchemaObject obj) {\n         if (obj.getSchema() != this) {\n             DbException.throwInternalError(\"wrong schema\");\n@@ -283,6 +300,8 @@ public class Schema extends DbObjectBase {\n      * @param obj the object to rename\n      * @param newName the new name\n      */\n+\n+\n     public void rename(SchemaObject obj, String newName) {\n         int type = obj.getType();\n         Map<String, SchemaObject> map = getMap(type);\n@@ -311,6 +330,8 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n+\n+\n     public Table findTableOrView(Session session, String name) {\n         Table table = tablesAndViews.get(name);\n         if (table == null && session != null) {\n@@ -329,6 +350,8 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n+\n+\n     public Table resolveTableOrView(Session session, String name) {\n         Table table = findTableOrView(session, name);\n         if (table == null) {\n@@ -347,6 +370,8 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n+\n+\n     public TableSynonym getSynonym(String name) {\n         return synonyms.get(name);\n     }\n@@ -357,6 +382,8 @@ public class Schema extends DbObjectBase {\n      * @param name the name of the domain\n      * @return the domain or null\n      */\n+\n+\n     public Domain findDomain(String name) {\n         return domains.get(name);\n     }\n@@ -369,6 +396,8 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n+\n+\n     public Index findIndex(Session session, String name) {\n         Index index = indexes.get(name);\n         if (index == null) {\n@@ -384,6 +413,8 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n+\n+\n     public TriggerObject findTrigger(String name) {\n         return triggers.get(name);\n     }\n@@ -395,6 +426,8 @@ public class Schema extends DbObjectBase {\n      * @param sequenceName the object name\n      * @return the object or null\n      */\n+\n+\n     public Sequence findSequence(String sequenceName) {\n         return sequences.get(sequenceName);\n     }\n@@ -407,6 +440,8 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n+\n+\n     public Constraint findConstraint(Session session, String name) {\n         Constraint constraint = constraints.get(name);\n         if (constraint == null) {\n@@ -422,6 +457,8 @@ public class Schema extends DbObjectBase {\n      * @param constantName the object name\n      * @return the object or null\n      */\n+\n+\n     public Constant findConstant(String constantName) {\n         return constants.get(constantName);\n     }\n@@ -433,6 +470,8 @@ public class Schema extends DbObjectBase {\n      * @param functionAlias the object name\n      * @return the object or null\n      */\n+\n+\n     public FunctionAlias findFunction(String functionAlias) {\n         return functions.get(functionAlias);\n     }\n@@ -442,6 +481,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @param name the object name\n      */\n+\n+\n     public void freeUniqueName(String name) {\n         if (name != null) {\n             synchronized (temporaryUniqueNames) {\n@@ -450,8 +491,7 @@ public class Schema extends DbObjectBase {\n         }\n     }\n \n-    private String getUniqueName(DbObject obj,\n-            Map<String, ? extends SchemaObject> map, String prefix) {\n+    private String getUniqueName(DbObject obj, Map<String, ? extends SchemaObject> map, String prefix) {\n         String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n         String name = null;\n         synchronized (temporaryUniqueNames) {\n@@ -483,6 +523,8 @@ public class Schema extends DbObjectBase {\n      * @param table the constraint table\n      * @return the unique name\n      */\n+\n+\n     public String getUniqueConstraintName(Session session, Table table) {\n         Map<String, Constraint> tableConstraints;\n         if (table.isTemporary() && !table.isGlobalTemporary()) {\n@@ -500,6 +542,8 @@ public class Schema extends DbObjectBase {\n      * @param domain the constraint domain\n      * @return the unique name\n      */\n+\n+\n     public String getUniqueDomainConstraintName(Session session, Domain domain) {\n         return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n     }\n@@ -512,6 +556,8 @@ public class Schema extends DbObjectBase {\n      * @param prefix the index name prefix\n      * @return the unique name\n      */\n+\n+\n     public String getUniqueIndexName(Session session, Table table, String prefix) {\n         Map<String, Index> tableIndexes;\n         if (table.isTemporary() && !table.isGlobalTemporary()) {\n@@ -531,6 +577,8 @@ public class Schema extends DbObjectBase {\n      * @return the table or view\n      * @throws DbException if no such object exists\n      */\n+\n+\n     public Table getTableOrView(Session session, String name) {\n         Table table = tablesAndViews.get(name);\n         if (table == null) {\n@@ -551,6 +599,8 @@ public class Schema extends DbObjectBase {\n      * @return the domain\n      * @throws DbException if no such object exists\n      */\n+\n+\n     public Domain getDomain(String name) {\n         Domain domain = domains.get(name);\n         if (domain == null) {\n@@ -566,6 +616,8 @@ public class Schema extends DbObjectBase {\n      * @return the index\n      * @throws DbException if no such object exists\n      */\n+\n+\n     public Index getIndex(String name) {\n         Index index = indexes.get(name);\n         if (index == null) {\n@@ -581,6 +633,8 @@ public class Schema extends DbObjectBase {\n      * @return the constraint\n      * @throws DbException if no such object exists\n      */\n+\n+\n     public Constraint getConstraint(String name) {\n         Constraint constraint = constraints.get(name);\n         if (constraint == null) {\n@@ -596,6 +650,8 @@ public class Schema extends DbObjectBase {\n      * @return the constant\n      * @throws DbException if no such object exists\n      */\n+\n+\n     public Constant getConstant(String constantName) {\n         Constant constant = constants.get(constantName);\n         if (constant == null) {\n@@ -611,6 +667,8 @@ public class Schema extends DbObjectBase {\n      * @return the sequence\n      * @throws DbException if no such object exists\n      */\n+\n+\n     public Sequence getSequence(String sequenceName) {\n         Sequence sequence = sequences.get(sequenceName);\n         if (sequence == null) {\n@@ -628,6 +686,8 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with all objects\n      */\n+\n+\n     public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n         if (addTo == null) {\n             addTo = Utils.newSmallArrayList();\n@@ -655,12 +715,14 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with objects of the given type\n      */\n+\n+\n     public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n         Collection<SchemaObject> values = getMap(type).values();\n         if (addTo != null) {\n             addTo.addAll(values);\n         } else {\n-            addTo = new ArrayList<>(values);\n+            addTo = new ArrayList< >(values);\n         }\n         return addTo;\n     }\n@@ -670,6 +732,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @return a (possible empty) list of all objects\n      */\n+\n+\n     public Collection<Table> getAllTablesAndViews() {\n         return tablesAndViews.values();\n     }\n@@ -679,6 +743,7 @@ public class Schema extends DbObjectBase {\n         return synonyms.values();\n     }\n \n+\n     public Collection<FunctionAlias> getAllFunctionAliases() {\n         return functions.values();\n     }\n@@ -689,6 +754,8 @@ public class Schema extends DbObjectBase {\n      * @param name the table name\n      * @return the table or null if not found\n      */\n+\n+\n     public Table getTableOrViewByName(String name) {\n         return tablesAndViews.get(name);\n     }\n@@ -698,6 +765,8 @@ public class Schema extends DbObjectBase {\n      *\n      * @param obj the object to remove\n      */\n+\n+\n     public void remove(SchemaObject obj) {\n         String objName = obj.getName();\n         Map<String, SchemaObject> map = getMap(obj.getType());\n@@ -713,6 +782,8 @@ public class Schema extends DbObjectBase {\n      * @param data the create table information\n      * @return the created {@link Table} object\n      */\n+\n+\n     public Table createTable(CreateTableData data) {\n         synchronized (database) {\n             if (!data.temporary || data.globalTemporary) {\n@@ -743,6 +814,8 @@ public class Schema extends DbObjectBase {\n      * @param data the create synonym information\n      * @return the created {@link TableSynonym} object\n      */\n+\n+\n     public TableSynonym createSynonym(CreateSynonymData data) {\n         synchronized (database) {\n             database.lockMeta(data.session);\n@@ -766,14 +839,12 @@ public class Schema extends DbObjectBase {\n      * @param force create the object even if the database can not be accessed\n      * @return the {@link TableLink} object\n      */\n-    public TableLink createTableLink(int id, String tableName, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n+\n+\n+    public TableLink createTableLink(int id, String tableName, String driver, String url, String user, String password, String originalSchema, String originalTable, boolean emitUpdates, boolean force) {\n         synchronized (database) {\n-            return new TableLink(this, id, tableName,\n-                    driver, url, user, password,\n-                    originalSchema, originalTable, emitUpdates, force);\n+            return new TableLink(this, id, tableName, driver, url, user, password, originalSchema, originalTable, emitUpdates, force);\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 99
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "161",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                },
                {
                    "line": "161",
                    "column": "68",
                    "severity": "warning",
                    "message": "'{' at column 68 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "161",
                    "column": "68",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/105/Schema.java\nindex 242e4f750f..b0a936dc19 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/105/Schema.java\n@@ -158,151 +158,150 @@ public class Schema extends DbObjectBase {\n                     if (dependentTable == null) {\n                         database.removeSchemaObject(session, obj);\n                         newModified = true;\n-                    } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getTraceSQL(), dependentTable.getTraceSQL());\n-                    } else if (!modified) {\n-                        dependentTable.removeColumnExpressionsDependencies(session);\n-                        dependentTable.setModified();\n-                        database.updateMeta(session, dependentTable);\n-                    }\n+                    } else if (dependentTable.getSchema() != this) {throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n+                            obj.getTraceSQL(), dependentTable.getTraceSQL());\n+                } else if (!modified) {\n+                    dependentTable.removeColumnExpressionsDependencies(session);\n+                    dependentTable.setModified();\n+                    database.updateMeta(session, dependentTable);\n                 }\n             }\n-            modified = newModified;\n         }\n-        removeChildrenFromMap(session, domains);\n-        removeChildrenFromMap(session, indexes);\n-        removeChildrenFromMap(session, sequences);\n-        removeChildrenFromMap(session, constants);\n-        removeChildrenFromMap(session, functions);\n-        for (Right right : database.getAllRights()) {\n-            if (right.getGrantedObject() == this) {\n-                database.removeDatabaseObject(session, right);\n-            }\n+        modified = newModified;\n+    }\n+    removeChildrenFromMap(session, domains);\n+    removeChildrenFromMap(session, indexes);\n+    removeChildrenFromMap(session, sequences);\n+    removeChildrenFromMap(session, constants);\n+    removeChildrenFromMap(session, functions);\n+    for (Right right : database.getAllRights()) {\n+        if (right.getGrantedObject() == this) {\n+            database.removeDatabaseObject(session, right);\n         }\n-        database.removeMeta(session, getId());\n-        owner = null;\n-        invalidate();\n     }\n+    database.removeMeta(session, getId());\n+    owner = null;\n+    invalidate();\n+}\n \n-    private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n-        if (!map.isEmpty()) {\n-            for (SchemaObject obj : map.values()) {\n-                // Database.removeSchemaObject() removes the object from\n-                // the map too, but it is safe for ConcurrentHashMap.\n-                database.removeSchemaObject(session, obj);\n-            }\n+private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n+    if (!map.isEmpty()) {\n+        for (SchemaObject obj : map.values()) {\n+            // Database.removeSchemaObject() removes the object from\n+            // the map too, but it is safe for ConcurrentHashMap.\n+            database.removeSchemaObject(session, obj);\n         }\n     }\n+}\n \n-    /**\n+/**\n      * Get the owner of this schema.\n      *\n      * @return the owner\n      */\n-    public User getOwner() {\n-        return owner;\n-    }\n+public User getOwner() {\n+    return owner;\n+}\n \n-    /**\n+/**\n      * Get table engine params of this schema.\n      *\n      * @return default table engine params\n      */\n-    public ArrayList<String> getTableEngineParams() {\n-        return tableEngineParams;\n-    }\n+public ArrayList<String> getTableEngineParams() {\n+    return tableEngineParams;\n+}\n \n-    /**\n+/**\n      * Set table engine params of this schema.\n      * @param tableEngineParams default table engine params\n      */\n-    public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n-        this.tableEngineParams = tableEngineParams;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String, SchemaObject> getMap(int type) {\n-        Map<String, ? extends SchemaObject> result;\n-        switch (type) {\n-        case DbObject.TABLE_OR_VIEW:\n-            result = tablesAndViews;\n-            break;\n-        case DbObject.DOMAIN:\n-            result = domains;\n-            break;\n-        case DbObject.SYNONYM:\n-            result = synonyms;\n-            break;\n-        case DbObject.SEQUENCE:\n-            result = sequences;\n-            break;\n-        case DbObject.INDEX:\n-            result = indexes;\n-            break;\n-        case DbObject.TRIGGER:\n-            result = triggers;\n-            break;\n-        case DbObject.CONSTRAINT:\n-            result = constraints;\n-            break;\n-        case DbObject.CONSTANT:\n-            result = constants;\n-            break;\n-        case DbObject.FUNCTION_ALIAS:\n-            result = functions;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        return (Map<String, SchemaObject>) result;\n-    }\n+public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n+    this.tableEngineParams = tableEngineParams;\n+}\n \n-    /**\n+@SuppressWarnings(\"unchecked\")\n+private Map<String, SchemaObject> getMap(int type) {\n+    Map<String, ? extends SchemaObject> result;\n+    switch (type) {\n+    case DbObject.TABLE_OR_VIEW:\n+        result = tablesAndViews;\n+        break;\n+    case DbObject.DOMAIN:\n+        result = domains;\n+        break;\n+    case DbObject.SYNONYM:\n+        result = synonyms;\n+        break;\n+    case DbObject.SEQUENCE:\n+        result = sequences;\n+        break;\n+    case DbObject.INDEX:\n+        result = indexes;\n+        break;\n+    case DbObject.TRIGGER:\n+        result = triggers;\n+        break;\n+    case DbObject.CONSTRAINT:\n+        result = constraints;\n+        break;\n+    case DbObject.CONSTANT:\n+        result = constants;\n+        break;\n+    case DbObject.FUNCTION_ALIAS:\n+        result = functions;\n+        break;\n+    default:\n+        throw DbException.throwInternalError(\"type=\" + type);\n+    }\n+    return (Map<String, SchemaObject>) result;\n+}\n+\n+/**\n      * Add an object to this schema.\n      * This method must not be called within CreateSchemaObject;\n      * use Database.addSchemaObject() instead\n      *\n      * @param obj the object to add\n      */\n-    public void add(SchemaObject obj) {\n-        if (obj.getSchema() != this) {\n-            DbException.throwInternalError(\"wrong schema\");\n-        }\n-        String name = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.putIfAbsent(name, obj) != null) {\n-            DbException.throwInternalError(\"object already exists: \" + name);\n-        }\n-        freeUniqueName(name);\n+public void add(SchemaObject obj) {\n+    if (obj.getSchema() != this) {\n+        DbException.throwInternalError(\"wrong schema\");\n     }\n+    String name = obj.getName();\n+    Map<String, SchemaObject> map = getMap(obj.getType());\n+    if (map.putIfAbsent(name, obj) != null) {\n+        DbException.throwInternalError(\"object already exists: \" + name);\n+    }\n+    freeUniqueName(name);\n+}\n \n-    /**\n+/**\n      * Rename an object.\n      *\n      * @param obj the object to rename\n      * @param newName the new name\n      */\n-    public void rename(SchemaObject obj, String newName) {\n-        int type = obj.getType();\n-        Map<String, SchemaObject> map = getMap(type);\n-        if (SysProperties.CHECK) {\n-            if (!map.containsKey(obj.getName())) {\n-                DbException.throwInternalError(\"not found: \" + obj.getName());\n-            }\n-            if (obj.getName().equals(newName) || map.containsKey(newName)) {\n-                DbException.throwInternalError(\"object already exists: \" + newName);\n-            }\n+public void rename(SchemaObject obj, String newName) {\n+    int type = obj.getType();\n+    Map<String, SchemaObject> map = getMap(type);\n+    if (SysProperties.CHECK) {\n+        if (!map.containsKey(obj.getName())) {\n+            DbException.throwInternalError(\"not found: \" + obj.getName());\n+        }\n+        if (obj.getName().equals(newName) || map.containsKey(newName)) {\n+            DbException.throwInternalError(\"object already exists: \" + newName);\n         }\n-        obj.checkRename();\n-        map.remove(obj.getName());\n-        freeUniqueName(obj.getName());\n-        obj.rename(newName);\n-        map.put(newName, obj);\n-        freeUniqueName(newName);\n     }\n+    obj.checkRename();\n+    map.remove(obj.getName());\n+    freeUniqueName(obj.getName());\n+    obj.rename(newName);\n+    map.put(newName, obj);\n+    freeUniqueName(newName);\n+}\n \n-    /**\n+/**\n      * Try to find a table or view with this name. This method returns null if\n      * no object with this name exists. Local temporary tables are also\n      * returned. Synonyms are not returned or resolved.\n@@ -311,15 +310,15 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Table findTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null && session != null) {\n-            table = session.findLocalTempTable(name);\n-        }\n-        return table;\n+public Table findTableOrView(Session session, String name) {\n+    Table table = tablesAndViews.get(name);\n+    if (table == null && session != null) {\n+        table = session.findLocalTempTable(name);\n     }\n+    return table;\n+}\n \n-    /**\n+/**\n      * Try to find a table or view with this name. This method returns null if\n      * no object with this name exists. Local temporary tables are also\n      * returned. If a synonym with this name exists, the backing table of the\n@@ -329,39 +328,39 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Table resolveTableOrView(Session session, String name) {\n-        Table table = findTableOrView(session, name);\n-        if (table == null) {\n-            TableSynonym synonym = synonyms.get(name);\n-            if (synonym != null) {\n-                return synonym.getSynonymFor();\n-            }\n+public Table resolveTableOrView(Session session, String name) {\n+    Table table = findTableOrView(session, name);\n+    if (table == null) {\n+        TableSynonym synonym = synonyms.get(name);\n+        if (synonym != null) {\n+            return synonym.getSynonymFor();\n         }\n-        return table;\n     }\n+    return table;\n+}\n \n-    /**\n+/**\n      * Try to find a synonym with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param name the object name\n      * @return the object or null\n      */\n-    public TableSynonym getSynonym(String name) {\n-        return synonyms.get(name);\n-    }\n+public TableSynonym getSynonym(String name) {\n+    return synonyms.get(name);\n+}\n \n-    /**\n+/**\n      * Get the domain if it exists, or null if not.\n      *\n      * @param name the name of the domain\n      * @return the domain or null\n      */\n-    public Domain findDomain(String name) {\n-        return domains.get(name);\n-    }\n+public Domain findDomain(String name) {\n+    return domains.get(name);\n+}\n \n-    /**\n+/**\n      * Try to find an index with this name. This method returns null if\n      * no object with this name exists.\n      *\n@@ -369,37 +368,37 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Index findIndex(Session session, String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            index = session.findLocalTempTableIndex(name);\n-        }\n-        return index;\n+public Index findIndex(Session session, String name) {\n+    Index index = indexes.get(name);\n+    if (index == null) {\n+        index = session.findLocalTempTableIndex(name);\n     }\n+    return index;\n+}\n \n-    /**\n+/**\n      * Try to find a trigger with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param name the object name\n      * @return the object or null\n      */\n-    public TriggerObject findTrigger(String name) {\n-        return triggers.get(name);\n-    }\n+public TriggerObject findTrigger(String name) {\n+    return triggers.get(name);\n+}\n \n-    /**\n+/**\n      * Try to find a sequence with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param sequenceName the object name\n      * @return the object or null\n      */\n-    public Sequence findSequence(String sequenceName) {\n-        return sequences.get(sequenceName);\n-    }\n+public Sequence findSequence(String sequenceName) {\n+    return sequences.get(sequenceName);\n+}\n \n-    /**\n+/**\n      * Try to find a constraint with this name. This method returns null if no\n      * object with this name exists.\n      *\n@@ -407,104 +406,104 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Constraint findConstraint(Session session, String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            constraint = session.findLocalTempTableConstraint(name);\n-        }\n-        return constraint;\n+public Constraint findConstraint(Session session, String name) {\n+    Constraint constraint = constraints.get(name);\n+    if (constraint == null) {\n+        constraint = session.findLocalTempTableConstraint(name);\n     }\n+    return constraint;\n+}\n \n-    /**\n+/**\n      * Try to find a user defined constant with this name. This method returns\n      * null if no object with this name exists.\n      *\n      * @param constantName the object name\n      * @return the object or null\n      */\n-    public Constant findConstant(String constantName) {\n-        return constants.get(constantName);\n-    }\n+public Constant findConstant(String constantName) {\n+    return constants.get(constantName);\n+}\n \n-    /**\n+/**\n      * Try to find a user defined function with this name. This method returns\n      * null if no object with this name exists.\n      *\n      * @param functionAlias the object name\n      * @return the object or null\n      */\n-    public FunctionAlias findFunction(String functionAlias) {\n-        return functions.get(functionAlias);\n-    }\n+public FunctionAlias findFunction(String functionAlias) {\n+    return functions.get(functionAlias);\n+}\n \n-    /**\n+/**\n      * Release a unique object name.\n      *\n      * @param name the object name\n      */\n-    public void freeUniqueName(String name) {\n-        if (name != null) {\n-            synchronized (temporaryUniqueNames) {\n-                temporaryUniqueNames.remove(name);\n-            }\n+public void freeUniqueName(String name) {\n+    if (name != null) {\n+        synchronized (temporaryUniqueNames) {\n+            temporaryUniqueNames.remove(name);\n         }\n     }\n+}\n \n-    private String getUniqueName(DbObject obj,\n-            Map<String, ? extends SchemaObject> map, String prefix) {\n-        String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n-        String name = null;\n-        synchronized (temporaryUniqueNames) {\n-            for (int i = 1, len = hash.length(); i < len; i++) {\n-                name = prefix + hash.substring(0, i);\n+private String getUniqueName(DbObject obj,\n+        Map<String, ? extends SchemaObject> map, String prefix) {\n+    String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n+    String name = null;\n+    synchronized (temporaryUniqueNames) {\n+        for (int i = 1, len = hash.length(); i < len; i++) {\n+            name = prefix + hash.substring(0, i);\n+            if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+                break;\n+            }\n+            name = null;\n+        }\n+        if (name == null) {\n+            prefix = prefix + hash + \"_\";\n+            for (int i = 0;; i++) {\n+                name = prefix + i;\n                 if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n                     break;\n                 }\n-                name = null;\n-            }\n-            if (name == null) {\n-                prefix = prefix + hash + \"_\";\n-                for (int i = 0;; i++) {\n-                    name = prefix + i;\n-                    if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                        break;\n-                    }\n-                }\n             }\n-            temporaryUniqueNames.add(name);\n         }\n-        return name;\n+        temporaryUniqueNames.add(name);\n     }\n+    return name;\n+}\n \n-    /**\n+/**\n      * Create a unique constraint name.\n      *\n      * @param session the session\n      * @param table the constraint table\n      * @return the unique name\n      */\n-    public String getUniqueConstraintName(Session session, Table table) {\n-        Map<String, Constraint> tableConstraints;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableConstraints = session.getLocalTempTableConstraints();\n-        } else {\n-            tableConstraints = constraints;\n-        }\n-        return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n+public String getUniqueConstraintName(Session session, Table table) {\n+    Map<String, Constraint> tableConstraints;\n+    if (table.isTemporary() && !table.isGlobalTemporary()) {\n+        tableConstraints = session.getLocalTempTableConstraints();\n+    } else {\n+        tableConstraints = constraints;\n     }\n+    return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n+}\n \n-    /**\n+/**\n      * Create a unique constraint name.\n      *\n      * @param session the session\n      * @param domain the constraint domain\n      * @return the unique name\n      */\n-    public String getUniqueDomainConstraintName(Session session, Domain domain) {\n-        return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n-    }\n+public String getUniqueDomainConstraintName(Session session, Domain domain) {\n+    return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n+}\n \n-    /**\n+/**\n      * Create a unique index name.\n      *\n      * @param session the session\n@@ -512,17 +511,17 @@ public class Schema extends DbObjectBase {\n      * @param prefix the index name prefix\n      * @return the unique name\n      */\n-    public String getUniqueIndexName(Session session, Table table, String prefix) {\n-        Map<String, Index> tableIndexes;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableIndexes = session.getLocalTempTableIndexes();\n-        } else {\n-            tableIndexes = indexes;\n-        }\n-        return getUniqueName(table, tableIndexes, prefix);\n+public String getUniqueIndexName(Session session, Table table, String prefix) {\n+    Map<String, Index> tableIndexes;\n+    if (table.isTemporary() && !table.isGlobalTemporary()) {\n+        tableIndexes = session.getLocalTempTableIndexes();\n+    } else {\n+        tableIndexes = indexes;\n     }\n+    return getUniqueName(table, tableIndexes, prefix);\n+}\n \n-    /**\n+/**\n      * Get the table or view with the given name.\n      * Local temporary tables are also returned.\n      *\n@@ -531,95 +530,95 @@ public class Schema extends DbObjectBase {\n      * @return the table or view\n      * @throws DbException if no such object exists\n      */\n-    public Table getTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n+public Table getTableOrView(Session session, String name) {\n+    Table table = tablesAndViews.get(name);\n+    if (table == null) {\n+        if (session != null) {\n+            table = session.findLocalTempTable(name);\n+        }\n         if (table == null) {\n-            if (session != null) {\n-                table = session.findLocalTempTable(name);\n-            }\n-            if (table == null) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n-            }\n+            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n         }\n-        return table;\n     }\n+    return table;\n+}\n \n-    /**\n+/**\n      * Get the domain with the given name.\n      *\n      * @param name the domain name\n      * @return the domain\n      * @throws DbException if no such object exists\n      */\n-    public Domain getDomain(String name) {\n-        Domain domain = domains.get(name);\n-        if (domain == null) {\n-            throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n-        }\n-        return domain;\n+public Domain getDomain(String name) {\n+    Domain domain = domains.get(name);\n+    if (domain == null) {\n+        throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n     }\n+    return domain;\n+}\n \n-    /**\n+/**\n      * Get the index with the given name.\n      *\n      * @param name the index name\n      * @return the index\n      * @throws DbException if no such object exists\n      */\n-    public Index getIndex(String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n-        }\n-        return index;\n+public Index getIndex(String name) {\n+    Index index = indexes.get(name);\n+    if (index == null) {\n+        throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n     }\n+    return index;\n+}\n \n-    /**\n+/**\n      * Get the constraint with the given name.\n      *\n      * @param name the constraint name\n      * @return the constraint\n      * @throws DbException if no such object exists\n      */\n-    public Constraint getConstraint(String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n-        }\n-        return constraint;\n+public Constraint getConstraint(String name) {\n+    Constraint constraint = constraints.get(name);\n+    if (constraint == null) {\n+        throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n     }\n+    return constraint;\n+}\n \n-    /**\n+/**\n      * Get the user defined constant with the given name.\n      *\n      * @param constantName the constant name\n      * @return the constant\n      * @throws DbException if no such object exists\n      */\n-    public Constant getConstant(String constantName) {\n-        Constant constant = constants.get(constantName);\n-        if (constant == null) {\n-            throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n-        }\n-        return constant;\n+public Constant getConstant(String constantName) {\n+    Constant constant = constants.get(constantName);\n+    if (constant == null) {\n+        throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n     }\n+    return constant;\n+}\n \n-    /**\n+/**\n      * Get the sequence with the given name.\n      *\n      * @param sequenceName the sequence name\n      * @return the sequence\n      * @throws DbException if no such object exists\n      */\n-    public Sequence getSequence(String sequenceName) {\n-        Sequence sequence = sequences.get(sequenceName);\n-        if (sequence == null) {\n-            throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n-        }\n-        return sequence;\n+public Sequence getSequence(String sequenceName) {\n+    Sequence sequence = sequences.get(sequenceName);\n+    if (sequence == null) {\n+        throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n     }\n+    return sequence;\n+}\n \n-    /**\n+/**\n      * Get all objects.\n      *\n      * @param addTo\n@@ -628,23 +627,23 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with all objects\n      */\n-    public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n-        if (addTo == null) {\n-            addTo = Utils.newSmallArrayList();\n-        }\n-        addTo.addAll(tablesAndViews.values());\n-        addTo.addAll(domains.values());\n-        addTo.addAll(synonyms.values());\n-        addTo.addAll(sequences.values());\n-        addTo.addAll(indexes.values());\n-        addTo.addAll(triggers.values());\n-        addTo.addAll(constraints.values());\n-        addTo.addAll(constants.values());\n-        addTo.addAll(functions.values());\n-        return addTo;\n-    }\n+public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n+    if (addTo == null) {\n+        addTo = Utils.newSmallArrayList();\n+    }\n+    addTo.addAll(tablesAndViews.values());\n+    addTo.addAll(domains.values());\n+    addTo.addAll(synonyms.values());\n+    addTo.addAll(sequences.values());\n+    addTo.addAll(indexes.values());\n+    addTo.addAll(triggers.values());\n+    addTo.addAll(constraints.values());\n+    addTo.addAll(constants.values());\n+    addTo.addAll(functions.values());\n+    return addTo;\n+}\n \n-    /**\n+/**\n      * Get all objects of the given type.\n      *\n      * @param type\n@@ -655,103 +654,103 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with objects of the given type\n      */\n-    public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n-        Collection<SchemaObject> values = getMap(type).values();\n-        if (addTo != null) {\n-            addTo.addAll(values);\n-        } else {\n-            addTo = new ArrayList<>(values);\n-        }\n-        return addTo;\n+public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n+    Collection<SchemaObject> values = getMap(type).values();\n+    if (addTo != null) {\n+        addTo.addAll(values);\n+    } else {\n+        addTo = new ArrayList<>(values);\n     }\n+    return addTo;\n+}\n \n-    /**\n+/**\n      * Get all tables and views.\n      *\n      * @return a (possible empty) list of all objects\n      */\n-    public Collection<Table> getAllTablesAndViews() {\n-        return tablesAndViews.values();\n-    }\n+public Collection<Table> getAllTablesAndViews() {\n+    return tablesAndViews.values();\n+}\n \n \n-    public Collection<TableSynonym> getAllSynonyms() {\n-        return synonyms.values();\n-    }\n+public Collection<TableSynonym> getAllSynonyms() {\n+    return synonyms.values();\n+}\n \n-    public Collection<FunctionAlias> getAllFunctionAliases() {\n-        return functions.values();\n-    }\n+public Collection<FunctionAlias> getAllFunctionAliases() {\n+    return functions.values();\n+}\n \n-    /**\n+/**\n      * Get the table with the given name, if any.\n      *\n      * @param name the table name\n      * @return the table or null if not found\n      */\n-    public Table getTableOrViewByName(String name) {\n-        return tablesAndViews.get(name);\n-    }\n+public Table getTableOrViewByName(String name) {\n+    return tablesAndViews.get(name);\n+}\n \n-    /**\n+/**\n      * Remove an object from this schema.\n      *\n      * @param obj the object to remove\n      */\n-    public void remove(SchemaObject obj) {\n-        String objName = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.remove(objName) == null) {\n-            DbException.throwInternalError(\"not found: \" + objName);\n-        }\n-        freeUniqueName(objName);\n+public void remove(SchemaObject obj) {\n+    String objName = obj.getName();\n+    Map<String, SchemaObject> map = getMap(obj.getType());\n+    if (map.remove(objName) == null) {\n+        DbException.throwInternalError(\"not found: \" + objName);\n     }\n+    freeUniqueName(objName);\n+}\n \n-    /**\n+/**\n      * Add a table to the schema.\n      *\n      * @param data the create table information\n      * @return the created {@link Table} object\n      */\n-    public Table createTable(CreateTableData data) {\n-        synchronized (database) {\n-            if (!data.temporary || data.globalTemporary) {\n-                database.lockMeta(data.session);\n-            }\n-            data.schema = this;\n-            if (data.tableEngine == null) {\n-                DbSettings s = database.getSettings();\n-                if (s.defaultTableEngine != null) {\n-                    data.tableEngine = s.defaultTableEngine;\n-                } else if (s.mvStore) {\n-                    data.tableEngine = MVTableEngine.class.getName();\n-                }\n+public Table createTable(CreateTableData data) {\n+    synchronized (database) {\n+        if (!data.temporary || data.globalTemporary) {\n+            database.lockMeta(data.session);\n+        }\n+        data.schema = this;\n+        if (data.tableEngine == null) {\n+            DbSettings s = database.getSettings();\n+            if (s.defaultTableEngine != null) {\n+                data.tableEngine = s.defaultTableEngine;\n+            } else if (s.mvStore) {\n+                data.tableEngine = MVTableEngine.class.getName();\n             }\n-            if (data.tableEngine != null) {\n-                if (data.tableEngineParams == null) {\n-                    data.tableEngineParams = this.tableEngineParams;\n-                }\n-                return database.getTableEngine(data.tableEngine).createTable(data);\n+        }\n+        if (data.tableEngine != null) {\n+            if (data.tableEngineParams == null) {\n+                data.tableEngineParams = this.tableEngineParams;\n             }\n-            return new PageStoreTable(data);\n+            return database.getTableEngine(data.tableEngine).createTable(data);\n         }\n+        return new PageStoreTable(data);\n     }\n+}\n \n-    /**\n+/**\n      * Add a table synonym to the schema.\n      *\n      * @param data the create synonym information\n      * @return the created {@link TableSynonym} object\n      */\n-    public TableSynonym createSynonym(CreateSynonymData data) {\n-        synchronized (database) {\n-            database.lockMeta(data.session);\n-            data.schema = this;\n-            return new TableSynonym(data);\n-        }\n+public TableSynonym createSynonym(CreateSynonymData data) {\n+    synchronized (database) {\n+        database.lockMeta(data.session);\n+        data.schema = this;\n+        return new TableSynonym(data);\n     }\n+}\n \n-    /**\n+/**\n      * Add a linked table to the schema.\n      *\n      * @param id the object id\n@@ -766,14 +765,14 @@ public class Schema extends DbObjectBase {\n      * @param force create the object even if the database can not be accessed\n      * @return the {@link TableLink} object\n      */\n-    public TableLink createTableLink(int id, String tableName, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n-        synchronized (database) {\n-            return new TableLink(this, id, tableName,\n-                    driver, url, user, password,\n-                    originalSchema, originalTable, emitUpdates, force);\n-        }\n+public TableLink createTableLink(int id, String tableName, String driver,\n+        String url, String user, String password, String originalSchema,\n+        String originalTable, boolean emitUpdates, boolean force) {\n+    synchronized (database) {\n+        return new TableLink(this, id, tableName,\n+                driver, url, user, password,\n+                originalSchema, originalTable, emitUpdates, force);\n     }\n+}\n \n }\n",
            "diff_size": 439
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "161",
                    "column": "68",
                    "severity": "warning",
                    "message": "'{' at column 68 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "161",
                    "column": "68",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "162",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/105/Schema.java\nindex 242e4f750f..845beb70c5 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/105/Schema.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/105/Schema.java\n@@ -158,151 +158,151 @@ public class Schema extends DbObjectBase {\n                     if (dependentTable == null) {\n                         database.removeSchemaObject(session, obj);\n                         newModified = true;\n-                    } else if (dependentTable.getSchema() != this) {\n-                        throw DbException.get(ErrorCode.CANNOT_DROP_2, //\n-                                obj.getTraceSQL(), dependentTable.getTraceSQL());\n-                    } else if (!modified) {\n-                        dependentTable.removeColumnExpressionsDependencies(session);\n-                        dependentTable.setModified();\n-                        database.updateMeta(session, dependentTable);\n-                    }\n-                }\n-            }\n-            modified = newModified;\n-        }\n-        removeChildrenFromMap(session, domains);\n-        removeChildrenFromMap(session, indexes);\n-        removeChildrenFromMap(session, sequences);\n-        removeChildrenFromMap(session, constants);\n-        removeChildrenFromMap(session, functions);\n-        for (Right right : database.getAllRights()) {\n-            if (right.getGrantedObject() == this) {\n-                database.removeDatabaseObject(session, right);\n-            }\n-        }\n-        database.removeMeta(session, getId());\n-        owner = null;\n-        invalidate();\n-    }\n-\n-    private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n-        if (!map.isEmpty()) {\n-            for (SchemaObject obj : map.values()) {\n-                // Database.removeSchemaObject() removes the object from\n-                // the map too, but it is safe for ConcurrentHashMap.\n-                database.removeSchemaObject(session, obj);\n-            }\n-        }\n-    }\n-\n-    /**\n+                    } else if (dependentTable.getSchema() != this) {throw\n+                            DbException.get(ErrorCode.CANNOT_DROP_2, //\n+                             obj.getTraceSQL(), dependentTable.getTraceSQL());\n+                 } else if (!modified) {\n+                     dependentTable.removeColumnExpressionsDependencies(session);\n+                     dependentTable.setModified();\n+                     database.updateMeta(session, dependentTable);\n+                 }\n+             }\n+         }\n+         modified = newModified;\n+     }\n+     removeChildrenFromMap(session, domains);\n+     removeChildrenFromMap(session, indexes);\n+     removeChildrenFromMap(session, sequences);\n+     removeChildrenFromMap(session, constants);\n+     removeChildrenFromMap(session, functions);\n+     for (Right right : database.getAllRights()) {\n+         if (right.getGrantedObject() == this) {\n+             database.removeDatabaseObject(session, right);\n+         }\n+     }\n+     database.removeMeta(session, getId());\n+     owner = null;\n+     invalidate();\n+ }\n+\n+ private void removeChildrenFromMap(Session session, ConcurrentHashMap<String, ? extends SchemaObject> map) {\n+     if (!map.isEmpty()) {\n+         for (SchemaObject obj : map.values()) {\n+             // Database.removeSchemaObject() removes the object from\n+             // the map too, but it is safe for ConcurrentHashMap.\n+             database.removeSchemaObject(session, obj);\n+         }\n+     }\n+ }\n+\n+ /**\n      * Get the owner of this schema.\n      *\n      * @return the owner\n      */\n-    public User getOwner() {\n-        return owner;\n-    }\n+ public User getOwner() {\n+     return owner;\n+ }\n \n-    /**\n+ /**\n      * Get table engine params of this schema.\n      *\n      * @return default table engine params\n      */\n-    public ArrayList<String> getTableEngineParams() {\n-        return tableEngineParams;\n-    }\n+ public ArrayList<String> getTableEngineParams() {\n+     return tableEngineParams;\n+ }\n \n-    /**\n+ /**\n      * Set table engine params of this schema.\n      * @param tableEngineParams default table engine params\n      */\n-    public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n-        this.tableEngineParams = tableEngineParams;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String, SchemaObject> getMap(int type) {\n-        Map<String, ? extends SchemaObject> result;\n-        switch (type) {\n-        case DbObject.TABLE_OR_VIEW:\n-            result = tablesAndViews;\n-            break;\n-        case DbObject.DOMAIN:\n-            result = domains;\n-            break;\n-        case DbObject.SYNONYM:\n-            result = synonyms;\n-            break;\n-        case DbObject.SEQUENCE:\n-            result = sequences;\n-            break;\n-        case DbObject.INDEX:\n-            result = indexes;\n-            break;\n-        case DbObject.TRIGGER:\n-            result = triggers;\n-            break;\n-        case DbObject.CONSTRAINT:\n-            result = constraints;\n-            break;\n-        case DbObject.CONSTANT:\n-            result = constants;\n-            break;\n-        case DbObject.FUNCTION_ALIAS:\n-            result = functions;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + type);\n-        }\n-        return (Map<String, SchemaObject>) result;\n-    }\n-\n-    /**\n+ public void setTableEngineParams(ArrayList<String> tableEngineParams) {\n+     this.tableEngineParams = tableEngineParams;\n+ }\n+\n+ @SuppressWarnings(\"unchecked\")\n+ private Map<String, SchemaObject> getMap(int type) {\n+     Map<String, ? extends SchemaObject> result;\n+     switch (type) {\n+     case DbObject.TABLE_OR_VIEW:\n+         result = tablesAndViews;\n+         break;\n+     case DbObject.DOMAIN:\n+         result = domains;\n+         break;\n+     case DbObject.SYNONYM:\n+         result = synonyms;\n+         break;\n+     case DbObject.SEQUENCE:\n+         result = sequences;\n+         break;\n+     case DbObject.INDEX:\n+         result = indexes;\n+         break;\n+     case DbObject.TRIGGER:\n+         result = triggers;\n+         break;\n+     case DbObject.CONSTRAINT:\n+         result = constraints;\n+         break;\n+     case DbObject.CONSTANT:\n+         result = constants;\n+         break;\n+     case DbObject.FUNCTION_ALIAS:\n+         result = functions;\n+         break;\n+     default:\n+         throw DbException.throwInternalError(\"type=\" + type);\n+     }\n+     return (Map<String, SchemaObject>) result;\n+ }\n+\n+ /**\n      * Add an object to this schema.\n      * This method must not be called within CreateSchemaObject;\n      * use Database.addSchemaObject() instead\n      *\n      * @param obj the object to add\n      */\n-    public void add(SchemaObject obj) {\n-        if (obj.getSchema() != this) {\n-            DbException.throwInternalError(\"wrong schema\");\n-        }\n-        String name = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.putIfAbsent(name, obj) != null) {\n-            DbException.throwInternalError(\"object already exists: \" + name);\n-        }\n-        freeUniqueName(name);\n-    }\n-\n-    /**\n+ public void add(SchemaObject obj) {\n+     if (obj.getSchema() != this) {\n+         DbException.throwInternalError(\"wrong schema\");\n+     }\n+     String name = obj.getName();\n+     Map<String, SchemaObject> map = getMap(obj.getType());\n+     if (map.putIfAbsent(name, obj) != null) {\n+         DbException.throwInternalError(\"object already exists: \" + name);\n+     }\n+     freeUniqueName(name);\n+ }\n+\n+ /**\n      * Rename an object.\n      *\n      * @param obj the object to rename\n      * @param newName the new name\n      */\n-    public void rename(SchemaObject obj, String newName) {\n-        int type = obj.getType();\n-        Map<String, SchemaObject> map = getMap(type);\n-        if (SysProperties.CHECK) {\n-            if (!map.containsKey(obj.getName())) {\n-                DbException.throwInternalError(\"not found: \" + obj.getName());\n-            }\n-            if (obj.getName().equals(newName) || map.containsKey(newName)) {\n-                DbException.throwInternalError(\"object already exists: \" + newName);\n-            }\n-        }\n-        obj.checkRename();\n-        map.remove(obj.getName());\n-        freeUniqueName(obj.getName());\n-        obj.rename(newName);\n-        map.put(newName, obj);\n-        freeUniqueName(newName);\n-    }\n-\n-    /**\n+ public void rename(SchemaObject obj, String newName) {\n+     int type = obj.getType();\n+     Map<String, SchemaObject> map = getMap(type);\n+     if (SysProperties.CHECK) {\n+         if (!map.containsKey(obj.getName())) {\n+             DbException.throwInternalError(\"not found: \" + obj.getName());\n+         }\n+         if (obj.getName().equals(newName) || map.containsKey(newName)) {\n+             DbException.throwInternalError(\"object already exists: \" + newName);\n+         }\n+     }\n+     obj.checkRename();\n+     map.remove(obj.getName());\n+     freeUniqueName(obj.getName());\n+     obj.rename(newName);\n+     map.put(newName, obj);\n+     freeUniqueName(newName);\n+ }\n+\n+ /**\n      * Try to find a table or view with this name. This method returns null if\n      * no object with this name exists. Local temporary tables are also\n      * returned. Synonyms are not returned or resolved.\n@@ -311,15 +311,15 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Table findTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null && session != null) {\n-            table = session.findLocalTempTable(name);\n-        }\n-        return table;\n-    }\n+ public Table findTableOrView(Session session, String name) {\n+     Table table = tablesAndViews.get(name);\n+     if (table == null && session != null) {\n+         table = session.findLocalTempTable(name);\n+     }\n+     return table;\n+ }\n \n-    /**\n+ /**\n      * Try to find a table or view with this name. This method returns null if\n      * no object with this name exists. Local temporary tables are also\n      * returned. If a synonym with this name exists, the backing table of the\n@@ -329,39 +329,39 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Table resolveTableOrView(Session session, String name) {\n-        Table table = findTableOrView(session, name);\n-        if (table == null) {\n-            TableSynonym synonym = synonyms.get(name);\n-            if (synonym != null) {\n-                return synonym.getSynonymFor();\n-            }\n-        }\n-        return table;\n-    }\n-\n-    /**\n+ public Table resolveTableOrView(Session session, String name) {\n+     Table table = findTableOrView(session, name);\n+     if (table == null) {\n+         TableSynonym synonym = synonyms.get(name);\n+         if (synonym != null) {\n+             return synonym.getSynonymFor();\n+         }\n+     }\n+     return table;\n+ }\n+\n+ /**\n      * Try to find a synonym with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param name the object name\n      * @return the object or null\n      */\n-    public TableSynonym getSynonym(String name) {\n-        return synonyms.get(name);\n-    }\n+ public TableSynonym getSynonym(String name) {\n+     return synonyms.get(name);\n+ }\n \n-    /**\n+ /**\n      * Get the domain if it exists, or null if not.\n      *\n      * @param name the name of the domain\n      * @return the domain or null\n      */\n-    public Domain findDomain(String name) {\n-        return domains.get(name);\n-    }\n+ public Domain findDomain(String name) {\n+     return domains.get(name);\n+ }\n \n-    /**\n+ /**\n      * Try to find an index with this name. This method returns null if\n      * no object with this name exists.\n      *\n@@ -369,37 +369,37 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Index findIndex(Session session, String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            index = session.findLocalTempTableIndex(name);\n-        }\n-        return index;\n-    }\n+ public Index findIndex(Session session, String name) {\n+     Index index = indexes.get(name);\n+     if (index == null) {\n+         index = session.findLocalTempTableIndex(name);\n+     }\n+     return index;\n+ }\n \n-    /**\n+ /**\n      * Try to find a trigger with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param name the object name\n      * @return the object or null\n      */\n-    public TriggerObject findTrigger(String name) {\n-        return triggers.get(name);\n-    }\n+ public TriggerObject findTrigger(String name) {\n+     return triggers.get(name);\n+ }\n \n-    /**\n+ /**\n      * Try to find a sequence with this name. This method returns null if\n      * no object with this name exists.\n      *\n      * @param sequenceName the object name\n      * @return the object or null\n      */\n-    public Sequence findSequence(String sequenceName) {\n-        return sequences.get(sequenceName);\n-    }\n+ public Sequence findSequence(String sequenceName) {\n+     return sequences.get(sequenceName);\n+ }\n \n-    /**\n+ /**\n      * Try to find a constraint with this name. This method returns null if no\n      * object with this name exists.\n      *\n@@ -407,104 +407,104 @@ public class Schema extends DbObjectBase {\n      * @param name the object name\n      * @return the object or null\n      */\n-    public Constraint findConstraint(Session session, String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            constraint = session.findLocalTempTableConstraint(name);\n-        }\n-        return constraint;\n-    }\n+ public Constraint findConstraint(Session session, String name) {\n+     Constraint constraint = constraints.get(name);\n+     if (constraint == null) {\n+         constraint = session.findLocalTempTableConstraint(name);\n+     }\n+     return constraint;\n+ }\n \n-    /**\n+ /**\n      * Try to find a user defined constant with this name. This method returns\n      * null if no object with this name exists.\n      *\n      * @param constantName the object name\n      * @return the object or null\n      */\n-    public Constant findConstant(String constantName) {\n-        return constants.get(constantName);\n-    }\n+ public Constant findConstant(String constantName) {\n+     return constants.get(constantName);\n+ }\n \n-    /**\n+ /**\n      * Try to find a user defined function with this name. This method returns\n      * null if no object with this name exists.\n      *\n      * @param functionAlias the object name\n      * @return the object or null\n      */\n-    public FunctionAlias findFunction(String functionAlias) {\n-        return functions.get(functionAlias);\n-    }\n+ public FunctionAlias findFunction(String functionAlias) {\n+     return functions.get(functionAlias);\n+ }\n \n-    /**\n+ /**\n      * Release a unique object name.\n      *\n      * @param name the object name\n      */\n-    public void freeUniqueName(String name) {\n-        if (name != null) {\n-            synchronized (temporaryUniqueNames) {\n-                temporaryUniqueNames.remove(name);\n-            }\n-        }\n-    }\n-\n-    private String getUniqueName(DbObject obj,\n-            Map<String, ? extends SchemaObject> map, String prefix) {\n-        String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n-        String name = null;\n-        synchronized (temporaryUniqueNames) {\n-            for (int i = 1, len = hash.length(); i < len; i++) {\n-                name = prefix + hash.substring(0, i);\n-                if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                    break;\n-                }\n-                name = null;\n-            }\n-            if (name == null) {\n-                prefix = prefix + hash + \"_\";\n-                for (int i = 0;; i++) {\n-                    name = prefix + i;\n-                    if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n-                        break;\n-                    }\n-                }\n-            }\n-            temporaryUniqueNames.add(name);\n-        }\n-        return name;\n-    }\n-\n-    /**\n+ public void freeUniqueName(String name) {\n+     if (name != null) {\n+         synchronized (temporaryUniqueNames) {\n+             temporaryUniqueNames.remove(name);\n+         }\n+     }\n+ }\n+\n+ private String getUniqueName(DbObject obj,\n+         Map<String, ? extends SchemaObject> map, String prefix) {\n+     String hash = StringUtils.toUpperEnglish(Integer.toHexString(obj.getName().hashCode()));\n+     String name = null;\n+     synchronized (temporaryUniqueNames) {\n+         for (int i = 1, len = hash.length(); i < len; i++) {\n+             name = prefix + hash.substring(0, i);\n+             if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+                 break;\n+             }\n+             name = null;\n+         }\n+         if (name == null) {\n+             prefix = prefix + hash + \"_\";\n+             for (int i = 0;; i++) {\n+                 name = prefix + i;\n+                 if (!map.containsKey(name) && !temporaryUniqueNames.contains(name)) {\n+                     break;\n+                 }\n+             }\n+         }\n+         temporaryUniqueNames.add(name);\n+     }\n+     return name;\n+ }\n+\n+ /**\n      * Create a unique constraint name.\n      *\n      * @param session the session\n      * @param table the constraint table\n      * @return the unique name\n      */\n-    public String getUniqueConstraintName(Session session, Table table) {\n-        Map<String, Constraint> tableConstraints;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableConstraints = session.getLocalTempTableConstraints();\n-        } else {\n-            tableConstraints = constraints;\n-        }\n-        return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n-    }\n-\n-    /**\n+ public String getUniqueConstraintName(Session session, Table table) {\n+     Map<String, Constraint> tableConstraints;\n+     if (table.isTemporary() && !table.isGlobalTemporary()) {\n+         tableConstraints = session.getLocalTempTableConstraints();\n+     } else {\n+         tableConstraints = constraints;\n+     }\n+     return getUniqueName(table, tableConstraints, \"CONSTRAINT_\");\n+ }\n+\n+ /**\n      * Create a unique constraint name.\n      *\n      * @param session the session\n      * @param domain the constraint domain\n      * @return the unique name\n      */\n-    public String getUniqueDomainConstraintName(Session session, Domain domain) {\n-        return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n-    }\n+ public String getUniqueDomainConstraintName(Session session, Domain domain) {\n+     return getUniqueName(domain, constraints, \"CONSTRAINT_\");\n+ }\n \n-    /**\n+ /**\n      * Create a unique index name.\n      *\n      * @param session the session\n@@ -512,17 +512,17 @@ public class Schema extends DbObjectBase {\n      * @param prefix the index name prefix\n      * @return the unique name\n      */\n-    public String getUniqueIndexName(Session session, Table table, String prefix) {\n-        Map<String, Index> tableIndexes;\n-        if (table.isTemporary() && !table.isGlobalTemporary()) {\n-            tableIndexes = session.getLocalTempTableIndexes();\n-        } else {\n-            tableIndexes = indexes;\n-        }\n-        return getUniqueName(table, tableIndexes, prefix);\n-    }\n-\n-    /**\n+ public String getUniqueIndexName(Session session, Table table, String prefix) {\n+     Map<String, Index> tableIndexes;\n+     if (table.isTemporary() && !table.isGlobalTemporary()) {\n+         tableIndexes = session.getLocalTempTableIndexes();\n+     } else {\n+         tableIndexes = indexes;\n+     }\n+     return getUniqueName(table, tableIndexes, prefix);\n+ }\n+\n+ /**\n      * Get the table or view with the given name.\n      * Local temporary tables are also returned.\n      *\n@@ -531,95 +531,95 @@ public class Schema extends DbObjectBase {\n      * @return the table or view\n      * @throws DbException if no such object exists\n      */\n-    public Table getTableOrView(Session session, String name) {\n-        Table table = tablesAndViews.get(name);\n-        if (table == null) {\n-            if (session != null) {\n-                table = session.findLocalTempTable(name);\n-            }\n-            if (table == null) {\n-                throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n-            }\n-        }\n-        return table;\n-    }\n-\n-    /**\n+ public Table getTableOrView(Session session, String name) {\n+     Table table = tablesAndViews.get(name);\n+     if (table == null) {\n+         if (session != null) {\n+             table = session.findLocalTempTable(name);\n+         }\n+         if (table == null) {\n+             throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, name);\n+         }\n+     }\n+     return table;\n+ }\n+\n+ /**\n      * Get the domain with the given name.\n      *\n      * @param name the domain name\n      * @return the domain\n      * @throws DbException if no such object exists\n      */\n-    public Domain getDomain(String name) {\n-        Domain domain = domains.get(name);\n-        if (domain == null) {\n-            throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n-        }\n-        return domain;\n-    }\n+ public Domain getDomain(String name) {\n+     Domain domain = domains.get(name);\n+     if (domain == null) {\n+         throw DbException.get(ErrorCode.DOMAIN_NOT_FOUND_1, name);\n+     }\n+     return domain;\n+ }\n \n-    /**\n+ /**\n      * Get the index with the given name.\n      *\n      * @param name the index name\n      * @return the index\n      * @throws DbException if no such object exists\n      */\n-    public Index getIndex(String name) {\n-        Index index = indexes.get(name);\n-        if (index == null) {\n-            throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n-        }\n-        return index;\n-    }\n+ public Index getIndex(String name) {\n+     Index index = indexes.get(name);\n+     if (index == null) {\n+         throw DbException.get(ErrorCode.INDEX_NOT_FOUND_1, name);\n+     }\n+     return index;\n+ }\n \n-    /**\n+ /**\n      * Get the constraint with the given name.\n      *\n      * @param name the constraint name\n      * @return the constraint\n      * @throws DbException if no such object exists\n      */\n-    public Constraint getConstraint(String name) {\n-        Constraint constraint = constraints.get(name);\n-        if (constraint == null) {\n-            throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n-        }\n-        return constraint;\n-    }\n+ public Constraint getConstraint(String name) {\n+     Constraint constraint = constraints.get(name);\n+     if (constraint == null) {\n+         throw DbException.get(ErrorCode.CONSTRAINT_NOT_FOUND_1, name);\n+     }\n+     return constraint;\n+ }\n \n-    /**\n+ /**\n      * Get the user defined constant with the given name.\n      *\n      * @param constantName the constant name\n      * @return the constant\n      * @throws DbException if no such object exists\n      */\n-    public Constant getConstant(String constantName) {\n-        Constant constant = constants.get(constantName);\n-        if (constant == null) {\n-            throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n-        }\n-        return constant;\n-    }\n+ public Constant getConstant(String constantName) {\n+     Constant constant = constants.get(constantName);\n+     if (constant == null) {\n+         throw DbException.get(ErrorCode.CONSTANT_NOT_FOUND_1, constantName);\n+     }\n+     return constant;\n+ }\n \n-    /**\n+ /**\n      * Get the sequence with the given name.\n      *\n      * @param sequenceName the sequence name\n      * @return the sequence\n      * @throws DbException if no such object exists\n      */\n-    public Sequence getSequence(String sequenceName) {\n-        Sequence sequence = sequences.get(sequenceName);\n-        if (sequence == null) {\n-            throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n-        }\n-        return sequence;\n-    }\n+ public Sequence getSequence(String sequenceName) {\n+     Sequence sequence = sequences.get(sequenceName);\n+     if (sequence == null) {\n+         throw DbException.get(ErrorCode.SEQUENCE_NOT_FOUND_1, sequenceName);\n+     }\n+     return sequence;\n+ }\n \n-    /**\n+ /**\n      * Get all objects.\n      *\n      * @param addTo\n@@ -628,23 +628,23 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with all objects\n      */\n-    public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n-        if (addTo == null) {\n-            addTo = Utils.newSmallArrayList();\n-        }\n-        addTo.addAll(tablesAndViews.values());\n-        addTo.addAll(domains.values());\n-        addTo.addAll(synonyms.values());\n-        addTo.addAll(sequences.values());\n-        addTo.addAll(indexes.values());\n-        addTo.addAll(triggers.values());\n-        addTo.addAll(constraints.values());\n-        addTo.addAll(constants.values());\n-        addTo.addAll(functions.values());\n-        return addTo;\n-    }\n-\n-    /**\n+ public ArrayList<SchemaObject> getAll(ArrayList<SchemaObject> addTo) {\n+     if (addTo == null) {\n+         addTo = Utils.newSmallArrayList();\n+     }\n+     addTo.addAll(tablesAndViews.values());\n+     addTo.addAll(domains.values());\n+     addTo.addAll(synonyms.values());\n+     addTo.addAll(sequences.values());\n+     addTo.addAll(indexes.values());\n+     addTo.addAll(triggers.values());\n+     addTo.addAll(constraints.values());\n+     addTo.addAll(constants.values());\n+     addTo.addAll(functions.values());\n+     return addTo;\n+ }\n+\n+ /**\n      * Get all objects of the given type.\n      *\n      * @param type\n@@ -655,103 +655,103 @@ public class Schema extends DbObjectBase {\n      * @return the specified list with added objects, or a new (possibly empty) list\n      *         with objects of the given type\n      */\n-    public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n-        Collection<SchemaObject> values = getMap(type).values();\n-        if (addTo != null) {\n-            addTo.addAll(values);\n-        } else {\n-            addTo = new ArrayList<>(values);\n-        }\n-        return addTo;\n-    }\n-\n-    /**\n+ public ArrayList<SchemaObject> getAll(int type, ArrayList<SchemaObject> addTo) {\n+     Collection<SchemaObject> values = getMap(type).values();\n+     if (addTo != null) {\n+         addTo.addAll(values);\n+     } else {\n+         addTo = new ArrayList<>(values);\n+     }\n+     return addTo;\n+ }\n+\n+ /**\n      * Get all tables and views.\n      *\n      * @return a (possible empty) list of all objects\n      */\n-    public Collection<Table> getAllTablesAndViews() {\n-        return tablesAndViews.values();\n-    }\n+ public Collection<Table> getAllTablesAndViews() {\n+     return tablesAndViews.values();\n+ }\n \n \n-    public Collection<TableSynonym> getAllSynonyms() {\n-        return synonyms.values();\n-    }\n+ public Collection<TableSynonym> getAllSynonyms() {\n+     return synonyms.values();\n+ }\n \n-    public Collection<FunctionAlias> getAllFunctionAliases() {\n-        return functions.values();\n-    }\n+ public Collection<FunctionAlias> getAllFunctionAliases() {\n+     return functions.values();\n+ }\n \n-    /**\n+ /**\n      * Get the table with the given name, if any.\n      *\n      * @param name the table name\n      * @return the table or null if not found\n      */\n-    public Table getTableOrViewByName(String name) {\n-        return tablesAndViews.get(name);\n-    }\n+ public Table getTableOrViewByName(String name) {\n+     return tablesAndViews.get(name);\n+ }\n \n-    /**\n+ /**\n      * Remove an object from this schema.\n      *\n      * @param obj the object to remove\n      */\n-    public void remove(SchemaObject obj) {\n-        String objName = obj.getName();\n-        Map<String, SchemaObject> map = getMap(obj.getType());\n-        if (map.remove(objName) == null) {\n-            DbException.throwInternalError(\"not found: \" + objName);\n-        }\n-        freeUniqueName(objName);\n-    }\n+ public void remove(SchemaObject obj) {\n+     String objName = obj.getName();\n+     Map<String, SchemaObject> map = getMap(obj.getType());\n+     if (map.remove(objName) == null) {\n+         DbException.throwInternalError(\"not found: \" + objName);\n+     }\n+     freeUniqueName(objName);\n+ }\n \n-    /**\n+ /**\n      * Add a table to the schema.\n      *\n      * @param data the create table information\n      * @return the created {@link Table} object\n      */\n-    public Table createTable(CreateTableData data) {\n-        synchronized (database) {\n-            if (!data.temporary || data.globalTemporary) {\n-                database.lockMeta(data.session);\n-            }\n-            data.schema = this;\n-            if (data.tableEngine == null) {\n-                DbSettings s = database.getSettings();\n-                if (s.defaultTableEngine != null) {\n-                    data.tableEngine = s.defaultTableEngine;\n-                } else if (s.mvStore) {\n-                    data.tableEngine = MVTableEngine.class.getName();\n-                }\n-            }\n-            if (data.tableEngine != null) {\n-                if (data.tableEngineParams == null) {\n-                    data.tableEngineParams = this.tableEngineParams;\n-                }\n-                return database.getTableEngine(data.tableEngine).createTable(data);\n-            }\n-            return new PageStoreTable(data);\n-        }\n-    }\n-\n-    /**\n+ public Table createTable(CreateTableData data) {\n+     synchronized (database) {\n+         if (!data.temporary || data.globalTemporary) {\n+             database.lockMeta(data.session);\n+         }\n+         data.schema = this;\n+         if (data.tableEngine == null) {\n+             DbSettings s = database.getSettings();\n+             if (s.defaultTableEngine != null) {\n+                 data.tableEngine = s.defaultTableEngine;\n+             } else if (s.mvStore) {\n+                 data.tableEngine = MVTableEngine.class.getName();\n+             }\n+         }\n+         if (data.tableEngine != null) {\n+             if (data.tableEngineParams == null) {\n+                 data.tableEngineParams = this.tableEngineParams;\n+             }\n+             return database.getTableEngine(data.tableEngine).createTable(data);\n+         }\n+         return new PageStoreTable(data);\n+     }\n+ }\n+\n+ /**\n      * Add a table synonym to the schema.\n      *\n      * @param data the create synonym information\n      * @return the created {@link TableSynonym} object\n      */\n-    public TableSynonym createSynonym(CreateSynonymData data) {\n-        synchronized (database) {\n-            database.lockMeta(data.session);\n-            data.schema = this;\n-            return new TableSynonym(data);\n-        }\n-    }\n+ public TableSynonym createSynonym(CreateSynonymData data) {\n+     synchronized (database) {\n+         database.lockMeta(data.session);\n+         data.schema = this;\n+         return new TableSynonym(data);\n+     }\n+ }\n \n-    /**\n+ /**\n      * Add a linked table to the schema.\n      *\n      * @param id the object id\n@@ -766,14 +766,14 @@ public class Schema extends DbObjectBase {\n      * @param force create the object even if the database can not be accessed\n      * @return the {@link TableLink} object\n      */\n-    public TableLink createTableLink(int id, String tableName, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n-        synchronized (database) {\n-            return new TableLink(this, id, tableName,\n-                    driver, url, user, password,\n-                    originalSchema, originalTable, emitUpdates, force);\n-        }\n-    }\n+ public TableLink createTableLink(int id, String tableName, String driver,\n+         String url, String user, String password, String originalSchema,\n+         String originalTable, boolean emitUpdates, boolean force) {\n+     synchronized (database) {\n+         return new TableLink(this, id, tableName,\n+                 driver, url, user, password,\n+                 originalSchema, originalTable, emitUpdates, force);\n+     }\n+ }\n \n }\n",
            "diff_size": 389
        }
    ]
}