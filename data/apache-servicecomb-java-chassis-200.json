{
    "error_id": "200",
    "information": {
        "errors": [
            {
                "line": "154",
                "column": "41",
                "severity": "warning",
                "message": "'&&' should be on a new line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "    if (response != null) {\n      Model model = response.getResponseSchema();\n      return model instanceof ModelImpl &&\n          FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n    }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/styler/200/RestOperationMeta.java\nindex c952221bdc..9fa2b42db2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/styler/200/RestOperationMeta.java\n@@ -151,198 +151,198 @@ public class RestOperationMeta {\n     Response response = operationMeta.getSwaggerOperation().getResponses().get(\"200\");\n     if (response != null) {\n       Model model = response.getResponseSchema();\n-      return model instanceof ModelImpl &&\n-          FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n-    }\n+      return model instanceof ModelImpl\n+          && FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n+ }\n \n-    return false;\n-  }\n+ return false;\n+}\n \n-  public boolean isFormData() {\n-    return formData;\n-  }\n+public boolean isFormData() {\n+  return formData;\n+}\n \n-  public void setOperationMeta(OperationMeta operationMeta) {\n-    this.operationMeta = operationMeta;\n-  }\n+public void setOperationMeta(OperationMeta operationMeta) {\n+  this.operationMeta = operationMeta;\n+}\n \n-  // \u8f93\u51fab/c/\u5f62\u5f0f\u7684url\n-  private String concatPath(String basePath, String operationPath) {\n-    return (\"/\" + nonNullify(basePath) + \"/\" + nonNullify(operationPath) + \"/\")\n-        .replaceAll(\"/{2,}\", \"/\");\n-  }\n+// \u8f93\u51fab/c/\u5f62\u5f0f\u7684url\n+private String concatPath(String basePath, String operationPath) {\n+  return (\"/\" + nonNullify(basePath) + \"/\" + nonNullify(operationPath) + \"/\")\n+      .replaceAll(\"/{2,}\", \"/\");\n+}\n \n-  private String nonNullify(String path) {\n-    return path == null ? \"\" : path;\n-  }\n+private String nonNullify(String path) {\n+  return path == null ? \"\" : path;\n+}\n \n-  public String getAbsolutePath() {\n-    return this.absolutePath;\n-  }\n+public String getAbsolutePath() {\n+  return this.absolutePath;\n+}\n \n-  public void setAbsolutePath(String absolutePath) {\n-    this.absolutePath = absolutePath;\n-    this.absolutePathRegExp = createPathRegExp(absolutePath);\n-    this.pathBuilder = new URLPathBuilder(absolutePath, paramMap);\n-  }\n+public void setAbsolutePath(String absolutePath) {\n+  this.absolutePath = absolutePath;\n+  this.absolutePathRegExp = createPathRegExp(absolutePath);\n+  this.pathBuilder = new URLPathBuilder(absolutePath, paramMap);\n+}\n \n-  public PathRegExp getAbsolutePathRegExp() {\n-    return this.absolutePathRegExp;\n-  }\n+public PathRegExp getAbsolutePathRegExp() {\n+  return this.absolutePathRegExp;\n+}\n \n-  public boolean isAbsoluteStaticPath() {\n-    return this.absolutePathRegExp.isStaticPath();\n-  }\n+public boolean isAbsoluteStaticPath() {\n+  return this.absolutePathRegExp.isStaticPath();\n+}\n \n-  protected PathRegExp createPathRegExp(String path) {\n-    if (path == null || path.equals(\"\")) {\n-      throw new Error(\"null rest url is not supported\");\n-    }\n-    try {\n-      return new PathRegExp(path);\n-    } catch (Exception e) {\n-      LOGGER.error(e.getMessage());\n-      return null;\n-    }\n+protected PathRegExp createPathRegExp(String path) {\n+  if (path == null || path.equals(\"\")) {\n+    throw new Error(\"null rest url is not supported\");\n   }\n-\n-  public RestParam getParamByName(String name) {\n-    return paramMap.get(name);\n+  try {\n+    return new PathRegExp(path);\n+  } catch (Exception e) {\n+    LOGGER.error(e.getMessage());\n+    return null;\n   }\n+}\n \n-  public RestParam getParamByIndex(int index) {\n-    return paramList.get(index);\n-  }\n+public RestParam getParamByName(String name) {\n+  return paramMap.get(name);\n+}\n \n-  public OperationMeta getOperationMeta() {\n-    return operationMeta;\n-  }\n+public RestParam getParamByIndex(int index) {\n+  return paramList.get(index);\n+}\n \n-  // \u4e3aoperation\u521b\u5efa\u652f\u6301\u7684\u591a\u79cdproduce processor\n-  protected void createProduceProcessors() {\n-    if (null == produces || produces.isEmpty()) {\n-      ProduceProcessorManager.INSTANCE.getObjMap().forEach((processorName, prodMap) -> {\n-        this.produceProcessorAcceptMap.put(processorName, prodMap);\n-      });\n-    } else {\n-      for (String produce : produces) {\n-        if (produce.contains(\";\")) {\n-          produce = produce.substring(0, produce.indexOf(\";\"));\n-        }\n-        Map<String, ProduceProcessor> processorMap = ProduceProcessorManager.INSTANCE.findValue(produce);\n-        if (processorMap == null) {\n-          LOGGER.error(\"produce {} is not supported\", produce);\n-          continue;\n-        }\n-        this.produceProcessorAcceptMap.put(produce, processorMap);\n-      }\n+public OperationMeta getOperationMeta() {\n+  return operationMeta;\n+}\n \n-      if (produceProcessorAcceptMap.isEmpty()) {\n-        produceProcessorAcceptMap\n-            .put(ProduceProcessorManager.DEFAULT_TYPE, ProduceProcessorManager.INSTANCE.getDefaultProcessorMap());\n+// \u4e3aoperation\u521b\u5efa\u652f\u6301\u7684\u591a\u79cdproduce processor\n+protected void createProduceProcessors() {\n+  if (null == produces || produces.isEmpty()) {\n+    ProduceProcessorManager.INSTANCE.getObjMap().forEach((processorName, prodMap) -> {\n+      this.produceProcessorAcceptMap.put(processorName, prodMap);\n+    });\n+  } else {\n+    for (String produce : produces) {\n+      if (produce.contains(\";\")) {\n+        produce = produce.substring(0, produce.indexOf(\";\"));\n       }\n+      Map<String, ProduceProcessor> processorMap = ProduceProcessorManager.INSTANCE.findValue(produce);\n+      if (processorMap == null) {\n+        LOGGER.error(\"produce {} is not supported\", produce);\n+        continue;\n+      }\n+      this.produceProcessorAcceptMap.put(produce, processorMap);\n     }\n \n-    defaultProcessorViewMap = produceProcessorAcceptMap.values().stream().findFirst().get();\n-    produceProcessorAcceptMap.putIfAbsent(MediaType.WILDCARD, defaultProcessorViewMap);\n+    if (produceProcessorAcceptMap.isEmpty()) {\n+      produceProcessorAcceptMap\n+          .put(ProduceProcessorManager.DEFAULT_TYPE, ProduceProcessorManager.INSTANCE.getDefaultProcessorMap());\n+    }\n   }\n \n-  public URLPathBuilder getPathBuilder() {\n-    return this.pathBuilder;\n-  }\n+  defaultProcessorViewMap = produceProcessorAcceptMap.values().stream().findFirst().get();\n+  produceProcessorAcceptMap.putIfAbsent(MediaType.WILDCARD, defaultProcessorViewMap);\n+}\n \n-  public List<RestParam> getParamList() {\n-    return paramList;\n-  }\n+public URLPathBuilder getPathBuilder() {\n+  return this.pathBuilder;\n+}\n \n-  private void addParam(RestParam param) {\n-    if (param.getParamProcessor() instanceof PartProcessor) {\n-      fileKeys.add(param.getParamName());\n-    }\n-    paramList.add(param);\n-    paramMap.put(param.getParamName(), param);\n-  }\n+public List<RestParam> getParamList() {\n+  return paramList;\n+}\n \n-  public ProduceProcessor findProduceProcessor(String type, String serialView) {\n-    if (this.produceProcessorAcceptMap.get(type) == null) {\n-      LOGGER.error(String.format(\"Unable to  find produce processor with type/%s\", type));\n-      return null;\n-    }\n-    return this.produceProcessorAcceptMap.get(type).get(serialView);\n+private void addParam(RestParam param) {\n+  if (param.getParamProcessor() instanceof PartProcessor) {\n+    fileKeys.add(param.getParamName());\n   }\n+  paramList.add(param);\n+  paramMap.put(param.getParamName(), param);\n+}\n \n-  public ProduceProcessor findProduceProcessor(String type) {\n-    return findProduceProcessor(type, ProduceProcessorManager.DEFAULT_SERIAL_CLASS);\n+public ProduceProcessor findProduceProcessor(String type, String serialView) {\n+  if (this.produceProcessorAcceptMap.get(type) == null) {\n+    LOGGER.error(String.format(\"Unable to  find produce processor with type/%s\", type));\n+    return null;\n   }\n+  return this.produceProcessorAcceptMap.get(type).get(serialView);\n+}\n \n-  // \u9009\u62e9\u4e0eaccept\u5339\u914d\u7684produce processor\u6216\u8005\u7f3a\u7701\u7684\n-  public ProduceProcessor ensureFindProduceProcessor(HttpServletRequestEx requestEx) {\n-    String acceptType = requestEx.getHeader(HttpHeaders.ACCEPT);\n-    SwaggerProducerOperation producerOperation = operationMeta.getExtData(Const.PRODUCER_OPERATION);\n-    if (producerOperation == null || producerOperation.getProducerMethod() == null) {\n-      return ensureFindProduceProcessor(acceptType);\n-    }\n-    return ensureFindProduceProcessor(acceptType, producerOperation.getProducerMethod().getDeclaredAnnotations());\n+public ProduceProcessor findProduceProcessor(String type) {\n+  return findProduceProcessor(type, ProduceProcessorManager.DEFAULT_SERIAL_CLASS);\n+}\n+\n+// \u9009\u62e9\u4e0eaccept\u5339\u914d\u7684produce processor\u6216\u8005\u7f3a\u7701\u7684\n+public ProduceProcessor ensureFindProduceProcessor(HttpServletRequestEx requestEx) {\n+  String acceptType = requestEx.getHeader(HttpHeaders.ACCEPT);\n+  SwaggerProducerOperation producerOperation = operationMeta.getExtData(Const.PRODUCER_OPERATION);\n+  if (producerOperation == null || producerOperation.getProducerMethod() == null) {\n+    return ensureFindProduceProcessor(acceptType);\n   }\n+  return ensureFindProduceProcessor(acceptType, producerOperation.getProducerMethod().getDeclaredAnnotations());\n+}\n \n-  public ProduceProcessor ensureFindProduceProcessor(String acceptType) {\n+public ProduceProcessor ensureFindProduceProcessor(String acceptType) {\n+  return doEnsureFindProduceProcessor(acceptType, null);\n+}\n+\n+public ProduceProcessor ensureFindProduceProcessor(String acceptType, Annotation[] annotations) {\n+  if (annotations == null || annotations.length < 1) {\n     return doEnsureFindProduceProcessor(acceptType, null);\n   }\n-\n-  public ProduceProcessor ensureFindProduceProcessor(String acceptType, Annotation[] annotations) {\n-    if (annotations == null || annotations.length < 1) {\n-      return doEnsureFindProduceProcessor(acceptType, null);\n-    }\n-    for (Annotation annotation : annotations) {\n-      if (annotation.annotationType() == JsonView.class) {\n-        Class<?>[] value = ((JsonView) annotation).value();\n-        if (value.length != 1) {\n-          throw new IllegalArgumentException(\n-              \"@JsonView only supported for exactly 1 class argument \");\n-        }\n-        return doEnsureFindProduceProcessor(acceptType, value[0]);\n+  for (Annotation annotation : annotations) {\n+    if (annotation.annotationType() == JsonView.class) {\n+      Class<?>[] value = ((JsonView) annotation).value();\n+      if (value.length != 1) {\n+        throw new IllegalArgumentException(\n+            \"@JsonView only supported for exactly 1 class argument \");\n       }\n+      return doEnsureFindProduceProcessor(acceptType, value[0]);\n     }\n-    return doEnsureFindProduceProcessor(acceptType, null);\n   }\n+  return doEnsureFindProduceProcessor(acceptType, null);\n+}\n \n-  private ProduceProcessor doEnsureFindProduceProcessor(String acceptType, Class<?> serialViewClass) {\n-    String serialViewKey =\n-        (serialViewClass == null ? ProduceProcessorManager.DEFAULT_SERIAL_CLASS : serialViewClass.getCanonicalName());\n-    if (downloadFile) {\n-      //do not check accept type, when the produces of provider is text/plain there will return text/plain processor\n-      //when the produces of provider is application/json there will return the application/json processor\n-      //so do not care what accept type the consumer will set.\n-      return this.produceProcessorAcceptMap.get(MediaType.WILDCARD)\n-          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n-              acceptType, serialViewClass, produceProcessorAcceptMap.get(MediaType.WILDCARD)));\n-    }\n-    if (StringUtils.isEmpty(acceptType)) {\n-      return defaultProcessorViewMap\n-          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n-              acceptType, serialViewClass, defaultProcessorViewMap));\n-    }\n-    List<String> mimeTypes = MimeTypesUtils.getSortedAcceptableMimeTypes(acceptType.toLowerCase(Locale.US));\n-    for (String mime : mimeTypes) {\n-      Map<String, ProduceProcessor> processorMap = this.produceProcessorAcceptMap.get(mime);\n-      if (null != processorMap) {\n-        return processorMap.computeIfAbsent(serialViewKey, key ->\n-            ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, processorMap));\n-      }\n+private ProduceProcessor doEnsureFindProduceProcessor(String acceptType, Class<?> serialViewClass) {\n+  String serialViewKey =\n+      (serialViewClass == null ? ProduceProcessorManager.DEFAULT_SERIAL_CLASS : serialViewClass.getCanonicalName());\n+  if (downloadFile) {\n+    //do not check accept type, when the produces of provider is text/plain there will return text/plain processor\n+    //when the produces of provider is application/json there will return the application/json processor\n+    //so do not care what accept type the consumer will set.\n+    return this.produceProcessorAcceptMap.get(MediaType.WILDCARD)\n+        .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n+            acceptType, serialViewClass, produceProcessorAcceptMap.get(MediaType.WILDCARD)));\n+  }\n+  if (StringUtils.isEmpty(acceptType)) {\n+    return defaultProcessorViewMap\n+        .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n+            acceptType, serialViewClass, defaultProcessorViewMap));\n+  }\n+  List<String> mimeTypes = MimeTypesUtils.getSortedAcceptableMimeTypes(acceptType.toLowerCase(Locale.US));\n+  for (String mime : mimeTypes) {\n+    Map<String, ProduceProcessor> processorMap = this.produceProcessorAcceptMap.get(mime);\n+    if (null != processorMap) {\n+      return processorMap.computeIfAbsent(serialViewKey, key ->\n+          ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, processorMap));\n     }\n-\n-    return null;\n   }\n \n-  public String getHttpMethod() {\n-    return operationMeta.getHttpMethod();\n-  }\n+  return null;\n+}\n \n-  public List<String> getFileKeys() {\n-    return fileKeys;\n-  }\n+public String getHttpMethod() {\n+  return operationMeta.getHttpMethod();\n+}\n \n-  public List<String> getProduces() {\n-    return produces;\n-  }\n+public List<String> getFileKeys() {\n+  return fileKeys;\n+}\n+\n+public List<String> getProduces() {\n+  return produces;\n+}\n }\n",
            "diff_size": 194
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "155",
                    "column": "41",
                    "severity": "warning",
                    "message": "'&&' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/intellij/200/RestOperationMeta.java\nindex c952221bdc..0747e040a9 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/intellij/200/RestOperationMeta.java\n@@ -122,8 +122,9 @@ public class RestOperationMeta {\n   /**\n    * EdgeService cannot recognize the map type form body whose value type is String,\n    * so there should be this additional setting.\n+   *\n    * @param parameter the swagger information of the parameter\n-   * @param type the resolved param type\n+   * @param type      the resolved param type\n    * @return the corrected param type\n    */\n   private Type correctFormBodyType(Parameter parameter, Type type) {\n",
            "diff_size": 2
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "156",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "318",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "322",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "328",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/naturalize/200/RestOperationMeta.java\nindex c952221bdc..b32c13be7b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/naturalize/200/RestOperationMeta.java\n@@ -130,11 +130,13 @@ public class RestOperationMeta {\n     if (null != type || !(parameter instanceof BodyParameter)) {\n       return type;\n     }\n-    final BodyParameter bodyParameter = (BodyParameter) parameter;\n+\n+final BodyParameter bodyParameter = (BodyParameter) parameter;\n     if (!(bodyParameter.getSchema() instanceof ModelImpl)) {\n       return type;\n     }\n-    final Property additionalProperties = ((ModelImpl) bodyParameter.getSchema()).getAdditionalProperties();\n+\n+final Property additionalProperties = ((ModelImpl) bodyParameter.getSchema()).getAdditionalProperties();\n     if (additionalProperties instanceof StringProperty) {\n       type = RestObjectMapperFactory.getRestObjectMapper().getTypeFactory()\n           .constructMapType(Map.class, String.class, String.class);\n@@ -151,8 +153,7 @@ public class RestOperationMeta {\n     Response response = operationMeta.getSwaggerOperation().getResponses().get(\"200\");\n     if (response != null) {\n       Model model = response.getResponseSchema();\n-      return model instanceof ModelImpl &&\n-          FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n+      return model instanceof ModelImpl && FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n     }\n \n     return false;\n@@ -314,20 +315,17 @@ public class RestOperationMeta {\n       //when the produces of provider is application/json there will return the application/json processor\n       //so do not care what accept type the consumer will set.\n       return this.produceProcessorAcceptMap.get(MediaType.WILDCARD)\n-          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n-              acceptType, serialViewClass, produceProcessorAcceptMap.get(MediaType.WILDCARD)));\n+          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, produceProcessorAcceptMap.get(MediaType.WILDCARD)));\n     }\n     if (StringUtils.isEmpty(acceptType)) {\n       return defaultProcessorViewMap\n-          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n-              acceptType, serialViewClass, defaultProcessorViewMap));\n-    }\n+          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, defaultProcessorViewMap));\n+  }\n     List<String> mimeTypes = MimeTypesUtils.getSortedAcceptableMimeTypes(acceptType.toLowerCase(Locale.US));\n     for (String mime : mimeTypes) {\n       Map<String, ProduceProcessor> processorMap = this.produceProcessorAcceptMap.get(mime);\n       if (null != processorMap) {\n-        return processorMap.computeIfAbsent(serialViewKey, key ->\n-            ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, processorMap));\n+        return processorMap.computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, processorMap));\n       }\n     }\n \n@@ -345,4 +343,4 @@ public class RestOperationMeta {\n   public List<String> getProduces() {\n     return produces;\n   }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 14
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/styler_random/200/RestOperationMeta.java\nindex c952221bdc..9fa2b42db2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/errored/1/200/RestOperationMeta.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/apache-servicecomb-java-chassis/styler_random/200/RestOperationMeta.java\n@@ -151,198 +151,198 @@ public class RestOperationMeta {\n     Response response = operationMeta.getSwaggerOperation().getResponses().get(\"200\");\n     if (response != null) {\n       Model model = response.getResponseSchema();\n-      return model instanceof ModelImpl &&\n-          FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n-    }\n+      return model instanceof ModelImpl\n+          && FileProperty.isType(((ModelImpl) model).getType(), ((ModelImpl) model).getFormat());\n+ }\n \n-    return false;\n-  }\n+ return false;\n+}\n \n-  public boolean isFormData() {\n-    return formData;\n-  }\n+public boolean isFormData() {\n+  return formData;\n+}\n \n-  public void setOperationMeta(OperationMeta operationMeta) {\n-    this.operationMeta = operationMeta;\n-  }\n+public void setOperationMeta(OperationMeta operationMeta) {\n+  this.operationMeta = operationMeta;\n+}\n \n-  // \u8f93\u51fab/c/\u5f62\u5f0f\u7684url\n-  private String concatPath(String basePath, String operationPath) {\n-    return (\"/\" + nonNullify(basePath) + \"/\" + nonNullify(operationPath) + \"/\")\n-        .replaceAll(\"/{2,}\", \"/\");\n-  }\n+// \u8f93\u51fab/c/\u5f62\u5f0f\u7684url\n+private String concatPath(String basePath, String operationPath) {\n+  return (\"/\" + nonNullify(basePath) + \"/\" + nonNullify(operationPath) + \"/\")\n+      .replaceAll(\"/{2,}\", \"/\");\n+}\n \n-  private String nonNullify(String path) {\n-    return path == null ? \"\" : path;\n-  }\n+private String nonNullify(String path) {\n+  return path == null ? \"\" : path;\n+}\n \n-  public String getAbsolutePath() {\n-    return this.absolutePath;\n-  }\n+public String getAbsolutePath() {\n+  return this.absolutePath;\n+}\n \n-  public void setAbsolutePath(String absolutePath) {\n-    this.absolutePath = absolutePath;\n-    this.absolutePathRegExp = createPathRegExp(absolutePath);\n-    this.pathBuilder = new URLPathBuilder(absolutePath, paramMap);\n-  }\n+public void setAbsolutePath(String absolutePath) {\n+  this.absolutePath = absolutePath;\n+  this.absolutePathRegExp = createPathRegExp(absolutePath);\n+  this.pathBuilder = new URLPathBuilder(absolutePath, paramMap);\n+}\n \n-  public PathRegExp getAbsolutePathRegExp() {\n-    return this.absolutePathRegExp;\n-  }\n+public PathRegExp getAbsolutePathRegExp() {\n+  return this.absolutePathRegExp;\n+}\n \n-  public boolean isAbsoluteStaticPath() {\n-    return this.absolutePathRegExp.isStaticPath();\n-  }\n+public boolean isAbsoluteStaticPath() {\n+  return this.absolutePathRegExp.isStaticPath();\n+}\n \n-  protected PathRegExp createPathRegExp(String path) {\n-    if (path == null || path.equals(\"\")) {\n-      throw new Error(\"null rest url is not supported\");\n-    }\n-    try {\n-      return new PathRegExp(path);\n-    } catch (Exception e) {\n-      LOGGER.error(e.getMessage());\n-      return null;\n-    }\n+protected PathRegExp createPathRegExp(String path) {\n+  if (path == null || path.equals(\"\")) {\n+    throw new Error(\"null rest url is not supported\");\n   }\n-\n-  public RestParam getParamByName(String name) {\n-    return paramMap.get(name);\n+  try {\n+    return new PathRegExp(path);\n+  } catch (Exception e) {\n+    LOGGER.error(e.getMessage());\n+    return null;\n   }\n+}\n \n-  public RestParam getParamByIndex(int index) {\n-    return paramList.get(index);\n-  }\n+public RestParam getParamByName(String name) {\n+  return paramMap.get(name);\n+}\n \n-  public OperationMeta getOperationMeta() {\n-    return operationMeta;\n-  }\n+public RestParam getParamByIndex(int index) {\n+  return paramList.get(index);\n+}\n \n-  // \u4e3aoperation\u521b\u5efa\u652f\u6301\u7684\u591a\u79cdproduce processor\n-  protected void createProduceProcessors() {\n-    if (null == produces || produces.isEmpty()) {\n-      ProduceProcessorManager.INSTANCE.getObjMap().forEach((processorName, prodMap) -> {\n-        this.produceProcessorAcceptMap.put(processorName, prodMap);\n-      });\n-    } else {\n-      for (String produce : produces) {\n-        if (produce.contains(\";\")) {\n-          produce = produce.substring(0, produce.indexOf(\";\"));\n-        }\n-        Map<String, ProduceProcessor> processorMap = ProduceProcessorManager.INSTANCE.findValue(produce);\n-        if (processorMap == null) {\n-          LOGGER.error(\"produce {} is not supported\", produce);\n-          continue;\n-        }\n-        this.produceProcessorAcceptMap.put(produce, processorMap);\n-      }\n+public OperationMeta getOperationMeta() {\n+  return operationMeta;\n+}\n \n-      if (produceProcessorAcceptMap.isEmpty()) {\n-        produceProcessorAcceptMap\n-            .put(ProduceProcessorManager.DEFAULT_TYPE, ProduceProcessorManager.INSTANCE.getDefaultProcessorMap());\n+// \u4e3aoperation\u521b\u5efa\u652f\u6301\u7684\u591a\u79cdproduce processor\n+protected void createProduceProcessors() {\n+  if (null == produces || produces.isEmpty()) {\n+    ProduceProcessorManager.INSTANCE.getObjMap().forEach((processorName, prodMap) -> {\n+      this.produceProcessorAcceptMap.put(processorName, prodMap);\n+    });\n+  } else {\n+    for (String produce : produces) {\n+      if (produce.contains(\";\")) {\n+        produce = produce.substring(0, produce.indexOf(\";\"));\n       }\n+      Map<String, ProduceProcessor> processorMap = ProduceProcessorManager.INSTANCE.findValue(produce);\n+      if (processorMap == null) {\n+        LOGGER.error(\"produce {} is not supported\", produce);\n+        continue;\n+      }\n+      this.produceProcessorAcceptMap.put(produce, processorMap);\n     }\n \n-    defaultProcessorViewMap = produceProcessorAcceptMap.values().stream().findFirst().get();\n-    produceProcessorAcceptMap.putIfAbsent(MediaType.WILDCARD, defaultProcessorViewMap);\n+    if (produceProcessorAcceptMap.isEmpty()) {\n+      produceProcessorAcceptMap\n+          .put(ProduceProcessorManager.DEFAULT_TYPE, ProduceProcessorManager.INSTANCE.getDefaultProcessorMap());\n+    }\n   }\n \n-  public URLPathBuilder getPathBuilder() {\n-    return this.pathBuilder;\n-  }\n+  defaultProcessorViewMap = produceProcessorAcceptMap.values().stream().findFirst().get();\n+  produceProcessorAcceptMap.putIfAbsent(MediaType.WILDCARD, defaultProcessorViewMap);\n+}\n \n-  public List<RestParam> getParamList() {\n-    return paramList;\n-  }\n+public URLPathBuilder getPathBuilder() {\n+  return this.pathBuilder;\n+}\n \n-  private void addParam(RestParam param) {\n-    if (param.getParamProcessor() instanceof PartProcessor) {\n-      fileKeys.add(param.getParamName());\n-    }\n-    paramList.add(param);\n-    paramMap.put(param.getParamName(), param);\n-  }\n+public List<RestParam> getParamList() {\n+  return paramList;\n+}\n \n-  public ProduceProcessor findProduceProcessor(String type, String serialView) {\n-    if (this.produceProcessorAcceptMap.get(type) == null) {\n-      LOGGER.error(String.format(\"Unable to  find produce processor with type/%s\", type));\n-      return null;\n-    }\n-    return this.produceProcessorAcceptMap.get(type).get(serialView);\n+private void addParam(RestParam param) {\n+  if (param.getParamProcessor() instanceof PartProcessor) {\n+    fileKeys.add(param.getParamName());\n   }\n+  paramList.add(param);\n+  paramMap.put(param.getParamName(), param);\n+}\n \n-  public ProduceProcessor findProduceProcessor(String type) {\n-    return findProduceProcessor(type, ProduceProcessorManager.DEFAULT_SERIAL_CLASS);\n+public ProduceProcessor findProduceProcessor(String type, String serialView) {\n+  if (this.produceProcessorAcceptMap.get(type) == null) {\n+    LOGGER.error(String.format(\"Unable to  find produce processor with type/%s\", type));\n+    return null;\n   }\n+  return this.produceProcessorAcceptMap.get(type).get(serialView);\n+}\n \n-  // \u9009\u62e9\u4e0eaccept\u5339\u914d\u7684produce processor\u6216\u8005\u7f3a\u7701\u7684\n-  public ProduceProcessor ensureFindProduceProcessor(HttpServletRequestEx requestEx) {\n-    String acceptType = requestEx.getHeader(HttpHeaders.ACCEPT);\n-    SwaggerProducerOperation producerOperation = operationMeta.getExtData(Const.PRODUCER_OPERATION);\n-    if (producerOperation == null || producerOperation.getProducerMethod() == null) {\n-      return ensureFindProduceProcessor(acceptType);\n-    }\n-    return ensureFindProduceProcessor(acceptType, producerOperation.getProducerMethod().getDeclaredAnnotations());\n+public ProduceProcessor findProduceProcessor(String type) {\n+  return findProduceProcessor(type, ProduceProcessorManager.DEFAULT_SERIAL_CLASS);\n+}\n+\n+// \u9009\u62e9\u4e0eaccept\u5339\u914d\u7684produce processor\u6216\u8005\u7f3a\u7701\u7684\n+public ProduceProcessor ensureFindProduceProcessor(HttpServletRequestEx requestEx) {\n+  String acceptType = requestEx.getHeader(HttpHeaders.ACCEPT);\n+  SwaggerProducerOperation producerOperation = operationMeta.getExtData(Const.PRODUCER_OPERATION);\n+  if (producerOperation == null || producerOperation.getProducerMethod() == null) {\n+    return ensureFindProduceProcessor(acceptType);\n   }\n+  return ensureFindProduceProcessor(acceptType, producerOperation.getProducerMethod().getDeclaredAnnotations());\n+}\n \n-  public ProduceProcessor ensureFindProduceProcessor(String acceptType) {\n+public ProduceProcessor ensureFindProduceProcessor(String acceptType) {\n+  return doEnsureFindProduceProcessor(acceptType, null);\n+}\n+\n+public ProduceProcessor ensureFindProduceProcessor(String acceptType, Annotation[] annotations) {\n+  if (annotations == null || annotations.length < 1) {\n     return doEnsureFindProduceProcessor(acceptType, null);\n   }\n-\n-  public ProduceProcessor ensureFindProduceProcessor(String acceptType, Annotation[] annotations) {\n-    if (annotations == null || annotations.length < 1) {\n-      return doEnsureFindProduceProcessor(acceptType, null);\n-    }\n-    for (Annotation annotation : annotations) {\n-      if (annotation.annotationType() == JsonView.class) {\n-        Class<?>[] value = ((JsonView) annotation).value();\n-        if (value.length != 1) {\n-          throw new IllegalArgumentException(\n-              \"@JsonView only supported for exactly 1 class argument \");\n-        }\n-        return doEnsureFindProduceProcessor(acceptType, value[0]);\n+  for (Annotation annotation : annotations) {\n+    if (annotation.annotationType() == JsonView.class) {\n+      Class<?>[] value = ((JsonView) annotation).value();\n+      if (value.length != 1) {\n+        throw new IllegalArgumentException(\n+            \"@JsonView only supported for exactly 1 class argument \");\n       }\n+      return doEnsureFindProduceProcessor(acceptType, value[0]);\n     }\n-    return doEnsureFindProduceProcessor(acceptType, null);\n   }\n+  return doEnsureFindProduceProcessor(acceptType, null);\n+}\n \n-  private ProduceProcessor doEnsureFindProduceProcessor(String acceptType, Class<?> serialViewClass) {\n-    String serialViewKey =\n-        (serialViewClass == null ? ProduceProcessorManager.DEFAULT_SERIAL_CLASS : serialViewClass.getCanonicalName());\n-    if (downloadFile) {\n-      //do not check accept type, when the produces of provider is text/plain there will return text/plain processor\n-      //when the produces of provider is application/json there will return the application/json processor\n-      //so do not care what accept type the consumer will set.\n-      return this.produceProcessorAcceptMap.get(MediaType.WILDCARD)\n-          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n-              acceptType, serialViewClass, produceProcessorAcceptMap.get(MediaType.WILDCARD)));\n-    }\n-    if (StringUtils.isEmpty(acceptType)) {\n-      return defaultProcessorViewMap\n-          .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n-              acceptType, serialViewClass, defaultProcessorViewMap));\n-    }\n-    List<String> mimeTypes = MimeTypesUtils.getSortedAcceptableMimeTypes(acceptType.toLowerCase(Locale.US));\n-    for (String mime : mimeTypes) {\n-      Map<String, ProduceProcessor> processorMap = this.produceProcessorAcceptMap.get(mime);\n-      if (null != processorMap) {\n-        return processorMap.computeIfAbsent(serialViewKey, key ->\n-            ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, processorMap));\n-      }\n+private ProduceProcessor doEnsureFindProduceProcessor(String acceptType, Class<?> serialViewClass) {\n+  String serialViewKey =\n+      (serialViewClass == null ? ProduceProcessorManager.DEFAULT_SERIAL_CLASS : serialViewClass.getCanonicalName());\n+  if (downloadFile) {\n+    //do not check accept type, when the produces of provider is text/plain there will return text/plain processor\n+    //when the produces of provider is application/json there will return the application/json processor\n+    //so do not care what accept type the consumer will set.\n+    return this.produceProcessorAcceptMap.get(MediaType.WILDCARD)\n+        .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n+            acceptType, serialViewClass, produceProcessorAcceptMap.get(MediaType.WILDCARD)));\n+  }\n+  if (StringUtils.isEmpty(acceptType)) {\n+    return defaultProcessorViewMap\n+        .computeIfAbsent(serialViewKey, key -> ProduceProcessorManager.cloneNewProduceProcessor(\n+            acceptType, serialViewClass, defaultProcessorViewMap));\n+  }\n+  List<String> mimeTypes = MimeTypesUtils.getSortedAcceptableMimeTypes(acceptType.toLowerCase(Locale.US));\n+  for (String mime : mimeTypes) {\n+    Map<String, ProduceProcessor> processorMap = this.produceProcessorAcceptMap.get(mime);\n+    if (null != processorMap) {\n+      return processorMap.computeIfAbsent(serialViewKey, key ->\n+          ProduceProcessorManager.cloneNewProduceProcessor(acceptType, serialViewClass, processorMap));\n     }\n-\n-    return null;\n   }\n \n-  public String getHttpMethod() {\n-    return operationMeta.getHttpMethod();\n-  }\n+  return null;\n+}\n \n-  public List<String> getFileKeys() {\n-    return fileKeys;\n-  }\n+public String getHttpMethod() {\n+  return operationMeta.getHttpMethod();\n+}\n \n-  public List<String> getProduces() {\n-    return produces;\n-  }\n+public List<String> getFileKeys() {\n+  return fileKeys;\n+}\n+\n+public List<String> getProduces() {\n+  return produces;\n+}\n }\n",
            "diff_size": 194
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "154",
                    "column": "41",
                    "severity": "warning",
                    "message": "'&&' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}