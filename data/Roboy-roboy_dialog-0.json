{
    "error_id": "0",
    "information": {
        "errors": [
            {
                "line": "17",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": " * control what categories to abstract out - efficiency improvement, right now\n * use all members of the cross product\n * \n * @author sidaw\n */\npublic class DALFeatureComputer implements FeatureComputer {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "17",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/errored/1/0/DALFeatureComputer.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/intellij/0/DALFeatureComputer.java\nindex 1f4e8a57b6..76bf8f797b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/errored/1/0/DALFeatureComputer.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/intellij/0/DALFeatureComputer.java\n@@ -14,153 +14,169 @@ import fig.basic.Option;\n  * Feature computer for the the dependency-based action language TODOs: -\n  * control what categories to abstract out - efficiency improvement, right now\n  * use all members of the cross product\n- * \n+ *\n  * @author sidaw\n  */\n public class DALFeatureComputer implements FeatureComputer {\n-  public static class Options {\n-    @Option(gloss = \"Verbosity\")\n-    public int verbose = 0;\n-\n-    @Option(gloss = \"the N in N-gram\")\n-    public int ngramN = 3;\n-\n-    @Option(gloss = \"size of the context window to consider\")\n-    public int windowSize = 2;\n-  }\n-\n-  public static Options opts = new Options();\n-\n-  @Override\n-  public void extractLocal(Example ex, Derivation deriv) {\n-    addStatsFeatures(ex, deriv);\n-    addWindowFeatures(ex, deriv);\n-    addSocialFeatures(ex, deriv);\n-    extractRuleFeatures(ex, deriv);\n-    extractSpanFeatures(ex, deriv);\n-  }\n-\n-  // function to abstract out ALL anchored stuff in the utterance.\n-  private List<String> abstractAnchors(Derivation deriv, List<String> tokens, int window) {\n-    if (deriv.start == -1)\n-      return tokens;\n-    List<String> newTokens = new ArrayList<>();\n-    int startInd = Math.max(0, deriv.start - window);\n-    int endInd = Math.min(tokens.size(), deriv.end + window);\n-    newTokens.addAll(tokens.subList(startInd, deriv.start));\n-    newTokens.add(deriv.cat);\n-    newTokens.addAll(tokens.subList(deriv.end, endInd));\n-    return newTokens;\n-  }\n-\n-  private List<String> getAllNgrams(List<String> tokens, int n, Derivation deriv) {\n-    List<String> ngrams = new ArrayList<>();\n-    List<String> paddedTokens = new ArrayList<>();\n-    if (deriv.start == -1) // floating, just add everything\n-      paddedTokens.addAll(tokens);\n-    else {\n-      paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - n + 1), Math.min(tokens.size(), deriv.end + n - 1)));\n+    public static class Options {\n+        @Option(gloss = \"Verbosity\")\n+        public int verbose = 0;\n+\n+        @Option(gloss = \"the N in N-gram\")\n+        public int ngramN = 3;\n+\n+        @Option(gloss = \"size of the context window to consider\")\n+        public int windowSize = 2;\n+    }\n+\n+    public static Options opts = new Options();\n+\n+    @Override\n+    public void extractLocal(Example ex, Derivation deriv) {\n+        addStatsFeatures(ex, deriv);\n+        addWindowFeatures(ex, deriv);\n+        addSocialFeatures(ex, deriv);\n+        extractRuleFeatures(ex, deriv);\n+        extractSpanFeatures(ex, deriv);\n+    }\n+\n+    // function to abstract out ALL anchored stuff in the utterance.\n+    private List<String> abstractAnchors(Derivation deriv, List<String> tokens, int window) {\n+        if (deriv.start == -1) {\n+            return tokens;\n+        }\n+        List<String> newTokens = new ArrayList<>();\n+        int startInd = Math.max(0, deriv.start - window);\n+        int endInd = Math.min(tokens.size(), deriv.end + window);\n+        newTokens.addAll(tokens.subList(startInd, deriv.start));\n+        newTokens.add(deriv.cat);\n+        newTokens.addAll(tokens.subList(deriv.end, endInd));\n+        return newTokens;\n     }\n \n-    for (int i = 0; i < paddedTokens.size() - n + 1; i++) {\n-      List<String> current = new ArrayList<>(paddedTokens.subList(i, i + n));\n-      ngrams.add(current.toString());\n+    private List<String> getAllNgrams(List<String> tokens, int n, Derivation deriv) {\n+        List<String> ngrams = new ArrayList<>();\n+        List<String> paddedTokens = new ArrayList<>();\n+        if (deriv.start == -1) // floating, just add everything\n+        {\n+            paddedTokens.addAll(tokens);\n+        } else {\n+            paddedTokens\n+                .addAll(tokens.subList(Math.max(0, deriv.start - n + 1), Math.min(tokens.size(), deriv.end + n - 1)));\n+        }\n+\n+        for (int i = 0; i < paddedTokens.size() - n + 1; i++) {\n+            List<String> current = new ArrayList<>(paddedTokens.subList(i, i + n));\n+            ngrams.add(current.toString());\n+        }\n+        return ngrams;\n     }\n-    return ngrams;\n-  }\n-\n-  private List<String> getAllSkipGrams(List<String> tokens, Derivation deriv) {\n-    List<String> ngrams = new ArrayList<>();\n-    List<String> paddedTokens = new ArrayList<>();\n-    if (tokens.size() < 3)\n-      return ngrams;\n-\n-    if (deriv.start == -1) // floating, just add everything\n-      paddedTokens.addAll(tokens);\n-    else\n-      paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - 2), Math.min(tokens.size(), deriv.end + 2)));\n-\n-    for (int i = 0; i < tokens.size() - 2; i++) {\n-      ngrams.add(\"[\" + tokens.get(i).toString() + \", *, \" + tokens.get(i + 2) + \"]\");\n+\n+    private List<String> getAllSkipGrams(List<String> tokens, Derivation deriv) {\n+        List<String> ngrams = new ArrayList<>();\n+        List<String> paddedTokens = new ArrayList<>();\n+        if (tokens.size() < 3) {\n+            return ngrams;\n+        }\n+\n+        if (deriv.start == -1) // floating, just add everything\n+        {\n+            paddedTokens.addAll(tokens);\n+        } else {\n+            paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - 2), Math.min(tokens.size(), deriv.end + 2)));\n+        }\n+\n+        for (int i = 0; i < tokens.size() - 2; i++) {\n+            ngrams.add(\"[\" + tokens.get(i).toString() + \", *, \" + tokens.get(i + 2) + \"]\");\n+        }\n+        return ngrams;\n     }\n-    return ngrams;\n-  }\n-\n-  private void addWindowFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":window\"))\n-      return;\n-    if (deriv.rule != Rule.nullRule) {\n-      deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 1).toString());\n-      deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 2).toString());\n+\n+    private void addWindowFeatures(Example ex, Derivation deriv) {\n+        if (!FeatureExtractor.containsDomain(\":window\")) {\n+            return;\n+        }\n+        if (deriv.rule != Rule.nullRule) {\n+            deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 1).toString());\n+            deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 2).toString());\n+        }\n     }\n-  }\n-\n-  private void addStatsFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":stats\"))\n-      return;\n-    if (deriv.rule != Rule.nullRule) {\n-      if (deriv.rule.isInduced())\n-        deriv.addFeature(\":stats\", \"induced\");\n-      else\n-        deriv.addFeature(\":stats\", \"core\");\n-\n-      if (deriv.rule.source != null) {\n-        deriv.addFeature(\":stats\", \"cite\", deriv.rule.source.cite);\n-        if (deriv.rule.source.cite > 0)\n-          deriv.addFeature(\":stats\", \"has_cite\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_cite\");\n-\n-        if (deriv.rule.source.self > 0)\n-          deriv.addFeature(\":stats\", \"has_selfcite\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_selfcite\");\n-\n-        if (deriv.rule.source.align)\n-          deriv.addFeature(\":stats\", \"align\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_align\");\n-\n-        if (deriv.rule.getInfoTag(\"simple_packing\") != -1.0)\n-          deriv.addFeature(\":stats\", \"simple_packing\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_simple_packing\");\n-\n-      }\n+\n+    private void addStatsFeatures(Example ex, Derivation deriv) {\n+        if (!FeatureExtractor.containsDomain(\":stats\")) {\n+            return;\n+        }\n+        if (deriv.rule != Rule.nullRule) {\n+            if (deriv.rule.isInduced()) {\n+                deriv.addFeature(\":stats\", \"induced\");\n+            } else {\n+                deriv.addFeature(\":stats\", \"core\");\n+            }\n+\n+            if (deriv.rule.source != null) {\n+                deriv.addFeature(\":stats\", \"cite\", deriv.rule.source.cite);\n+                if (deriv.rule.source.cite > 0) {\n+                    deriv.addFeature(\":stats\", \"has_cite\");\n+                } else {\n+                    deriv.addFeature(\":stats\", \"no_cite\");\n+                }\n+\n+                if (deriv.rule.source.self > 0) {\n+                    deriv.addFeature(\":stats\", \"has_selfcite\");\n+                } else {\n+                    deriv.addFeature(\":stats\", \"no_selfcite\");\n+                }\n+\n+                if (deriv.rule.source.align) {\n+                    deriv.addFeature(\":stats\", \"align\");\n+                } else {\n+                    deriv.addFeature(\":stats\", \"no_align\");\n+                }\n+\n+                if (deriv.rule.getInfoTag(\"simple_packing\") != -1.0) {\n+                    deriv.addFeature(\":stats\", \"simple_packing\");\n+                } else {\n+                    deriv.addFeature(\":stats\", \"no_simple_packing\");\n+                }\n+\n+            }\n+        }\n     }\n-  }\n-\n-  private void addSocialFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":social\"))\n-      return;\n-    if (deriv.rule != Rule.nullRule && deriv.rule.source != null) {\n-      // everyone like a particular author\n-      deriv.addFeature(\":social\", deriv.rule.source.uid);\n-      // a particular user likes a particular author, perhaps himself\n-      deriv.addFeature(\":social\", deriv.rule.source.uid + \"::\" + ex.id);\n-      // the degree everyone likes to use their own rules\n-      deriv.addFeature(\":social\", \"isself::\" + deriv.rule.source.uid.equals(ex.id));\n+\n+    private void addSocialFeatures(Example ex, Derivation deriv) {\n+        if (!FeatureExtractor.containsDomain(\":social\")) {\n+            return;\n+        }\n+        if (deriv.rule != Rule.nullRule && deriv.rule.source != null) {\n+            // everyone like a particular author\n+            deriv.addFeature(\":social\", deriv.rule.source.uid);\n+            // a particular user likes a particular author, perhaps himself\n+            deriv.addFeature(\":social\", deriv.rule.source.uid + \"::\" + ex.id);\n+            // the degree everyone likes to use their own rules\n+            deriv.addFeature(\":social\", \"isself::\" + deriv.rule.source.uid.equals(ex.id));\n+        }\n     }\n-  }\n-\n-  // Add an indicator for each applied rule.\n-  private void extractRuleFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":rule\"))\n-      return;\n-    if (deriv.rule != Rule.nullRule) {\n-      deriv.addFeature(\":rule\", \"fire\");\n-      deriv.addFeature(\":rule\", deriv.rule.toString());\n+\n+    // Add an indicator for each applied rule.\n+    private void extractRuleFeatures(Example ex, Derivation deriv) {\n+        if (!FeatureExtractor.containsDomain(\":rule\")) {\n+            return;\n+        }\n+        if (deriv.rule != Rule.nullRule) {\n+            deriv.addFeature(\":rule\", \"fire\");\n+            deriv.addFeature(\":rule\", deriv.rule.toString());\n+        }\n+    }\n+\n+    // Extract features on the linguistic information of the spanned (anchored)\n+    // tokens.\n+    // (Not applicable for floating rules)\n+    private void extractSpanFeatures(Example ex, Derivation deriv) {\n+        if (!FeatureExtractor.containsDomain(\":span\") || deriv.start == -1) {\n+            return;\n+        }\n+        deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: len=\" + (deriv.end - deriv.start));\n+        deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: \" + ex.token(deriv.start) + \"...\" + ex.token(deriv.end - 1));\n     }\n-  }\n-\n-  // Extract features on the linguistic information of the spanned (anchored)\n-  // tokens.\n-  // (Not applicable for floating rules)\n-  private void extractSpanFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":span\") || deriv.start == -1)\n-      return;\n-    deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: len=\" + (deriv.end - deriv.start));\n-    deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: \" + ex.token(deriv.start) + \"...\" + ex.token(deriv.end - 1));\n-  }\n \n }\n",
            "diff_size": 172
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "17",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/errored/1/0/DALFeatureComputer.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/naturalize/0/DALFeatureComputer.java\nindex 1f4e8a57b6..6b7db9cf6b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/errored/1/0/DALFeatureComputer.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/naturalize/0/DALFeatureComputer.java\n@@ -125,8 +125,7 @@ public class DALFeatureComputer implements FeatureComputer {\n           deriv.addFeature(\":stats\", \"simple_packing\");\n         else\n           deriv.addFeature(\":stats\", \"no_simple_packing\");\n-\n-      }\n+  }\n     }\n   }\n \n@@ -163,4 +162,4 @@ public class DALFeatureComputer implements FeatureComputer {\n     deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: \" + ex.token(deriv.start) + \"...\" + ex.token(deriv.end - 1));\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "16",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/errored/1/0/DALFeatureComputer.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/codebuff/0/DALFeatureComputer.java\nindex 1f4e8a57b6..e2a3a5380c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/errored/1/0/DALFeatureComputer.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Roboy-roboy_dialog/codebuff/0/DALFeatureComputer.java\n@@ -2,7 +2,6 @@ package edu.stanford.nlp.sempre.interactive;\n \n import java.util.ArrayList;\n import java.util.List;\n-\n import edu.stanford.nlp.sempre.Derivation;\n import edu.stanford.nlp.sempre.Example;\n import edu.stanford.nlp.sempre.FeatureComputer;\n@@ -17,33 +16,32 @@ import fig.basic.Option;\n  * \n  * @author sidaw\n  */\n+\n+\n public class DALFeatureComputer implements FeatureComputer {\n-  public static class Options {\n+    public static class Options {\n     @Option(gloss = \"Verbosity\")\n     public int verbose = 0;\n-\n     @Option(gloss = \"the N in N-gram\")\n     public int ngramN = 3;\n-\n     @Option(gloss = \"size of the context window to consider\")\n     public int windowSize = 2;\n-  }\n-\n-  public static Options opts = new Options();\n+    }\n \n-  @Override\n-  public void extractLocal(Example ex, Derivation deriv) {\n+    public static Options opts = new Options();\n+    @Override\n+    public void extractLocal(Example ex, Derivation deriv) {\n     addStatsFeatures(ex, deriv);\n     addWindowFeatures(ex, deriv);\n     addSocialFeatures(ex, deriv);\n     extractRuleFeatures(ex, deriv);\n     extractSpanFeatures(ex, deriv);\n-  }\n+    }\n \n   // function to abstract out ALL anchored stuff in the utterance.\n-  private List<String> abstractAnchors(Derivation deriv, List<String> tokens, int window) {\n-    if (deriv.start == -1)\n-      return tokens;\n+\n+    private List<String> abstractAnchors(Derivation deriv, List<String> tokens, int window) {\n+    if (deriv.start == -1) return tokens;\n     List<String> newTokens = new ArrayList<>();\n     int startInd = Math.max(0, deriv.start - window);\n     int endInd = Math.min(tokens.size(), deriv.end + window);\n@@ -51,116 +49,104 @@ public class DALFeatureComputer implements FeatureComputer {\n     newTokens.add(deriv.cat);\n     newTokens.addAll(tokens.subList(deriv.end, endInd));\n     return newTokens;\n-  }\n+    }\n \n-  private List<String> getAllNgrams(List<String> tokens, int n, Derivation deriv) {\n+    private List<String> getAllNgrams(List<String> tokens, int n, Derivation deriv) {\n     List<String> ngrams = new ArrayList<>();\n     List<String> paddedTokens = new ArrayList<>();\n     if (deriv.start == -1) // floating, just add everything\n-      paddedTokens.addAll(tokens);\n+        paddedTokens.addAll(tokens);\n     else {\n-      paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - n + 1), Math.min(tokens.size(), deriv.end + n - 1)));\n+    paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - n + 1), Math.min(tokens.size(), deriv.end + n - 1)));\n     }\n \n     for (int i = 0; i < paddedTokens.size() - n + 1; i++) {\n-      List<String> current = new ArrayList<>(paddedTokens.subList(i, i + n));\n-      ngrams.add(current.toString());\n+        List<String> current = new ArrayList<>(paddedTokens.subList(i, i + n));\n+        ngrams.add(current.toString());\n     }\n     return ngrams;\n-  }\n+    }\n \n-  private List<String> getAllSkipGrams(List<String> tokens, Derivation deriv) {\n+    private List<String> getAllSkipGrams(List<String> tokens, Derivation deriv) {\n     List<String> ngrams = new ArrayList<>();\n     List<String> paddedTokens = new ArrayList<>();\n-    if (tokens.size() < 3)\n-      return ngrams;\n-\n+    if (tokens.size() < 3) return ngrams;\n     if (deriv.start == -1) // floating, just add everything\n-      paddedTokens.addAll(tokens);\n+        paddedTokens.addAll(tokens);\n     else\n-      paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - 2), Math.min(tokens.size(), deriv.end + 2)));\n-\n+        paddedTokens.addAll(tokens.subList(Math.max(0, deriv.start - 2), Math.min(tokens.size(), deriv.end + 2)));\n     for (int i = 0; i < tokens.size() - 2; i++) {\n-      ngrams.add(\"[\" + tokens.get(i).toString() + \", *, \" + tokens.get(i + 2) + \"]\");\n+        ngrams.add(\"[\" + tokens.get(i).toString() + \", *, \" + tokens.get(i + 2) + \"]\");\n     }\n     return ngrams;\n-  }\n+    }\n \n-  private void addWindowFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":window\"))\n-      return;\n+    private void addWindowFeatures(Example ex, Derivation deriv) {\n+    if (!FeatureExtractor.containsDomain(\":window\")) return;\n     if (deriv.rule != Rule.nullRule) {\n-      deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 1).toString());\n-      deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 2).toString());\n+        deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 1).toString());\n+        deriv.addFeature(\":window\", abstractAnchors(deriv, ex.getTokens(), 2).toString());\n+    }\n     }\n-  }\n \n-  private void addStatsFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":stats\"))\n-      return;\n+    private void addStatsFeatures(Example ex, Derivation deriv) {\n+    if (!FeatureExtractor.containsDomain(\":stats\")) return;\n     if (deriv.rule != Rule.nullRule) {\n-      if (deriv.rule.isInduced())\n+        if (deriv.rule.isInduced())\n         deriv.addFeature(\":stats\", \"induced\");\n-      else\n-        deriv.addFeature(\":stats\", \"core\");\n-\n-      if (deriv.rule.source != null) {\n-        deriv.addFeature(\":stats\", \"cite\", deriv.rule.source.cite);\n-        if (deriv.rule.source.cite > 0)\n-          deriv.addFeature(\":stats\", \"has_cite\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_cite\");\n-\n-        if (deriv.rule.source.self > 0)\n-          deriv.addFeature(\":stats\", \"has_selfcite\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_selfcite\");\n-\n-        if (deriv.rule.source.align)\n-          deriv.addFeature(\":stats\", \"align\");\n-        else\n-          deriv.addFeature(\":stats\", \"no_align\");\n-\n-        if (deriv.rule.getInfoTag(\"simple_packing\") != -1.0)\n-          deriv.addFeature(\":stats\", \"simple_packing\");\n         else\n-          deriv.addFeature(\":stats\", \"no_simple_packing\");\n-\n-      }\n+        deriv.addFeature(\":stats\", \"core\");\n+        if (deriv.rule.source != null) {\n+                                         deriv.addFeature(\":stats\", \"cite\", deriv.rule.source.cite);\n+                                         if (deriv.rule.source.cite > 0)\n+            deriv.addFeature(\":stats\", \"has_cite\");\n+                                         else\n+            deriv.addFeature(\":stats\", \"no_cite\");\n+                                         if (deriv.rule.source.self > 0)\n+            deriv.addFeature(\":stats\", \"has_selfcite\");\n+                                         else\n+            deriv.addFeature(\":stats\", \"no_selfcite\");\n+                                         if (deriv.rule.source.align)\n+            deriv.addFeature(\":stats\", \"align\");\n+                                         else\n+            deriv.addFeature(\":stats\", \"no_align\");\n+                                         if (deriv.rule.getInfoTag(\"simple_packing\") != -1.0)\n+            deriv.addFeature(\":stats\", \"simple_packing\");\n+                                         else\n+            deriv.addFeature(\":stats\", \"no_simple_packing\");\n+        }\n+    }\n     }\n-  }\n \n-  private void addSocialFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":social\"))\n-      return;\n+    private void addSocialFeatures(Example ex, Derivation deriv) {\n+    if (!FeatureExtractor.containsDomain(\":social\")) return;\n     if (deriv.rule != Rule.nullRule && deriv.rule.source != null) {\n       // everyone like a particular author\n-      deriv.addFeature(\":social\", deriv.rule.source.uid);\n+        deriv.addFeature(\":social\", deriv.rule.source.uid);\n       // a particular user likes a particular author, perhaps himself\n-      deriv.addFeature(\":social\", deriv.rule.source.uid + \"::\" + ex.id);\n+        deriv.addFeature(\":social\", deriv.rule.source.uid + \"::\" + ex.id);\n       // the degree everyone likes to use their own rules\n-      deriv.addFeature(\":social\", \"isself::\" + deriv.rule.source.uid.equals(ex.id));\n+        deriv.addFeature(\":social\", \"isself::\" + deriv.rule.source.uid.equals(ex.id));\n+    }\n     }\n-  }\n \n   // Add an indicator for each applied rule.\n-  private void extractRuleFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":rule\"))\n-      return;\n+\n+    private void extractRuleFeatures(Example ex, Derivation deriv) {\n+    if (!FeatureExtractor.containsDomain(\":rule\")) return;\n     if (deriv.rule != Rule.nullRule) {\n-      deriv.addFeature(\":rule\", \"fire\");\n-      deriv.addFeature(\":rule\", deriv.rule.toString());\n+        deriv.addFeature(\":rule\", \"fire\");\n+        deriv.addFeature(\":rule\", deriv.rule.toString());\n+    }\n     }\n-  }\n \n   // Extract features on the linguistic information of the spanned (anchored)\n   // tokens.\n   // (Not applicable for floating rules)\n-  private void extractSpanFeatures(Example ex, Derivation deriv) {\n-    if (!FeatureExtractor.containsDomain(\":span\") || deriv.start == -1)\n-      return;\n+\n+    private void extractSpanFeatures(Example ex, Derivation deriv) {\n+    if (!FeatureExtractor.containsDomain(\":span\") || deriv.start == -1) return;\n     deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: len=\" + (deriv.end - deriv.start));\n     deriv.addFeature(\":span\", \"cat=\" + deriv.cat + \":: \" + ex.token(deriv.start) + \"...\" + ex.token(deriv.end - 1));\n-  }\n-\n-}\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 108
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "17",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}