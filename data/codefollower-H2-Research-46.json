{
    "error_id": "46",
    "information": {
        "errors": [
            {
                "line": "484",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        int value = c.get(field);\n        if (field == Calendar.MONTH) {\n            return value + 1; //\u6708\u4efd\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u8981\u52a01\n        }\n        return value;\n    }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "484",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "485",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/intellij/46/DateTimeUtils.java\nindex ea7edc96c5..1ca9170c00 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/intellij/46/DateTimeUtils.java\n@@ -4,6 +4,7 @@\n  * Group Iso8601: Initial Developer: Robert Rathsack (firstName dot lastName at\n  * gmx dot de)\n  */\n+\n package org.h2.util;\n \n import java.sql.Date;\n@@ -40,14 +41,14 @@ public class DateTimeUtils {\n     private static final int SHIFT_YEAR = 9;\n     private static final int SHIFT_MONTH = 5;\n \n-    private static final int[] NORMAL_DAYS_PER_MONTH = { 0, 31, 28, 31, 30, 31,\n-            30, 31, 31, 30, 31, 30, 31 };\n+    private static final int[] NORMAL_DAYS_PER_MONTH = {0, 31, 28, 31, 30, 31,\n+        30, 31, 31, 30, 31, 30, 31};\n \n     /**\n      * Offsets of month within a year, starting with March, April,...\n      */\n-    private static final int[] DAYS_OFFSET = { 0, 31, 61, 92, 122, 153, 184,\n-            214, 245, 275, 306, 337, 366 };\n+    private static final int[] DAYS_OFFSET = {0, 31, 61, 92, 122, 153, 184,\n+        214, 245, 275, 306, 337, 366};\n \n     /**\n      * The thread local. Can not override initialValue because this would result\n@@ -63,7 +64,7 @@ public class DateTimeUtils {\n      * A cached instance of Calendar used when a timezone is specified.\n      */\n     private static final ThreadLocal<Calendar> CACHED_CALENDAR_NON_DEFAULT_TIMEZONE =\n-            new ThreadLocal<Calendar>();\n+        new ThreadLocal<Calendar>();\n \n     /**\n      * Observed JVM behaviour is that if the timezone of the host computer is\n@@ -74,7 +75,7 @@ public class DateTimeUtils {\n      * have this offset change, possibly midway through a long-running query.\n      */\n     private static int zoneOffsetMillis = Calendar.getInstance()\n-            .get(Calendar.ZONE_OFFSET);\n+        .get(Calendar.ZONE_OFFSET);\n \n     private DateTimeUtils() {\n         // utility class\n@@ -123,7 +124,7 @@ public class DateTimeUtils {\n     /**\n      * Convert the date to the specified time zone.\n      *\n-     * @param value the date (might be ValueNull)\n+     * @param value    the date (might be ValueNull)\n      * @param calendar the calendar\n      * @return the date using the correct time zone\n      */\n@@ -137,8 +138,8 @@ public class DateTimeUtils {\n         cal.setLenient(true);\n         long dateValue = d.getDateValue();\n         setCalendarFields(cal, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n+            0, 0, 0);\n         long ms = cal.getTimeInMillis();\n         return new Date(ms);\n     }\n@@ -146,7 +147,7 @@ public class DateTimeUtils {\n     /**\n      * Convert the time to the specified time zone.\n      *\n-     * @param value the time (might be ValueNull)\n+     * @param value    the time (might be ValueNull)\n      * @param calendar the calendar\n      * @return the time using the correct time zone\n      */\n@@ -168,7 +169,7 @@ public class DateTimeUtils {\n         long h = m / 60;\n         m -= h * 60;\n         setCalendarFields(cal, 1970, 1, 1, (int) h, (int) m, (int) s,\n-                (int) millis);\n+            (int) millis);\n         long ms = cal.getTimeInMillis();\n         return new Time(ms);\n     }\n@@ -176,7 +177,7 @@ public class DateTimeUtils {\n     /**\n      * Convert the timestamp to the specified time zone.\n      *\n-     * @param value the timestamp (might be ValueNull)\n+     * @param value    the timestamp (might be ValueNull)\n      * @param calendar the calendar\n      * @return the timestamp using the correct time zone\n      */\n@@ -199,8 +200,8 @@ public class DateTimeUtils {\n         long h = m / 60;\n         m -= h * 60;\n         setCalendarFields(cal, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n-                (int) h, (int) m, (int) s, (int) millis);\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n+            (int) h, (int) m, (int) s, (int) millis);\n         long ms = cal.getTimeInMillis();\n         Timestamp x = new Timestamp(ms);\n         x.setNanos((int) (nanos + millis * 1000000));\n@@ -210,7 +211,7 @@ public class DateTimeUtils {\n     /**\n      * Convert a java.util.Date using the specified calendar.\n      *\n-     * @param x the date\n+     * @param x        the date\n      * @param calendar the calendar\n      * @return the date\n      */\n@@ -227,7 +228,7 @@ public class DateTimeUtils {\n     /**\n      * Convert the time using the specified calendar.\n      *\n-     * @param x the time\n+     * @param x        the time\n      * @param calendar the calendar\n      * @return the time\n      */\n@@ -244,7 +245,7 @@ public class DateTimeUtils {\n     /**\n      * Convert a date to the specified time zone.\n      *\n-     * @param x the date to convert\n+     * @param x      the date to convert\n      * @param target the calendar with the target timezone\n      * @return the milliseconds in UTC\n      */\n@@ -275,12 +276,12 @@ public class DateTimeUtils {\n     /**\n      * Convert the timestamp using the specified calendar.\n      *\n-     * @param x the time\n+     * @param x        the time\n      * @param calendar the calendar\n      * @return the timestamp\n      */\n     public static ValueTimestamp convertTimestamp(Timestamp x,\n-            Calendar calendar) {\n+                                                  Calendar calendar) {\n         if (calendar == null) {\n             throw DbException.getInvalidValueException(\"calendar\", null);\n         }\n@@ -295,9 +296,9 @@ public class DateTimeUtils {\n     /**\n      * Parse a date string. The format is: [+|-]year-month-day\n      *\n-     * @param s the string to parse\n+     * @param s     the string to parse\n      * @param start the parse index start\n-     * @param end the parse index end\n+     * @param end   the parse index end\n      * @return the date value\n      * @throws IllegalArgumentException if there is a problem\n      */\n@@ -325,16 +326,16 @@ public class DateTimeUtils {\n      * Parse a time string. The format is: [-]hour:minute:second[.nanos] or\n      * alternatively [-]hour.minute.second[.nanos].\n      *\n-     * @param s the string to parse\n-     * @param start the parse index start\n-     * @param end the parse index end\n+     * @param s         the string to parse\n+     * @param start     the parse index start\n+     * @param end       the parse index end\n      * @param timeOfDay whether the result need to be within 0 (inclusive) and 1\n-     *            day (exclusive)\n+     *                  day (exclusive)\n      * @return the time in nanoseconds\n      * @throws IllegalArgumentException if there is a problem\n      */\n     public static long parseTimeNanos(String s, int start, int end,\n-            boolean timeOfDay) {\n+                                      boolean timeOfDay) {\n         int hour = 0, minute = 0, second = 0;\n         long nanos = 0;\n         int s1 = s.indexOf(':', start);\n@@ -371,7 +372,7 @@ public class DateTimeUtils {\n             nanos = Integer.parseInt(n);\n         }\n         if (hour >= 2000000 || minute < 0 || minute >= 60 || second < 0\n-                || second >= 60) {\n+            || second >= 60) {\n             throw new IllegalArgumentException(s);\n         }\n         if (timeOfDay && hour >= 24) {\n@@ -385,22 +386,22 @@ public class DateTimeUtils {\n      * Calculate the milliseconds since 1970-01-01 (UTC) for the given date and\n      * time (in the specified timezone).\n      *\n-     * @param tz the timezone of the parameters, or null for the default\n-     *            timezone\n-     * @param year the absolute year (positive or negative)\n-     * @param month the month (1-12)\n-     * @param day the day (1-31)\n-     * @param hour the hour (0-23)\n+     * @param tz     the timezone of the parameters, or null for the default\n+     *               timezone\n+     * @param year   the absolute year (positive or negative)\n+     * @param month  the month (1-12)\n+     * @param day    the day (1-31)\n+     * @param hour   the hour (0-23)\n      * @param minute the minutes (0-59)\n      * @param second the number of seconds (0-59)\n      * @param millis the number of milliseconds\n      * @return the number of milliseconds (UTC)\n      */\n     public static long getMillis(TimeZone tz, int year, int month, int day,\n-            int hour, int minute, int second, int millis) {\n+                                 int hour, int minute, int second, int millis) {\n         try {\n             return getTimeTry(false, tz, year, month, day, hour, minute, second,\n-                    millis);\n+                millis);\n         } catch (IllegalArgumentException e) {\n             // special case: if the time simply doesn't exist because of\n             // daylight saving time changes, use the lenient version\n@@ -410,7 +411,7 @@ public class DateTimeUtils {\n                     throw e;\n                 }\n                 return getTimeTry(true, tz, year, month, day, hour, minute,\n-                        second, millis);\n+                    second, millis);\n             } else if (message.indexOf(\"DAY_OF_MONTH\") > 0) {\n                 int maxDay;\n                 if (month == 2) {\n@@ -426,16 +427,16 @@ public class DateTimeUtils {\n                 // for example for 2042-10-12 00:00:00.\n                 hour += 6;\n                 return getTimeTry(true, tz, year, month, day, hour, minute,\n-                        second, millis);\n+                    second, millis);\n             } else {\n                 return getTimeTry(true, tz, year, month, day, hour, minute,\n-                        second, millis);\n+                    second, millis);\n             }\n         }\n     }\n \n     private static long getTimeTry(boolean lenient, TimeZone tz, int year,\n-            int month, int day, int hour, int minute, int second, int millis) {\n+                                   int month, int day, int hour, int minute, int second, int millis) {\n         Calendar c;\n         if (tz == null) {\n             c = getCalendar();\n@@ -448,7 +449,7 @@ public class DateTimeUtils {\n     }\n \n     private static void setCalendarFields(Calendar cal, int year, int month,\n-            int day, int hour, int minute, int second, int millis) {\n+                                          int day, int hour, int minute, int second, int millis) {\n         if (year <= 0) {\n             cal.set(Calendar.ERA, GregorianCalendar.BC);\n             cal.set(Calendar.YEAR, 1 - year);\n@@ -469,7 +470,7 @@ public class DateTimeUtils {\n      * Get the specified field of a date, however with years normalized to\n      * positive or negative, and month starting with 1.\n      *\n-     * @param d the date\n+     * @param d     the date\n      * @param field the field type\n      * @return the value\n      */\n@@ -526,9 +527,9 @@ public class DateTimeUtils {\n      * Return the day of week according to the ISO 8601 specification. Week\n      * starts at Monday. See also http://en.wikipedia.org/wiki/ISO_8601\n      *\n-     * @author Robert Rathsack\n      * @param date the date object which day of week should be calculated\n      * @return the day of the week, Monday as 1 to Sunday as 7\n+     * @author Robert Rathsack\n      */\n     public static int getIsoDayOfWeek(java.util.Date date) {\n         Calendar cal = Calendar.getInstance();\n@@ -547,9 +548,9 @@ public class DateTimeUtils {\n      * previous year. Hence January 4th always belongs to the first week while\n      * the December 28th always belongs to the last week.\n      *\n-     * @author Robert Rathsack\n      * @param date the date object which week of year should be calculated\n      * @return the week of the year\n+     * @author Robert Rathsack\n      */\n     public static int getIsoWeek(java.util.Date date) {\n         Calendar c = Calendar.getInstance();\n@@ -562,9 +563,9 @@ public class DateTimeUtils {\n     /**\n      * Returns the year according to the ISO week definition.\n      *\n-     * @author Robert Rathsack\n      * @param date the date object which year should be calculated\n      * @return the year\n+     * @author Robert Rathsack\n      */\n     public static int getIsoYear(java.util.Date date) {\n         Calendar cal = Calendar.getInstance();\n@@ -585,14 +586,14 @@ public class DateTimeUtils {\n     /**\n      * Formats a date using a format string.\n      *\n-     * @param date the date to format\n-     * @param format the format string\n-     * @param locale the locale\n+     * @param date     the date to format\n+     * @param format   the format string\n+     * @param locale   the locale\n      * @param timeZone the timezone\n      * @return the formatted date\n      */\n     public static String formatDateTime(java.util.Date date, String format,\n-            String locale, String timeZone) {\n+                                        String locale, String timeZone) {\n         SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n         synchronized (dateFormat) {\n             return dateFormat.format(date);\n@@ -602,14 +603,14 @@ public class DateTimeUtils {\n     /**\n      * Parses a date using a format string.\n      *\n-     * @param date the date to parse\n-     * @param format the parsing format\n-     * @param locale the locale\n+     * @param date     the date to parse\n+     * @param format   the parsing format\n+     * @param locale   the locale\n      * @param timeZone the timeZone\n      * @return the parsed date\n      */\n     public static java.util.Date parseDateTime(String date, String format,\n-            String locale, String timeZone) {\n+                                               String locale, String timeZone) {\n         SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n         try {\n             synchronized (dateFormat) {\n@@ -622,7 +623,7 @@ public class DateTimeUtils {\n     }\n \n     private static SimpleDateFormat getDateFormat(String format, String locale,\n-            String timeZone) {\n+                                                  String timeZone) {\n         try {\n             // currently, a new instance is create for each call\n             // however, could cache the last few instances\n@@ -639,16 +640,16 @@ public class DateTimeUtils {\n             return df;\n         } catch (Exception e) {\n             throw DbException.get(ErrorCode.PARSE_ERROR_1, e,\n-                    format + \"/\" + locale + \"/\" + timeZone);\n+                format + \"/\" + locale + \"/\" + timeZone);\n         }\n     }\n \n     /**\n      * Verify if the specified date is valid.\n      *\n-     * @param year the year\n+     * @param year  the year\n      * @param month the month (January is 1)\n-     * @param day the day (1 is the first of the month)\n+     * @param day   the day (1 is the first of the month)\n      * @return true if it is valid\n      */\n     public static boolean isValidDate(int year, int month, int day) {\n@@ -684,22 +685,22 @@ public class DateTimeUtils {\n      */\n     public static Date convertDateValueToDate(long dateValue) {\n         long millis = getMillis(null, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n+            0, 0, 0);\n         return new Date(millis);\n     }\n \n     /**\n      * Convert an encoded date value to millis, using the supplied timezone.\n      *\n-     * @param tz the timezone\n+     * @param tz        the timezone\n      * @param dateValue the date value\n      * @return the date\n      */\n     public static long convertDateValueToMillis(TimeZone tz, long dateValue) {\n         return getMillis(tz, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n+            0, 0, 0);\n     }\n \n     /**\n@@ -711,7 +712,7 @@ public class DateTimeUtils {\n      * @return the timestamp\n      */\n     public static Timestamp convertDateValueToTimestamp(long dateValue,\n-            long timeNanos) {\n+                                                        long timeNanos) {\n         long millis = timeNanos / 1000000;\n         timeNanos -= millis * 1000000;\n         long s = millis / 1000;\n@@ -721,8 +722,8 @@ public class DateTimeUtils {\n         long h = m / 60;\n         m -= h * 60;\n         long ms = getMillis(null, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n-                (int) h, (int) m, (int) s, 0);\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n+            (int) h, (int) m, (int) s, 0);\n         Timestamp ts = new Timestamp(ms);\n         ts.setNanos((int) (timeNanos + millis * 1000000));\n         return ts;\n@@ -743,7 +744,7 @@ public class DateTimeUtils {\n         long h = m / 60;\n         m -= h * 60;\n         long ms = getMillis(null, 1970, 1, 1, (int) (h % 24), (int) m, (int) s,\n-                (int) millis);\n+            (int) millis);\n         return new Time(ms);\n     }\n \n@@ -780,9 +781,9 @@ public class DateTimeUtils {\n     /**\n      * Get the date value from a given date.\n      *\n-     * @param year the year\n+     * @param year  the year\n      * @param month the month (1..12)\n-     * @param day the day (1..31)\n+     * @param day   the day (1..31)\n      * @return the date value\n      */\n     public static long dateValue(long year, int month, int day) {\n@@ -847,11 +848,11 @@ public class DateTimeUtils {\n      * Calculate the normalized timestamp.\n      *\n      * @param absoluteDay the absolute day\n-     * @param nanos the nanoseconds (may be negative or larger than one day)\n+     * @param nanos       the nanoseconds (may be negative or larger than one day)\n      * @return the timestamp\n      */\n     public static ValueTimestamp normalizeTimestamp(long absoluteDay,\n-            long nanos) {\n+                                                    long nanos) {\n         if (nanos > NANOS_PER_DAY || nanos < 0) {\n             long d;\n             if (nanos > NANOS_PER_DAY) {\n@@ -863,7 +864,7 @@ public class DateTimeUtils {\n             absoluteDay += d;\n         }\n         return ValueTimestamp.fromDateValueAndNanos(\n-                dateValueFromAbsoluteDay(absoluteDay), nanos);\n+            dateValueFromAbsoluteDay(absoluteDay), nanos);\n     }\n \n     /**\n@@ -937,7 +938,7 @@ public class DateTimeUtils {\n      * day-of-months gets adjusted accordingly: <br>\n      * 30.04.2007 - 2 months = 28.02.2007\n      *\n-     * @param refDate the original date\n+     * @param refDate         the original date\n      * @param nrOfMonthsToAdd the number of months to add\n      * @return the new timestamp\n      */\n",
            "diff_size": 75
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/naturalize/46/DateTimeUtils.java\nindex ea7edc96c5..7ef1c6255d 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/naturalize/46/DateTimeUtils.java\n@@ -370,8 +370,7 @@ public class DateTimeUtils {\n             String n = (s.substring(s3 + 1, end) + \"000000000\").substring(0, 9);\n             nanos = Integer.parseInt(n);\n         }\n-        if (hour >= 2000000 || minute < 0 || minute >= 60 || second < 0\n-                || second >= 60) {\n+        if (hour >= 2000000 || minute < 0 || minute >= 60 || second < 0 || second >= 60) {\n             throw new IllegalArgumentException(s);\n         }\n         if (timeOfDay && hour >= 24) {\n@@ -481,7 +480,8 @@ public class DateTimeUtils {\n         }\n         int value = c.get(field);\n         if (field == Calendar.MONTH) {\n-            return value + 1; //\u6708\u4efd\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u8981\u52a01\n+            return value + 1;\n+//\u6708\u4efd\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u8981\u52a01\n         }\n         return value;\n     }\n@@ -951,4 +951,4 @@ public class DateTimeUtils {\n         return resultDate;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "494",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/codebuff/46/DateTimeUtils.java\nindex ea7edc96c5..7dc11b1863 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/codebuff/46/DateTimeUtils.java\n@@ -28,26 +28,25 @@ import org.h2.value.ValueTimestamp;\n  * Date value: a bit field with bits for the year, month, and day. Absolute day:\n  * the day number (0 means 1970-01-01).\n  */\n+\n+\n public class DateTimeUtils {\n \n     /**\n      * The number of milliseconds per day.\n      */\n-    public static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000L;\n \n-    private static final long NANOS_PER_DAY = MILLIS_PER_DAY * 1000000;\n \n+    public static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000L;\n+    private static final long NANOS_PER_DAY = MILLIS_PER_DAY * 1000000;\n     private static final int SHIFT_YEAR = 9;\n     private static final int SHIFT_MONTH = 5;\n-\n-    private static final int[] NORMAL_DAYS_PER_MONTH = { 0, 31, 28, 31, 30, 31,\n-            30, 31, 31, 30, 31, 30, 31 };\n+    private static final int[] NORMAL_DAYS_PER_MONTH = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n \n     /**\n      * Offsets of month within a year, starting with March, April,...\n      */\n-    private static final int[] DAYS_OFFSET = { 0, 31, 61, 92, 122, 153, 184,\n-            214, 245, 275, 306, 337, 366 };\n+    private static final int[] DAYS_OFFSET = { 0, 31, 61, 92, 122, 153, 184, 214, 245, 275, 306, 337, 366 };\n \n     /**\n      * The thread local. Can not override initialValue because this would result\n@@ -62,8 +61,7 @@ public class DateTimeUtils {\n     /**\n      * A cached instance of Calendar used when a timezone is specified.\n      */\n-    private static final ThreadLocal<Calendar> CACHED_CALENDAR_NON_DEFAULT_TIMEZONE =\n-            new ThreadLocal<Calendar>();\n+    private static final ThreadLocal<Calendar> CACHED_CALENDAR_NON_DEFAULT_TIMEZONE = new ThreadLocal<Calendar>();\n \n     /**\n      * Observed JVM behaviour is that if the timezone of the host computer is\n@@ -73,17 +71,19 @@ public class DateTimeUtils {\n      * use a fixed value throughout the duration of the JVM's life, rather than\n      * have this offset change, possibly midway through a long-running query.\n      */\n-    private static int zoneOffsetMillis = Calendar.getInstance()\n-            .get(Calendar.ZONE_OFFSET);\n+    private static int zoneOffsetMillis = Calendar.getInstance().get(Calendar.ZONE_OFFSET);\n \n     private DateTimeUtils() {\n         // utility class\n+\n     }\n \n     /**\n      * Reset the cached calendar for default timezone, for example after\n      * changing the default timezone.\n      */\n+\n+\n     public static void resetCalendar() {\n         CACHED_CALENDAR.remove();\n         zoneOffsetMillis = Calendar.getInstance().get(Calendar.ZONE_OFFSET);\n@@ -94,6 +94,7 @@ public class DateTimeUtils {\n      *\n      * @return a calendar instance. A cached instance is returned where possible\n      */\n+\n     private static Calendar getCalendar() {\n         Calendar c = CACHED_CALENDAR.get();\n         if (c == null) {\n@@ -110,6 +111,7 @@ public class DateTimeUtils {\n      * @param tz timezone for the calendar, is never null\n      * @return a calendar instance. A cached instance is returned where possible\n      */\n+\n     private static Calendar getCalendar(TimeZone tz) {\n         Calendar c = CACHED_CALENDAR_NON_DEFAULT_TIMEZONE.get();\n         if (c == null || !c.getTimeZone().equals(tz)) {\n@@ -127,6 +129,8 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the date using the correct time zone\n      */\n+\n+\n     public static Date convertDate(Value value, Calendar calendar) {\n         if (value == ValueNull.INSTANCE) {\n             return null;\n@@ -136,9 +140,7 @@ public class DateTimeUtils {\n         cal.clear();\n         cal.setLenient(true);\n         long dateValue = d.getDateValue();\n-        setCalendarFields(cal, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n+        setCalendarFields(cal, yearFromDateValue(dateValue), monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0, 0, 0, 0);\n         long ms = cal.getTimeInMillis();\n         return new Date(ms);\n     }\n@@ -150,6 +152,8 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the time using the correct time zone\n      */\n+\n+\n     public static Time convertTime(Value value, Calendar calendar) {\n         if (value == ValueNull.INSTANCE) {\n             return null;\n@@ -167,8 +171,7 @@ public class DateTimeUtils {\n         s -= m * 60;\n         long h = m / 60;\n         m -= h * 60;\n-        setCalendarFields(cal, 1970, 1, 1, (int) h, (int) m, (int) s,\n-                (int) millis);\n+        setCalendarFields(cal, 1970, 1, 1, (int) h, (int) m, (int) s, (int) millis);\n         long ms = cal.getTimeInMillis();\n         return new Time(ms);\n     }\n@@ -180,6 +183,8 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the timestamp using the correct time zone\n      */\n+\n+\n     public static Timestamp convertTimestamp(Value value, Calendar calendar) {\n         if (value == ValueNull.INSTANCE) {\n             return null;\n@@ -198,9 +203,7 @@ public class DateTimeUtils {\n         s -= m * 60;\n         long h = m / 60;\n         m -= h * 60;\n-        setCalendarFields(cal, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n-                (int) h, (int) m, (int) s, (int) millis);\n+        setCalendarFields(cal, yearFromDateValue(dateValue), monthFromDateValue(dateValue), dayFromDateValue(dateValue), (int) h, (int) m, (int) s, (int) millis);\n         long ms = cal.getTimeInMillis();\n         Timestamp x = new Timestamp(ms);\n         x.setNanos((int) (nanos + millis * 1000000));\n@@ -214,6 +217,8 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the date\n      */\n+\n+\n     public static ValueDate convertDate(Date x, Calendar calendar) {\n         if (calendar == null) {\n             throw DbException.getInvalidValueException(\"calendar\", null);\n@@ -231,6 +236,8 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the time\n      */\n+\n+\n     public static ValueTime convertTime(Time x, Calendar calendar) {\n         if (calendar == null) {\n             throw DbException.getInvalidValueException(\"calendar\", null);\n@@ -248,6 +255,8 @@ public class DateTimeUtils {\n      * @param target the calendar with the target timezone\n      * @return the milliseconds in UTC\n      */\n+\n+\n     public static long convertToLocal(java.util.Date x, Calendar target) {\n         if (target == null) {\n             throw DbException.getInvalidValueException(\"calendar\", null);\n@@ -265,7 +274,8 @@ public class DateTimeUtils {\n         to.set(Calendar.ERA, from.get(Calendar.ERA));\n         to.set(Calendar.YEAR, from.get(Calendar.YEAR));\n         to.set(Calendar.MONTH, from.get(Calendar.MONTH));\n-        to.set(Calendar.DAY_OF_MONTH, from.get(Calendar.DAY_OF_MONTH));\n+        to.set(Calendar.DAY_OF_MONTH,\n+from.get(Calendar.DAY_OF_MONTH));\n         to.set(Calendar.HOUR_OF_DAY, from.get(Calendar.HOUR_OF_DAY));\n         to.set(Calendar.MINUTE, from.get(Calendar.MINUTE));\n         to.set(Calendar.SECOND, from.get(Calendar.SECOND));\n@@ -279,8 +289,9 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the timestamp\n      */\n-    public static ValueTimestamp convertTimestamp(Timestamp x,\n-            Calendar calendar) {\n+\n+\n+    public static ValueTimestamp convertTimestamp(Timestamp x, Calendar calendar) {\n         if (calendar == null) {\n             throw DbException.getInvalidValueException(\"calendar\", null);\n         }\n@@ -301,6 +312,8 @@ public class DateTimeUtils {\n      * @return the date value\n      * @throws IllegalArgumentException if there is a problem\n      */\n+\n+\n     public static long parseDateValue(String s, int start, int end) {\n         if (s.charAt(start) == '+') {\n             // +year\n@@ -316,7 +329,8 @@ public class DateTimeUtils {\n         int month = Integer.parseInt(s.substring(s1 + 1, s2));\n         int day = Integer.parseInt(s.substring(s2 + 1, end));\n         if (!isValidDate(year, month, day)) {\n-            throw new IllegalArgumentException(year + \"-\" + month + \"-\" + day);\n+            throw new IllegalArgumentException(year + \"-\"\n+            + month + \"-\" + day);\n         }\n         return dateValue(year, month, day);\n     }\n@@ -333,8 +347,9 @@ public class DateTimeUtils {\n      * @return the time in nanoseconds\n      * @throws IllegalArgumentException if there is a problem\n      */\n-    public static long parseTimeNanos(String s, int start, int end,\n-            boolean timeOfDay) {\n+\n+\n+    public static long parseTimeNanos(String s, int start, int end, boolean timeOfDay) {\n         int hour = 0, minute = 0, second = 0;\n         long nanos = 0;\n         int s1 = s.indexOf(':', start);\n@@ -346,7 +361,6 @@ public class DateTimeUtils {\n             s1 = s.indexOf('.', start);\n             s2 = s.indexOf('.', s1 + 1);\n             s3 = s.indexOf('.', s2 + 1);\n-\n             if (s1 <= 0 || s2 <= s1) {\n                 throw new IllegalArgumentException(s);\n             }\n@@ -370,8 +384,7 @@ public class DateTimeUtils {\n             String n = (s.substring(s3 + 1, end) + \"000000000\").substring(0, 9);\n             nanos = Integer.parseInt(n);\n         }\n-        if (hour >= 2000000 || minute < 0 || minute >= 60 || second < 0\n-                || second >= 60) {\n+        if (hour >= 2000000 || minute < 0 || minute >= 60 || second < 0 || second >= 60) {\n             throw new IllegalArgumentException(s);\n         }\n         if (timeOfDay && hour >= 24) {\n@@ -396,11 +409,11 @@ public class DateTimeUtils {\n      * @param millis the number of milliseconds\n      * @return the number of milliseconds (UTC)\n      */\n-    public static long getMillis(TimeZone tz, int year, int month, int day,\n-            int hour, int minute, int second, int millis) {\n+\n+\n+    public static long getMillis(TimeZone tz, int year, int month, int day, int hour, int minute, int second, int millis) {\n         try {\n-            return getTimeTry(false, tz, year, month, day, hour, minute, second,\n-                    millis);\n+            return getTimeTry(false, tz, year, month, day, hour, minute, second, millis);\n         } catch (IllegalArgumentException e) {\n             // special case: if the time simply doesn't exist because of\n             // daylight saving time changes, use the lenient version\n@@ -409,8 +422,7 @@ public class DateTimeUtils {\n                 if (hour < 0 || hour > 23) {\n                     throw e;\n                 }\n-                return getTimeTry(true, tz, year, month, day, hour, minute,\n-                        second, millis);\n+                return getTimeTry(true, tz, year, month, day, hour, minute, second, millis);\n             } else if (message.indexOf(\"DAY_OF_MONTH\") > 0) {\n                 int maxDay;\n                 if (month == 2) {\n@@ -425,17 +437,14 @@ public class DateTimeUtils {\n                 // using the timezone Brasilia and others,\n                 // for example for 2042-10-12 00:00:00.\n                 hour += 6;\n-                return getTimeTry(true, tz, year, month, day, hour, minute,\n-                        second, millis);\n+                return getTimeTry(true, tz, year, month, day, hour, minute, second, millis);\n             } else {\n-                return getTimeTry(true, tz, year, month, day, hour, minute,\n-                        second, millis);\n+                return getTimeTry(true, tz, year, month, day, hour, minute, second, millis);\n             }\n         }\n     }\n \n-    private static long getTimeTry(boolean lenient, TimeZone tz, int year,\n-            int month, int day, int hour, int minute, int second, int millis) {\n+    private static long getTimeTry(boolean lenient, TimeZone tz, int year, int month, int day, int hour, int minute, int second, int millis) {\n         Calendar c;\n         if (tz == null) {\n             c = getCalendar();\n@@ -447,8 +456,7 @@ public class DateTimeUtils {\n         return c.getTime().getTime();\n     }\n \n-    private static void setCalendarFields(Calendar cal, int year, int month,\n-            int day, int hour, int minute, int second, int millis) {\n+    private static void setCalendarFields(Calendar cal, int year, int month, int day, int hour, int minute, int second, int millis) {\n         if (year <= 0) {\n             cal.set(Calendar.ERA, GregorianCalendar.BC);\n             cal.set(Calendar.YEAR, 1 - year);\n@@ -473,6 +481,8 @@ public class DateTimeUtils {\n      * @param field the field type\n      * @return the value\n      */\n+\n+\n     public static int getDatePart(java.util.Date d, int field) {\n         Calendar c = getCalendar();\n         c.setTime(d);\n@@ -492,6 +502,7 @@ public class DateTimeUtils {\n      * @param calendar the calendar\n      * @return the year\n      */\n+\n     private static int getYear(Calendar calendar) {\n         int year = calendar.get(Calendar.YEAR);\n         if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n@@ -507,6 +518,8 @@ public class DateTimeUtils {\n      * @param d the date\n      * @return the milliseconds\n      */\n+\n+\n     public static long getTimeLocalWithoutDst(java.util.Date d) {\n         return d.getTime() + zoneOffsetMillis;\n     }\n@@ -518,6 +531,8 @@ public class DateTimeUtils {\n      * @param millis the number of milliseconds in the local timezone\n      * @return the number of milliseconds in UTC\n      */\n+\n+\n     public static long getTimeUTCWithoutDst(long millis) {\n         return millis - zoneOffsetMillis;\n     }\n@@ -530,6 +545,8 @@ public class DateTimeUtils {\n      * @param date the date object which day of week should be calculated\n      * @return the day of the week, Monday as 1 to Sunday as 7\n      */\n+\n+\n     public static int getIsoDayOfWeek(java.util.Date date) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTimeInMillis(date.getTime());\n@@ -551,6 +568,8 @@ public class DateTimeUtils {\n      * @param date the date object which week of year should be calculated\n      * @return the week of the year\n      */\n+\n+\n     public static int getIsoWeek(java.util.Date date) {\n         Calendar c = Calendar.getInstance();\n         c.setTimeInMillis(date.getTime());\n@@ -566,6 +585,8 @@ public class DateTimeUtils {\n      * @param date the date object which year should be calculated\n      * @return the year\n      */\n+\n+\n     public static int getIsoYear(java.util.Date date) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTimeInMillis(date.getTime());\n@@ -591,7 +612,10 @@ public class DateTimeUtils {\n      * @param timeZone the timezone\n      * @return the formatted date\n      */\n-    public static String formatDateTime(java.util.Date date, String format,\n+\n+\n+    public static String formatDateTime(java.util.Date date,\n+        String format,\n             String locale, String timeZone) {\n         SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n         synchronized (dateFormat) {\n@@ -608,8 +632,9 @@ public class DateTimeUtils {\n      * @param timeZone the timeZone\n      * @return the parsed date\n      */\n-    public static java.util.Date parseDateTime(String date, String format,\n-            String locale, String timeZone) {\n+\n+\n+    public static java.util.Date parseDateTime(String date, String format, String locale, String timeZone) {\n         SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n         try {\n             synchronized (dateFormat) {\n@@ -621,8 +646,7 @@ public class DateTimeUtils {\n         }\n     }\n \n-    private static SimpleDateFormat getDateFormat(String format, String locale,\n-            String timeZone) {\n+    private static SimpleDateFormat getDateFormat(String format, String locale, String timeZone) {\n         try {\n             // currently, a new instance is create for each call\n             // however, could cache the last few instances\n@@ -638,8 +662,10 @@ public class DateTimeUtils {\n             }\n             return df;\n         } catch (Exception e) {\n-            throw DbException.get(ErrorCode.PARSE_ERROR_1, e,\n-                    format + \"/\" + locale + \"/\" + timeZone);\n+            throw DbException.get(ErrorCode.PARSE_ERROR_1,\n+                                  e,\n+                                  format + \"/\"\n+                                  + locale + \"/\" + timeZone);\n         }\n     }\n \n@@ -651,6 +677,8 @@ public class DateTimeUtils {\n      * @param day the day (1 is the first of the month)\n      * @return true if it is valid\n      */\n+\n+\n     public static boolean isValidDate(int year, int month, int day) {\n         if (month < 1 || month > 12 || day < 1) {\n             return false;\n@@ -664,7 +692,8 @@ public class DateTimeUtils {\n             if ((year & 3) != 0) {\n                 return day <= 28;\n             }\n-            return day <= ((year % 100 != 0) || (year % 400 == 0) ? 29 : 28);\n+            return day <= ((year % 100 != 0) ||\n+                       (year % 400 == 0) ? 29 : 28);\n         } else if (year == 1582 && month == 10) {\n             // special case: days 1582-10-05 .. 1582-10-14 don't exist\n             return day <= 31 && (day < 5 || day > 14);\n@@ -682,10 +711,10 @@ public class DateTimeUtils {\n      * @param dateValue the date value\n      * @return the date\n      */\n+\n+\n     public static Date convertDateValueToDate(long dateValue) {\n-        long millis = getMillis(null, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n+        long millis = getMillis(null, yearFromDateValue(dateValue), monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0, 0, 0, 0);\n         return new Date(millis);\n     }\n \n@@ -696,10 +725,10 @@ public class DateTimeUtils {\n      * @param dateValue the date value\n      * @return the date\n      */\n+\n+\n     public static long convertDateValueToMillis(TimeZone tz, long dateValue) {\n-        return getMillis(tz, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n+        return getMillis(tz, yearFromDateValue(dateValue), monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0, 0, 0, 0);\n     }\n \n     /**\n@@ -710,8 +739,9 @@ public class DateTimeUtils {\n      * @param timeNanos the nanoseconds since midnight\n      * @return the timestamp\n      */\n-    public static Timestamp convertDateValueToTimestamp(long dateValue,\n-            long timeNanos) {\n+\n+\n+    public static Timestamp convertDateValueToTimestamp(long dateValue, long timeNanos) {\n         long millis = timeNanos / 1000000;\n         timeNanos -= millis * 1000000;\n         long s = millis / 1000;\n@@ -720,9 +750,7 @@ public class DateTimeUtils {\n         s -= m * 60;\n         long h = m / 60;\n         m -= h * 60;\n-        long ms = getMillis(null, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n-                (int) h, (int) m, (int) s, 0);\n+        long ms = getMillis(null, yearFromDateValue(dateValue), monthFromDateValue(dateValue), dayFromDateValue(dateValue), (int) h, (int) m, (int) s, 0);\n         Timestamp ts = new Timestamp(ms);\n         ts.setNanos((int) (timeNanos + millis * 1000000));\n         return ts;\n@@ -734,6 +762,8 @@ public class DateTimeUtils {\n      * @param nanosSinceMidnight the nanoseconds since midnight\n      * @return the time\n      */\n+\n+\n     public static Time convertNanoToTime(long nanosSinceMidnight) {\n         long millis = nanosSinceMidnight / 1000000;\n         long s = millis / 1000;\n@@ -742,8 +772,7 @@ public class DateTimeUtils {\n         s -= m * 60;\n         long h = m / 60;\n         m -= h * 60;\n-        long ms = getMillis(null, 1970, 1, 1, (int) (h % 24), (int) m, (int) s,\n-                (int) millis);\n+        long ms = getMillis(null, 1970, 1, 1, (int) (h % 24), (int) m, (int) s, (int) millis);\n         return new Time(ms);\n     }\n \n@@ -753,6 +782,8 @@ public class DateTimeUtils {\n      * @param x the date value\n      * @return the year\n      */\n+\n+\n     public static int yearFromDateValue(long x) {\n         return (int) (x >>> SHIFT_YEAR);\n     }\n@@ -763,6 +794,8 @@ public class DateTimeUtils {\n      * @param x the date value\n      * @return the month (1..12)\n      */\n+\n+\n     public static int monthFromDateValue(long x) {\n         return (int) (x >>> SHIFT_MONTH) & 15;\n     }\n@@ -773,6 +806,8 @@ public class DateTimeUtils {\n      * @param x the date value\n      * @return the day (1..31)\n      */\n+\n+\n     public static int dayFromDateValue(long x) {\n         return (int) (x & 31);\n     }\n@@ -785,6 +820,8 @@ public class DateTimeUtils {\n      * @param day the day (1..31)\n      * @return the date value\n      */\n+\n+\n     public static long dateValue(long year, int month, int day) {\n         return (year << SHIFT_YEAR) | (month << SHIFT_MONTH) | day;\n     }\n@@ -796,6 +833,8 @@ public class DateTimeUtils {\n      * @param ms the milliseconds\n      * @return the date value\n      */\n+\n+\n     public static long dateValueFromDate(long ms) {\n         Calendar cal = getCalendar();\n         cal.setTimeInMillis(ms);\n@@ -808,6 +847,7 @@ public class DateTimeUtils {\n      * @param cal the calendar\n      * @return the date value\n      */\n+\n     private static long dateValueFromCalendar(Calendar cal) {\n         int year, month, day;\n         year = getYear(cal);\n@@ -823,6 +863,8 @@ public class DateTimeUtils {\n      * @param ms the milliseconds\n      * @return the nanoseconds\n      */\n+\n+\n     public static long nanosFromDate(long ms) {\n         Calendar cal = getCalendar();\n         cal.setTimeInMillis(ms);\n@@ -835,6 +877,7 @@ public class DateTimeUtils {\n      * @param cal the calendar\n      * @return the nanoseconds\n      */\n+\n     private static long nanosFromCalendar(Calendar cal) {\n         int h = cal.get(Calendar.HOUR_OF_DAY);\n         int m = cal.get(Calendar.MINUTE);\n@@ -850,8 +893,9 @@ public class DateTimeUtils {\n      * @param nanos the nanoseconds (may be negative or larger than one day)\n      * @return the timestamp\n      */\n-    public static ValueTimestamp normalizeTimestamp(long absoluteDay,\n-            long nanos) {\n+\n+\n+    public static ValueTimestamp normalizeTimestamp(long absoluteDay, long nanos) {\n         if (nanos > NANOS_PER_DAY || nanos < 0) {\n             long d;\n             if (nanos > NANOS_PER_DAY) {\n@@ -862,8 +906,7 @@ public class DateTimeUtils {\n             nanos -= d * NANOS_PER_DAY;\n             absoluteDay += d;\n         }\n-        return ValueTimestamp.fromDateValueAndNanos(\n-                dateValueFromAbsoluteDay(absoluteDay), nanos);\n+        return ValueTimestamp.fromDateValueAndNanos(dateValueFromAbsoluteDay(absoluteDay), nanos);\n     }\n \n     /**\n@@ -872,6 +915,8 @@ public class DateTimeUtils {\n      * @param dateValue the date value\n      * @return the absolute day\n      */\n+\n+\n     public static long absoluteDayFromDateValue(long dateValue) {\n         long y = yearFromDateValue(dateValue);\n         int m = monthFromDateValue(dateValue);\n@@ -881,7 +926,8 @@ public class DateTimeUtils {\n             m += 12;\n         }\n         long a = ((y * 2922L) >> 3) + DAYS_OFFSET[m - 3] + d - 719484;\n-        if (y <= 1582 && ((y < 1582) || (m * 100 + d < 1005))) {\n+        if (y <= 1582 && ((y < 1582) ||\n+                (m * 100 + d < 1005))) {\n             // Julian calendar (cutover at 1582-10-04 / 1582-10-15)\n             a += 13;\n         } else if (y < 1901 || y > 2099) {\n@@ -897,6 +943,8 @@ public class DateTimeUtils {\n      * @param absoluteDay the absolute day\n      * @return the date value\n      */\n+\n+\n     public static long dateValueFromAbsoluteDay(long absoluteDay) {\n         long d = absoluteDay + 719468;\n         long y100 = 0, offset;\n@@ -941,14 +989,15 @@ public class DateTimeUtils {\n      * @param nrOfMonthsToAdd the number of months to add\n      * @return the new timestamp\n      */\n+\n+\n     public static Timestamp addMonths(Timestamp refDate, int nrOfMonthsToAdd) {\n         Calendar calendar = Calendar.getInstance();\n         calendar.setTime(refDate);\n         calendar.add(Calendar.MONTH, nrOfMonthsToAdd);\n-\n         Timestamp resultDate = new Timestamp(calendar.getTimeInMillis());\n         resultDate.setNanos(refDate.getNanos());\n         return resultDate;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 149
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "483",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                },
                {
                    "line": "483",
                    "column": "38",
                    "severity": "warning",
                    "message": "'{' at column 38 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "483",
                    "column": "38",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "483",
                    "column": "39",
                    "severity": "warning",
                    "message": "'return' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/styler_random/46/DateTimeUtils.java\nindex ea7edc96c5..f5a1224d8d 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/errored/1/46/DateTimeUtils.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/codefollower-H2-Research/styler_random/46/DateTimeUtils.java\n@@ -480,49 +480,48 @@ public class DateTimeUtils {\n             return getYear(c);\n         }\n         int value = c.get(field);\n-        if (field == Calendar.MONTH) {\n-            return value + 1; //\u6708\u4efd\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u8981\u52a01\n-        }\n-        return value;\n+        if (field == Calendar.MONTH) {return value + 1; //\u6708\u4efd\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u8981\u52a01\n     }\n+    return value;\n+}\n \n-    /**\n+/**\n      * Get the year (positive or negative) from a calendar.\n      *\n      * @param calendar the calendar\n      * @return the year\n      */\n-    private static int getYear(Calendar calendar) {\n-        int year = calendar.get(Calendar.YEAR);\n-        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n-            year = 1 - year;\n-        }\n-        return year;\n+private static int getYear(Calendar calendar) {\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year;\n     }\n+    return year;\n+}\n \n-    /**\n+/**\n      * Get the number of milliseconds since 1970-01-01 in the local timezone,\n      * but without daylight saving time into account.\n      *\n      * @param d the date\n      * @return the milliseconds\n      */\n-    public static long getTimeLocalWithoutDst(java.util.Date d) {\n-        return d.getTime() + zoneOffsetMillis;\n-    }\n+public static long getTimeLocalWithoutDst(java.util.Date d) {\n+    return d.getTime() + zoneOffsetMillis;\n+}\n \n-    /**\n+/**\n      * Convert the number of milliseconds since 1970-01-01 in the local timezone\n      * to UTC, but without daylight saving time into account.\n      *\n      * @param millis the number of milliseconds in the local timezone\n      * @return the number of milliseconds in UTC\n      */\n-    public static long getTimeUTCWithoutDst(long millis) {\n-        return millis - zoneOffsetMillis;\n-    }\n+public static long getTimeUTCWithoutDst(long millis) {\n+    return millis - zoneOffsetMillis;\n+}\n \n-    /**\n+/**\n      * Return the day of week according to the ISO 8601 specification. Week\n      * starts at Monday. See also http://en.wikipedia.org/wiki/ISO_8601\n      *\n@@ -530,14 +529,14 @@ public class DateTimeUtils {\n      * @param date the date object which day of week should be calculated\n      * @return the day of the week, Monday as 1 to Sunday as 7\n      */\n-    public static int getIsoDayOfWeek(java.util.Date date) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTimeInMillis(date.getTime());\n-        int val = cal.get(Calendar.DAY_OF_WEEK) - 1;\n-        return val == 0 ? 7 : val;\n-    }\n+public static int getIsoDayOfWeek(java.util.Date date) {\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(date.getTime());\n+    int val = cal.get(Calendar.DAY_OF_WEEK) - 1;\n+    return val == 0 ? 7 : val;\n+}\n \n-    /**\n+/**\n      * Returns the week of the year according to the ISO 8601 specification. The\n      * spec defines the first week of the year as the week which contains at\n      * least 4 days of the new year. The week starts at Monday. Therefore\n@@ -551,38 +550,38 @@ public class DateTimeUtils {\n      * @param date the date object which week of year should be calculated\n      * @return the week of the year\n      */\n-    public static int getIsoWeek(java.util.Date date) {\n-        Calendar c = Calendar.getInstance();\n-        c.setTimeInMillis(date.getTime());\n-        c.setFirstDayOfWeek(Calendar.MONDAY);\n-        c.setMinimalDaysInFirstWeek(4);\n-        return c.get(Calendar.WEEK_OF_YEAR);\n-    }\n+public static int getIsoWeek(java.util.Date date) {\n+    Calendar c = Calendar.getInstance();\n+    c.setTimeInMillis(date.getTime());\n+    c.setFirstDayOfWeek(Calendar.MONDAY);\n+    c.setMinimalDaysInFirstWeek(4);\n+    return c.get(Calendar.WEEK_OF_YEAR);\n+}\n \n-    /**\n+/**\n      * Returns the year according to the ISO week definition.\n      *\n      * @author Robert Rathsack\n      * @param date the date object which year should be calculated\n      * @return the year\n      */\n-    public static int getIsoYear(java.util.Date date) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTimeInMillis(date.getTime());\n-        cal.setFirstDayOfWeek(Calendar.MONDAY);\n-        cal.setMinimalDaysInFirstWeek(4);\n-        int year = getYear(cal);\n-        int month = cal.get(Calendar.MONTH);\n-        int week = cal.get(Calendar.WEEK_OF_YEAR);\n-        if (month == 0 && week > 51) {\n-            year--;\n-        } else if (month == 11 && week == 1) {\n-            year++;\n-        }\n-        return year;\n-    }\n+public static int getIsoYear(java.util.Date date) {\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(date.getTime());\n+    cal.setFirstDayOfWeek(Calendar.MONDAY);\n+    cal.setMinimalDaysInFirstWeek(4);\n+    int year = getYear(cal);\n+    int month = cal.get(Calendar.MONTH);\n+    int week = cal.get(Calendar.WEEK_OF_YEAR);\n+    if (month == 0 && week > 51) {\n+        year--;\n+    } else if (month == 11 && week == 1) {\n+        year++;\n+    }\n+    return year;\n+}\n \n-    /**\n+/**\n      * Formats a date using a format string.\n      *\n      * @param date the date to format\n@@ -591,15 +590,15 @@ public class DateTimeUtils {\n      * @param timeZone the timezone\n      * @return the formatted date\n      */\n-    public static String formatDateTime(java.util.Date date, String format,\n-            String locale, String timeZone) {\n-        SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n-        synchronized (dateFormat) {\n-            return dateFormat.format(date);\n-        }\n+public static String formatDateTime(java.util.Date date, String format,\n+        String locale, String timeZone) {\n+    SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n+    synchronized (dateFormat) {\n+        return dateFormat.format(date);\n     }\n+}\n \n-    /**\n+/**\n      * Parses a date using a format string.\n      *\n      * @param date the date to parse\n@@ -608,42 +607,42 @@ public class DateTimeUtils {\n      * @param timeZone the timeZone\n      * @return the parsed date\n      */\n-    public static java.util.Date parseDateTime(String date, String format,\n-            String locale, String timeZone) {\n-        SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n-        try {\n-            synchronized (dateFormat) {\n-                return dateFormat.parse(date);\n-            }\n-        } catch (Exception e) {\n-            // ParseException\n-            throw DbException.get(ErrorCode.PARSE_ERROR_1, e, date);\n+public static java.util.Date parseDateTime(String date, String format,\n+        String locale, String timeZone) {\n+    SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n+    try {\n+        synchronized (dateFormat) {\n+            return dateFormat.parse(date);\n         }\n+    } catch (Exception e) {\n+        // ParseException\n+        throw DbException.get(ErrorCode.PARSE_ERROR_1, e, date);\n     }\n+}\n \n-    private static SimpleDateFormat getDateFormat(String format, String locale,\n-            String timeZone) {\n-        try {\n-            // currently, a new instance is create for each call\n-            // however, could cache the last few instances\n-            SimpleDateFormat df;\n-            if (locale == null) {\n-                df = new SimpleDateFormat(format);\n-            } else {\n-                Locale l = new Locale(locale);\n-                df = new SimpleDateFormat(format, l);\n-            }\n-            if (timeZone != null) {\n-                df.setTimeZone(TimeZone.getTimeZone(timeZone));\n-            }\n-            return df;\n-        } catch (Exception e) {\n-            throw DbException.get(ErrorCode.PARSE_ERROR_1, e,\n-                    format + \"/\" + locale + \"/\" + timeZone);\n+private static SimpleDateFormat getDateFormat(String format, String locale,\n+        String timeZone) {\n+    try {\n+        // currently, a new instance is create for each call\n+        // however, could cache the last few instances\n+        SimpleDateFormat df;\n+        if (locale == null) {\n+            df = new SimpleDateFormat(format);\n+        } else {\n+            Locale l = new Locale(locale);\n+            df = new SimpleDateFormat(format, l);\n         }\n+        if (timeZone != null) {\n+            df.setTimeZone(TimeZone.getTimeZone(timeZone));\n+        }\n+        return df;\n+    } catch (Exception e) {\n+        throw DbException.get(ErrorCode.PARSE_ERROR_1, e,\n+                format + \"/\" + locale + \"/\" + timeZone);\n     }\n+}\n \n-    /**\n+/**\n      * Verify if the specified date is valid.\n      *\n      * @param year the year\n@@ -651,58 +650,58 @@ public class DateTimeUtils {\n      * @param day the day (1 is the first of the month)\n      * @return true if it is valid\n      */\n-    public static boolean isValidDate(int year, int month, int day) {\n-        if (month < 1 || month > 12 || day < 1) {\n-            return false;\n-        }\n-        if (year > 1582) {\n-            // Gregorian calendar\n-            if (month != 2) {\n-                return day <= NORMAL_DAYS_PER_MONTH[month];\n-            }\n-            // February\n-            if ((year & 3) != 0) {\n-                return day <= 28;\n-            }\n-            return day <= ((year % 100 != 0) || (year % 400 == 0) ? 29 : 28);\n-        } else if (year == 1582 && month == 10) {\n-            // special case: days 1582-10-05 .. 1582-10-14 don't exist\n-            return day <= 31 && (day < 5 || day > 14);\n+public static boolean isValidDate(int year, int month, int day) {\n+    if (month < 1 || month > 12 || day < 1) {\n+        return false;\n+    }\n+    if (year > 1582) {\n+        // Gregorian calendar\n+        if (month != 2) {\n+            return day <= NORMAL_DAYS_PER_MONTH[month];\n         }\n-        if (month != 2 && day <= NORMAL_DAYS_PER_MONTH[month]) {\n-            return true;\n+        // February\n+        if ((year & 3) != 0) {\n+            return day <= 28;\n         }\n-        return day <= ((year & 3) != 0 ? 28 : 29);\n+        return day <= ((year % 100 != 0) || (year % 400 == 0) ? 29 : 28);\n+    } else if (year == 1582 && month == 10) {\n+        // special case: days 1582-10-05 .. 1582-10-14 don't exist\n+        return day <= 31 && (day < 5 || day > 14);\n+    }\n+    if (month != 2 && day <= NORMAL_DAYS_PER_MONTH[month]) {\n+        return true;\n     }\n+    return day <= ((year & 3) != 0 ? 28 : 29);\n+}\n \n-    /**\n+/**\n      * Convert an encoded date value to a java.util.Date, using the default\n      * timezone.\n      *\n      * @param dateValue the date value\n      * @return the date\n      */\n-    public static Date convertDateValueToDate(long dateValue) {\n-        long millis = getMillis(null, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n-        return new Date(millis);\n-    }\n+public static Date convertDateValueToDate(long dateValue) {\n+    long millis = getMillis(null, yearFromDateValue(dateValue),\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n+            0, 0, 0);\n+    return new Date(millis);\n+}\n \n-    /**\n+/**\n      * Convert an encoded date value to millis, using the supplied timezone.\n      *\n      * @param tz the timezone\n      * @param dateValue the date value\n      * @return the date\n      */\n-    public static long convertDateValueToMillis(TimeZone tz, long dateValue) {\n-        return getMillis(tz, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n-                0, 0, 0);\n-    }\n+public static long convertDateValueToMillis(TimeZone tz, long dateValue) {\n+    return getMillis(tz, yearFromDateValue(dateValue),\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue), 0,\n+            0, 0, 0);\n+}\n \n-    /**\n+/**\n      * Convert an encoded date value / time value to a timestamp, using the\n      * default timezone.\n      *\n@@ -710,74 +709,74 @@ public class DateTimeUtils {\n      * @param timeNanos the nanoseconds since midnight\n      * @return the timestamp\n      */\n-    public static Timestamp convertDateValueToTimestamp(long dateValue,\n-            long timeNanos) {\n-        long millis = timeNanos / 1000000;\n-        timeNanos -= millis * 1000000;\n-        long s = millis / 1000;\n-        millis -= s * 1000;\n-        long m = s / 60;\n-        s -= m * 60;\n-        long h = m / 60;\n-        m -= h * 60;\n-        long ms = getMillis(null, yearFromDateValue(dateValue),\n-                monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n-                (int) h, (int) m, (int) s, 0);\n-        Timestamp ts = new Timestamp(ms);\n-        ts.setNanos((int) (timeNanos + millis * 1000000));\n-        return ts;\n-    }\n+public static Timestamp convertDateValueToTimestamp(long dateValue,\n+        long timeNanos) {\n+    long millis = timeNanos / 1000000;\n+    timeNanos -= millis * 1000000;\n+    long s = millis / 1000;\n+    millis -= s * 1000;\n+    long m = s / 60;\n+    s -= m * 60;\n+    long h = m / 60;\n+    m -= h * 60;\n+    long ms = getMillis(null, yearFromDateValue(dateValue),\n+            monthFromDateValue(dateValue), dayFromDateValue(dateValue),\n+            (int) h, (int) m, (int) s, 0);\n+    Timestamp ts = new Timestamp(ms);\n+    ts.setNanos((int) (timeNanos + millis * 1000000));\n+    return ts;\n+}\n \n-    /**\n+/**\n      * Convert a time value to a time, using the default timezone.\n      *\n      * @param nanosSinceMidnight the nanoseconds since midnight\n      * @return the time\n      */\n-    public static Time convertNanoToTime(long nanosSinceMidnight) {\n-        long millis = nanosSinceMidnight / 1000000;\n-        long s = millis / 1000;\n-        millis -= s * 1000;\n-        long m = s / 60;\n-        s -= m * 60;\n-        long h = m / 60;\n-        m -= h * 60;\n-        long ms = getMillis(null, 1970, 1, 1, (int) (h % 24), (int) m, (int) s,\n-                (int) millis);\n-        return new Time(ms);\n-    }\n+public static Time convertNanoToTime(long nanosSinceMidnight) {\n+    long millis = nanosSinceMidnight / 1000000;\n+    long s = millis / 1000;\n+    millis -= s * 1000;\n+    long m = s / 60;\n+    s -= m * 60;\n+    long h = m / 60;\n+    m -= h * 60;\n+    long ms = getMillis(null, 1970, 1, 1, (int) (h % 24), (int) m, (int) s,\n+            (int) millis);\n+    return new Time(ms);\n+}\n \n-    /**\n+/**\n      * Get the year from a date value.\n      *\n      * @param x the date value\n      * @return the year\n      */\n-    public static int yearFromDateValue(long x) {\n-        return (int) (x >>> SHIFT_YEAR);\n-    }\n+public static int yearFromDateValue(long x) {\n+    return (int) (x >>> SHIFT_YEAR);\n+}\n \n-    /**\n+/**\n      * Get the month from a date value.\n      *\n      * @param x the date value\n      * @return the month (1..12)\n      */\n-    public static int monthFromDateValue(long x) {\n-        return (int) (x >>> SHIFT_MONTH) & 15;\n-    }\n+public static int monthFromDateValue(long x) {\n+    return (int) (x >>> SHIFT_MONTH) & 15;\n+}\n \n-    /**\n+/**\n      * Get the day of month from a date value.\n      *\n      * @param x the date value\n      * @return the day (1..31)\n      */\n-    public static int dayFromDateValue(long x) {\n-        return (int) (x & 31);\n-    }\n+public static int dayFromDateValue(long x) {\n+    return (int) (x & 31);\n+}\n \n-    /**\n+/**\n      * Get the date value from a given date.\n      *\n      * @param year the year\n@@ -785,153 +784,153 @@ public class DateTimeUtils {\n      * @param day the day (1..31)\n      * @return the date value\n      */\n-    public static long dateValue(long year, int month, int day) {\n-        return (year << SHIFT_YEAR) | (month << SHIFT_MONTH) | day;\n-    }\n+public static long dateValue(long year, int month, int day) {\n+    return (year << SHIFT_YEAR) | (month << SHIFT_MONTH) | day;\n+}\n \n-    /**\n+/**\n      * Convert a UTC datetime in millis to an encoded date in the default\n      * timezone.\n      *\n      * @param ms the milliseconds\n      * @return the date value\n      */\n-    public static long dateValueFromDate(long ms) {\n-        Calendar cal = getCalendar();\n-        cal.setTimeInMillis(ms);\n-        return dateValueFromCalendar(cal);\n-    }\n+public static long dateValueFromDate(long ms) {\n+    Calendar cal = getCalendar();\n+    cal.setTimeInMillis(ms);\n+    return dateValueFromCalendar(cal);\n+}\n \n-    /**\n+/**\n      * Calculate the encoded date value from a given calendar.\n      *\n      * @param cal the calendar\n      * @return the date value\n      */\n-    private static long dateValueFromCalendar(Calendar cal) {\n-        int year, month, day;\n-        year = getYear(cal);\n-        month = cal.get(Calendar.MONTH) + 1;\n-        day = cal.get(Calendar.DAY_OF_MONTH);\n-        return ((long) year << SHIFT_YEAR) | (month << SHIFT_MONTH) | day;\n-    }\n+private static long dateValueFromCalendar(Calendar cal) {\n+    int year, month, day;\n+    year = getYear(cal);\n+    month = cal.get(Calendar.MONTH) + 1;\n+    day = cal.get(Calendar.DAY_OF_MONTH);\n+    return ((long) year << SHIFT_YEAR) | (month << SHIFT_MONTH) | day;\n+}\n \n-    /**\n+/**\n      * Convert a time in milliseconds in UTC to the nanoseconds since midnight\n      * (in the default timezone).\n      *\n      * @param ms the milliseconds\n      * @return the nanoseconds\n      */\n-    public static long nanosFromDate(long ms) {\n-        Calendar cal = getCalendar();\n-        cal.setTimeInMillis(ms);\n-        return nanosFromCalendar(cal);\n-    }\n+public static long nanosFromDate(long ms) {\n+    Calendar cal = getCalendar();\n+    cal.setTimeInMillis(ms);\n+    return nanosFromCalendar(cal);\n+}\n \n-    /**\n+/**\n      * Convert a java.util.Calendar to nanoseconds since midnight.\n      *\n      * @param cal the calendar\n      * @return the nanoseconds\n      */\n-    private static long nanosFromCalendar(Calendar cal) {\n-        int h = cal.get(Calendar.HOUR_OF_DAY);\n-        int m = cal.get(Calendar.MINUTE);\n-        int s = cal.get(Calendar.SECOND);\n-        int millis = cal.get(Calendar.MILLISECOND);\n-        return ((((((h * 60L) + m) * 60) + s) * 1000) + millis) * 1000000;\n-    }\n+private static long nanosFromCalendar(Calendar cal) {\n+    int h = cal.get(Calendar.HOUR_OF_DAY);\n+    int m = cal.get(Calendar.MINUTE);\n+    int s = cal.get(Calendar.SECOND);\n+    int millis = cal.get(Calendar.MILLISECOND);\n+    return ((((((h * 60L) + m) * 60) + s) * 1000) + millis) * 1000000;\n+}\n \n-    /**\n+/**\n      * Calculate the normalized timestamp.\n      *\n      * @param absoluteDay the absolute day\n      * @param nanos the nanoseconds (may be negative or larger than one day)\n      * @return the timestamp\n      */\n-    public static ValueTimestamp normalizeTimestamp(long absoluteDay,\n-            long nanos) {\n-        if (nanos > NANOS_PER_DAY || nanos < 0) {\n-            long d;\n-            if (nanos > NANOS_PER_DAY) {\n-                d = nanos / NANOS_PER_DAY;\n-            } else {\n-                d = (nanos - NANOS_PER_DAY + 1) / NANOS_PER_DAY;\n-            }\n-            nanos -= d * NANOS_PER_DAY;\n-            absoluteDay += d;\n+public static ValueTimestamp normalizeTimestamp(long absoluteDay,\n+        long nanos) {\n+    if (nanos > NANOS_PER_DAY || nanos < 0) {\n+        long d;\n+        if (nanos > NANOS_PER_DAY) {\n+            d = nanos / NANOS_PER_DAY;\n+        } else {\n+            d = (nanos - NANOS_PER_DAY + 1) / NANOS_PER_DAY;\n         }\n-        return ValueTimestamp.fromDateValueAndNanos(\n-                dateValueFromAbsoluteDay(absoluteDay), nanos);\n+        nanos -= d * NANOS_PER_DAY;\n+        absoluteDay += d;\n     }\n+    return ValueTimestamp.fromDateValueAndNanos(\n+            dateValueFromAbsoluteDay(absoluteDay), nanos);\n+}\n \n-    /**\n+/**\n      * Calculate the absolute day from an encoded date value.\n      *\n      * @param dateValue the date value\n      * @return the absolute day\n      */\n-    public static long absoluteDayFromDateValue(long dateValue) {\n-        long y = yearFromDateValue(dateValue);\n-        int m = monthFromDateValue(dateValue);\n-        int d = dayFromDateValue(dateValue);\n-        if (m <= 2) {\n-            y--;\n-            m += 12;\n-        }\n-        long a = ((y * 2922L) >> 3) + DAYS_OFFSET[m - 3] + d - 719484;\n-        if (y <= 1582 && ((y < 1582) || (m * 100 + d < 1005))) {\n-            // Julian calendar (cutover at 1582-10-04 / 1582-10-15)\n-            a += 13;\n-        } else if (y < 1901 || y > 2099) {\n-            // Gregorian calendar (slow mode)\n-            a += (y / 400) - (y / 100) + 15;\n-        }\n-        return a;\n-    }\n+public static long absoluteDayFromDateValue(long dateValue) {\n+    long y = yearFromDateValue(dateValue);\n+    int m = monthFromDateValue(dateValue);\n+    int d = dayFromDateValue(dateValue);\n+    if (m <= 2) {\n+        y--;\n+        m += 12;\n+    }\n+    long a = ((y * 2922L) >> 3) + DAYS_OFFSET[m - 3] + d - 719484;\n+    if (y <= 1582 && ((y < 1582) || (m * 100 + d < 1005))) {\n+        // Julian calendar (cutover at 1582-10-04 / 1582-10-15)\n+        a += 13;\n+    } else if (y < 1901 || y > 2099) {\n+        // Gregorian calendar (slow mode)\n+        a += (y / 400) - (y / 100) + 15;\n+    }\n+    return a;\n+}\n \n-    /**\n+/**\n      * Calculate the encoded date value from an absolute day.\n      *\n      * @param absoluteDay the absolute day\n      * @return the date value\n      */\n-    public static long dateValueFromAbsoluteDay(long absoluteDay) {\n-        long d = absoluteDay + 719468;\n-        long y100 = 0, offset;\n-        if (d > 578040) {\n-            // Gregorian calendar\n-            long y400 = d / 146097;\n-            d -= y400 * 146097;\n-            y100 = d / 36524;\n-            d -= y100 * 36524;\n-            offset = y400 * 400 + y100 * 100;\n-        } else {\n-            // Julian calendar\n-            d += 292200000002L;\n-            offset = -800000000;\n-        }\n-        long y4 = d / 1461;\n-        d -= y4 * 1461;\n-        long y = d / 365;\n-        d -= y * 365;\n-        if (d == 0 && (y == 4 || y100 == 4)) {\n-            y--;\n-            d += 365;\n-        }\n-        y += offset + y4 * 4;\n-        // month of a day\n-        int m = ((int) d * 2 + 1) * 5 / 306;\n-        d -= DAYS_OFFSET[m] - 1;\n-        if (m >= 10) {\n-            y++;\n-            m -= 12;\n-        }\n-        return dateValue(y, m + 3, (int) d);\n-    }\n+public static long dateValueFromAbsoluteDay(long absoluteDay) {\n+    long d = absoluteDay + 719468;\n+    long y100 = 0, offset;\n+    if (d > 578040) {\n+        // Gregorian calendar\n+        long y400 = d / 146097;\n+        d -= y400 * 146097;\n+        y100 = d / 36524;\n+        d -= y100 * 36524;\n+        offset = y400 * 400 + y100 * 100;\n+    } else {\n+        // Julian calendar\n+        d += 292200000002L;\n+        offset = -800000000;\n+    }\n+    long y4 = d / 1461;\n+    d -= y4 * 1461;\n+    long y = d / 365;\n+    d -= y * 365;\n+    if (d == 0 && (y == 4 || y100 == 4)) {\n+        y--;\n+        d += 365;\n+    }\n+    y += offset + y4 * 4;\n+    // month of a day\n+    int m = ((int) d * 2 + 1) * 5 / 306;\n+    d -= DAYS_OFFSET[m] - 1;\n+    if (m >= 10) {\n+        y++;\n+        m -= 12;\n+    }\n+    return dateValue(y, m + 3, (int) d);\n+}\n \n-    /**\n+/**\n      * Adds the number of months to the date. If the resulting month's number of\n      * days is less than the original's day-of-month, the resulting\n      * day-of-months gets adjusted accordingly: <br>\n@@ -941,14 +940,14 @@ public class DateTimeUtils {\n      * @param nrOfMonthsToAdd the number of months to add\n      * @return the new timestamp\n      */\n-    public static Timestamp addMonths(Timestamp refDate, int nrOfMonthsToAdd) {\n-        Calendar calendar = Calendar.getInstance();\n-        calendar.setTime(refDate);\n-        calendar.add(Calendar.MONTH, nrOfMonthsToAdd);\n+public static Timestamp addMonths(Timestamp refDate, int nrOfMonthsToAdd) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTime(refDate);\n+    calendar.add(Calendar.MONTH, nrOfMonthsToAdd);\n \n-        Timestamp resultDate = new Timestamp(calendar.getTimeInMillis());\n-        resultDate.setNanos(refDate.getNanos());\n-        return resultDate;\n-    }\n+    Timestamp resultDate = new Timestamp(calendar.getTimeInMillis());\n+    resultDate.setNanos(refDate.getNanos());\n+    return resultDate;\n+}\n \n }\n",
            "diff_size": 301
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "484",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}