{
    "error_id": "54",
    "information": {
        "errors": [
            {
                "line": "841",
                "column": "13",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "\n        } else {\n            if(object.getClass().isArray()) {\n                // 'Switch' on type of array, to dispatch to the correct handler\n                // This handles multi dimensional arrays\n                if (object instanceof long[]) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/54/HashCodeBuilder.java\nindex c69eb5b145..a340f4d4a1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler/54/HashCodeBuilder.java\n@@ -1,976 +1,976 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n-\r\n-/**\r\n- * <p>\r\n- * Assists in implementing {@link Object#hashCode()} methods.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\r\n- * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\r\n- * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * The following is the approach taken. When appending a data field, the current total is multiplied by the\r\n- * multiplier then a relevant value\r\n- * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then\r\n- * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\r\n- * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\r\n- * method.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * To use this class write code as follows:\r\n- * </p>\r\n- *\r\n- * <pre>\r\n- * public class Person {\r\n- *   String name;\r\n- *   int age;\r\n- *   boolean smoker;\r\n- *   ...\r\n- *\r\n- *   public int hashCode() {\r\n- *     // you pick a hard-coded, randomly chosen, non-zero, odd number\r\n- *     // ideally different for each class\r\n- *     return new HashCodeBuilder(17, 37).\r\n- *       append(name).\r\n- *       append(age).\r\n- *       append(smoker).\r\n- *       toHashCode();\r\n- *   }\r\n- * }\r\n- * </pre>\r\n- *\r\n- * <p>\r\n- * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\r\n- * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\r\n- * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\r\n- * are set up correctly. It is also slower than testing explicitly.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * A typical invocation for this method would look like:\r\n- * </p>\r\n- *\r\n- * <pre>\r\n- * public int hashCode() {\r\n- *   return HashCodeBuilder.reflectionHashCode(this);\r\n- * }\r\n- * </pre>\r\n- *\r\n- * @since 1.0\r\n- * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\r\n- */\r\n-public class HashCodeBuilder implements Builder<Integer> {\r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 2.3\r\n-     */\r\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of objects being traversed by the reflection methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 2.3\r\n-     */\r\n-    static Set<IDKey> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\r\n-     * infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to lookup in the registry.\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 2.3\r\n-     */\r\n-    static boolean isRegistered(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        return registry != null && registry.contains(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given <code>Class</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the object to append details of\r\n-     * @param clazz\r\n-     *            the class to append details of\r\n-     * @param builder\r\n-     *            the builder to append to\r\n-     * @param useTransients\r\n-     *            whether to use transient fields\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     */\r\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n-            String[] excludeFields) {\r\n-        if (isRegistered(object)) {\r\n-            return;\r\n-        }\r\n-        try {\r\n-            register(object);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n-                        Object fieldValue = field.get(object);\r\n-                        builder.append(fieldValue);\r\n-                    } catch (IllegalAccessException e) {\r\n-                        // this can't happen. Would get a Security exception instead\r\n-                        // throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(object);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n-            boolean testTransients) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be included up to and including the specified\r\n-     * superclass. A null superclass is treated as java.lang.Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object involved\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     * @since 2.0\r\n-     */\r\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n-            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n-        }\r\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n-        Class<?> clazz = object.getClass();\r\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n-            clazz = clazz.getSuperclass();\r\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        }\r\n-        return builder.toHashCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <P>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\r\n-        return reflectionHashCode(17, 37, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\r\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object. Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to register.\r\n-     */\r\n-    static void register(Object value) {\r\n-        synchronized (HashCodeBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<IDKey>());\r\n-            }\r\n-        }\r\n-        getRegistry().add(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param value\r\n-     *            The object to unregister.\r\n-     * @since 2.3\r\n-     */\r\n-    static void unregister(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            registry.remove(new IDKey(value));\r\n-            synchronized (HashCodeBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constant to use in building the hashCode.\r\n-     */\r\n-    private final int iConstant;\r\n-\r\n-    /**\r\n-     * Running total of the hashCode.\r\n-     */\r\n-    private int iTotal = 0;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n-     * </p>\r\n-     */\r\n-    public HashCodeBuilder() {\r\n-        iConstant = 37;\r\n-        iTotal = 17;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n-        if (initialNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n-        }\r\n-        if (initialNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n-        }\r\n-        iConstant = multiplierNonZeroOddNumber;\r\n-        iTotal = initialNonZeroOddNumber;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\r\n-     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>false</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in accordance with the <quote>Effective Java</quote> design.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the boolean to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean value) {\r\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (boolean element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the byte to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (byte element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the char to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (char element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the double to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double value) {\r\n-        return append(Double.doubleToLongBits(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (double element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the float to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float value) {\r\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (float element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the int to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (int element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the long to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    // NOTE: This method uses >> and not >>> as Effective Java and\r\n-    //       Long.hashCode do. Ideally we should switch to >>> at\r\n-    //       some stage. There are backwards compat issues, so\r\n-    //       that will have to wait for the time being. cf LANG-342.\r\n-    public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(long[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (long element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object object) {\r\n-        if (object == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-\r\n-        } else {\r\n-            if(object.getClass().isArray()) {\r\n-                // 'Switch' on type of array, to dispatch to the correct handler\r\n-                // This handles multi dimensional arrays\r\n-                if (object instanceof long[]) {\r\n-                    append((long[]) object);\r\n-                } else if (object instanceof int[]) {\r\n-                    append((int[]) object);\r\n-                } else if (object instanceof short[]) {\r\n-                    append((short[]) object);\r\n-                } else if (object instanceof char[]) {\r\n-                    append((char[]) object);\r\n-                } else if (object instanceof byte[]) {\r\n-                    append((byte[]) object);\r\n-                } else if (object instanceof double[]) {\r\n-                    append((double[]) object);\r\n-                } else if (object instanceof float[]) {\r\n-                    append((float[]) object);\r\n-                } else if (object instanceof boolean[]) {\r\n-                    append((boolean[]) object);\r\n-                } else {\r\n-                    // Not an array of primitives\r\n-                    append((Object[]) object);\r\n-                }\r\n-            } else {\r\n-                iTotal = iTotal * iConstant + object.hashCode();\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (Object element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the short to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (short element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Adds the result of super.hashCode() to this builder.\r\n-     * </p>\r\n-     *\r\n-     * @param superHashCode\r\n-     *            the result of calling <code>super.hashCode()</code>\r\n-     * @return this HashCodeBuilder, used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public HashCodeBuilder appendSuper(int superHashCode) {\r\n-        iTotal = iTotal * iConstant + superHashCode;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Return the computed <code>hashCode</code>.\r\n-     * </p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     */\r\n-    public int toHashCode() {\r\n-        return iTotal;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the computed <code>hashCode</code>.\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Integer build() {\r\n-        return Integer.valueOf(toHashCode());\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\r\n-     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\r\n-     * HashCodeBuilder itself is.</p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     * @since 2.5\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return toHashCode();\r\n-    }\r\n-\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#hashCode()} methods.\n+ * </p>\n+ *\n+ * <p>\n+ * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n+ * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n+ * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n+ * </p>\n+ *\n+ * <p>\n+ * The following is the approach taken. When appending a data field, the current total is multiplied by the\n+ * multiplier then a relevant value\n+ * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then\n+ * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.\n+ * </p>\n+ *\n+ * <p>\n+ * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n+ * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n+ * method.\n+ * </p>\n+ *\n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ *\n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ *   ...\n+ *\n+ *   public int hashCode() {\n+ *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n+ *     // ideally different for each class\n+ *     return new HashCodeBuilder(17, 37).\n+ *       append(name).\n+ *       append(age).\n+ *       append(smoker).\n+ *       toHashCode();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>\n+ * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n+ * </p>\n+ *\n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n+ * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n+ * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n+ * are set up correctly. It is also slower than testing explicitly.\n+ * </p>\n+ *\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ *\n+ * <pre>\n+ * public int hashCode() {\n+ *   return HashCodeBuilder.reflectionHashCode(this);\n+ * }\n+ * </pre>\n+ *\n+ * @since 1.0\n+ * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\n+ */\n+public class HashCodeBuilder implements Builder<Integer> {\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     *\n+     * @since 2.3\n+     */\n+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n+\n+    /*\n+     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     *\n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     *\n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     *\n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *\n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n+     * </p>\n+     *\n+     * @return Set the registry of objects being traversed\n+     * @since 2.3\n+     */\n+    static Set<IDKey> getRegistry() {\n+        return REGISTRY.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     *\n+     * @param value\n+     *            The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 2.3\n+     */\n+    static boolean isRegistered(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        return registry != null && registry.contains(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n+     * </p>\n+     *\n+     * @param object\n+     *            the object to append details of\n+     * @param clazz\n+     *            the class to append details of\n+     * @param builder\n+     *            the builder to append to\n+     * @param useTransients\n+     *            whether to use transient fields\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     */\n+    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n+            String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (Field field : fields) {\n+                if (!ArrayUtils.contains(excludeFields, field.getName())\n+                    && (field.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n+                    && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n+                    } catch (IllegalAccessException e) {\n+                        // this can't happen. Would get a Security exception instead\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be included. Superclass fields will be included up to and including the specified\n+     * superclass. A null superclass is treated as java.lang.Object.\n+     * </p>\n+     *\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param <T>\n+     *            the type of the object involved\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     * @since 2.0\n+     */\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n+            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Class<?> clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        }\n+        return builder.toHashCode();\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <P>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String... excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     *\n+     * @param value\n+     *            The object to register.\n+     */\n+    static void register(Object value) {\n+        synchronized (HashCodeBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<IDKey>());\n+            }\n+        }\n+        getRegistry().add(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     *\n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     *\n+     * @param value\n+     *            The object to unregister.\n+     * @since 2.3\n+     */\n+    static void unregister(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        if (registry != null) {\n+            registry.remove(new IDKey(value));\n+            synchronized (HashCodeBuilder.class) {\n+                //read again\n+                registry = getRegistry();\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Constant to use in building the hashCode.\n+     */\n+    private final int iConstant;\n+\n+    /**\n+     * Running total of the hashCode.\n+     */\n+    private int iTotal = 0;\n+\n+    /**\n+     * <p>\n+     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n+     * </p>\n+     */\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+\n+    /**\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital.\n+     * </p>\n+     *\n+     * <p>\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code>.\n+     * </p>\n+     * <p>\n+     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\n+     * </p>\n+     * <p>\n+     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\n+     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\n+     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\n+     * that represent <code>false</code>.\n+     * </p>\n+     * <p>\n+     * This is in accordance with the <quote>Effective Java</quote> design.\n+     * </p>\n+     *\n+     * @param value\n+     *            the boolean to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (boolean element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the byte to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (byte element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the char to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (char element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the double to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (double element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the float to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (float element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the int to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the long to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    // NOTE: This method uses >> and not >>> as Effective Java and\n+    //       Long.hashCode do. Ideally we should switch to >>> at\n+    //       some stage. There are backwards compat issues, so\n+    //       that will have to wait for the time being. cf LANG-342.\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (long element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code>.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+\n+        } else {\n+            if (object.getClass().isArray()) {\n+                // 'Switch' on type of array, to dispatch to the correct handler\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                    append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                    append((short[]) object);\n+                } else if (object instanceof char[]) {\n+                    append((char[]) object);\n+                } else if (object instanceof byte[]) {\n+                    append((byte[]) object);\n+                } else if (object instanceof double[]) {\n+                    append((double[]) object);\n+                } else if (object instanceof float[]) {\n+                    append((float[]) object);\n+                } else if (object instanceof boolean[]) {\n+                    append((boolean[]) object);\n+                } else {\n+                    // Not an array of primitives\n+                    append((Object[]) object);\n+                }\n+            } else {\n+                iTotal = iTotal * iConstant + object.hashCode();\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (Object element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the short to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (short element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the result of super.hashCode() to this builder.\n+     * </p>\n+     *\n+     * @param superHashCode\n+     *            the result of calling <code>super.hashCode()</code>\n+     * @return this HashCodeBuilder, used to chain calls.\n+     * @since 2.0\n+     */\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the computed <code>hashCode</code>.\n+     * </p>\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    public int toHashCode() {\n+        return iTotal;\n+    }\n+\n+    /**\n+     * Returns the computed <code>hashCode</code>.\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     *\n+     * @since 3.0\n+     */\n+    public Integer build() {\n+        return Integer.valueOf(toHashCode());\n+    }\n+\n+    /**\n+     * <p>\n+     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\n+     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\n+     * HashCodeBuilder itself is.</p>\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     * @since 2.5\n+     */\n+    @Override\n+    public int hashCode() {\n+        return toHashCode();\n+    }\n+\n+}\n",
            "diff_size": 976
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/54/HashCodeBuilder.java\nindex c69eb5b145..e0e4bed7f6 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/intellij/54/HashCodeBuilder.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -113,864 +113,864 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayU\n  * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\r\n  */\r\n public class HashCodeBuilder implements Builder<Integer> {\r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 2.3\r\n-     */\r\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of objects being traversed by the reflection methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 2.3\r\n-     */\r\n-    static Set<IDKey> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\r\n-     * infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to lookup in the registry.\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 2.3\r\n-     */\r\n-    static boolean isRegistered(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        return registry != null && registry.contains(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given <code>Class</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the object to append details of\r\n-     * @param clazz\r\n-     *            the class to append details of\r\n-     * @param builder\r\n-     *            the builder to append to\r\n-     * @param useTransients\r\n-     *            whether to use transient fields\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     */\r\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n-            String[] excludeFields) {\r\n-        if (isRegistered(object)) {\r\n-            return;\r\n-        }\r\n-        try {\r\n-            register(object);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n-                        Object fieldValue = field.get(object);\r\n-                        builder.append(fieldValue);\r\n-                    } catch (IllegalAccessException e) {\r\n-                        // this can't happen. Would get a Security exception instead\r\n-                        // throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(object);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n-            boolean testTransients) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be included up to and including the specified\r\n-     * superclass. A null superclass is treated as java.lang.Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object involved\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     * @since 2.0\r\n-     */\r\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n-            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n-        }\r\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n-        Class<?> clazz = object.getClass();\r\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n-            clazz = clazz.getSuperclass();\r\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        }\r\n-        return builder.toHashCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <P>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\r\n-        return reflectionHashCode(17, 37, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\r\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object. Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to register.\r\n-     */\r\n-    static void register(Object value) {\r\n-        synchronized (HashCodeBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<IDKey>());\r\n-            }\r\n-        }\r\n-        getRegistry().add(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param value\r\n-     *            The object to unregister.\r\n-     * @since 2.3\r\n-     */\r\n-    static void unregister(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            registry.remove(new IDKey(value));\r\n-            synchronized (HashCodeBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constant to use in building the hashCode.\r\n-     */\r\n-    private final int iConstant;\r\n-\r\n-    /**\r\n-     * Running total of the hashCode.\r\n-     */\r\n-    private int iTotal = 0;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n-     * </p>\r\n-     */\r\n-    public HashCodeBuilder() {\r\n-        iConstant = 37;\r\n-        iTotal = 17;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n-        if (initialNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n-        }\r\n-        if (initialNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n-        }\r\n-        iConstant = multiplierNonZeroOddNumber;\r\n-        iTotal = initialNonZeroOddNumber;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\r\n-     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>false</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in accordance with the <quote>Effective Java</quote> design.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the boolean to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean value) {\r\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (boolean element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the byte to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (byte element : array) {\r\n-                append(element);\r\n-            }\r\n+  /**\r\n+   * <p>\r\n+   * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @since 2.3\r\n+   */\r\n+  private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n+\r\n+  /*\r\n+   * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n+   * we are in the process of calculating.\r\n+   *\r\n+   * So we generate a one-to-one mapping from the original object to a new object.\r\n+   *\r\n+   * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n+   * are equal, so we also need to ensure that the replacement objects are only equal\r\n+   * if the original objects are identical.\r\n+   *\r\n+   * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n+   * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n+   *\r\n+   * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n+   * to disambiguate the duplicate ids.\r\n+   */\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns the registry of objects being traversed by the reflection methods in the current thread.\r\n+   * </p>\r\n+   *\r\n+   * @return Set the registry of objects being traversed\r\n+   * @since 2.3\r\n+   */\r\n+  static Set<IDKey> getRegistry() {\r\n+    return REGISTRY.get();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\r\n+   * infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            The object to lookup in the registry.\r\n+   * @return boolean <code>true</code> if the registry contains the given object.\r\n+   * @since 2.3\r\n+   */\r\n+  static boolean isRegistered(Object value) {\r\n+    Set<IDKey> registry = getRegistry();\r\n+    return registry != null && registry.contains(new IDKey(value));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Appends the fields and values defined by the given object of the given <code>Class</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the object to append details of\r\n+   * @param clazz\r\n+   *            the class to append details of\r\n+   * @param builder\r\n+   *            the builder to append to\r\n+   * @param useTransients\r\n+   *            whether to use transient fields\r\n+   * @param excludeFields\r\n+   *            Collection of String field names to exclude from use in calculation of hash code\r\n+   */\r\n+  private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n+                                       String[] excludeFields) {\r\n+    if (isRegistered(object)) {\r\n+      return;\r\n+    }\r\n+    try {\r\n+      register(object);\r\n+      Field[] fields = clazz.getDeclaredFields();\r\n+      AccessibleObject.setAccessible(fields, true);\r\n+      for (Field field : fields) {\r\n+        if (!ArrayUtils.contains(excludeFields, field.getName())\r\n+          && (field.getName().indexOf('$') == -1)\r\n+          && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n+          && (!Modifier.isStatic(field.getModifiers()))) {\r\n+          try {\r\n+            Object fieldValue = field.get(object);\r\n+            builder.append(fieldValue);\r\n+          } catch (IllegalAccessException e) {\r\n+            // this can't happen. Would get a Security exception instead\r\n+            // throw a runtime exception in case the impossible happens.\r\n+            throw new InternalError(\"Unexpected IllegalAccessException\");\r\n+          }\r\n         }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the char to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (char element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the double to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double value) {\r\n-        return append(Double.doubleToLongBits(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (double element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the float to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float value) {\r\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (float element : array) {\r\n-                append(element);\r\n-            }\r\n+      }\r\n+    } finally {\r\n+      unregister(object);\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n+   * <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   */\r\n+  public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n+    return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param testTransients\r\n+   *            whether to include transient fields\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   */\r\n+  public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n+                                       boolean testTransients) {\r\n+    return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be included. Superclass fields will be included up to and including the specified\r\n+   * superclass. A null superclass is treated as java.lang.Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param <T>\r\n+   *            the type of the object involved\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param testTransients\r\n+   *            whether to include transient fields\r\n+   * @param reflectUpToClass\r\n+   *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n+   * @param excludeFields\r\n+   *            array of field names to exclude from use in calculation of hash code\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   * @since 2.0\r\n+   */\r\n+  public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n+                                           boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n+\r\n+    if (object == null) {\r\n+      throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n+    }\r\n+    HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n+    Class<?> clazz = object.getClass();\r\n+    reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n+    while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n+      clazz = clazz.getSuperclass();\r\n+      reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n+    }\r\n+    return builder.toHashCode();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <P>\r\n+   * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param testTransients\r\n+   *            whether to include transient fields\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the object is <code>null</code>\r\n+   */\r\n+  public static int reflectionHashCode(Object object, boolean testTransients) {\r\n+    return reflectionHashCode(17, 37, object, testTransients, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n+   * <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param excludeFields\r\n+   *            Collection of String field names to exclude from use in calculation of hash code\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the object is <code>null</code>\r\n+   */\r\n+  public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n+    return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n+  }\r\n+\r\n+  // -------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * This method uses reflection to build a valid hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n+   * <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be tested. Superclass fields will be included.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to create a <code>hashCode</code> for\r\n+   * @param excludeFields\r\n+   *            array of field names to exclude from use in calculation of hash code\r\n+   * @return int hash code\r\n+   * @throws IllegalArgumentException\r\n+   *             if the object is <code>null</code>\r\n+   */\r\n+  public static int reflectionHashCode(Object object, String... excludeFields) {\r\n+    return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Registers the given object. Used by the reflection methods to avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            The object to register.\r\n+   */\r\n+  static void register(Object value) {\r\n+    synchronized (HashCodeBuilder.class) {\r\n+      if (getRegistry() == null) {\r\n+        REGISTRY.set(new HashSet<IDKey>());\r\n+      }\r\n+    }\r\n+    getRegistry().add(new IDKey(value));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Unregisters the given object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   *\r\n+   * @param value\r\n+   *            The object to unregister.\r\n+   * @since 2.3\r\n+   */\r\n+  static void unregister(Object value) {\r\n+    Set<IDKey> registry = getRegistry();\r\n+    if (registry != null) {\r\n+      registry.remove(new IDKey(value));\r\n+      synchronized (HashCodeBuilder.class) {\r\n+        //read again\r\n+        registry = getRegistry();\r\n+        if (registry != null && registry.isEmpty()) {\r\n+          REGISTRY.remove();\r\n         }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the int to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Constant to use in building the hashCode.\r\n+   */\r\n+  private final int iConstant;\r\n+\r\n+  /**\r\n+   * Running total of the hashCode.\r\n+   */\r\n+  private int iTotal = 0;\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n+   * </p>\r\n+   */\r\n+  public HashCodeBuilder() {\r\n+    iConstant = 37;\r\n+    iTotal = 17;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n+   * however this is not vital.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Prime numbers are preferred, especially for the multiplier.\r\n+   * </p>\r\n+   *\r\n+   * @param initialNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the initial value\r\n+   * @param multiplierNonZeroOddNumber\r\n+   *            a non-zero, odd number used as the multiplier\r\n+   * @throws IllegalArgumentException\r\n+   *             if the number is zero or even\r\n+   */\r\n+  public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n+    if (initialNonZeroOddNumber == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n+    }\r\n+    if (initialNonZeroOddNumber % 2 == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n+    }\r\n+    if (multiplierNonZeroOddNumber == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n+    }\r\n+    if (multiplierNonZeroOddNumber % 2 == 0) {\r\n+      throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n+    }\r\n+    iConstant = multiplierNonZeroOddNumber;\r\n+    iTotal = initialNonZeroOddNumber;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>boolean</code>.\r\n+   * </p>\r\n+   * <p>\r\n+   * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\r\n+   * </p>\r\n+   * <p>\r\n+   * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\r\n+   * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\r\n+   * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\r\n+   * that represent <code>false</code>.\r\n+   * </p>\r\n+   * <p>\r\n+   * This is in accordance with the <quote>Effective Java</quote> design.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the boolean to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(boolean value) {\r\n+    iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>boolean</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(boolean[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (boolean element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  // -------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>byte</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the byte to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(byte value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  // -------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>byte</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(byte[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (byte element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>char</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the char to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(char value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>char</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(char[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (char element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>double</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the double to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(double value) {\r\n+    return append(Double.doubleToLongBits(value));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>double</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(double[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (double element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>float</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the float to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(float value) {\r\n+    iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>float</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(float[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (float element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>int</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the int to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(int value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>int</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(int[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (int element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>long</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the long to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  // NOTE: This method uses >> and not >>> as Effective Java and\r\n+  //       Long.hashCode do. Ideally we should switch to >>> at\r\n+  //       some stage. There are backwards compat issues, so\r\n+  //       that will have to wait for the time being. cf LANG-342.\r\n+  public HashCodeBuilder append(long value) {\r\n+    iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>long</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(long[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (long element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(Object object) {\r\n+    if (object == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+\r\n+    } else {\r\n+      if (object.getClass().isArray()) {\r\n+        // 'Switch' on type of array, to dispatch to the correct handler\r\n+        // This handles multi dimensional arrays\r\n+        if (object instanceof long[]) {\r\n+          append((long[]) object);\r\n+        } else if (object instanceof int[]) {\r\n+          append((int[]) object);\r\n+        } else if (object instanceof short[]) {\r\n+          append((short[]) object);\r\n+        } else if (object instanceof char[]) {\r\n+          append((char[]) object);\r\n+        } else if (object instanceof byte[]) {\r\n+          append((byte[]) object);\r\n+        } else if (object instanceof double[]) {\r\n+          append((double[]) object);\r\n+        } else if (object instanceof float[]) {\r\n+          append((float[]) object);\r\n+        } else if (object instanceof boolean[]) {\r\n+          append((boolean[]) object);\r\n         } else {\r\n-            for (int element : array) {\r\n-                append(element);\r\n-            }\r\n+          // Not an array of primitives\r\n+          append((Object[]) object);\r\n         }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the long to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    // NOTE: This method uses >> and not >>> as Effective Java and\r\n-    //       Long.hashCode do. Ideally we should switch to >>> at\r\n-    //       some stage. There are backwards compat issues, so\r\n-    //       that will have to wait for the time being. cf LANG-342.\r\n-    public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(long[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (long element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object object) {\r\n-        if (object == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-\r\n-        } else {\r\n-            if(object.getClass().isArray()) {\r\n-                // 'Switch' on type of array, to dispatch to the correct handler\r\n-                // This handles multi dimensional arrays\r\n-                if (object instanceof long[]) {\r\n-                    append((long[]) object);\r\n-                } else if (object instanceof int[]) {\r\n-                    append((int[]) object);\r\n-                } else if (object instanceof short[]) {\r\n-                    append((short[]) object);\r\n-                } else if (object instanceof char[]) {\r\n-                    append((char[]) object);\r\n-                } else if (object instanceof byte[]) {\r\n-                    append((byte[]) object);\r\n-                } else if (object instanceof double[]) {\r\n-                    append((double[]) object);\r\n-                } else if (object instanceof float[]) {\r\n-                    append((float[]) object);\r\n-                } else if (object instanceof boolean[]) {\r\n-                    append((boolean[]) object);\r\n-                } else {\r\n-                    // Not an array of primitives\r\n-                    append((Object[]) object);\r\n-                }\r\n-            } else {\r\n-                iTotal = iTotal * iConstant + object.hashCode();\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (Object element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the short to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (short element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Adds the result of super.hashCode() to this builder.\r\n-     * </p>\r\n-     *\r\n-     * @param superHashCode\r\n-     *            the result of calling <code>super.hashCode()</code>\r\n-     * @return this HashCodeBuilder, used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public HashCodeBuilder appendSuper(int superHashCode) {\r\n-        iTotal = iTotal * iConstant + superHashCode;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Return the computed <code>hashCode</code>.\r\n-     * </p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     */\r\n-    public int toHashCode() {\r\n-        return iTotal;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the computed <code>hashCode</code>.\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Integer build() {\r\n-        return Integer.valueOf(toHashCode());\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\r\n-     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\r\n-     * HashCodeBuilder itself is.</p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     * @since 2.5\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return toHashCode();\r\n-    }\r\n+      } else {\r\n+        iTotal = iTotal * iConstant + object.hashCode();\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for an <code>Object</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(Object[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (Object element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>short</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param value\r\n+   *            the short to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(short value) {\r\n+    iTotal = iTotal * iConstant + value;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append a <code>hashCode</code> for a <code>short</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>hashCode</code>\r\n+   * @return this\r\n+   */\r\n+  public HashCodeBuilder append(short[] array) {\r\n+    if (array == null) {\r\n+      iTotal = iTotal * iConstant;\r\n+    } else {\r\n+      for (short element : array) {\r\n+        append(element);\r\n+      }\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Adds the result of super.hashCode() to this builder.\r\n+   * </p>\r\n+   *\r\n+   * @param superHashCode\r\n+   *            the result of calling <code>super.hashCode()</code>\r\n+   * @return this HashCodeBuilder, used to chain calls.\r\n+   * @since 2.0\r\n+   */\r\n+  public HashCodeBuilder appendSuper(int superHashCode) {\r\n+    iTotal = iTotal * iConstant + superHashCode;\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Return the computed <code>hashCode</code>.\r\n+   * </p>\r\n+   *\r\n+   * @return <code>hashCode</code> based on the fields appended\r\n+   */\r\n+  public int toHashCode() {\r\n+    return iTotal;\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns the computed <code>hashCode</code>.\r\n+   *\r\n+   * @return <code>hashCode</code> based on the fields appended\r\n+   *\r\n+   * @since 3.0\r\n+   */\r\n+  public Integer build() {\r\n+    return Integer.valueOf(toHashCode());\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\r\n+   * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\r\n+   * HashCodeBuilder itself is.</p>\r\n+   *\r\n+   * @return <code>hashCode</code> based on the fields appended\r\n+   * @since 2.5\r\n+   */\r\n+  @Override\r\n+  public int hashCode() {\r\n+    return toHashCode();\r\n+  }\r\n \r\n }\r\n",
            "diff_size": 1380
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "196",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 227).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/54/HashCodeBuilder.java\nindex c69eb5b145..b717a77a01 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/naturalize/54/HashCodeBuilder.java\n@@ -193,11 +193,8 @@ public class HashCodeBuilder implements Builder<Integer> {\n             Field[] fields = clazz.getDeclaredFields();\r\n             AccessibleObject.setAccessible(fields, true);\r\n             for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n+                if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) {\n+    try {\r\n                         Object fieldValue = field.get(object);\r\n                         builder.append(fieldValue);\r\n                     } catch (IllegalAccessException e) {\r\n@@ -345,9 +342,8 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @since 2.0\r\n      */\r\n     public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n+            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+    if (object == null) {\r\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n         }\r\n         HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n@@ -800,7 +796,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n     //       some stage. There are backwards compat issues, so\r\n     //       that will have to wait for the time being. cf LANG-342.\r\n     public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n+        iTotal = iTotal * iConstant + ((int)(value ^ (value >> 32)));\r\n         return this;\r\n     }\r\n \r\n@@ -838,7 +834,7 @@ public class HashCodeBuilder implements Builder<Integer> {\n             iTotal = iTotal * iConstant;\r\n \r\n         } else {\r\n-            if(object.getClass().isArray()) {\r\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n                 // This handles multi dimensional arrays\r\n                 if (object instanceof long[]) {\r\n@@ -973,4 +969,4 @@ public class HashCodeBuilder implements Builder<Integer> {\n         return toHashCode();\r\n     }\r\n \r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 11
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "204",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 227).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "359",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 201).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "930",
                    "severity": "warning",
                    "message": "Comment has incorrect indentation level 20, expected is 48, indentation should be the same level as line 931.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/54/HashCodeBuilder.java\nindex c69eb5b145..e4bafb4293 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/codebuff/54/HashCodeBuilder.java\n@@ -30,15 +30,14 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n \r\n /**\r\n@@ -111,7 +110,9 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayU\n  *\r\n  * @since 1.0\r\n  * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\r\n- */\r\n+ */\n+\n+\n public class HashCodeBuilder implements Builder<Integer> {\r\n     /**\r\n      * <p>\r\n@@ -119,7 +120,8 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * </p>\r\n      *\r\n      * @since 2.3\r\n-     */\r\n+     */\n+\n     private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n \r\n     /*\r\n@@ -146,9 +148,9 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *\r\n      * @return Set the registry of objects being traversed\r\n      * @since 2.3\r\n-     */\r\n-    static Set<IDKey> getRegistry() {\r\n-        return REGISTRY.get();\r\n+     */\n+    static Set<IDKey> getRegistry() {\n+    return REGISTRY.get();\n     }\r\n \r\n     /**\r\n@@ -161,10 +163,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            The object to lookup in the registry.\r\n      * @return boolean <code>true</code> if the registry contains the given object.\r\n      * @since 2.3\r\n-     */\r\n-    static boolean isRegistered(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        return registry != null && registry.contains(new IDKey(value));\r\n+     */\n+\n+\n+    static boolean isRegistered(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        return registry != null && registry.contains(new IDKey(value));\n     }\r\n \r\n     /**\r\n@@ -182,34 +186,35 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            whether to use transient fields\r\n      * @param excludeFields\r\n      *            Collection of String field names to exclude from use in calculation of hash code\r\n-     */\r\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n-            String[] excludeFields) {\r\n-        if (isRegistered(object)) {\r\n-            return;\r\n-        }\r\n-        try {\r\n-            register(object);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n-                        Object fieldValue = field.get(object);\r\n-                        builder.append(fieldValue);\r\n+     */\n+\n+    private static void reflectionAppend(Object object,\n+                                         Class<?> clazz,\n+                                         HashCodeBuilder builder,\n+                                         boolean useTransients, String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+\n+            for (Field field : fields) {\n+                if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n                     } catch (IllegalAccessException e) {\r\n                         // this can't happen. Would get a Security exception instead\r\n-                        // throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(object);\r\n-        }\r\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n     }\r\n \r\n     /**\r\n@@ -248,9 +253,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *             if the Object is <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n     }\r\n \r\n     /**\r\n@@ -291,10 +298,13 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *             if the Object is <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n-            boolean testTransients) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(int initialNonZeroOddNumber,\n+                                         int multiplierNonZeroOddNumber,\n+                                         Object object, boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n     }\r\n \r\n     /**\r\n@@ -343,21 +353,31 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n      * @since 2.0\r\n-     */\r\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n-            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n-        }\r\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n-        Class<?> clazz = object.getClass();\r\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n-            clazz = clazz.getSuperclass();\r\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        }\r\n-        return builder.toHashCode();\r\n+     */\n+\n+\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object, boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber,\n+                                                      multiplierNonZeroOddNumber);\n+        Class<?> clazz = object.getClass();\n+        reflectionAppend(object,\n+                         clazz,\n+                         builder,\n+                         testTransients,\n+                         excludeFields);\n+\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object,\n+                             clazz,\n+                             builder,\n+                             testTransients,\n+                             excludeFields);\n+        }\n+        return builder.toHashCode();\n     }\r\n \r\n     /**\r\n@@ -391,9 +411,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return int hash code\r\n      * @throws IllegalArgumentException\r\n      *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\r\n-        return reflectionHashCode(17, 37, object, testTransients, null);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null);\n     }\r\n \r\n     /**\r\n@@ -427,9 +449,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return int hash code\r\n      * @throws IllegalArgumentException\r\n      *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n+     */\n+\n+\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\r\n \r\n     // -------------------------------------------------------------------------\r\n@@ -465,9 +489,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return int hash code\r\n      * @throws IllegalArgumentException\r\n      *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\r\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n+     */\n+\n+\n+    public static int reflectionHashCode(Object object, String... excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n     }\r\n \r\n     /**\r\n@@ -477,14 +503,17 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *\r\n      * @param value\r\n      *            The object to register.\r\n-     */\r\n-    static void register(Object value) {\r\n-        synchronized (HashCodeBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<IDKey>());\r\n-            }\r\n-        }\r\n-        getRegistry().add(new IDKey(value));\r\n+     */\n+\n+\n+    static void register(Object value) {\n+        synchronized (HashCodeBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<IDKey>());\n+            }\n+        }\n+\n+        getRegistry().add(new IDKey(value));\n     }\r\n \r\n     /**\r\n@@ -498,39 +527,45 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            The object to unregister.\r\n      * @since 2.3\r\n-     */\r\n-    static void unregister(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            registry.remove(new IDKey(value));\r\n+     */\n+\n+\n+    static void unregister(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        if (registry != null) {\n+            registry.remove(new IDKey(value));\n             synchronized (HashCodeBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n+                //read again\n+                registry = getRegistry();\n+\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n     }\r\n \r\n     /**\r\n      * Constant to use in building the hashCode.\r\n-     */\r\n+     */\n+\n     private final int iConstant;\r\n \r\n     /**\r\n      * Running total of the hashCode.\r\n-     */\r\n+     */\n     private int iTotal = 0;\r\n \r\n     /**\r\n      * <p>\r\n      * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n      * </p>\r\n-     */\r\n-    public HashCodeBuilder() {\r\n-        iConstant = 37;\r\n-        iTotal = 17;\r\n+     */\n+\n+\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n     }\r\n \r\n     /**\r\n@@ -549,22 +584,27 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            a non-zero, odd number used as the multiplier\r\n      * @throws IllegalArgumentException\r\n      *             if the number is zero or even\r\n-     */\r\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n-        if (initialNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n-        }\r\n-        if (initialNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n-        }\r\n-        iConstant = multiplierNonZeroOddNumber;\r\n-        iTotal = initialNonZeroOddNumber;\r\n+     */\n+\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n     }\r\n \r\n     /**\r\n@@ -587,10 +627,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the boolean to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean value) {\r\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -601,16 +643,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (boolean element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (boolean element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     // -------------------------------------------------------------------------\r\n@@ -623,10 +667,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the byte to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     // -------------------------------------------------------------------------\r\n@@ -639,16 +685,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (byte element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (byte element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -659,10 +707,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the char to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -673,16 +723,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (char element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (char element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -693,9 +745,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the double to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double value) {\r\n-        return append(Double.doubleToLongBits(value));\r\n+     */\n+\n+\n+    public HashCodeBuilder append(double value) {\n+    return append(Double.doubleToLongBits(value));\n     }\r\n \r\n     /**\r\n@@ -706,16 +760,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (double element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (double element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -726,10 +782,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the float to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float value) {\r\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -740,16 +798,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (float element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (float element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -760,10 +820,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the int to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -774,16 +836,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (int element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -798,10 +862,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n     // NOTE: This method uses >> and not >>> as Effective Java and\r\n     //       Long.hashCode do. Ideally we should switch to >>> at\r\n     //       some stage. There are backwards compat issues, so\r\n-    //       that will have to wait for the time being. cf LANG-342.\r\n-    public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n-        return this;\r\n+    //       that will have to wait for the time being. cf LANG-342.\n+\n+\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int)(value ^ (value >> 32)));\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -812,16 +878,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(long[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (long element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (long element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -832,40 +900,41 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param object\r\n      *            the Object to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object object) {\r\n-        if (object == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-\r\n-        } else {\r\n-            if(object.getClass().isArray()) {\r\n+     */\n+\n+\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            if (object.getClass().isArray()) {\r\n                 // 'Switch' on type of array, to dispatch to the correct handler\r\n-                // This handles multi dimensional arrays\r\n-                if (object instanceof long[]) {\r\n-                    append((long[]) object);\r\n-                } else if (object instanceof int[]) {\r\n-                    append((int[]) object);\r\n-                } else if (object instanceof short[]) {\r\n-                    append((short[]) object);\r\n-                } else if (object instanceof char[]) {\r\n-                    append((char[]) object);\r\n-                } else if (object instanceof byte[]) {\r\n-                    append((byte[]) object);\r\n-                } else if (object instanceof double[]) {\r\n-                    append((double[]) object);\r\n-                } else if (object instanceof float[]) {\r\n-                    append((float[]) object);\r\n-                } else if (object instanceof boolean[]) {\r\n-                    append((boolean[]) object);\r\n-                } else {\r\n-                    // Not an array of primitives\r\n-                    append((Object[]) object);\r\n-                }\r\n-            } else {\r\n-                iTotal = iTotal * iConstant + object.hashCode();\r\n-            }\r\n-        }\r\n-        return this;\r\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                           append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                           append((short[]) object);\n+                       } else if (object instanceof char[]) {\n+                                  append((char[]) object);\n+                       } else if (object instanceof byte[]) {\n+                                  append((byte[]) object);\n+                              } else if (object instanceof double[]) {\n+                                         append((double[]) object);\n+                              } else if (object instanceof float[]) {\n+                                         append((float[]) object);\n+                                     } else if (object instanceof boolean[]) {\n+                                                append((boolean[]) object);\n+                                     } else {\r\n+                    // Not an array of primitives\n+                                                append((Object[]) object);\n+                                     }\n+            } else {\n+                iTotal = iTotal * iConstant + object.hashCode();\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -876,16 +945,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (Object element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (Object element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -896,10 +967,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param value\r\n      *            the short to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -910,16 +983,18 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @param array\r\n      *            the array to add to the <code>hashCode</code>\r\n      * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (short element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (short element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -931,10 +1006,12 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *            the result of calling <code>super.hashCode()</code>\r\n      * @return this HashCodeBuilder, used to chain calls.\r\n      * @since 2.0\r\n-     */\r\n-    public HashCodeBuilder appendSuper(int superHashCode) {\r\n-        iTotal = iTotal * iConstant + superHashCode;\r\n-        return this;\r\n+     */\n+\n+\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -943,9 +1020,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * </p>\r\n      *\r\n      * @return <code>hashCode</code> based on the fields appended\r\n-     */\r\n-    public int toHashCode() {\r\n-        return iTotal;\r\n+     */\n+\n+\n+    public int toHashCode() {\n+    return iTotal;\n     }\r\n \r\n     /**\r\n@@ -954,9 +1033,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      * @return <code>hashCode</code> based on the fields appended\r\n      *\r\n      * @since 3.0\r\n-     */\r\n-    public Integer build() {\r\n-        return Integer.valueOf(toHashCode());\r\n+     */\n+\n+\n+    public Integer build() {\n+    return Integer.valueOf(toHashCode());\n     }\r\n \r\n     /**\r\n@@ -967,10 +1048,11 @@ public class HashCodeBuilder implements Builder<Integer> {\n      *\r\n      * @return <code>hashCode</code> based on the fields appended\r\n      * @since 2.5\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return toHashCode();\r\n-    }\r\n-\r\n-}\r\n+     */\n+\n+\n+    @Override\n+    public int hashCode() {\n+        return toHashCode();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 371
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/54/HashCodeBuilder.java\nindex c69eb5b145..a340f4d4a1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/errored/1/54/HashCodeBuilder.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Internet2-grouper/styler_random/54/HashCodeBuilder.java\n@@ -1,976 +1,976 @@\n-/**\r\n- * Copyright 2014 Internet2\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *      http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Set;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n-\r\n-/**\r\n- * <p>\r\n- * Assists in implementing {@link Object#hashCode()} methods.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\r\n- * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\r\n- * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * The following is the approach taken. When appending a data field, the current total is multiplied by the\r\n- * multiplier then a relevant value\r\n- * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then\r\n- * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\r\n- * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\r\n- * method.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * To use this class write code as follows:\r\n- * </p>\r\n- *\r\n- * <pre>\r\n- * public class Person {\r\n- *   String name;\r\n- *   int age;\r\n- *   boolean smoker;\r\n- *   ...\r\n- *\r\n- *   public int hashCode() {\r\n- *     // you pick a hard-coded, randomly chosen, non-zero, odd number\r\n- *     // ideally different for each class\r\n- *     return new HashCodeBuilder(17, 37).\r\n- *       append(name).\r\n- *       append(age).\r\n- *       append(smoker).\r\n- *       toHashCode();\r\n- *   }\r\n- * }\r\n- * </pre>\r\n- *\r\n- * <p>\r\n- * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\r\n- * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\r\n- * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\r\n- * are set up correctly. It is also slower than testing explicitly.\r\n- * </p>\r\n- *\r\n- * <p>\r\n- * A typical invocation for this method would look like:\r\n- * </p>\r\n- *\r\n- * <pre>\r\n- * public int hashCode() {\r\n- *   return HashCodeBuilder.reflectionHashCode(this);\r\n- * }\r\n- * </pre>\r\n- *\r\n- * @since 1.0\r\n- * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\r\n- */\r\n-public class HashCodeBuilder implements Builder<Integer> {\r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 2.3\r\n-     */\r\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of objects being traversed by the reflection methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 2.3\r\n-     */\r\n-    static Set<IDKey> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\r\n-     * infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to lookup in the registry.\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 2.3\r\n-     */\r\n-    static boolean isRegistered(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        return registry != null && registry.contains(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given <code>Class</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the object to append details of\r\n-     * @param clazz\r\n-     *            the class to append details of\r\n-     * @param builder\r\n-     *            the builder to append to\r\n-     * @param useTransients\r\n-     *            whether to use transient fields\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     */\r\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\r\n-            String[] excludeFields) {\r\n-        if (isRegistered(object)) {\r\n-            return;\r\n-        }\r\n-        try {\r\n-            register(object);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (Field field : fields) {\r\n-                if (!ArrayUtils.contains(excludeFields, field.getName())\r\n-                    && (field.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\r\n-                    && (!Modifier.isStatic(field.getModifiers()))) {\r\n-                    try {\r\n-                        Object fieldValue = field.get(object);\r\n-                        builder.append(fieldValue);\r\n-                    } catch (IllegalAccessException e) {\r\n-                        // this can't happen. Would get a Security exception instead\r\n-                        // throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(object);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\r\n-            boolean testTransients) {\r\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be included up to and including the specified\r\n-     * superclass. A null superclass is treated as java.lang.Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object involved\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     * @since 2.0\r\n-     */\r\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\r\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\r\n-\r\n-        if (object == null) {\r\n-            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\r\n-        }\r\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\r\n-        Class<?> clazz = object.getClass();\r\n-        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\r\n-            clazz = clazz.getSuperclass();\r\n-            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\r\n-        }\r\n-        return builder.toHashCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <P>\r\n-     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param testTransients\r\n-     *            whether to include transient fields\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\r\n-        return reflectionHashCode(17, 37, object, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            Collection of String field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\r\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * This method uses reflection to build a valid hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\r\n-     * <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be tested. Superclass fields will be included.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to create a <code>hashCode</code> for\r\n-     * @param excludeFields\r\n-     *            array of field names to exclude from use in calculation of hash code\r\n-     * @return int hash code\r\n-     * @throws IllegalArgumentException\r\n-     *             if the object is <code>null</code>\r\n-     */\r\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\r\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object. Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            The object to register.\r\n-     */\r\n-    static void register(Object value) {\r\n-        synchronized (HashCodeBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<IDKey>());\r\n-            }\r\n-        }\r\n-        getRegistry().add(new IDKey(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param value\r\n-     *            The object to unregister.\r\n-     * @since 2.3\r\n-     */\r\n-    static void unregister(Object value) {\r\n-        Set<IDKey> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            registry.remove(new IDKey(value));\r\n-            synchronized (HashCodeBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constant to use in building the hashCode.\r\n-     */\r\n-    private final int iConstant;\r\n-\r\n-    /**\r\n-     * Running total of the hashCode.\r\n-     */\r\n-    private int iTotal = 0;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\r\n-     * </p>\r\n-     */\r\n-    public HashCodeBuilder() {\r\n-        iConstant = 37;\r\n-        iTotal = 17;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\r\n-     * however this is not vital.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Prime numbers are preferred, especially for the multiplier.\r\n-     * </p>\r\n-     *\r\n-     * @param initialNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the initial value\r\n-     * @param multiplierNonZeroOddNumber\r\n-     *            a non-zero, odd number used as the multiplier\r\n-     * @throws IllegalArgumentException\r\n-     *             if the number is zero or even\r\n-     */\r\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\r\n-        if (initialNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\r\n-        }\r\n-        if (initialNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\r\n-        }\r\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\r\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\r\n-        }\r\n-        iConstant = multiplierNonZeroOddNumber;\r\n-        iTotal = initialNonZeroOddNumber;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\r\n-     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\r\n-     * that represent <code>false</code>.\r\n-     * </p>\r\n-     * <p>\r\n-     * This is in accordance with the <quote>Effective Java</quote> design.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the boolean to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean value) {\r\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>boolean</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(boolean[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (boolean element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the byte to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    // -------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>byte</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(byte[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (byte element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the char to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>char</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(char[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (char element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the double to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double value) {\r\n-        return append(Double.doubleToLongBits(value));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>double</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(double[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (double element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the float to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float value) {\r\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>float</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(float[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (float element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the int to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>int</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(int[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (int element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the long to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    // NOTE: This method uses >> and not >>> as Effective Java and\r\n-    //       Long.hashCode do. Ideally we should switch to >>> at\r\n-    //       some stage. There are backwards compat issues, so\r\n-    //       that will have to wait for the time being. cf LANG-342.\r\n-    public HashCodeBuilder append(long value) {\r\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>long</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(long[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (long element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object object) {\r\n-        if (object == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-\r\n-        } else {\r\n-            if(object.getClass().isArray()) {\r\n-                // 'Switch' on type of array, to dispatch to the correct handler\r\n-                // This handles multi dimensional arrays\r\n-                if (object instanceof long[]) {\r\n-                    append((long[]) object);\r\n-                } else if (object instanceof int[]) {\r\n-                    append((int[]) object);\r\n-                } else if (object instanceof short[]) {\r\n-                    append((short[]) object);\r\n-                } else if (object instanceof char[]) {\r\n-                    append((char[]) object);\r\n-                } else if (object instanceof byte[]) {\r\n-                    append((byte[]) object);\r\n-                } else if (object instanceof double[]) {\r\n-                    append((double[]) object);\r\n-                } else if (object instanceof float[]) {\r\n-                    append((float[]) object);\r\n-                } else if (object instanceof boolean[]) {\r\n-                    append((boolean[]) object);\r\n-                } else {\r\n-                    // Not an array of primitives\r\n-                    append((Object[]) object);\r\n-                }\r\n-            } else {\r\n-                iTotal = iTotal * iConstant + object.hashCode();\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(Object[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (Object element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param value\r\n-     *            the short to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short value) {\r\n-        iTotal = iTotal * iConstant + value;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append a <code>hashCode</code> for a <code>short</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>hashCode</code>\r\n-     * @return this\r\n-     */\r\n-    public HashCodeBuilder append(short[] array) {\r\n-        if (array == null) {\r\n-            iTotal = iTotal * iConstant;\r\n-        } else {\r\n-            for (short element : array) {\r\n-                append(element);\r\n-            }\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Adds the result of super.hashCode() to this builder.\r\n-     * </p>\r\n-     *\r\n-     * @param superHashCode\r\n-     *            the result of calling <code>super.hashCode()</code>\r\n-     * @return this HashCodeBuilder, used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public HashCodeBuilder appendSuper(int superHashCode) {\r\n-        iTotal = iTotal * iConstant + superHashCode;\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Return the computed <code>hashCode</code>.\r\n-     * </p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     */\r\n-    public int toHashCode() {\r\n-        return iTotal;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the computed <code>hashCode</code>.\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Integer build() {\r\n-        return Integer.valueOf(toHashCode());\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\r\n-     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\r\n-     * HashCodeBuilder itself is.</p>\r\n-     *\r\n-     * @return <code>hashCode</code> based on the fields appended\r\n-     * @since 2.5\r\n-     */\r\n-    @Override\r\n-    public int hashCode() {\r\n-        return toHashCode();\r\n-    }\r\n-\r\n-}\r\n+/**\n+ * Copyright 2014 Internet2\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#hashCode()} methods.\n+ * </p>\n+ *\n+ * <p>\n+ * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n+ * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n+ * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n+ * </p>\n+ *\n+ * <p>\n+ * The following is the approach taken. When appending a data field, the current total is multiplied by the\n+ * multiplier then a relevant value\n+ * for that data type is added. For example, if the current hashCode is 17, and the multiplier is 37, then\n+ * appending the integer 45 will create a hashcode of 674, namely 17 * 37 + 45.\n+ * </p>\n+ *\n+ * <p>\n+ * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n+ * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n+ * method.\n+ * </p>\n+ *\n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ *\n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ *   ...\n+ *\n+ *   public int hashCode() {\n+ *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n+ *     // ideally different for each class\n+ *     return new HashCodeBuilder(17, 37).\n+ *       append(name).\n+ *       append(age).\n+ *       append(smoker).\n+ *       toHashCode();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>\n+ * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n+ * </p>\n+ *\n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n+ * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n+ * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n+ * are set up correctly. It is also slower than testing explicitly.\n+ * </p>\n+ *\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ *\n+ * <pre>\n+ * public int hashCode() {\n+ *   return HashCodeBuilder.reflectionHashCode(this);\n+ * }\n+ * </pre>\n+ *\n+ * @since 1.0\n+ * @version $Id: HashCodeBuilder.java 1144929 2011-07-10 18:26:16Z ggregory $\n+ */\n+public class HashCodeBuilder implements Builder<Integer> {\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     *\n+     * @since 2.3\n+     */\n+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n+\n+    /*\n+     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     *\n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     *\n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     *\n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *\n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n+     * </p>\n+     *\n+     * @return Set the registry of objects being traversed\n+     * @since 2.3\n+     */\n+    static Set<IDKey> getRegistry() {\n+        return REGISTRY.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     *\n+     * @param value\n+     *            The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 2.3\n+     */\n+    static boolean isRegistered(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        return registry != null && registry.contains(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n+     * </p>\n+     *\n+     * @param object\n+     *            the object to append details of\n+     * @param clazz\n+     *            the class to append details of\n+     * @param builder\n+     *            the builder to append to\n+     * @param useTransients\n+     *            whether to use transient fields\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     */\n+    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n+            String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (Field field : fields) {\n+                if (!ArrayUtils.contains(excludeFields, field.getName())\n+                    && (field.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n+                    && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n+                    } catch (IllegalAccessException e) {\n+                        // this can't happen. Would get a Security exception instead\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be included. Superclass fields will be included up to and including the specified\n+     * superclass. A null superclass is treated as java.lang.Object.\n+     * </p>\n+     *\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param <T>\n+     *            the type of the object involved\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     * @since 2.0\n+     */\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n+            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Class<?> clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        }\n+        return builder.toHashCode();\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <P>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     *\n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     *\n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     *\n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String... excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     *\n+     * @param value\n+     *            The object to register.\n+     */\n+    static void register(Object value) {\n+        synchronized (HashCodeBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<IDKey>());\n+            }\n+        }\n+        getRegistry().add(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     *\n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     *\n+     * @param value\n+     *            The object to unregister.\n+     * @since 2.3\n+     */\n+    static void unregister(Object value) {\n+        Set<IDKey> registry = getRegistry();\n+        if (registry != null) {\n+            registry.remove(new IDKey(value));\n+            synchronized (HashCodeBuilder.class) {\n+                //read again\n+                registry = getRegistry();\n+                if (registry != null && registry.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Constant to use in building the hashCode.\n+     */\n+    private final int iConstant;\n+\n+    /**\n+     * Running total of the hashCode.\n+     */\n+    private int iTotal = 0;\n+\n+    /**\n+     * <p>\n+     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n+     * </p>\n+     */\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+\n+    /**\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital.\n+     * </p>\n+     *\n+     * <p>\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     *\n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code>.\n+     * </p>\n+     * <p>\n+     * This adds <code>1</code> when true, and <code>0</code> when false to the <code>hashCode</code>.\n+     * </p>\n+     * <p>\n+     * This is in contrast to the standard <code>java.lang.Boolean.hashCode</code> handling, which computes\n+     * a <code>hashCode</code> value of <code>1231</code> for <code>java.lang.Boolean</code> instances\n+     * that represent <code>true</code> or <code>1237</code> for <code>java.lang.Boolean</code> instances\n+     * that represent <code>false</code>.\n+     * </p>\n+     * <p>\n+     * This is in accordance with the <quote>Effective Java</quote> design.\n+     * </p>\n+     *\n+     * @param value\n+     *            the boolean to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (boolean element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the byte to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (byte element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the char to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (char element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the double to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (double element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the float to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (float element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the int to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the long to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    // NOTE: This method uses >> and not >>> as Effective Java and\n+    //       Long.hashCode do. Ideally we should switch to >>> at\n+    //       some stage. There are backwards compat issues, so\n+    //       that will have to wait for the time being. cf LANG-342.\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (long element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code>.\n+     * </p>\n+     *\n+     * @param object\n+     *            the Object to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+\n+        } else {\n+            if (object.getClass().isArray()) {\n+                // 'Switch' on type of array, to dispatch to the correct handler\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                    append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                    append((short[]) object);\n+                } else if (object instanceof char[]) {\n+                    append((char[]) object);\n+                } else if (object instanceof byte[]) {\n+                    append((byte[]) object);\n+                } else if (object instanceof double[]) {\n+                    append((double[]) object);\n+                } else if (object instanceof float[]) {\n+                    append((float[]) object);\n+                } else if (object instanceof boolean[]) {\n+                    append((boolean[]) object);\n+                } else {\n+                    // Not an array of primitives\n+                    append((Object[]) object);\n+                }\n+            } else {\n+                iTotal = iTotal * iConstant + object.hashCode();\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (Object element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code>.\n+     * </p>\n+     *\n+     * @param value\n+     *            the short to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code> array.\n+     * </p>\n+     *\n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (short element : array) {\n+                append(element);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the result of super.hashCode() to this builder.\n+     * </p>\n+     *\n+     * @param superHashCode\n+     *            the result of calling <code>super.hashCode()</code>\n+     * @return this HashCodeBuilder, used to chain calls.\n+     * @since 2.0\n+     */\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the computed <code>hashCode</code>.\n+     * </p>\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    public int toHashCode() {\n+        return iTotal;\n+    }\n+\n+    /**\n+     * Returns the computed <code>hashCode</code>.\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     *\n+     * @since 3.0\n+     */\n+    public Integer build() {\n+        return Integer.valueOf(toHashCode());\n+    }\n+\n+    /**\n+     * <p>\n+     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelihood\n+     * of bugs in mis-calling toHashCode() and the unlikeliness of it mattering what the hashCode for\n+     * HashCodeBuilder itself is.</p>\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     * @since 2.5\n+     */\n+    @Override\n+    public int hashCode() {\n+        return toHashCode();\n+    }\n+\n+}\n",
            "diff_size": 976
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}