{
    "error_id": "19",
    "information": {
        "errors": [
            {
                "line": "199",
                "column": "56",
                "severity": "warning",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "        long[] timetrapOffsets = TimeTrapUtil.getTimetrapOffsets(from, toInclusive, timetrapSize);\n\n        if (timetrapOffsets.length > requestLimitCount){\n            throw new LimitExceededException();\n        }\n",
    "results": [
        {
            "tool": "styler",
            "errors": null,
            "diff": null
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/19/TimelineReader.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/intellij/19/TimelineReader.java\nindex f287cefc90..07cbcb196f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/19/TimelineReader.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/intellij/19/TimelineReader.java\n@@ -28,7 +28,7 @@ import java.util.stream.Collectors;\n \n /**\n  * Read event timeline from Cassandra cluster\n- *\n+ * <p>\n  * FIXME: Should be revised and refactored\n  */\n public class TimelineReader {\n@@ -115,6 +115,7 @@ public class TimelineReader {\n     }\n \n     private static final byte[] NIL = new byte[24];\n+\n     private static boolean isNil(byte[] eventId) {\n         return Arrays.equals(NIL, eventId);\n     }\n@@ -123,42 +124,42 @@ public class TimelineReader {\n     private static final String PAYLOAD = \"payload\";\n \n     private static final String SELECT_EVENTS = \"\" +\n-            \"SELECT\" +\n-            \"  event_id,\" +\n-            \"  payload\" +\n-            \" \" +\n-            \"FROM\" +\n-            \"  %s\" +\n-            \" \" +\n-            \"WHERE\" +\n-            \"  slice = %d AND\" +\n-            \"  tt_offset = %d AND\" +\n-            \"  event_id > %s AND\" + // Lower bound\n-            \"  event_id < %s\" + // Upper bound\n-            \" \" +\n-            \"ORDER BY \" +\n-            \"  event_id\" +\n-            \" \" +\n-            \"LIMIT %d;\";\n+        \"SELECT\" +\n+        \"  event_id,\" +\n+        \"  payload\" +\n+        \" \" +\n+        \"FROM\" +\n+        \"  %s\" +\n+        \" \" +\n+        \"WHERE\" +\n+        \"  slice = %d AND\" +\n+        \"  tt_offset = %d AND\" +\n+        \"  event_id > %s AND\" + // Lower bound\n+        \"  event_id < %s\" + // Upper bound\n+        \" \" +\n+        \"ORDER BY \" +\n+        \"  event_id\" +\n+        \" \" +\n+        \"LIMIT %d;\";\n \n     private static final String SELECT_EVENTS_START_READING_SLICE = \"\" +\n-            \"SELECT\" +\n-            \"  event_id,\" +\n-            \"  payload\" +\n-            \" \" +\n-            \"FROM\" +\n-            \"  %s\" +\n-            \" \" +\n-            \"WHERE\" +\n-            \"  slice = %d AND\" +\n-            \"  tt_offset = %d AND\" +\n-            \"  event_id >= %s AND\" + // Lower bound\n-            \"  event_id < %s\" + // Upper bound\n-            \" \" +\n-            \"ORDER BY \" +\n-            \"  event_id\" +\n-            \" \" +\n-            \"LIMIT %d;\";\n+        \"SELECT\" +\n+        \"  event_id,\" +\n+        \"  payload\" +\n+        \" \" +\n+        \"FROM\" +\n+        \"  %s\" +\n+        \" \" +\n+        \"WHERE\" +\n+        \"  slice = %d AND\" +\n+        \"  tt_offset = %d AND\" +\n+        \"  event_id >= %s AND\" + // Lower bound\n+        \"  event_id < %s\" + // Upper bound\n+        \" \" +\n+        \"ORDER BY \" +\n+        \"  event_id\" +\n+        \" \" +\n+        \"LIMIT %d;\";\n \n     private final Session session;\n \n@@ -168,35 +169,36 @@ public class TimelineReader {\n \n     /**\n      * Read timeline content from Cassandra cluster\n-     * @param timeline timeline info\n-     * @param readState offsets data\n+     *\n+     * @param timeline   timeline info\n+     * @param readState  offsets data\n      * @param shardIndex parameter for logical partitioning\n      * @param shardCount parameter for logical partitioning\n-     * @param take fetch size\n-     * @param from lower timestamp bound in 100-ns ticks from Unix epoch\n-     * @param to upper timestamp bound exclusive in 100-ns ticks from Unix epoch\n+     * @param take       fetch size\n+     * @param from       lower timestamp bound in 100-ns ticks from Unix epoch\n+     * @param to         upper timestamp bound exclusive in 100-ns ticks from Unix epoch\n      * @return timeline content\n      */\n     public TimelineByteContent readTimeline(\n-            Timeline timeline,\n-            TimelineState readState,\n-            int shardIndex,\n-            int shardCount,\n-            int take,\n-            long from,\n-            long to,\n-            int requestLimitCount\n+        Timeline timeline,\n+        TimelineState readState,\n+        int shardIndex,\n+        int shardCount,\n+        int take,\n+        long from,\n+        long to,\n+        int requestLimitCount\n     ) throws LimitExceededException {\n         long toInclusive = to - 1;\n         long timetrapSize = timeline.getTimetrapSize();\n \n         int[] partitions = LogicalPartitioner.getPartitionsForLogicalSharding(timeline, shardIndex, shardCount);\n         if (partitions.length == 0) {\n-            return new TimelineByteContent(readState, new byte[][]{});\n+            return new TimelineByteContent(readState, new byte[][] {});\n         }\n         long[] timetrapOffsets = TimeTrapUtil.getTimetrapOffsets(from, toInclusive, timetrapSize);\n \n-        if (timetrapOffsets.length > requestLimitCount){\n+        if (timetrapOffsets.length > requestLimitCount) {\n             throw new LimitExceededException();\n         }\n \n@@ -206,12 +208,12 @@ public class TimelineReader {\n \n         for (Parameters params : new Grid(partitions, timetrapOffsets)) {\n             TimelineShardReadStateOffset offset = offsetMap.computeIfAbsent(\n-                    params.slice,\n-                    i -> getEmptyReadStateOffset(params.ttOffset)\n+                params.slice,\n+                i -> getEmptyReadStateOffset(params.ttOffset)\n             );\n             if (params.ttOffset < offset.ttOffset) {\n                 continue; // Skip already red timetrap offsets\n-            } else if (offset.ttOffset < params.ttOffset ) {\n+            } else if (offset.ttOffset < params.ttOffset) {\n                 offsetMap.put(params.slice, getEmptyReadStateOffset(params.ttOffset));\n                 offset = offsetMap.get(params.slice);\n             }\n@@ -251,46 +253,46 @@ public class TimelineReader {\n     private static SimpleStatement generateStatement(Timeline timeline, Parameters params, TimelineShardReadStateOffset offset, int take) {\n         if (!isNil(offset.eventId)) {\n             return new SimpleStatement(String.format(\n-                    SELECT_EVENTS,\n-                    timeline.getName(),\n-                    params.slice,\n-                    params.ttOffset,\n-                    EventUtil.eventIdOfBytesAsHexString(offset.eventId),\n-                    EventUtil.minEventIdForTimestampAsHexString(TimeUtil.millisToTicks(params.ttOffset + timeline.getTimetrapSize())),\n-                    take\n+                SELECT_EVENTS,\n+                timeline.getName(),\n+                params.slice,\n+                params.ttOffset,\n+                EventUtil.eventIdOfBytesAsHexString(offset.eventId),\n+                EventUtil.minEventIdForTimestampAsHexString(TimeUtil.millisToTicks(params.ttOffset + timeline.getTimetrapSize())),\n+                take\n             ));\n         } else {\n             return new SimpleStatement(String.format(\n-                    SELECT_EVENTS_START_READING_SLICE,\n-                    timeline.getName(),\n-                    params.slice,\n-                    params.ttOffset,\n-                    EventUtil.minEventIdForTimestampAsHexString(TimeUtil.millisToTicks(params.ttOffset)),\n-                    EventUtil.minEventIdForTimestampAsHexString(TimeUtil.millisToTicks(params.ttOffset + timeline.getTimetrapSize())),\n-                    take\n+                SELECT_EVENTS_START_READING_SLICE,\n+                timeline.getName(),\n+                params.slice,\n+                params.ttOffset,\n+                EventUtil.minEventIdForTimestampAsHexString(TimeUtil.millisToTicks(params.ttOffset)),\n+                EventUtil.minEventIdForTimestampAsHexString(TimeUtil.millisToTicks(params.ttOffset + timeline.getTimetrapSize())),\n+                take\n             ));\n         }\n     }\n \n     private static Map<Integer, TimelineShardReadStateOffset> toMap(TimelineState readState) {\n         return Arrays.stream(readState.getSliceStates())\n-                .collect(Collectors.toMap(\n-                        TimelineSliceState::getSlice,\n-                        shardState -> new TimelineShardReadStateOffset(\n-                                shardState.getTtOffset(),\n-                                shardState.getEventId()\n-                        )\n-                ));\n+            .collect(Collectors.toMap(\n+                TimelineSliceState::getSlice,\n+                shardState -> new TimelineShardReadStateOffset(\n+                    shardState.getTtOffset(),\n+                    shardState.getEventId()\n+                )\n+            ));\n     }\n \n     private static TimelineState toState(Map<Integer, TimelineShardReadStateOffset> offsetMap) {\n         return new TimelineState(offsetMap.entrySet().stream()\n-                .map(offsetEntry -> new TimelineSliceState(\n-                        offsetEntry.getKey(),\n-                        offsetEntry.getValue().ttOffset,\n-                        offsetEntry.getValue().eventId\n-                ))\n-                .toArray(TimelineSliceState[]::new)\n+            .map(offsetEntry -> new TimelineSliceState(\n+                offsetEntry.getKey(),\n+                offsetEntry.getValue().ttOffset,\n+                offsetEntry.getValue().eventId\n+            ))\n+            .toArray(TimelineSliceState[]::new)\n         );\n     }\n \n",
            "diff_size": 82
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ]
}