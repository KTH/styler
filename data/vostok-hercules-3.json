{
    "error_id": "3",
    "information": {
        "errors": [
            {
                "line": "166",
                "severity": "warning",
                "message": "Line is longer than 160 characters (found 196).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            ResponseUtil.badRequest(\n                    httpServerExchange,\n                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n            return;\n        }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/styler/3/ReadTimelineHandler.java\nindex 9df791f11c..8044f367e2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/styler/3/ReadTimelineHandler.java\n@@ -162,36 +162,37 @@ public class ReadTimelineHandler implements HttpHandler {\n         Timeline timeline = optionalTimeline.get();\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n             ResponseUtil.badRequest(\n-                    httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n-            return;\n-        }\n-\n-        httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n-            exchange.dispatch(() -> {\n-                try {\n-                    TimelineState readState = STATE_READER.read(new Decoder(message));\n-\n-                    TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n-\n-                    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-                    Encoder encoder = new Encoder(stream);\n-                    CONTENT_WRITER.write(encoder, byteContent);\n-\n-                    exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n-                } catch (Exception e) {\n-                    LOGGER.error(\"Error on processing request\", e);\n-                    ResponseUtil.internalServerError(exchange);\n-                } finally {\n-                    exchange.endExchange();\n-                }\n-            });\n-        });\n-    }\n-}\n+                    httpServerExchange, \"Time interval should not exceeded \"\n+                    + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n+             return;\n+         }\n+\n+         httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n+             exchange.dispatch(() -> {\n+                 try {\n+                     TimelineState readState = STATE_READER.read(new Decoder(message));\n+\n+                     TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n+                             readState,\n+                             shardIndex.get(),\n+                             shardCount.get(),\n+                             take.get(),\n+                             from.get(),\n+                             to.get());\n+\n+                     ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+                     Encoder encoder = new Encoder(stream);\n+                     CONTENT_WRITER.write(encoder, byteContent);\n+\n+                     exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n+                 } catch (Exception e) {\n+                     LOGGER.error(\"Error on processing request\", e);\n+                     ResponseUtil.internalServerError(exchange);\n+                 } finally {\n+                     exchange.endExchange();\n+                 }\n+             });\n+         });\n+     }\n+ }\n+ \n\\ No newline at end of file\n",
            "diff_size": 34
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/intellij/3/ReadTimelineHandler.java\nindex 9df791f11c..62a5c17881 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/intellij/3/ReadTimelineHandler.java\n@@ -162,8 +162,9 @@ public class ReadTimelineHandler implements HttpHandler {\n         Timeline timeline = optionalTimeline.get();\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n             ResponseUtil.badRequest(\n-                    httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n+                httpServerExchange,\n+                \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" +\n+                    (to.get() - from.get()) + \" ticks\");\n             return;\n         }\n \n@@ -173,12 +174,12 @@ public class ReadTimelineHandler implements HttpHandler {\n                     TimelineState readState = STATE_READER.read(new Decoder(message));\n \n                     TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n+                        readState,\n+                        shardIndex.get(),\n+                        shardCount.get(),\n+                        take.get(),\n+                        from.get(),\n+                        to.get());\n \n                     ByteArrayOutputStream stream = new ByteArrayOutputStream();\n                     Encoder encoder = new Encoder(stream);\n",
            "diff_size": 9
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "166",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 196).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/naturalize/3/ReadTimelineHandler.java\nindex 9df791f11c..13579b0057 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/naturalize/3/ReadTimelineHandler.java\n@@ -173,7 +173,7 @@ public class ReadTimelineHandler implements HttpHandler {\n                     TimelineState readState = STATE_READER.read(new Decoder(message));\n \n                     TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n+readState,\n                             shardIndex.get(),\n                             shardCount.get(),\n                             take.get(),\n@@ -194,4 +194,4 @@ public class ReadTimelineHandler implements HttpHandler {\n             });\n         });\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "182",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 193).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/codebuff/3/ReadTimelineHandler.java\nindex 9df791f11c..b1e35ad7d0 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/codebuff/3/ReadTimelineHandler.java\n@@ -19,33 +19,45 @@ import ru.kontur.vostok.hercules.undertow.util.ResponseUtil;\n import ru.kontur.vostok.hercules.util.functional.Result;\n import ru.kontur.vostok.hercules.util.parsing.Parsers;\n import ru.kontur.vostok.hercules.util.time.TimeUtil;\n-\n import java.io.ByteArrayOutputStream;\n import java.nio.ByteBuffer;\n import java.util.Optional;\n \n-public class ReadTimelineHandler implements HttpHandler {\n \n+public class ReadTimelineHandler implements HttpHandler {\n     private static final Logger LOGGER = LoggerFactory.getLogger(ReadTimelineHandler.class);\n \n     private static final TimelineStateReader STATE_READER = new TimelineStateReader();\n+\n     private static final TimelineByteContentWriter CONTENT_WRITER = new TimelineByteContentWriter();\n \n     private static final String REASON_MISSING_PARAM = \"Missing required parameter \";\n \n     private static final String PARAM_TIMELINE = \"timeline\";\n+\n     private static final String PARAM_SHARD_INDEX = \"shardIndex\";\n+\n     private static final String PARAM_SHARD_COUNT = \"shardCount\";\n+\n     private static final String PARAM_TAKE = \"take\";\n+\n     private static final String PARAM_FROM = \"from\";\n+\n     private static final String PARAM_TO = \"to\";\n \n     private final TimelineRepository timelineRepository;\n+\n     private final TimelineReader timelineReader;\n+\n     private final AuthManager authManager;\n+\n     private final int timetrapCountLimit;\n \n-    public ReadTimelineHandler(TimelineRepository timelineRepository, TimelineReader timelineReader, AuthManager authManager, int timetrapCountLimit) {\n+    public ReadTimelineHandler(\n+        TimelineRepository timelineRepository,\n+        TimelineReader timelineReader,\n+        AuthManager authManager, int timetrapCountLimit\n+    ) {\n         this.timelineRepository = timelineRepository;\n         this.timelineReader = timelineReader;\n         this.authManager = authManager;\n@@ -58,12 +70,12 @@ public class ReadTimelineHandler implements HttpHandler {\n \n     @Override\n     public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {\n-\n         Optional<Integer> optionalContentLength = ExchangeUtil.extractContentLength(httpServerExchange);\n         if (!optionalContentLength.isPresent()) {\n             ResponseUtil.lengthRequired(httpServerExchange);\n             return;\n         }\n+\n         if (optionalContentLength.get() < 0) {\n             ResponseUtil.badRequest(httpServerExchange);\n             return;\n@@ -74,8 +86,8 @@ public class ReadTimelineHandler implements HttpHandler {\n             ResponseUtil.unauthorized(httpServerExchange);\n             return;\n         }\n-        String apiKey = optionalApiKey.get();\n \n+        String apiKey = optionalApiKey.get();\n         Optional<String> optionalTimelineName = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TIMELINE);\n         if (!optionalTimelineName.isPresent()) {\n             ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TIMELINE);\n@@ -83,12 +95,12 @@ public class ReadTimelineHandler implements HttpHandler {\n         }\n \n         AuthResult authResult = authManager.authRead(apiKey, optionalTimelineName.get());\n-\n         if (!authResult.isSuccess()) {\n             if (authResult.isUnknown()) {\n                 ResponseUtil.unauthorized(httpServerExchange);\n                 return;\n             }\n+\n             ResponseUtil.forbidden(httpServerExchange);\n             return;\n         }\n@@ -101,7 +113,10 @@ public class ReadTimelineHandler implements HttpHandler {\n \n         Result<Integer, String> shardIndex = Parsers.parseInteger(optionalShardIndex.get());\n         if (!shardIndex.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, shardIndex.getError() + \" in parameter \" + PARAM_SHARD_INDEX);\n+            ResponseUtil.badRequest(\n+                httpServerExchange,\n+                shardIndex.getError() + \" in parameter \" + PARAM_SHARD_INDEX\n+            );\n             return;\n         }\n \n@@ -113,7 +128,10 @@ public class ReadTimelineHandler implements HttpHandler {\n \n         Result<Integer, String> shardCount = Parsers.parseInteger(optionalShardCount.get());\n         if (!shardCount.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, shardCount.getError() + \" in parameter \" + PARAM_SHARD_COUNT);\n+            ResponseUtil.badRequest(\n+                httpServerExchange,\n+                shardCount.getError() + \" in parameter \" + PARAM_SHARD_COUNT\n+            );\n             return;\n         }\n \n@@ -161,9 +179,8 @@ public class ReadTimelineHandler implements HttpHandler {\n \n         Timeline timeline = optionalTimeline.get();\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n-            ResponseUtil.badRequest(\n-                    httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n+            ResponseUtil.badRequest(httpServerExchange, \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \"\n+            + (to.get() - from.get()) + \" ticks\");\n             return;\n         }\n \n@@ -171,19 +188,18 @@ public class ReadTimelineHandler implements HttpHandler {\n             exchange.dispatch(() -> {\n                 try {\n                     TimelineState readState = STATE_READER.read(new Decoder(message));\n-\n-                    TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n-\n+                    TimelineByteContent byteContent = timelineReader.readTimeline(\n+                        optionalTimeline.get(),\n+                        readState,\n+                        shardIndex.get(),\n+                        shardCount.get(),\n+                        take.get(),\n+                        from.get(),\n+                        to.get()\n+                    );\n                     ByteArrayOutputStream stream = new ByteArrayOutputStream();\n                     Encoder encoder = new Encoder(stream);\n                     CONTENT_WRITER.write(encoder, byteContent);\n-\n                     exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n                 } catch (Exception e) {\n                     LOGGER.error(\"Error on processing request\", e);\n@@ -194,4 +210,4 @@ public class ReadTimelineHandler implements HttpHandler {\n             });\n         });\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 45
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "166",
                    "column": "102",
                    "severity": "warning",
                    "message": "'*' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "166",
                    "column": "102",
                    "severity": "warning",
                    "message": "'*' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "60",
                    "severity": "warning",
                    "message": "'-' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/styler_random/3/ReadTimelineHandler.java\nindex 9df791f11c..217afca6d4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/styler_random/3/ReadTimelineHandler.java\n@@ -163,35 +163,38 @@ public class ReadTimelineHandler implements HttpHandler {\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n             ResponseUtil.badRequest(\n                     httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n-            return;\n-        }\n-\n-        httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n-            exchange.dispatch(() -> {\n-                try {\n-                    TimelineState readState = STATE_READER.read(new Decoder(message));\n-\n-                    TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n-\n-                    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-                    Encoder encoder = new Encoder(stream);\n-                    CONTENT_WRITER.write(encoder, byteContent);\n-\n-                    exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n-                } catch (Exception e) {\n-                    LOGGER.error(\"Error on processing request\", e);\n-                    ResponseUtil.internalServerError(exchange);\n-                } finally {\n-                    exchange.endExchange();\n-                }\n-            });\n-        });\n-    }\n-}\n+                    \"Time interval should not exceeded \" + TimeUtil .millisToTicks(timetrapCountLimit*timeline .getTimetrapSize())\n+                    + \" ticks, but requested \" + (to.get() -from.get(\n+                    ) ) + \" ticks\");\n+             return;\n+         }\n+\n+         httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n+             exchange.dispatch(() -> {\n+                 try {\n+                     TimelineState readState = STATE_READER.read(new Decoder(message));\n+\n+                     TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n+                             readState,\n+                             shardIndex.get(),\n+                             shardCount.get(),\n+                             take.get(),\n+                             from.get(),\n+                             to.get());\n+\n+                     ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+                     Encoder encoder = new Encoder(stream);\n+                     CONTENT_WRITER.write(encoder, byteContent);\n+\n+                     exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n+                 } catch (Exception e) {\n+                     LOGGER.error(\"Error on processing request\", e);\n+                     ResponseUtil.internalServerError(exchange);\n+                 } finally {\n+                     exchange.endExchange();\n+                 }\n+             });\n+         });\n+     }\n+ }\n+ \n\\ No newline at end of file\n",
            "diff_size": 35
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/styler_three_grams/3/ReadTimelineHandler.java\nindex 9df791f11c..8044f367e2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/errored/1/3/ReadTimelineHandler.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/vostok-hercules/styler_three_grams/3/ReadTimelineHandler.java\n@@ -162,36 +162,37 @@ public class ReadTimelineHandler implements HttpHandler {\n         Timeline timeline = optionalTimeline.get();\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n             ResponseUtil.badRequest(\n-                    httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n-            return;\n-        }\n-\n-        httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n-            exchange.dispatch(() -> {\n-                try {\n-                    TimelineState readState = STATE_READER.read(new Decoder(message));\n-\n-                    TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n-\n-                    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-                    Encoder encoder = new Encoder(stream);\n-                    CONTENT_WRITER.write(encoder, byteContent);\n-\n-                    exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n-                } catch (Exception e) {\n-                    LOGGER.error(\"Error on processing request\", e);\n-                    ResponseUtil.internalServerError(exchange);\n-                } finally {\n-                    exchange.endExchange();\n-                }\n-            });\n-        });\n-    }\n-}\n+                    httpServerExchange, \"Time interval should not exceeded \"\n+                    + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n+             return;\n+         }\n+\n+         httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n+             exchange.dispatch(() -> {\n+                 try {\n+                     TimelineState readState = STATE_READER.read(new Decoder(message));\n+\n+                     TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n+                             readState,\n+                             shardIndex.get(),\n+                             shardCount.get(),\n+                             take.get(),\n+                             from.get(),\n+                             to.get());\n+\n+                     ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+                     Encoder encoder = new Encoder(stream);\n+                     CONTENT_WRITER.write(encoder, byteContent);\n+\n+                     exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n+                 } catch (Exception e) {\n+                     LOGGER.error(\"Error on processing request\", e);\n+                     ResponseUtil.internalServerError(exchange);\n+                 } finally {\n+                     exchange.endExchange();\n+                 }\n+             });\n+         });\n+     }\n+ }\n+ \n\\ No newline at end of file\n",
            "diff_size": 34
        }
    ]
}