{
    "error_id": "770",
    "information": {
        "errors": [
            {
                "line": "331",
                "column": "17",
                "severity": "error",
                "message": "'+' should be on the previous line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "          } else {\n            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n          }\n\n          if (timerEntity.getEndDate() == null) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler/770/DefaultJobManager.java\nindex f786d115fb..9bf7ce72d4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler/770/DefaultJobManager.java\n@@ -46,29 +46,29 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class DefaultJobManager implements JobManager {\n-  \n+\n   private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n-  \n+\n   protected ProcessEngineConfigurationImpl processEngineConfiguration;\n-  \n+\n   public DefaultJobManager() {\n   }\n-  \n+\n   public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n     this.processEngineConfiguration = processEngineConfiguration;\n   }\n-  \n+\n   @Override\n   public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n     JobEntity jobEntity = null;\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n       jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n-      \n+\n     } else {\n       jobEntity = internalCreateAsyncJob(execution, exclusive);\n     }\n-    \n+\n     return jobEntity;\n   }\n \n@@ -81,26 +81,26 @@ public class DefaultJobManager implements JobManager {\n   protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n-      hintAsyncExecutor(jobEntity); \n+      hintAsyncExecutor(jobEntity);\n     }\n   }\n-  \n+\n   @Override\n-  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting, \n+  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting,\n       ExecutionEntity execution, String timerEventType, String jobHandlerConfiguration) {\n-    \n-    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting, \n+\n+    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting,\n         execution, timerEventType, jobHandlerConfiguration);\n-    \n+\n     return timerEntity;\n   }\n-  \n+\n   @Override\n   public void scheduleTimerJob(TimerJobEntity timerJob) {\n     if (timerJob == null) {\n       throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n+\n     processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n \n     CommandContext commandContext = Context.getCommandContext();\n@@ -109,13 +109,13 @@ public class DefaultJobManager implements JobManager {\n       eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED, timerJob));\n     }\n   }\n-  \n+\n   @Override\n   public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n     if (timerJob == null) {\n       throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n+\n     JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n     boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n     if (insertSuccesful) {\n@@ -125,7 +125,7 @@ public class DefaultJobManager implements JobManager {\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n     TimerJobEntity timerJob = createTimerJobFromOtherJob(job);\n@@ -136,64 +136,64 @@ public class DefaultJobManager implements JobManager {\n       } else if (job instanceof SuspendedJobEntity) {\n         processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n       }\n-      \n+\n       return timerJob;\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n     SuspendedJobEntity suspendedJob = createSuspendedJobFromOtherJob(job);\n     processEngineConfiguration.getSuspendedJobEntityManager().insert(suspendedJob);\n     if (job instanceof TimerJobEntity) {\n       processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n+\n     return suspendedJob;\n   }\n-  \n+\n   @Override\n   public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n     AbstractJobEntity activatedJob = null;\n     if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n       activatedJob = createTimerJobFromOtherJob(job);\n       processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n-      \n+\n     } else {\n       activatedJob = createExecutableJobFromOtherJob(job);\n       JobEntity jobEntity = (JobEntity) activatedJob;\n       processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n       triggerExecutorIfNeeded(jobEntity);\n     }\n-    \n+\n     processEngineConfiguration.getSuspendedJobEntityManager().delete(job);\n     return activatedJob;\n   }\n-  \n+\n   @Override\n   public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n     DeadLetterJobEntity deadLetterJob = createDeadLetterJobFromOtherJob(job);\n     processEngineConfiguration.getDeadLetterJobEntityManager().insert(deadLetterJob);\n     if (job instanceof TimerJobEntity) {\n       processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n+\n     return deadLetterJob;\n   }\n-  \n+\n   @Override\n   public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n     if (deadLetterJobEntity == null) {\n       throw new ActivitiIllegalArgumentException(\"Null job provided\");\n     }\n-    \n+\n     JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n     executableJob.setRetries(retries);\n     boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n@@ -204,7 +204,7 @@ public class DefaultJobManager implements JobManager {\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public void execute(Job job) {\n     if (job instanceof JobEntity) {\n@@ -213,55 +213,55 @@ public class DefaultJobManager implements JobManager {\n       } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n         executeTimerJob((JobEntity) job);\n       }\n-      \n+\n     } else {\n       throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n     }\n   }\n-  \n+\n   @Override\n   public void unacquire(Job job) {\n-    \n+\n     // Deleting the old job and inserting it again with another id,\n     // will avoid that the job is immediately is picked up again (for example\n     // when doing lots of exclusive jobs for the same process instance)\n     if (job instanceof JobEntity) {\n       JobEntity jobEntity = (JobEntity) job;\n       processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n-      \n+\n       JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n       copyJobInfo(newJobEntity, jobEntity);\n       newJobEntity.setId(null); // We want a new id to be assigned to this job\n       newJobEntity.setLockExpirationTime(null);\n       newJobEntity.setLockOwner(null);\n       processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n-      \n+\n       // We're not calling triggerExecutorIfNeeded here after the inser. The unacquire happened\n       // for a reason (eg queue full or exclusive lock failure). No need to try it immediately again,\n       // as the chance of failure will be high.\n-      \n+\n     } else {\n       // It could be a v5 job, so simply unlock it.\n       processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n     }\n-    \n+\n   }\n-   \n+\n   protected void executeMessageJob(JobEntity jobEntity) {\n     executeJobHandler(jobEntity);\n     if (jobEntity.getId() != null) {\n       Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n     }\n   }\n-   \n+\n   protected void executeTimerJob(JobEntity timerEntity) {\n     TimerJobEntityManager timerJobEntityManager = processEngineConfiguration.getTimerJobEntityManager();\n-    \n+\n     VariableScope variableScope = null;\n     if (timerEntity.getExecutionId() != null) {\n       variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n     }\n-     \n+\n     if (variableScope == null) {\n       variableScope = NoExecutionVariableScope.getSharedInstance();\n     }\n@@ -283,7 +283,7 @@ public class DefaultJobManager implements JobManager {\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"Timer {} fired. Deleting timer.\", timerEntity.getId());\n     }\n-    \n+\n     if (timerEntity.getRepeat() != null) {\n       TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n       if (newTimerJobEntity != null) {\n@@ -291,7 +291,7 @@ public class DefaultJobManager implements JobManager {\n       }\n     }\n   }\n-  \n+\n   protected void executeJobHandler(JobEntity jobEntity) {\n     ExecutionEntity execution = null;\n     if (jobEntity.getExecutionId() != null) {\n@@ -302,7 +302,7 @@ public class DefaultJobManager implements JobManager {\n     JobHandler jobHandler = jobHandlers.get(jobEntity.getJobHandlerType());\n     jobHandler.execute(jobEntity, jobEntity.getJobHandlerConfiguration(), execution, getCommandContext());\n   }\n-   \n+\n   protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n     String activityId = timerEntity.getJobHandlerConfiguration();\n \n@@ -327,198 +327,198 @@ public class DefaultJobManager implements JobManager {\n           } else if (endDateValue instanceof Date) {\n             timerEntity.setEndDate((Date) endDateValue);\n           } else {\n-            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n-                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n-          }\n+            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId() +\n+                                             \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n+       }\n \n-          if (timerEntity.getEndDate() == null) {\n-            timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n-          }\n-        }\n-      }\n-    }\n+       if (timerEntity.getEndDate() == null) {\n+         timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n+       }\n+     }\n+   }\n+ }\n \n-    int maxIterations = 1;\n-    if (timerEntity.getProcessDefinitionId() != null) {\n-      org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n-      maxIterations = getMaxIterations(process, activityId);\n-      if (maxIterations <= 1) {\n-        maxIterations = getMaxIterations(process, activityId);\n-      }\n-    }\n-    timerEntity.setMaxIterations(maxIterations);\n-  }\n-   \n-  protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n-    FlowElement flowElement = process.getFlowElement(activityId, true);\n-    if (flowElement != null) {\n-      if (flowElement instanceof Event) {\n-         \n-        Event event = (Event) flowElement;\n-        List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n-         \n-        if (eventDefinitions != null) {\n-           \n-          for (EventDefinition eventDefinition : eventDefinitions) {\n-            if (eventDefinition instanceof TimerEventDefinition) {\n-              TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n-              if (timerEventDefinition.getTimeCycle() != null) {\n-                return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n-              }\n+ int maxIterations = 1;\n+ if (timerEntity.getProcessDefinitionId() != null) {\n+   org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n+   maxIterations = getMaxIterations(process, activityId);\n+   if (maxIterations <= 1) {\n+     maxIterations = getMaxIterations(process, activityId);\n+   }\n+ }\n+ timerEntity.setMaxIterations(maxIterations);\n+}\n+\n+protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n+  FlowElement flowElement = process.getFlowElement(activityId, true);\n+  if (flowElement != null) {\n+    if (flowElement instanceof Event) {\n+\n+      Event event = (Event) flowElement;\n+      List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n+\n+      if (eventDefinitions != null) {\n+\n+        for (EventDefinition eventDefinition : eventDefinitions) {\n+          if (eventDefinition instanceof TimerEventDefinition) {\n+            TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n+            if (timerEventDefinition.getTimeCycle() != null) {\n+              return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n             }\n           }\n-           \n         }\n-         \n-      }\n-    }\n-    return -1;\n-  }\n-   \n-  protected int calculateMaxIterationsValue(String originalExpression) {\n-    int times = Integer.MAX_VALUE;\n-    List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n-    if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n-      times = Integer.MAX_VALUE;\n-      if (expression.get(0).length() > 1) {\n-        times = Integer.parseInt(expression.get(0).substring(1));\n+\n       }\n+\n     }\n-    return times;\n-  }\n-   \n-  protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n-    BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-        getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n-    return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n   }\n-  \n-  protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n-    String businessCalendarName = CycleBusinessCalendar.NAME;\n-    if (StringUtils.isNotEmpty(calendarName)) {\n-      businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n-          .createExpression(calendarName).getValue(variableScope);\n+  return -1;\n+}\n+\n+protected int calculateMaxIterationsValue(String originalExpression) {\n+  int times = Integer.MAX_VALUE;\n+  List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n+  if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n+    times = Integer.MAX_VALUE;\n+    if (expression.get(0).length() > 1) {\n+      times = Integer.parseInt(expression.get(0).substring(1));\n     }\n-    return businessCalendarName;\n   }\n-  \n-  protected void hintAsyncExecutor(JobEntity job) {\n-    AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n-    getCommandContext().addCloseListener(jobAddedNotification);\n+  return times;\n+}\n+\n+protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n+  BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n+      getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+  return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n+}\n+\n+protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n+  String businessCalendarName = CycleBusinessCalendar.NAME;\n+  if (StringUtils.isNotEmpty(calendarName)) {\n+    businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n+        .createExpression(calendarName).getValue(variableScope);\n   }\n-  \n-  protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    return asyncJob;\n+  return businessCalendarName;\n+}\n+\n+protected void hintAsyncExecutor(JobEntity job) {\n+  AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n+  getCommandContext().addCloseListener(jobAddedNotification);\n+}\n+\n+protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+  JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+  fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+  return asyncJob;\n+}\n+\n+protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+  JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+  fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+\n+  GregorianCalendar gregorianCalendar = new GregorianCalendar();\n+  gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n+  gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n+  asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n+  asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n+\n+  return asyncJob;\n+}\n+\n+protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n+  jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n+  jobEntity.setRevision(1);\n+  jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n+  jobEntity.setExecutionId(execution.getId());\n+  jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n+  jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n+  jobEntity.setExclusive(exclusive);\n+  jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n+\n+  // Inherit tenant id (if applicable)\n+  if (execution.getTenantId() != null) {\n+    jobEntity.setTenantId(execution.getTenantId());\n   }\n-  \n-  protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    \n+}\n+\n+protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n+  JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n+  copyJobInfo(executableJob, job);\n+\n+  if (isAsyncExecutorActive()) {\n     GregorianCalendar gregorianCalendar = new GregorianCalendar();\n     gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n-    asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n-    asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    \n-    return asyncJob;\n-  }\n-  \n-  protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n-    jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n-    jobEntity.setRevision(1);\n-    jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n-    jobEntity.setExecutionId(execution.getId());\n-    jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n-    jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n-    jobEntity.setExclusive(exclusive);\n-    jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n-    \n-    // Inherit tenant id (if applicable)\n-    if (execution.getTenantId() != null) {\n-      jobEntity.setTenantId(execution.getTenantId());\n-    }\n-  }\n-  \n-  protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n-    JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n-    copyJobInfo(executableJob, job);\n-    \n-    if (isAsyncExecutorActive()) {\n-      GregorianCalendar gregorianCalendar = new GregorianCalendar();\n-      gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-      gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n-      executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n-      executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    }\n-    \n-    return executableJob;\n-  }\n-  \n-  protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n-    TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n-    copyJobInfo(timerJob, otherJob);\n-    return timerJob;\n-  }\n-  \n-  protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n-    SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n-    copyJobInfo(suspendedJob, otherJob);\n-    return suspendedJob;\n-  }\n-  \n-  protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n-    DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n-    copyJobInfo(deadLetterJob, otherJob);\n-    return deadLetterJob;\n-  }\n-  \n-  protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n-    copyToJob.setDuedate(copyFromJob.getDuedate());\n-    copyToJob.setEndDate(copyFromJob.getEndDate());\n-    copyToJob.setExclusive(copyFromJob.isExclusive());\n-    copyToJob.setExecutionId(copyFromJob.getExecutionId());\n-    copyToJob.setId(copyFromJob.getId());\n-    copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n-    copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n-    copyToJob.setJobType(copyFromJob.getJobType());\n-    copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n-    copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n-    copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n-    copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n-    copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n-    copyToJob.setRepeat(copyFromJob.getRepeat());\n-    copyToJob.setRetries(copyFromJob.getRetries());\n-    copyToJob.setRevision(copyFromJob.getRevision());\n-    copyToJob.setTenantId(copyFromJob.getTenantId());\n-    \n-    return copyToJob;\n-  }\n-  \n-  public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n-    return processEngineConfiguration;\n+    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n+    executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n+    executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n   }\n \n-  public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n-    this.processEngineConfiguration = processEngineConfiguration;\n-  }\n+  return executableJob;\n+}\n+\n+protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n+  TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n+  copyJobInfo(timerJob, otherJob);\n+  return timerJob;\n+}\n+\n+protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n+  SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n+  copyJobInfo(suspendedJob, otherJob);\n+  return suspendedJob;\n+}\n+\n+protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n+  DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n+  copyJobInfo(deadLetterJob, otherJob);\n+  return deadLetterJob;\n+}\n+\n+protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n+  copyToJob.setDuedate(copyFromJob.getDuedate());\n+  copyToJob.setEndDate(copyFromJob.getEndDate());\n+  copyToJob.setExclusive(copyFromJob.isExclusive());\n+  copyToJob.setExecutionId(copyFromJob.getExecutionId());\n+  copyToJob.setId(copyFromJob.getId());\n+  copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n+  copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n+  copyToJob.setJobType(copyFromJob.getJobType());\n+  copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n+  copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n+  copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n+  copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n+  copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n+  copyToJob.setRepeat(copyFromJob.getRepeat());\n+  copyToJob.setRetries(copyFromJob.getRetries());\n+  copyToJob.setRevision(copyFromJob.getRevision());\n+  copyToJob.setTenantId(copyFromJob.getTenantId());\n+\n+  return copyToJob;\n+}\n+\n+public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n+  return processEngineConfiguration;\n+}\n+\n+public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+  this.processEngineConfiguration = processEngineConfiguration;\n+}\n+\n+protected boolean isAsyncExecutorActive() {\n+  return processEngineConfiguration.getAsyncExecutor().isActive();\n+}\n+\n+protected CommandContext getCommandContext() {\n+  return Context.getCommandContext();\n+}\n+\n+protected AsyncExecutor getAsyncExecutor() {\n+  return processEngineConfiguration.getAsyncExecutor();\n+}\n+\n+protected ExecutionEntityManager getExecutionEntityManager() {\n+  return processEngineConfiguration.getExecutionEntityManager();\n+}\n \n-  protected boolean isAsyncExecutorActive() {\n-    return processEngineConfiguration.getAsyncExecutor().isActive();\n-  }\n-  \n-  protected CommandContext getCommandContext() {\n-    return Context.getCommandContext();\n-  }\n-  \n-  protected AsyncExecutor getAsyncExecutor() {\n-    return processEngineConfiguration.getAsyncExecutor();\n-  }\n-  \n-  protected ExecutionEntityManager getExecutionEntityManager() {\n-    return processEngineConfiguration.getExecutionEntityManager();\n-  }\n-  \n }\n",
            "diff_size": 337
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "331",
                    "column": "33",
                    "severity": "error",
                    "message": "'+' should be on the previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/intellij/770/DefaultJobManager.java\nindex f786d115fb..309d49445b 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/intellij/770/DefaultJobManager.java\n@@ -46,479 +46,479 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class DefaultJobManager implements JobManager {\n-  \n-  private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n-  \n-  protected ProcessEngineConfigurationImpl processEngineConfiguration;\n-  \n-  public DefaultJobManager() {\n-  }\n-  \n-  public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n-    this.processEngineConfiguration = processEngineConfiguration;\n-  }\n-  \n-  @Override\n-  public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity jobEntity = null;\n-    // When the async executor is activated, the job is directly passed on to the async executor thread\n-    if (isAsyncExecutorActive()) {\n-      jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n-      \n-    } else {\n-      jobEntity = internalCreateAsyncJob(execution, exclusive);\n-    }\n-    \n-    return jobEntity;\n-  }\n-\n-  @Override\n-  public void scheduleAsyncJob(JobEntity jobEntity) {\n-    processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n-    triggerExecutorIfNeeded(jobEntity);\n-  }\n-\n-  protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n-    // When the async executor is activated, the job is directly passed on to the async executor thread\n-    if (isAsyncExecutorActive()) {\n-      hintAsyncExecutor(jobEntity); \n-    }\n-  }\n-  \n-  @Override\n-  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting, \n-      ExecutionEntity execution, String timerEventType, String jobHandlerConfiguration) {\n-    \n-    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting, \n-        execution, timerEventType, jobHandlerConfiguration);\n-    \n-    return timerEntity;\n-  }\n-  \n-  @Override\n-  public void scheduleTimerJob(TimerJobEntity timerJob) {\n-    if (timerJob == null) {\n-      throw new ActivitiException(\"Empty timer job can not be scheduled\");\n-    }\n-    \n-    processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n-\n-    CommandContext commandContext = Context.getCommandContext();\n-    ActivitiEventDispatcher eventDispatcher = commandContext.getEventDispatcher();\n-    if (eventDispatcher.isEnabled()) {\n-      eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED, timerJob));\n-    }\n-  }\n-  \n-  @Override\n-  public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n-    if (timerJob == null) {\n-      throw new ActivitiException(\"Empty timer job can not be scheduled\");\n-    }\n-    \n-    JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n-    boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n-    if (insertSuccesful) {\n-      processEngineConfiguration.getTimerJobEntityManager().delete(timerJob);\n-      triggerExecutorIfNeeded(executableJob);\n-      return executableJob;\n-    }\n-    return null;\n-  }\n-  \n-  @Override\n-  public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n-    TimerJobEntity timerJob = createTimerJobFromOtherJob(job);\n-    boolean insertSuccesful = processEngineConfiguration.getTimerJobEntityManager().insertTimerJobEntity(timerJob);\n-    if (insertSuccesful) {\n-      if (job instanceof JobEntity) {\n-        processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n-      } else if (job instanceof SuspendedJobEntity) {\n-        processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n-      }\n-      \n-      return timerJob;\n-    }\n-    return null;\n-  }\n-  \n-  @Override\n-  public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n-    SuspendedJobEntity suspendedJob = createSuspendedJobFromOtherJob(job);\n-    processEngineConfiguration.getSuspendedJobEntityManager().insert(suspendedJob);\n-    if (job instanceof TimerJobEntity) {\n-      processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n-    } else if (job instanceof JobEntity) {\n-      processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n-    }\n-    \n-    return suspendedJob;\n-  }\n-  \n-  @Override\n-  public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n-    AbstractJobEntity activatedJob = null;\n-    if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n-      activatedJob = createTimerJobFromOtherJob(job);\n-      processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n-      \n-    } else {\n-      activatedJob = createExecutableJobFromOtherJob(job);\n-      JobEntity jobEntity = (JobEntity) activatedJob;\n-      processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n-      triggerExecutorIfNeeded(jobEntity);\n-    }\n-    \n-    processEngineConfiguration.getSuspendedJobEntityManager().delete(job);\n-    return activatedJob;\n-  }\n-  \n-  @Override\n-  public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n-    DeadLetterJobEntity deadLetterJob = createDeadLetterJobFromOtherJob(job);\n-    processEngineConfiguration.getDeadLetterJobEntityManager().insert(deadLetterJob);\n-    if (job instanceof TimerJobEntity) {\n-      processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n-    } else if (job instanceof JobEntity) {\n-      processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n-    }\n-    \n-    return deadLetterJob;\n-  }\n-  \n-  @Override\n-  public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n-    if (deadLetterJobEntity == null) {\n-      throw new ActivitiIllegalArgumentException(\"Null job provided\");\n-    }\n-    \n-    JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n-    executableJob.setRetries(retries);\n-    boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n-    if (insertSuccesful) {\n-      processEngineConfiguration.getDeadLetterJobEntityManager().delete(deadLetterJobEntity);\n-      triggerExecutorIfNeeded(executableJob);\n-      return executableJob;\n-    }\n-    return null;\n-  }\n-  \n-  @Override\n-  public void execute(Job job) {\n-    if (job instanceof JobEntity) {\n-      if (Job.JOB_TYPE_MESSAGE.equals(job.getJobType())) {\n-        executeMessageJob((JobEntity) job);\n-      } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n-        executeTimerJob((JobEntity) job);\n-      }\n-      \n-    } else {\n-      throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n-    }\n-  }\n-  \n-  @Override\n-  public void unacquire(Job job) {\n-    \n-    // Deleting the old job and inserting it again with another id,\n-    // will avoid that the job is immediately is picked up again (for example\n-    // when doing lots of exclusive jobs for the same process instance)\n-    if (job instanceof JobEntity) {\n-      JobEntity jobEntity = (JobEntity) job;\n-      processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n-      \n-      JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n-      copyJobInfo(newJobEntity, jobEntity);\n-      newJobEntity.setId(null); // We want a new id to be assigned to this job\n-      newJobEntity.setLockExpirationTime(null);\n-      newJobEntity.setLockOwner(null);\n-      processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n-      \n-      // We're not calling triggerExecutorIfNeeded here after the inser. The unacquire happened\n-      // for a reason (eg queue full or exclusive lock failure). No need to try it immediately again,\n-      // as the chance of failure will be high.\n-      \n-    } else {\n-      // It could be a v5 job, so simply unlock it.\n-      processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n-    }\n-    \n-  }\n-   \n-  protected void executeMessageJob(JobEntity jobEntity) {\n-    executeJobHandler(jobEntity);\n-    if (jobEntity.getId() != null) {\n-      Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n-    }\n-  }\n-   \n-  protected void executeTimerJob(JobEntity timerEntity) {\n-    TimerJobEntityManager timerJobEntityManager = processEngineConfiguration.getTimerJobEntityManager();\n-    \n-    VariableScope variableScope = null;\n-    if (timerEntity.getExecutionId() != null) {\n-      variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n-    }\n-     \n-    if (variableScope == null) {\n-      variableScope = NoExecutionVariableScope.getSharedInstance();\n-    }\n-\n-    // set endDate if it was set to the definition\n-    restoreExtraData(timerEntity, variableScope);\n-\n-    if (timerEntity.getDuedate() != null && !isValidTime(timerEntity, timerEntity.getDuedate(), variableScope)) {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Timer {} fired. but the dueDate is after the endDate.  Deleting timer.\", timerEntity.getId());\n-      }\n-      processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n-      return;\n-    }\n-\n-    executeJobHandler(timerEntity);\n-    processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n-\n-    if (logger.isDebugEnabled()) {\n-      logger.debug(\"Timer {} fired. Deleting timer.\", timerEntity.getId());\n-    }\n-    \n-    if (timerEntity.getRepeat() != null) {\n-      TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n-      if (newTimerJobEntity != null) {\n-        scheduleTimerJob(newTimerJobEntity);\n-      }\n-    }\n-  }\n-  \n-  protected void executeJobHandler(JobEntity jobEntity) {\n-    ExecutionEntity execution = null;\n-    if (jobEntity.getExecutionId() != null) {\n-      execution = getExecutionEntityManager().findById(jobEntity.getExecutionId());\n-    }\n-\n-    Map<String, JobHandler> jobHandlers = processEngineConfiguration.getJobHandlers();\n-    JobHandler jobHandler = jobHandlers.get(jobEntity.getJobHandlerType());\n-    jobHandler.execute(jobEntity, jobEntity.getJobHandlerConfiguration(), execution, getCommandContext());\n-  }\n-   \n-  protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n-    String activityId = timerEntity.getJobHandlerConfiguration();\n-\n-    if (timerEntity.getJobHandlerType().equalsIgnoreCase(TimerStartEventJobHandler.TYPE) ||\n-        timerEntity.getJobHandlerType().equalsIgnoreCase(TriggerTimerEventJobHandler.TYPE)) {\n-\n-      activityId = TimerEventHandler.getActivityIdFromConfiguration(timerEntity.getJobHandlerConfiguration());\n-      String endDateExpressionString = TimerEventHandler.getEndDateFromConfiguration(timerEntity.getJobHandlerConfiguration());\n-\n-      if (endDateExpressionString != null) {\n-        Expression endDateExpression = processEngineConfiguration.getExpressionManager().createExpression(endDateExpressionString);\n-\n-        String endDateString = null;\n \n-        BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-            getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n-\n-        if (endDateExpression != null) {\n-          Object endDateValue = endDateExpression.getValue(variableScope);\n-          if (endDateValue instanceof String) {\n-            endDateString = (String) endDateValue;\n-          } else if (endDateValue instanceof Date) {\n-            timerEntity.setEndDate((Date) endDateValue);\n-          } else {\n-            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n-                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n-          }\n-\n-          if (timerEntity.getEndDate() == null) {\n-            timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n-          }\n+    private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n+\n+    protected ProcessEngineConfigurationImpl processEngineConfiguration;\n+\n+    public DefaultJobManager() {\n+    }\n+\n+    public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+        this.processEngineConfiguration = processEngineConfiguration;\n+    }\n+\n+    @Override\n+    public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+        JobEntity jobEntity = null;\n+        // When the async executor is activated, the job is directly passed on to the async executor thread\n+        if (isAsyncExecutorActive()) {\n+            jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n+\n+        } else {\n+            jobEntity = internalCreateAsyncJob(execution, exclusive);\n+        }\n+\n+        return jobEntity;\n+    }\n+\n+    @Override\n+    public void scheduleAsyncJob(JobEntity jobEntity) {\n+        processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n+        triggerExecutorIfNeeded(jobEntity);\n+    }\n+\n+    protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n+        // When the async executor is activated, the job is directly passed on to the async executor thread\n+        if (isAsyncExecutorActive()) {\n+            hintAsyncExecutor(jobEntity);\n+        }\n+    }\n+\n+    @Override\n+    public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting,\n+                                         ExecutionEntity execution, String timerEventType, String jobHandlerConfiguration) {\n+\n+        TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting,\n+                execution, timerEventType, jobHandlerConfiguration);\n+\n+        return timerEntity;\n+    }\n+\n+    @Override\n+    public void scheduleTimerJob(TimerJobEntity timerJob) {\n+        if (timerJob == null) {\n+            throw new ActivitiException(\"Empty timer job can not be scheduled\");\n         }\n-      }\n-    }\n-\n-    int maxIterations = 1;\n-    if (timerEntity.getProcessDefinitionId() != null) {\n-      org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n-      maxIterations = getMaxIterations(process, activityId);\n-      if (maxIterations <= 1) {\n-        maxIterations = getMaxIterations(process, activityId);\n-      }\n-    }\n-    timerEntity.setMaxIterations(maxIterations);\n-  }\n-   \n-  protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n-    FlowElement flowElement = process.getFlowElement(activityId, true);\n-    if (flowElement != null) {\n-      if (flowElement instanceof Event) {\n-         \n-        Event event = (Event) flowElement;\n-        List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n-         \n-        if (eventDefinitions != null) {\n-           \n-          for (EventDefinition eventDefinition : eventDefinitions) {\n-            if (eventDefinition instanceof TimerEventDefinition) {\n-              TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n-              if (timerEventDefinition.getTimeCycle() != null) {\n-                return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n-              }\n+\n+        processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n+\n+        CommandContext commandContext = Context.getCommandContext();\n+        ActivitiEventDispatcher eventDispatcher = commandContext.getEventDispatcher();\n+        if (eventDispatcher.isEnabled()) {\n+            eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED, timerJob));\n+        }\n+    }\n+\n+    @Override\n+    public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n+        if (timerJob == null) {\n+            throw new ActivitiException(\"Empty timer job can not be scheduled\");\n+        }\n+\n+        JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n+        boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n+        if (insertSuccesful) {\n+            processEngineConfiguration.getTimerJobEntityManager().delete(timerJob);\n+            triggerExecutorIfNeeded(executableJob);\n+            return executableJob;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n+        TimerJobEntity timerJob = createTimerJobFromOtherJob(job);\n+        boolean insertSuccesful = processEngineConfiguration.getTimerJobEntityManager().insertTimerJobEntity(timerJob);\n+        if (insertSuccesful) {\n+            if (job instanceof JobEntity) {\n+                processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n+            } else if (job instanceof SuspendedJobEntity) {\n+                processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n             }\n-          }\n-           \n+\n+            return timerJob;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n+        SuspendedJobEntity suspendedJob = createSuspendedJobFromOtherJob(job);\n+        processEngineConfiguration.getSuspendedJobEntityManager().insert(suspendedJob);\n+        if (job instanceof TimerJobEntity) {\n+            processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n+\n+        } else if (job instanceof JobEntity) {\n+            processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n+        }\n+\n+        return suspendedJob;\n+    }\n+\n+    @Override\n+    public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n+        AbstractJobEntity activatedJob = null;\n+        if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n+            activatedJob = createTimerJobFromOtherJob(job);\n+            processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n+\n+        } else {\n+            activatedJob = createExecutableJobFromOtherJob(job);\n+            JobEntity jobEntity = (JobEntity) activatedJob;\n+            processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n+            triggerExecutorIfNeeded(jobEntity);\n+        }\n+\n+        processEngineConfiguration.getSuspendedJobEntityManager().delete(job);\n+        return activatedJob;\n+    }\n+\n+    @Override\n+    public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n+        DeadLetterJobEntity deadLetterJob = createDeadLetterJobFromOtherJob(job);\n+        processEngineConfiguration.getDeadLetterJobEntityManager().insert(deadLetterJob);\n+        if (job instanceof TimerJobEntity) {\n+            processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n+\n+        } else if (job instanceof JobEntity) {\n+            processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n+        }\n+\n+        return deadLetterJob;\n+    }\n+\n+    @Override\n+    public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n+        if (deadLetterJobEntity == null) {\n+            throw new ActivitiIllegalArgumentException(\"Null job provided\");\n+        }\n+\n+        JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n+        executableJob.setRetries(retries);\n+        boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n+        if (insertSuccesful) {\n+            processEngineConfiguration.getDeadLetterJobEntityManager().delete(deadLetterJobEntity);\n+            triggerExecutorIfNeeded(executableJob);\n+            return executableJob;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void execute(Job job) {\n+        if (job instanceof JobEntity) {\n+            if (Job.JOB_TYPE_MESSAGE.equals(job.getJobType())) {\n+                executeMessageJob((JobEntity) job);\n+            } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n+                executeTimerJob((JobEntity) job);\n+            }\n+\n+        } else {\n+            throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n+        }\n+    }\n+\n+    @Override\n+    public void unacquire(Job job) {\n+\n+        // Deleting the old job and inserting it again with another id,\n+        // will avoid that the job is immediately is picked up again (for example\n+        // when doing lots of exclusive jobs for the same process instance)\n+        if (job instanceof JobEntity) {\n+            JobEntity jobEntity = (JobEntity) job;\n+            processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n+\n+            JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n+            copyJobInfo(newJobEntity, jobEntity);\n+            newJobEntity.setId(null); // We want a new id to be assigned to this job\n+            newJobEntity.setLockExpirationTime(null);\n+            newJobEntity.setLockOwner(null);\n+            processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n+\n+            // We're not calling triggerExecutorIfNeeded here after the inser. The unacquire happened\n+            // for a reason (eg queue full or exclusive lock failure). No need to try it immediately again,\n+            // as the chance of failure will be high.\n+\n+        } else {\n+            // It could be a v5 job, so simply unlock it.\n+            processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n+        }\n+\n+    }\n+\n+    protected void executeMessageJob(JobEntity jobEntity) {\n+        executeJobHandler(jobEntity);\n+        if (jobEntity.getId() != null) {\n+            Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n+        }\n+    }\n+\n+    protected void executeTimerJob(JobEntity timerEntity) {\n+        TimerJobEntityManager timerJobEntityManager = processEngineConfiguration.getTimerJobEntityManager();\n+\n+        VariableScope variableScope = null;\n+        if (timerEntity.getExecutionId() != null) {\n+            variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n+        }\n+\n+        if (variableScope == null) {\n+            variableScope = NoExecutionVariableScope.getSharedInstance();\n+        }\n+\n+        // set endDate if it was set to the definition\n+        restoreExtraData(timerEntity, variableScope);\n+\n+        if (timerEntity.getDuedate() != null && !isValidTime(timerEntity, timerEntity.getDuedate(), variableScope)) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Timer {} fired. but the dueDate is after the endDate.  Deleting timer.\", timerEntity.getId());\n+            }\n+            processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n+            return;\n+        }\n+\n+        executeJobHandler(timerEntity);\n+        processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Timer {} fired. Deleting timer.\", timerEntity.getId());\n         }\n-         \n-      }\n-    }\n-    return -1;\n-  }\n-   \n-  protected int calculateMaxIterationsValue(String originalExpression) {\n-    int times = Integer.MAX_VALUE;\n-    List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n-    if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n-      times = Integer.MAX_VALUE;\n-      if (expression.get(0).length() > 1) {\n-        times = Integer.parseInt(expression.get(0).substring(1));\n-      }\n-    }\n-    return times;\n-  }\n-   \n-  protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n-    BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-        getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n-    return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n-  }\n-  \n-  protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n-    String businessCalendarName = CycleBusinessCalendar.NAME;\n-    if (StringUtils.isNotEmpty(calendarName)) {\n-      businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n-          .createExpression(calendarName).getValue(variableScope);\n-    }\n-    return businessCalendarName;\n-  }\n-  \n-  protected void hintAsyncExecutor(JobEntity job) {\n-    AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n-    getCommandContext().addCloseListener(jobAddedNotification);\n-  }\n-  \n-  protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    return asyncJob;\n-  }\n-  \n-  protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    \n-    GregorianCalendar gregorianCalendar = new GregorianCalendar();\n-    gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n-    asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n-    asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    \n-    return asyncJob;\n-  }\n-  \n-  protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n-    jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n-    jobEntity.setRevision(1);\n-    jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n-    jobEntity.setExecutionId(execution.getId());\n-    jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n-    jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n-    jobEntity.setExclusive(exclusive);\n-    jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n-    \n-    // Inherit tenant id (if applicable)\n-    if (execution.getTenantId() != null) {\n-      jobEntity.setTenantId(execution.getTenantId());\n-    }\n-  }\n-  \n-  protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n-    JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n-    copyJobInfo(executableJob, job);\n-    \n-    if (isAsyncExecutorActive()) {\n-      GregorianCalendar gregorianCalendar = new GregorianCalendar();\n-      gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-      gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n-      executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n-      executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    }\n-    \n-    return executableJob;\n-  }\n-  \n-  protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n-    TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n-    copyJobInfo(timerJob, otherJob);\n-    return timerJob;\n-  }\n-  \n-  protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n-    SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n-    copyJobInfo(suspendedJob, otherJob);\n-    return suspendedJob;\n-  }\n-  \n-  protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n-    DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n-    copyJobInfo(deadLetterJob, otherJob);\n-    return deadLetterJob;\n-  }\n-  \n-  protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n-    copyToJob.setDuedate(copyFromJob.getDuedate());\n-    copyToJob.setEndDate(copyFromJob.getEndDate());\n-    copyToJob.setExclusive(copyFromJob.isExclusive());\n-    copyToJob.setExecutionId(copyFromJob.getExecutionId());\n-    copyToJob.setId(copyFromJob.getId());\n-    copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n-    copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n-    copyToJob.setJobType(copyFromJob.getJobType());\n-    copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n-    copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n-    copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n-    copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n-    copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n-    copyToJob.setRepeat(copyFromJob.getRepeat());\n-    copyToJob.setRetries(copyFromJob.getRetries());\n-    copyToJob.setRevision(copyFromJob.getRevision());\n-    copyToJob.setTenantId(copyFromJob.getTenantId());\n-    \n-    return copyToJob;\n-  }\n-  \n-  public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n-    return processEngineConfiguration;\n-  }\n-\n-  public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n-    this.processEngineConfiguration = processEngineConfiguration;\n-  }\n-\n-  protected boolean isAsyncExecutorActive() {\n-    return processEngineConfiguration.getAsyncExecutor().isActive();\n-  }\n-  \n-  protected CommandContext getCommandContext() {\n-    return Context.getCommandContext();\n-  }\n-  \n-  protected AsyncExecutor getAsyncExecutor() {\n-    return processEngineConfiguration.getAsyncExecutor();\n-  }\n-  \n-  protected ExecutionEntityManager getExecutionEntityManager() {\n-    return processEngineConfiguration.getExecutionEntityManager();\n-  }\n-  \n+\n+        if (timerEntity.getRepeat() != null) {\n+            TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n+            if (newTimerJobEntity != null) {\n+                scheduleTimerJob(newTimerJobEntity);\n+            }\n+        }\n+    }\n+\n+    protected void executeJobHandler(JobEntity jobEntity) {\n+        ExecutionEntity execution = null;\n+        if (jobEntity.getExecutionId() != null) {\n+            execution = getExecutionEntityManager().findById(jobEntity.getExecutionId());\n+        }\n+\n+        Map<String, JobHandler> jobHandlers = processEngineConfiguration.getJobHandlers();\n+        JobHandler jobHandler = jobHandlers.get(jobEntity.getJobHandlerType());\n+        jobHandler.execute(jobEntity, jobEntity.getJobHandlerConfiguration(), execution, getCommandContext());\n+    }\n+\n+    protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n+        String activityId = timerEntity.getJobHandlerConfiguration();\n+\n+        if (timerEntity.getJobHandlerType().equalsIgnoreCase(TimerStartEventJobHandler.TYPE) ||\n+                timerEntity.getJobHandlerType().equalsIgnoreCase(TriggerTimerEventJobHandler.TYPE)) {\n+\n+            activityId = TimerEventHandler.getActivityIdFromConfiguration(timerEntity.getJobHandlerConfiguration());\n+            String endDateExpressionString = TimerEventHandler.getEndDateFromConfiguration(timerEntity.getJobHandlerConfiguration());\n+\n+            if (endDateExpressionString != null) {\n+                Expression endDateExpression = processEngineConfiguration.getExpressionManager().createExpression(endDateExpressionString);\n+\n+                String endDateString = null;\n+\n+                BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n+                        getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+\n+                if (endDateExpression != null) {\n+                    Object endDateValue = endDateExpression.getValue(variableScope);\n+                    if (endDateValue instanceof String) {\n+                        endDateString = (String) endDateValue;\n+                    } else if (endDateValue instanceof Date) {\n+                        timerEntity.setEndDate((Date) endDateValue);\n+                    } else {\n+                        throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n+                                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n+                    }\n+\n+                    if (timerEntity.getEndDate() == null) {\n+                        timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n+                    }\n+                }\n+            }\n+        }\n+\n+        int maxIterations = 1;\n+        if (timerEntity.getProcessDefinitionId() != null) {\n+            org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n+            maxIterations = getMaxIterations(process, activityId);\n+            if (maxIterations <= 1) {\n+                maxIterations = getMaxIterations(process, activityId);\n+            }\n+        }\n+        timerEntity.setMaxIterations(maxIterations);\n+    }\n+\n+    protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n+        FlowElement flowElement = process.getFlowElement(activityId, true);\n+        if (flowElement != null) {\n+            if (flowElement instanceof Event) {\n+\n+                Event event = (Event) flowElement;\n+                List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n+\n+                if (eventDefinitions != null) {\n+\n+                    for (EventDefinition eventDefinition : eventDefinitions) {\n+                        if (eventDefinition instanceof TimerEventDefinition) {\n+                            TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n+                            if (timerEventDefinition.getTimeCycle() != null) {\n+                                return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n+                            }\n+                        }\n+                    }\n+\n+                }\n+\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    protected int calculateMaxIterationsValue(String originalExpression) {\n+        int times = Integer.MAX_VALUE;\n+        List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n+        if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n+            times = Integer.MAX_VALUE;\n+            if (expression.get(0).length() > 1) {\n+                times = Integer.parseInt(expression.get(0).substring(1));\n+            }\n+        }\n+        return times;\n+    }\n+\n+    protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n+        BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n+                getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+        return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n+    }\n+\n+    protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n+        String businessCalendarName = CycleBusinessCalendar.NAME;\n+        if (StringUtils.isNotEmpty(calendarName)) {\n+            businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n+                    .createExpression(calendarName).getValue(variableScope);\n+        }\n+        return businessCalendarName;\n+    }\n+\n+    protected void hintAsyncExecutor(JobEntity job) {\n+        AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n+        getCommandContext().addCloseListener(jobAddedNotification);\n+    }\n+\n+    protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+        JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+        fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+        return asyncJob;\n+    }\n+\n+    protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+        JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+        fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+\n+        GregorianCalendar gregorianCalendar = new GregorianCalendar();\n+        gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n+        gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n+        asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n+        asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n+\n+        return asyncJob;\n+    }\n+\n+    protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n+        jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n+        jobEntity.setRevision(1);\n+        jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n+        jobEntity.setExecutionId(execution.getId());\n+        jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n+        jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n+        jobEntity.setExclusive(exclusive);\n+        jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n+\n+        // Inherit tenant id (if applicable)\n+        if (execution.getTenantId() != null) {\n+            jobEntity.setTenantId(execution.getTenantId());\n+        }\n+    }\n+\n+    protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n+        JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n+        copyJobInfo(executableJob, job);\n+\n+        if (isAsyncExecutorActive()) {\n+            GregorianCalendar gregorianCalendar = new GregorianCalendar();\n+            gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n+            gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n+            executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n+            executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n+        }\n+\n+        return executableJob;\n+    }\n+\n+    protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n+        TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n+        copyJobInfo(timerJob, otherJob);\n+        return timerJob;\n+    }\n+\n+    protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n+        SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n+        copyJobInfo(suspendedJob, otherJob);\n+        return suspendedJob;\n+    }\n+\n+    protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n+        DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n+        copyJobInfo(deadLetterJob, otherJob);\n+        return deadLetterJob;\n+    }\n+\n+    protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n+        copyToJob.setDuedate(copyFromJob.getDuedate());\n+        copyToJob.setEndDate(copyFromJob.getEndDate());\n+        copyToJob.setExclusive(copyFromJob.isExclusive());\n+        copyToJob.setExecutionId(copyFromJob.getExecutionId());\n+        copyToJob.setId(copyFromJob.getId());\n+        copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n+        copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n+        copyToJob.setJobType(copyFromJob.getJobType());\n+        copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n+        copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n+        copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n+        copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n+        copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n+        copyToJob.setRepeat(copyFromJob.getRepeat());\n+        copyToJob.setRetries(copyFromJob.getRetries());\n+        copyToJob.setRevision(copyFromJob.getRevision());\n+        copyToJob.setTenantId(copyFromJob.getTenantId());\n+\n+        return copyToJob;\n+    }\n+\n+    public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n+        return processEngineConfiguration;\n+    }\n+\n+    public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+        this.processEngineConfiguration = processEngineConfiguration;\n+    }\n+\n+    protected boolean isAsyncExecutorActive() {\n+        return processEngineConfiguration.getAsyncExecutor().isActive();\n+    }\n+\n+    protected CommandContext getCommandContext() {\n+        return Context.getCommandContext();\n+    }\n+\n+    protected AsyncExecutor getAsyncExecutor() {\n+        return processEngineConfiguration.getAsyncExecutor();\n+    }\n+\n+    protected ExecutionEntityManager getExecutionEntityManager() {\n+        return processEngineConfiguration.getExecutionEntityManager();\n+    }\n+\n }\n",
            "diff_size": 741
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "48",
                    "severity": "error",
                    "message": "'CLASS_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "220",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 4, expected is 8, indentation should be the same level as line 221.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "235",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 8, 8, indentation should be the same level as line 231, 236.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "237",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 6, expected is 12, indentation should be the same level as line 238.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "310",
                    "severity": "error",
                    "message": "Line is longer than 240 characters (found 257).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "373",
                    "severity": "error",
                    "message": "Line is longer than 240 characters (found 249).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/codebuff/770/DefaultJobManager.java\nindex f786d115fb..aee405b134 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/codebuff/770/DefaultJobManager.java\n@@ -6,7 +6,6 @@ import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.List;\n import java.util.Map;\n-\n import org.activiti.bpmn.model.Event;\n import org.activiti.bpmn.model.EventDefinition;\n import org.activiti.bpmn.model.FlowElement;\n@@ -45,388 +44,370 @@ import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+\n public class DefaultJobManager implements JobManager {\n-  \n-  private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n-  \n-  protected ProcessEngineConfigurationImpl processEngineConfiguration;\n-  \n-  public DefaultJobManager() {\n-  }\n-  \n-  public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+\n+    private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n+    protected ProcessEngineConfigurationImpl processEngineConfiguration;\n+\n+    public DefaultJobManager() {\n+    }\n+\n+    public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n     this.processEngineConfiguration = processEngineConfiguration;\n-  }\n-  \n-  @Override\n-  public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+    }\n+\n+    @Override\n+    public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n     JobEntity jobEntity = null;\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n-      jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n-      \n+        jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n     } else {\n-      jobEntity = internalCreateAsyncJob(execution, exclusive);\n+        jobEntity = internalCreateAsyncJob(execution, exclusive);\n     }\n-    \n     return jobEntity;\n-  }\n+    }\n \n-  @Override\n-  public void scheduleAsyncJob(JobEntity jobEntity) {\n+    @Override\n+    public void scheduleAsyncJob(JobEntity jobEntity) {\n     processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n     triggerExecutorIfNeeded(jobEntity);\n-  }\n+    }\n \n-  protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n+    protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n-      hintAsyncExecutor(jobEntity); \n+        hintAsyncExecutor(jobEntity);\n     }\n-  }\n-  \n-  @Override\n-  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting, \n-      ExecutionEntity execution, String timerEventType, String jobHandlerConfiguration) {\n-    \n-    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting, \n-        execution, timerEventType, jobHandlerConfiguration);\n-    \n-    return timerEntity;\n-  }\n-  \n-  @Override\n-  public void scheduleTimerJob(TimerJobEntity timerJob) {\n-    if (timerJob == null) {\n-      throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n-    processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n \n-    CommandContext commandContext = Context.getCommandContext();\n-    ActivitiEventDispatcher eventDispatcher = commandContext.getEventDispatcher();\n-    if (eventDispatcher.isEnabled()) {\n-      eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED, timerJob));\n+    @Override\n+    public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition,\n+                                         boolean interrupting,\n+                                         ExecutionEntity execution,\n+                                         String timerEventType, String jobHandlerConfiguration) {\n+    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting, execution, timerEventType, jobHandlerConfiguration);\n+    return timerEntity;\n     }\n-  }\n-  \n-  @Override\n-  public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n-    if (timerJob == null) {\n-      throw new ActivitiException(\"Empty timer job can not be scheduled\");\n+\n+    @Override\n+    public void scheduleTimerJob(TimerJobEntity timerJob) {\n+        if (timerJob == null) {\n+        throw new ActivitiException(\"Empty timer job can not be scheduled\");\n+        }\n+        processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n+\n+\n+        CommandContext commandContext = Context.getCommandContext();\n+        ActivitiEventDispatcher eventDispatcher = commandContext.getEventDispatcher();\n+        if (eventDispatcher.isEnabled()) {\n+            eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED,\n+                                                                                 timerJob));\n+        }\n     }\n-    \n-    JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n-    boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n-    if (insertSuccesful) {\n-      processEngineConfiguration.getTimerJobEntityManager().delete(timerJob);\n-      triggerExecutorIfNeeded(executableJob);\n-      return executableJob;\n+\n+    @Override\n+    public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n+        if (timerJob == null) {\n+        throw new ActivitiException(\"Empty timer job can not be scheduled\");\n+        }\n+\n+        JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n+        boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n+        if (insertSuccesful) {\n+            processEngineConfiguration.getTimerJobEntityManager().delete(timerJob);\n+            triggerExecutorIfNeeded(executableJob);\n+            return executableJob;\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n-  \n-  @Override\n-  public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n+\n+    @Override\n+    public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n     TimerJobEntity timerJob = createTimerJobFromOtherJob(job);\n     boolean insertSuccesful = processEngineConfiguration.getTimerJobEntityManager().insertTimerJobEntity(timerJob);\n     if (insertSuccesful) {\n-      if (job instanceof JobEntity) {\n-        processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n-      } else if (job instanceof SuspendedJobEntity) {\n-        processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n-      }\n-      \n-      return timerJob;\n+        if (job instanceof JobEntity) {\n+                             processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n+        } else if (job instanceof SuspendedJobEntity) {\n+          processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n+        }\n+        return timerJob;\n     }\n     return null;\n-  }\n-  \n-  @Override\n-  public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n+    }\n+\n+    @Override\n+    public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n     SuspendedJobEntity suspendedJob = createSuspendedJobFromOtherJob(job);\n     processEngineConfiguration.getSuspendedJobEntityManager().insert(suspendedJob);\n     if (job instanceof TimerJobEntity) {\n-      processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+        processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n     return suspendedJob;\n-  }\n-  \n-  @Override\n-  public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n+    }\n+\n+    @Override\n+    public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n     AbstractJobEntity activatedJob = null;\n     if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n-      activatedJob = createTimerJobFromOtherJob(job);\n-      processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n-      \n+        activatedJob = createTimerJobFromOtherJob(job);\n+        processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n     } else {\n-      activatedJob = createExecutableJobFromOtherJob(job);\n-      JobEntity jobEntity = (JobEntity) activatedJob;\n-      processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n-      triggerExecutorIfNeeded(jobEntity);\n+        activatedJob = createExecutableJobFromOtherJob(job);\n+\n+\n+        JobEntity jobEntity = (JobEntity) activatedJob;\n+        processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n+        triggerExecutorIfNeeded(jobEntity);\n     }\n-    \n     processEngineConfiguration.getSuspendedJobEntityManager().delete(job);\n     return activatedJob;\n-  }\n-  \n-  @Override\n-  public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n+    }\n+\n+    @Override\n+    public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n     DeadLetterJobEntity deadLetterJob = createDeadLetterJobFromOtherJob(job);\n     processEngineConfiguration.getDeadLetterJobEntityManager().insert(deadLetterJob);\n     if (job instanceof TimerJobEntity) {\n-      processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+        processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n     return deadLetterJob;\n-  }\n-  \n-  @Override\n-  public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n-    if (deadLetterJobEntity == null) {\n-      throw new ActivitiIllegalArgumentException(\"Null job provided\");\n     }\n-    \n-    JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n-    executableJob.setRetries(retries);\n-    boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n-    if (insertSuccesful) {\n-      processEngineConfiguration.getDeadLetterJobEntityManager().delete(deadLetterJobEntity);\n-      triggerExecutorIfNeeded(executableJob);\n-      return executableJob;\n+\n+    @Override\n+    public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n+        if (deadLetterJobEntity == null) {\n+        throw new ActivitiIllegalArgumentException(\"Null job provided\");\n+        }\n+\n+        JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n+        executableJob.setRetries(retries);\n+\n+\n+        boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n+        if (insertSuccesful) {\n+            processEngineConfiguration.getDeadLetterJobEntityManager().delete(deadLetterJobEntity);\n+            triggerExecutorIfNeeded(executableJob);\n+            return executableJob;\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n-  \n-  @Override\n-  public void execute(Job job) {\n-    if (job instanceof JobEntity) {\n-      if (Job.JOB_TYPE_MESSAGE.equals(job.getJobType())) {\n-        executeMessageJob((JobEntity) job);\n-      } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n-        executeTimerJob((JobEntity) job);\n-      }\n-      \n-    } else {\n-      throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n+\n+    @Override\n+    public void execute(Job job) {\n+        if (job instanceof JobEntity) {\n+        if (Job.JOB_TYPE_MESSAGE.equals(job.getJobType())) {\n+                                          executeMessageJob((JobEntity) job);\n+        } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n+          executeTimerJob((JobEntity) job);\n+        }\n+        } else {\n+          throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n+        }\n     }\n-  }\n-  \n-  @Override\n-  public void unacquire(Job job) {\n+\n+    @Override\n+    public void unacquire(Job job) {\n     \n     // Deleting the old job and inserting it again with another id,\n     // will avoid that the job is immediately is picked up again (for example\n     // when doing lots of exclusive jobs for the same process instance)\n-    if (job instanceof JobEntity) {\n-      JobEntity jobEntity = (JobEntity) job;\n-      processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n-      \n-      JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n-      copyJobInfo(newJobEntity, jobEntity);\n-      newJobEntity.setId(null); // We want a new id to be assigned to this job\n-      newJobEntity.setLockExpirationTime(null);\n-      newJobEntity.setLockOwner(null);\n-      processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n+        if (job instanceof JobEntity) {\n+        JobEntity jobEntity = (JobEntity) job;\n+        processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n+\n+\n+        JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n+        copyJobInfo(newJobEntity, jobEntity);\n+        newJobEntity.setId(null); // We want a new id to be assigned to this job\n+        newJobEntity.setLockExpirationTime(null);\n+        newJobEntity.setLockOwner(null);\n+        processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n       \n       // We're not calling triggerExecutorIfNeeded here after the inser. The unacquire happened\n       // for a reason (eg queue full or exclusive lock failure). No need to try it immediately again,\n       // as the chance of failure will be high.\n-      \n-    } else {\n+        } else {\n       // It could be a v5 job, so simply unlock it.\n-      processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n+            processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n+        }\n     }\n-    \n-  }\n-   \n-  protected void executeMessageJob(JobEntity jobEntity) {\n+\n+    protected void executeMessageJob(JobEntity jobEntity) {\n     executeJobHandler(jobEntity);\n     if (jobEntity.getId() != null) {\n-      Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n+        Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n     }\n-  }\n-   \n-  protected void executeTimerJob(JobEntity timerEntity) {\n+    }\n+\n+    protected void executeTimerJob(JobEntity timerEntity) {\n     TimerJobEntityManager timerJobEntityManager = processEngineConfiguration.getTimerJobEntityManager();\n-    \n     VariableScope variableScope = null;\n     if (timerEntity.getExecutionId() != null) {\n-      variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n+        variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n     }\n-     \n+\n     if (variableScope == null) {\n-      variableScope = NoExecutionVariableScope.getSharedInstance();\n+        variableScope = NoExecutionVariableScope.getSharedInstance();\n     }\n \n     // set endDate if it was set to the definition\n     restoreExtraData(timerEntity, variableScope);\n-\n-    if (timerEntity.getDuedate() != null && !isValidTime(timerEntity, timerEntity.getDuedate(), variableScope)) {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Timer {} fired. but the dueDate is after the endDate.  Deleting timer.\", timerEntity.getId());\n-      }\n-      processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n-      return;\n+    if (timerEntity.getDuedate() != null && !isValidTime(timerEntity,\n+                                                         timerEntity.getDuedate(),\n+                                                         variableScope)) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Timer {} fired. but the dueDate is after the endDate.  Deleting timer.\", timerEntity.getId());\n+        }\n+        processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n+        return;\n     }\n-\n     executeJobHandler(timerEntity);\n     processEngineConfiguration.getJobEntityManager().delete(timerEntity);\n-\n     if (logger.isDebugEnabled()) {\n-      logger.debug(\"Timer {} fired. Deleting timer.\", timerEntity.getId());\n+        logger.debug(\"Timer {} fired. Deleting timer.\",\n+                     timerEntity.getId());\n     }\n-    \n+\n     if (timerEntity.getRepeat() != null) {\n-      TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n-      if (newTimerJobEntity != null) {\n-        scheduleTimerJob(newTimerJobEntity);\n-      }\n-    }\n-  }\n-  \n-  protected void executeJobHandler(JobEntity jobEntity) {\n+        TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n+        if (newTimerJobEntity != null) {\n+            scheduleTimerJob(newTimerJobEntity);\n+        }\n+    }\n+    }\n+\n+    protected void executeJobHandler(JobEntity jobEntity) {\n     ExecutionEntity execution = null;\n     if (jobEntity.getExecutionId() != null) {\n-      execution = getExecutionEntityManager().findById(jobEntity.getExecutionId());\n+        execution = getExecutionEntityManager().findById(jobEntity.getExecutionId());\n     }\n \n     Map<String, JobHandler> jobHandlers = processEngineConfiguration.getJobHandlers();\n     JobHandler jobHandler = jobHandlers.get(jobEntity.getJobHandlerType());\n-    jobHandler.execute(jobEntity, jobEntity.getJobHandlerConfiguration(), execution, getCommandContext());\n-  }\n-   \n-  protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n-    String activityId = timerEntity.getJobHandlerConfiguration();\n-\n-    if (timerEntity.getJobHandlerType().equalsIgnoreCase(TimerStartEventJobHandler.TYPE) ||\n-        timerEntity.getJobHandlerType().equalsIgnoreCase(TriggerTimerEventJobHandler.TYPE)) {\n-\n-      activityId = TimerEventHandler.getActivityIdFromConfiguration(timerEntity.getJobHandlerConfiguration());\n-      String endDateExpressionString = TimerEventHandler.getEndDateFromConfiguration(timerEntity.getJobHandlerConfiguration());\n-\n-      if (endDateExpressionString != null) {\n-        Expression endDateExpression = processEngineConfiguration.getExpressionManager().createExpression(endDateExpressionString);\n+    jobHandler.execute(jobEntity,\n+                       jobEntity.getJobHandlerConfiguration(),\n+                       execution,\n+                       getCommandContext());\n+    }\n \n-        String endDateString = null;\n+    protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n+    String activityId = timerEntity.getJobHandlerConfiguration();\n+    if (timerEntity.getJobHandlerType().equalsIgnoreCase(TimerStartEventJobHandler.TYPE) || timerEntity.getJobHandlerType().equalsIgnoreCase(TriggerTimerEventJobHandler.TYPE)) {\n+        activityId = TimerEventHandler.getActivityIdFromConfiguration(timerEntity.getJobHandlerConfiguration());\n \n-        BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-            getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n \n-        if (endDateExpression != null) {\n-          Object endDateValue = endDateExpression.getValue(variableScope);\n-          if (endDateValue instanceof String) {\n-            endDateString = (String) endDateValue;\n-          } else if (endDateValue instanceof Date) {\n-            timerEntity.setEndDate((Date) endDateValue);\n-          } else {\n-            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n-                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n-          }\n+        String endDateExpressionString = TimerEventHandler.getEndDateFromConfiguration(timerEntity.getJobHandlerConfiguration());\n+        if (endDateExpressionString != null) {\n+            Expression endDateExpression = processEngineConfiguration.getExpressionManager().createExpression(endDateExpressionString);\n+            String endDateString = null;\n+            BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+            if (endDateExpression != null) {\n+                Object endDateValue = endDateExpression.getValue(variableScope);\n+                if (endDateValue instanceof String) {\n+                                               endDateString = (String) endDateValue;\n+                } else if (endDateValue instanceof Date) {\n+                  timerEntity.setEndDate((Date) endDateValue);\n+                } else {\n+                  throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId() + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n+                }\n \n-          if (timerEntity.getEndDate() == null) {\n-            timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n-          }\n+                if (timerEntity.getEndDate() == null) {\n+                    timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n+                }\n+            }\n         }\n-      }\n     }\n \n     int maxIterations = 1;\n     if (timerEntity.getProcessDefinitionId() != null) {\n-      org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n-      maxIterations = getMaxIterations(process, activityId);\n-      if (maxIterations <= 1) {\n+        org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n         maxIterations = getMaxIterations(process, activityId);\n-      }\n+        if (maxIterations <= 1) {\n+            maxIterations = getMaxIterations(process, activityId);\n+        }\n     }\n     timerEntity.setMaxIterations(maxIterations);\n-  }\n-   \n-  protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n+    }\n+\n+    protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n     FlowElement flowElement = process.getFlowElement(activityId, true);\n     if (flowElement != null) {\n-      if (flowElement instanceof Event) {\n-         \n-        Event event = (Event) flowElement;\n-        List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n-         \n-        if (eventDefinitions != null) {\n-           \n-          for (EventDefinition eventDefinition : eventDefinitions) {\n-            if (eventDefinition instanceof TimerEventDefinition) {\n-              TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n-              if (timerEventDefinition.getTimeCycle() != null) {\n-                return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n-              }\n+        if (flowElement instanceof Event) {\n+            Event event = (Event) flowElement;\n+            List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n+            if (eventDefinitions != null) {\n+                for (EventDefinition eventDefinition : eventDefinitions) {\n+                if (eventDefinition instanceof TimerEventDefinition) {\n+                    TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n+                    if (timerEventDefinition.getTimeCycle() != null) {\n+                                                                         return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n+                    }\n+                }\n+                }\n             }\n-          }\n-           \n         }\n-         \n-      }\n     }\n     return -1;\n-  }\n-   \n-  protected int calculateMaxIterationsValue(String originalExpression) {\n+    }\n+\n+    protected int calculateMaxIterationsValue(String originalExpression) {\n     int times = Integer.MAX_VALUE;\n     List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n     if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n-      times = Integer.MAX_VALUE;\n-      if (expression.get(0).length() > 1) {\n-        times = Integer.parseInt(expression.get(0).substring(1));\n-      }\n+        times = Integer.MAX_VALUE;\n+        if (expression.get(0).length() > 1) {\n+            times = Integer.parseInt(expression.get(0).substring(1));\n+        }\n     }\n     return times;\n-  }\n-   \n-  protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n-    BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-        getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+    }\n+\n+    protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n+    BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n     return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n-  }\n-  \n-  protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n+    }\n+\n+    protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n     String businessCalendarName = CycleBusinessCalendar.NAME;\n     if (StringUtils.isNotEmpty(calendarName)) {\n-      businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n-          .createExpression(calendarName).getValue(variableScope);\n+        businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager().createExpression(calendarName).getValue(variableScope);\n     }\n     return businessCalendarName;\n-  }\n-  \n-  protected void hintAsyncExecutor(JobEntity job) {\n+    }\n+\n+    protected void hintAsyncExecutor(JobEntity job) {\n     AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n     getCommandContext().addCloseListener(jobAddedNotification);\n-  }\n-  \n-  protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+    }\n+\n+    protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n     JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n     fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n     return asyncJob;\n-  }\n-  \n-  protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+    }\n+\n+    protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n     JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n     fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    \n+\n+\n     GregorianCalendar gregorianCalendar = new GregorianCalendar();\n     gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n+    gregorianCalendar.add(Calendar.MILLISECOND,\n+                          getAsyncExecutor().getAsyncJobLockTimeInMillis());\n     asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n     asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    \n     return asyncJob;\n-  }\n-  \n-  protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n+    }\n+\n+    protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n     jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n     jobEntity.setRevision(1);\n     jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n@@ -438,44 +419,43 @@ public class DefaultJobManager implements JobManager {\n     \n     // Inherit tenant id (if applicable)\n     if (execution.getTenantId() != null) {\n-      jobEntity.setTenantId(execution.getTenantId());\n+        jobEntity.setTenantId(execution.getTenantId());\n     }\n-  }\n-  \n-  protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n+    }\n+\n+    protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n     JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n     copyJobInfo(executableJob, job);\n-    \n     if (isAsyncExecutorActive()) {\n-      GregorianCalendar gregorianCalendar = new GregorianCalendar();\n-      gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-      gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n-      executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n-      executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n+        GregorianCalendar gregorianCalendar = new GregorianCalendar();\n+        gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n+        gregorianCalendar.add(Calendar.MILLISECOND,\n+                              getAsyncExecutor().getTimerLockTimeInMillis());\n+        executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n+        executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n     }\n-    \n     return executableJob;\n-  }\n-  \n-  protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n+    }\n+\n+    protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n     TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n     copyJobInfo(timerJob, otherJob);\n     return timerJob;\n-  }\n-  \n-  protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n+    }\n+\n+    protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n     SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n     copyJobInfo(suspendedJob, otherJob);\n     return suspendedJob;\n-  }\n-  \n-  protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n+    }\n+\n+    protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n     DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n     copyJobInfo(deadLetterJob, otherJob);\n     return deadLetterJob;\n-  }\n-  \n-  protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n+    }\n+\n+    protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n     copyToJob.setDuedate(copyFromJob.getDuedate());\n     copyToJob.setEndDate(copyFromJob.getEndDate());\n     copyToJob.setExclusive(copyFromJob.isExclusive());\n@@ -493,32 +473,31 @@ public class DefaultJobManager implements JobManager {\n     copyToJob.setRetries(copyFromJob.getRetries());\n     copyToJob.setRevision(copyFromJob.getRevision());\n     copyToJob.setTenantId(copyFromJob.getTenantId());\n-    \n     return copyToJob;\n-  }\n-  \n-  public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n+    }\n+\n+    public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n     return processEngineConfiguration;\n-  }\n+    }\n \n-  public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+    public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n     this.processEngineConfiguration = processEngineConfiguration;\n-  }\n+    }\n \n-  protected boolean isAsyncExecutorActive() {\n+    protected boolean isAsyncExecutorActive() {\n     return processEngineConfiguration.getAsyncExecutor().isActive();\n-  }\n-  \n-  protected CommandContext getCommandContext() {\n+    }\n+\n+    protected CommandContext getCommandContext() {\n     return Context.getCommandContext();\n-  }\n-  \n-  protected AsyncExecutor getAsyncExecutor() {\n+    }\n+\n+    protected AsyncExecutor getAsyncExecutor() {\n     return processEngineConfiguration.getAsyncExecutor();\n-  }\n-  \n-  protected ExecutionEntityManager getExecutionEntityManager() {\n+    }\n+\n+    protected ExecutionEntityManager getExecutionEntityManager() {\n     return processEngineConfiguration.getExecutionEntityManager();\n-  }\n-  \n-}\n+    }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 354
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_random/770/DefaultJobManager.java\nindex f786d115fb..87ad9cc5b2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_random/770/DefaultJobManager.java\n@@ -46,29 +46,29 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class DefaultJobManager implements JobManager {\n-  \n+\n   private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n-  \n+\n   protected ProcessEngineConfigurationImpl processEngineConfiguration;\n-  \n+\n   public DefaultJobManager() {\n   }\n-  \n+\n   public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n     this.processEngineConfiguration = processEngineConfiguration;\n   }\n-  \n+\n   @Override\n   public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n     JobEntity jobEntity = null;\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n       jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n-      \n+\n     } else {\n       jobEntity = internalCreateAsyncJob(execution, exclusive);\n     }\n-    \n+\n     return jobEntity;\n   }\n \n@@ -81,26 +81,26 @@ public class DefaultJobManager implements JobManager {\n   protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n-      hintAsyncExecutor(jobEntity); \n+      hintAsyncExecutor(jobEntity);\n     }\n   }\n-  \n+\n   @Override\n-  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting, \n+  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting,\n       ExecutionEntity execution, String timerEventType, String jobHandlerConfiguration) {\n-    \n-    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting, \n+\n+    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting,\n         execution, timerEventType, jobHandlerConfiguration);\n-    \n+\n     return timerEntity;\n   }\n-  \n+\n   @Override\n   public void scheduleTimerJob(TimerJobEntity timerJob) {\n     if (timerJob == null) {\n       throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n+\n     processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n \n     CommandContext commandContext = Context.getCommandContext();\n@@ -109,13 +109,13 @@ public class DefaultJobManager implements JobManager {\n       eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED, timerJob));\n     }\n   }\n-  \n+\n   @Override\n   public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n     if (timerJob == null) {\n       throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n+\n     JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n     boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n     if (insertSuccesful) {\n@@ -125,7 +125,7 @@ public class DefaultJobManager implements JobManager {\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n     TimerJobEntity timerJob = createTimerJobFromOtherJob(job);\n@@ -136,64 +136,64 @@ public class DefaultJobManager implements JobManager {\n       } else if (job instanceof SuspendedJobEntity) {\n         processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n       }\n-      \n+\n       return timerJob;\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n     SuspendedJobEntity suspendedJob = createSuspendedJobFromOtherJob(job);\n     processEngineConfiguration.getSuspendedJobEntityManager().insert(suspendedJob);\n     if (job instanceof TimerJobEntity) {\n       processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n+\n     return suspendedJob;\n   }\n-  \n+\n   @Override\n   public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n     AbstractJobEntity activatedJob = null;\n     if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n       activatedJob = createTimerJobFromOtherJob(job);\n       processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n-      \n+\n     } else {\n       activatedJob = createExecutableJobFromOtherJob(job);\n       JobEntity jobEntity = (JobEntity) activatedJob;\n       processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n       triggerExecutorIfNeeded(jobEntity);\n     }\n-    \n+\n     processEngineConfiguration.getSuspendedJobEntityManager().delete(job);\n     return activatedJob;\n   }\n-  \n+\n   @Override\n   public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n     DeadLetterJobEntity deadLetterJob = createDeadLetterJobFromOtherJob(job);\n     processEngineConfiguration.getDeadLetterJobEntityManager().insert(deadLetterJob);\n     if (job instanceof TimerJobEntity) {\n       processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n+\n     return deadLetterJob;\n   }\n-  \n+\n   @Override\n   public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n     if (deadLetterJobEntity == null) {\n       throw new ActivitiIllegalArgumentException(\"Null job provided\");\n     }\n-    \n+\n     JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n     executableJob.setRetries(retries);\n     boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n@@ -204,7 +204,7 @@ public class DefaultJobManager implements JobManager {\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public void execute(Job job) {\n     if (job instanceof JobEntity) {\n@@ -213,55 +213,55 @@ public class DefaultJobManager implements JobManager {\n       } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n         executeTimerJob((JobEntity) job);\n       }\n-      \n+\n     } else {\n       throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n     }\n   }\n-  \n+\n   @Override\n   public void unacquire(Job job) {\n-    \n+\n     // Deleting the old job and inserting it again with another id,\n     // will avoid that the job is immediately is picked up again (for example\n     // when doing lots of exclusive jobs for the same process instance)\n     if (job instanceof JobEntity) {\n       JobEntity jobEntity = (JobEntity) job;\n       processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n-      \n+\n       JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n       copyJobInfo(newJobEntity, jobEntity);\n       newJobEntity.setId(null); // We want a new id to be assigned to this job\n       newJobEntity.setLockExpirationTime(null);\n       newJobEntity.setLockOwner(null);\n       processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n-      \n+\n       // We're not calling triggerExecutorIfNeeded here after the inser. The unacquire happened\n       // for a reason (eg queue full or exclusive lock failure). No need to try it immediately again,\n       // as the chance of failure will be high.\n-      \n+\n     } else {\n       // It could be a v5 job, so simply unlock it.\n       processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n     }\n-    \n+\n   }\n-   \n+\n   protected void executeMessageJob(JobEntity jobEntity) {\n     executeJobHandler(jobEntity);\n     if (jobEntity.getId() != null) {\n       Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n     }\n   }\n-   \n+\n   protected void executeTimerJob(JobEntity timerEntity) {\n     TimerJobEntityManager timerJobEntityManager = processEngineConfiguration.getTimerJobEntityManager();\n-    \n+\n     VariableScope variableScope = null;\n     if (timerEntity.getExecutionId() != null) {\n       variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n     }\n-     \n+\n     if (variableScope == null) {\n       variableScope = NoExecutionVariableScope.getSharedInstance();\n     }\n@@ -283,7 +283,7 @@ public class DefaultJobManager implements JobManager {\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"Timer {} fired. Deleting timer.\", timerEntity.getId());\n     }\n-    \n+\n     if (timerEntity.getRepeat() != null) {\n       TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n       if (newTimerJobEntity != null) {\n@@ -291,7 +291,7 @@ public class DefaultJobManager implements JobManager {\n       }\n     }\n   }\n-  \n+\n   protected void executeJobHandler(JobEntity jobEntity) {\n     ExecutionEntity execution = null;\n     if (jobEntity.getExecutionId() != null) {\n@@ -302,7 +302,7 @@ public class DefaultJobManager implements JobManager {\n     JobHandler jobHandler = jobHandlers.get(jobEntity.getJobHandlerType());\n     jobHandler.execute(jobEntity, jobEntity.getJobHandlerConfiguration(), execution, getCommandContext());\n   }\n-   \n+\n   protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n     String activityId = timerEntity.getJobHandlerConfiguration();\n \n@@ -327,198 +327,197 @@ public class DefaultJobManager implements JobManager {\n           } else if (endDateValue instanceof Date) {\n             timerEntity.setEndDate((Date) endDateValue);\n           } else {\n-            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n-                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n-          }\n-\n-          if (timerEntity.getEndDate() == null) {\n-            timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n-          }\n-        }\n+            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId() + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n       }\n-    }\n \n-    int maxIterations = 1;\n-    if (timerEntity.getProcessDefinitionId() != null) {\n-      org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n-      maxIterations = getMaxIterations(process, activityId);\n-      if (maxIterations <= 1) {\n-        maxIterations = getMaxIterations(process, activityId);\n+      if (timerEntity.getEndDate() == null) {\n+        timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n       }\n     }\n-    timerEntity.setMaxIterations(maxIterations);\n   }\n-   \n-  protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n-    FlowElement flowElement = process.getFlowElement(activityId, true);\n-    if (flowElement != null) {\n-      if (flowElement instanceof Event) {\n-         \n-        Event event = (Event) flowElement;\n-        List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n-         \n-        if (eventDefinitions != null) {\n-           \n-          for (EventDefinition eventDefinition : eventDefinitions) {\n-            if (eventDefinition instanceof TimerEventDefinition) {\n-              TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n-              if (timerEventDefinition.getTimeCycle() != null) {\n-                return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n-              }\n+}\n+\n+int maxIterations = 1;\n+if (timerEntity.getProcessDefinitionId() != null) {\n+  org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n+  maxIterations = getMaxIterations(process, activityId);\n+  if (maxIterations <= 1) {\n+    maxIterations = getMaxIterations(process, activityId);\n+  }\n+}\n+timerEntity.setMaxIterations(maxIterations);\n+}\n+\n+protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n+  FlowElement flowElement = process.getFlowElement(activityId, true);\n+  if (flowElement != null) {\n+    if (flowElement instanceof Event) {\n+\n+      Event event = (Event) flowElement;\n+      List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n+\n+      if (eventDefinitions != null) {\n+\n+        for (EventDefinition eventDefinition : eventDefinitions) {\n+          if (eventDefinition instanceof TimerEventDefinition) {\n+            TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n+            if (timerEventDefinition.getTimeCycle() != null) {\n+              return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n             }\n           }\n-           \n         }\n-         \n-      }\n-    }\n-    return -1;\n-  }\n-   \n-  protected int calculateMaxIterationsValue(String originalExpression) {\n-    int times = Integer.MAX_VALUE;\n-    List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n-    if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n-      times = Integer.MAX_VALUE;\n-      if (expression.get(0).length() > 1) {\n-        times = Integer.parseInt(expression.get(0).substring(1));\n+\n       }\n+\n     }\n-    return times;\n   }\n-   \n-  protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n-    BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-        getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n-    return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n-  }\n-  \n-  protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n-    String businessCalendarName = CycleBusinessCalendar.NAME;\n-    if (StringUtils.isNotEmpty(calendarName)) {\n-      businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n-          .createExpression(calendarName).getValue(variableScope);\n+  return -1;\n+}\n+\n+protected int calculateMaxIterationsValue(String originalExpression) {\n+  int times = Integer.MAX_VALUE;\n+  List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n+  if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n+    times = Integer.MAX_VALUE;\n+    if (expression.get(0).length() > 1) {\n+      times = Integer.parseInt(expression.get(0).substring(1));\n     }\n-    return businessCalendarName;\n   }\n-  \n-  protected void hintAsyncExecutor(JobEntity job) {\n-    AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n-    getCommandContext().addCloseListener(jobAddedNotification);\n+  return times;\n+}\n+\n+protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n+  BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n+      getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+  return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n+}\n+\n+protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n+  String businessCalendarName = CycleBusinessCalendar.NAME;\n+  if (StringUtils.isNotEmpty(calendarName)) {\n+    businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n+        .createExpression(calendarName).getValue(variableScope);\n   }\n-  \n-  protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    return asyncJob;\n+  return businessCalendarName;\n+}\n+\n+protected void hintAsyncExecutor(JobEntity job) {\n+  AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n+  getCommandContext().addCloseListener(jobAddedNotification);\n+}\n+\n+protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+  JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+  fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+  return asyncJob;\n+}\n+\n+protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+  JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+  fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+\n+  GregorianCalendar gregorianCalendar = new GregorianCalendar();\n+  gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n+  gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n+  asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n+  asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n+\n+  return asyncJob;\n+}\n+\n+protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n+  jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n+  jobEntity.setRevision(1);\n+  jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n+  jobEntity.setExecutionId(execution.getId());\n+  jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n+  jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n+  jobEntity.setExclusive(exclusive);\n+  jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n+\n+  // Inherit tenant id (if applicable)\n+  if (execution.getTenantId() != null) {\n+    jobEntity.setTenantId(execution.getTenantId());\n   }\n-  \n-  protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    \n+}\n+\n+protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n+  JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n+  copyJobInfo(executableJob, job);\n+\n+  if (isAsyncExecutorActive()) {\n     GregorianCalendar gregorianCalendar = new GregorianCalendar();\n     gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n-    asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n-    asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    \n-    return asyncJob;\n-  }\n-  \n-  protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n-    jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n-    jobEntity.setRevision(1);\n-    jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n-    jobEntity.setExecutionId(execution.getId());\n-    jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n-    jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n-    jobEntity.setExclusive(exclusive);\n-    jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n-    \n-    // Inherit tenant id (if applicable)\n-    if (execution.getTenantId() != null) {\n-      jobEntity.setTenantId(execution.getTenantId());\n-    }\n-  }\n-  \n-  protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n-    JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n-    copyJobInfo(executableJob, job);\n-    \n-    if (isAsyncExecutorActive()) {\n-      GregorianCalendar gregorianCalendar = new GregorianCalendar();\n-      gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-      gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n-      executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n-      executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    }\n-    \n-    return executableJob;\n-  }\n-  \n-  protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n-    TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n-    copyJobInfo(timerJob, otherJob);\n-    return timerJob;\n-  }\n-  \n-  protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n-    SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n-    copyJobInfo(suspendedJob, otherJob);\n-    return suspendedJob;\n-  }\n-  \n-  protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n-    DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n-    copyJobInfo(deadLetterJob, otherJob);\n-    return deadLetterJob;\n-  }\n-  \n-  protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n-    copyToJob.setDuedate(copyFromJob.getDuedate());\n-    copyToJob.setEndDate(copyFromJob.getEndDate());\n-    copyToJob.setExclusive(copyFromJob.isExclusive());\n-    copyToJob.setExecutionId(copyFromJob.getExecutionId());\n-    copyToJob.setId(copyFromJob.getId());\n-    copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n-    copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n-    copyToJob.setJobType(copyFromJob.getJobType());\n-    copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n-    copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n-    copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n-    copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n-    copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n-    copyToJob.setRepeat(copyFromJob.getRepeat());\n-    copyToJob.setRetries(copyFromJob.getRetries());\n-    copyToJob.setRevision(copyFromJob.getRevision());\n-    copyToJob.setTenantId(copyFromJob.getTenantId());\n-    \n-    return copyToJob;\n-  }\n-  \n-  public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n-    return processEngineConfiguration;\n+    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n+    executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n+    executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n   }\n \n-  public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n-    this.processEngineConfiguration = processEngineConfiguration;\n-  }\n+  return executableJob;\n+}\n+\n+protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n+  TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n+  copyJobInfo(timerJob, otherJob);\n+  return timerJob;\n+}\n+\n+protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n+  SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n+  copyJobInfo(suspendedJob, otherJob);\n+  return suspendedJob;\n+}\n+\n+protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n+  DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n+  copyJobInfo(deadLetterJob, otherJob);\n+  return deadLetterJob;\n+}\n+\n+protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n+  copyToJob.setDuedate(copyFromJob.getDuedate());\n+  copyToJob.setEndDate(copyFromJob.getEndDate());\n+  copyToJob.setExclusive(copyFromJob.isExclusive());\n+  copyToJob.setExecutionId(copyFromJob.getExecutionId());\n+  copyToJob.setId(copyFromJob.getId());\n+  copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n+  copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n+  copyToJob.setJobType(copyFromJob.getJobType());\n+  copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n+  copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n+  copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n+  copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n+  copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n+  copyToJob.setRepeat(copyFromJob.getRepeat());\n+  copyToJob.setRetries(copyFromJob.getRetries());\n+  copyToJob.setRevision(copyFromJob.getRevision());\n+  copyToJob.setTenantId(copyFromJob.getTenantId());\n+\n+  return copyToJob;\n+}\n+\n+public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n+  return processEngineConfiguration;\n+}\n+\n+public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+  this.processEngineConfiguration = processEngineConfiguration;\n+}\n+\n+protected boolean isAsyncExecutorActive() {\n+  return processEngineConfiguration.getAsyncExecutor().isActive();\n+}\n+\n+protected CommandContext getCommandContext() {\n+  return Context.getCommandContext();\n+}\n+\n+protected AsyncExecutor getAsyncExecutor() {\n+  return processEngineConfiguration.getAsyncExecutor();\n+}\n+\n+protected ExecutionEntityManager getExecutionEntityManager() {\n+  return processEngineConfiguration.getExecutionEntityManager();\n+}\n \n-  protected boolean isAsyncExecutorActive() {\n-    return processEngineConfiguration.getAsyncExecutor().isActive();\n-  }\n-  \n-  protected CommandContext getCommandContext() {\n-    return Context.getCommandContext();\n-  }\n-  \n-  protected AsyncExecutor getAsyncExecutor() {\n-    return processEngineConfiguration.getAsyncExecutor();\n-  }\n-  \n-  protected ExecutionEntityManager getExecutionEntityManager() {\n-    return processEngineConfiguration.getExecutionEntityManager();\n-  }\n-  \n }\n",
            "diff_size": 341
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_three_grams/770/DefaultJobManager.java\nindex f786d115fb..9bf7ce72d4 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/errored/1/770/DefaultJobManager.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Activiti-Activiti/styler_three_grams/770/DefaultJobManager.java\n@@ -46,29 +46,29 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class DefaultJobManager implements JobManager {\n-  \n+\n   private static Logger logger = LoggerFactory.getLogger(DefaultJobManager.class);\n-  \n+\n   protected ProcessEngineConfigurationImpl processEngineConfiguration;\n-  \n+\n   public DefaultJobManager() {\n   }\n-  \n+\n   public DefaultJobManager(ProcessEngineConfigurationImpl processEngineConfiguration) {\n     this.processEngineConfiguration = processEngineConfiguration;\n   }\n-  \n+\n   @Override\n   public JobEntity createAsyncJob(ExecutionEntity execution, boolean exclusive) {\n     JobEntity jobEntity = null;\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n       jobEntity = internalCreateLockedAsyncJob(execution, exclusive);\n-      \n+\n     } else {\n       jobEntity = internalCreateAsyncJob(execution, exclusive);\n     }\n-    \n+\n     return jobEntity;\n   }\n \n@@ -81,26 +81,26 @@ public class DefaultJobManager implements JobManager {\n   protected void triggerExecutorIfNeeded(JobEntity jobEntity) {\n     // When the async executor is activated, the job is directly passed on to the async executor thread\n     if (isAsyncExecutorActive()) {\n-      hintAsyncExecutor(jobEntity); \n+      hintAsyncExecutor(jobEntity);\n     }\n   }\n-  \n+\n   @Override\n-  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting, \n+  public TimerJobEntity createTimerJob(TimerEventDefinition timerEventDefinition, boolean interrupting,\n       ExecutionEntity execution, String timerEventType, String jobHandlerConfiguration) {\n-    \n-    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting, \n+\n+    TimerJobEntity timerEntity = TimerUtil.createTimerEntityForTimerEventDefinition(timerEventDefinition, interrupting,\n         execution, timerEventType, jobHandlerConfiguration);\n-    \n+\n     return timerEntity;\n   }\n-  \n+\n   @Override\n   public void scheduleTimerJob(TimerJobEntity timerJob) {\n     if (timerJob == null) {\n       throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n+\n     processEngineConfiguration.getTimerJobEntityManager().insert(timerJob);\n \n     CommandContext commandContext = Context.getCommandContext();\n@@ -109,13 +109,13 @@ public class DefaultJobManager implements JobManager {\n       eventDispatcher.dispatchEvent(ActivitiEventBuilder.createEntityEvent(ActivitiEventType.TIMER_SCHEDULED, timerJob));\n     }\n   }\n-  \n+\n   @Override\n   public JobEntity moveTimerJobToExecutableJob(TimerJobEntity timerJob) {\n     if (timerJob == null) {\n       throw new ActivitiException(\"Empty timer job can not be scheduled\");\n     }\n-    \n+\n     JobEntity executableJob = createExecutableJobFromOtherJob(timerJob);\n     boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n     if (insertSuccesful) {\n@@ -125,7 +125,7 @@ public class DefaultJobManager implements JobManager {\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public TimerJobEntity moveJobToTimerJob(AbstractJobEntity job) {\n     TimerJobEntity timerJob = createTimerJobFromOtherJob(job);\n@@ -136,64 +136,64 @@ public class DefaultJobManager implements JobManager {\n       } else if (job instanceof SuspendedJobEntity) {\n         processEngineConfiguration.getSuspendedJobEntityManager().delete((SuspendedJobEntity) job);\n       }\n-      \n+\n       return timerJob;\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public SuspendedJobEntity moveJobToSuspendedJob(AbstractJobEntity job) {\n     SuspendedJobEntity suspendedJob = createSuspendedJobFromOtherJob(job);\n     processEngineConfiguration.getSuspendedJobEntityManager().insert(suspendedJob);\n     if (job instanceof TimerJobEntity) {\n       processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n+\n     return suspendedJob;\n   }\n-  \n+\n   @Override\n   public AbstractJobEntity activateSuspendedJob(SuspendedJobEntity job) {\n     AbstractJobEntity activatedJob = null;\n     if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n       activatedJob = createTimerJobFromOtherJob(job);\n       processEngineConfiguration.getTimerJobEntityManager().insert((TimerJobEntity) activatedJob);\n-      \n+\n     } else {\n       activatedJob = createExecutableJobFromOtherJob(job);\n       JobEntity jobEntity = (JobEntity) activatedJob;\n       processEngineConfiguration.getJobEntityManager().insert(jobEntity);\n       triggerExecutorIfNeeded(jobEntity);\n     }\n-    \n+\n     processEngineConfiguration.getSuspendedJobEntityManager().delete(job);\n     return activatedJob;\n   }\n-  \n+\n   @Override\n   public DeadLetterJobEntity moveJobToDeadLetterJob(AbstractJobEntity job) {\n     DeadLetterJobEntity deadLetterJob = createDeadLetterJobFromOtherJob(job);\n     processEngineConfiguration.getDeadLetterJobEntityManager().insert(deadLetterJob);\n     if (job instanceof TimerJobEntity) {\n       processEngineConfiguration.getTimerJobEntityManager().delete((TimerJobEntity) job);\n-      \n+\n     } else if (job instanceof JobEntity) {\n       processEngineConfiguration.getJobEntityManager().delete((JobEntity) job);\n     }\n-    \n+\n     return deadLetterJob;\n   }\n-  \n+\n   @Override\n   public JobEntity moveDeadLetterJobToExecutableJob(DeadLetterJobEntity deadLetterJobEntity, int retries) {\n     if (deadLetterJobEntity == null) {\n       throw new ActivitiIllegalArgumentException(\"Null job provided\");\n     }\n-    \n+\n     JobEntity executableJob = createExecutableJobFromOtherJob(deadLetterJobEntity);\n     executableJob.setRetries(retries);\n     boolean insertSuccesful = processEngineConfiguration.getJobEntityManager().insertJobEntity(executableJob);\n@@ -204,7 +204,7 @@ public class DefaultJobManager implements JobManager {\n     }\n     return null;\n   }\n-  \n+\n   @Override\n   public void execute(Job job) {\n     if (job instanceof JobEntity) {\n@@ -213,55 +213,55 @@ public class DefaultJobManager implements JobManager {\n       } else if (Job.JOB_TYPE_TIMER.equals(job.getJobType())) {\n         executeTimerJob((JobEntity) job);\n       }\n-      \n+\n     } else {\n       throw new ActivitiException(\"Only jobs with type JobEntity are supported to be executed\");\n     }\n   }\n-  \n+\n   @Override\n   public void unacquire(Job job) {\n-    \n+\n     // Deleting the old job and inserting it again with another id,\n     // will avoid that the job is immediately is picked up again (for example\n     // when doing lots of exclusive jobs for the same process instance)\n     if (job instanceof JobEntity) {\n       JobEntity jobEntity = (JobEntity) job;\n       processEngineConfiguration.getJobEntityManager().delete(jobEntity.getId());\n-      \n+\n       JobEntity newJobEntity = processEngineConfiguration.getJobEntityManager().create();\n       copyJobInfo(newJobEntity, jobEntity);\n       newJobEntity.setId(null); // We want a new id to be assigned to this job\n       newJobEntity.setLockExpirationTime(null);\n       newJobEntity.setLockOwner(null);\n       processEngineConfiguration.getJobEntityManager().insert(newJobEntity);\n-      \n+\n       // We're not calling triggerExecutorIfNeeded here after the inser. The unacquire happened\n       // for a reason (eg queue full or exclusive lock failure). No need to try it immediately again,\n       // as the chance of failure will be high.\n-      \n+\n     } else {\n       // It could be a v5 job, so simply unlock it.\n       processEngineConfiguration.getJobEntityManager().resetExpiredJob(job.getId());\n     }\n-    \n+\n   }\n-   \n+\n   protected void executeMessageJob(JobEntity jobEntity) {\n     executeJobHandler(jobEntity);\n     if (jobEntity.getId() != null) {\n       Context.getCommandContext().getJobEntityManager().delete(jobEntity);\n     }\n   }\n-   \n+\n   protected void executeTimerJob(JobEntity timerEntity) {\n     TimerJobEntityManager timerJobEntityManager = processEngineConfiguration.getTimerJobEntityManager();\n-    \n+\n     VariableScope variableScope = null;\n     if (timerEntity.getExecutionId() != null) {\n       variableScope = getExecutionEntityManager().findById(timerEntity.getExecutionId());\n     }\n-     \n+\n     if (variableScope == null) {\n       variableScope = NoExecutionVariableScope.getSharedInstance();\n     }\n@@ -283,7 +283,7 @@ public class DefaultJobManager implements JobManager {\n     if (logger.isDebugEnabled()) {\n       logger.debug(\"Timer {} fired. Deleting timer.\", timerEntity.getId());\n     }\n-    \n+\n     if (timerEntity.getRepeat() != null) {\n       TimerJobEntity newTimerJobEntity = timerJobEntityManager.createAndCalculateNextTimer(timerEntity, variableScope);\n       if (newTimerJobEntity != null) {\n@@ -291,7 +291,7 @@ public class DefaultJobManager implements JobManager {\n       }\n     }\n   }\n-  \n+\n   protected void executeJobHandler(JobEntity jobEntity) {\n     ExecutionEntity execution = null;\n     if (jobEntity.getExecutionId() != null) {\n@@ -302,7 +302,7 @@ public class DefaultJobManager implements JobManager {\n     JobHandler jobHandler = jobHandlers.get(jobEntity.getJobHandlerType());\n     jobHandler.execute(jobEntity, jobEntity.getJobHandlerConfiguration(), execution, getCommandContext());\n   }\n-   \n+\n   protected void restoreExtraData(JobEntity timerEntity, VariableScope variableScope) {\n     String activityId = timerEntity.getJobHandlerConfiguration();\n \n@@ -327,198 +327,198 @@ public class DefaultJobManager implements JobManager {\n           } else if (endDateValue instanceof Date) {\n             timerEntity.setEndDate((Date) endDateValue);\n           } else {\n-            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId()\n-                + \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n-          }\n+            throw new ActivitiException(\"Timer '\" + ((ExecutionEntity) variableScope).getActivityId() +\n+                                             \"' was not configured with a valid duration/time, either hand in a java.util.Date or a String in format 'yyyy-MM-dd'T'hh:mm:ss'\");\n+       }\n \n-          if (timerEntity.getEndDate() == null) {\n-            timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n-          }\n-        }\n-      }\n-    }\n+       if (timerEntity.getEndDate() == null) {\n+         timerEntity.setEndDate(businessCalendar.resolveEndDate(endDateString));\n+       }\n+     }\n+   }\n+ }\n \n-    int maxIterations = 1;\n-    if (timerEntity.getProcessDefinitionId() != null) {\n-      org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n-      maxIterations = getMaxIterations(process, activityId);\n-      if (maxIterations <= 1) {\n-        maxIterations = getMaxIterations(process, activityId);\n-      }\n-    }\n-    timerEntity.setMaxIterations(maxIterations);\n-  }\n-   \n-  protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n-    FlowElement flowElement = process.getFlowElement(activityId, true);\n-    if (flowElement != null) {\n-      if (flowElement instanceof Event) {\n-         \n-        Event event = (Event) flowElement;\n-        List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n-         \n-        if (eventDefinitions != null) {\n-           \n-          for (EventDefinition eventDefinition : eventDefinitions) {\n-            if (eventDefinition instanceof TimerEventDefinition) {\n-              TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n-              if (timerEventDefinition.getTimeCycle() != null) {\n-                return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n-              }\n+ int maxIterations = 1;\n+ if (timerEntity.getProcessDefinitionId() != null) {\n+   org.activiti.bpmn.model.Process process = ProcessDefinitionUtil.getProcess(timerEntity.getProcessDefinitionId());\n+   maxIterations = getMaxIterations(process, activityId);\n+   if (maxIterations <= 1) {\n+     maxIterations = getMaxIterations(process, activityId);\n+   }\n+ }\n+ timerEntity.setMaxIterations(maxIterations);\n+}\n+\n+protected int getMaxIterations(org.activiti.bpmn.model.Process process, String activityId) {\n+  FlowElement flowElement = process.getFlowElement(activityId, true);\n+  if (flowElement != null) {\n+    if (flowElement instanceof Event) {\n+\n+      Event event = (Event) flowElement;\n+      List<EventDefinition> eventDefinitions = event.getEventDefinitions();\n+\n+      if (eventDefinitions != null) {\n+\n+        for (EventDefinition eventDefinition : eventDefinitions) {\n+          if (eventDefinition instanceof TimerEventDefinition) {\n+            TimerEventDefinition timerEventDefinition = (TimerEventDefinition) eventDefinition;\n+            if (timerEventDefinition.getTimeCycle() != null) {\n+              return calculateMaxIterationsValue(timerEventDefinition.getTimeCycle());\n             }\n           }\n-           \n         }\n-         \n-      }\n-    }\n-    return -1;\n-  }\n-   \n-  protected int calculateMaxIterationsValue(String originalExpression) {\n-    int times = Integer.MAX_VALUE;\n-    List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n-    if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n-      times = Integer.MAX_VALUE;\n-      if (expression.get(0).length() > 1) {\n-        times = Integer.parseInt(expression.get(0).substring(1));\n+\n       }\n+\n     }\n-    return times;\n-  }\n-   \n-  protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n-    BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n-        getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n-    return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n   }\n-  \n-  protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n-    String businessCalendarName = CycleBusinessCalendar.NAME;\n-    if (StringUtils.isNotEmpty(calendarName)) {\n-      businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n-          .createExpression(calendarName).getValue(variableScope);\n+  return -1;\n+}\n+\n+protected int calculateMaxIterationsValue(String originalExpression) {\n+  int times = Integer.MAX_VALUE;\n+  List<String> expression = Arrays.asList(originalExpression.split(\"/\"));\n+  if (expression.size() > 1 && expression.get(0).startsWith(\"R\")) {\n+    times = Integer.MAX_VALUE;\n+    if (expression.get(0).length() > 1) {\n+      times = Integer.parseInt(expression.get(0).substring(1));\n     }\n-    return businessCalendarName;\n   }\n-  \n-  protected void hintAsyncExecutor(JobEntity job) {\n-    AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n-    getCommandContext().addCloseListener(jobAddedNotification);\n+  return times;\n+}\n+\n+protected boolean isValidTime(JobEntity timerEntity, Date newTimerDate, VariableScope variableScope) {\n+  BusinessCalendar businessCalendar = processEngineConfiguration.getBusinessCalendarManager().getBusinessCalendar(\n+      getBusinessCalendarName(TimerEventHandler.geCalendarNameFromConfiguration(timerEntity.getJobHandlerConfiguration()), variableScope));\n+  return businessCalendar.validateDuedate(timerEntity.getRepeat(), timerEntity.getMaxIterations(), timerEntity.getEndDate(), newTimerDate);\n+}\n+\n+protected String getBusinessCalendarName(String calendarName, VariableScope variableScope) {\n+  String businessCalendarName = CycleBusinessCalendar.NAME;\n+  if (StringUtils.isNotEmpty(calendarName)) {\n+    businessCalendarName = (String) Context.getProcessEngineConfiguration().getExpressionManager()\n+        .createExpression(calendarName).getValue(variableScope);\n   }\n-  \n-  protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    return asyncJob;\n+  return businessCalendarName;\n+}\n+\n+protected void hintAsyncExecutor(JobEntity job) {\n+  AsyncJobAddedNotification jobAddedNotification = new AsyncJobAddedNotification(job, getAsyncExecutor());\n+  getCommandContext().addCloseListener(jobAddedNotification);\n+}\n+\n+protected JobEntity internalCreateAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+  JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+  fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+  return asyncJob;\n+}\n+\n+protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n+  JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n+  fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n+\n+  GregorianCalendar gregorianCalendar = new GregorianCalendar();\n+  gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n+  gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n+  asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n+  asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n+\n+  return asyncJob;\n+}\n+\n+protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n+  jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n+  jobEntity.setRevision(1);\n+  jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n+  jobEntity.setExecutionId(execution.getId());\n+  jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n+  jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n+  jobEntity.setExclusive(exclusive);\n+  jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n+\n+  // Inherit tenant id (if applicable)\n+  if (execution.getTenantId() != null) {\n+    jobEntity.setTenantId(execution.getTenantId());\n   }\n-  \n-  protected JobEntity internalCreateLockedAsyncJob(ExecutionEntity execution, boolean exclusive) {\n-    JobEntity asyncJob = processEngineConfiguration.getJobEntityManager().create();\n-    fillDefaultAsyncJobInfo(asyncJob, execution, exclusive);\n-    \n+}\n+\n+protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n+  JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n+  copyJobInfo(executableJob, job);\n+\n+  if (isAsyncExecutorActive()) {\n     GregorianCalendar gregorianCalendar = new GregorianCalendar();\n     gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getAsyncJobLockTimeInMillis());\n-    asyncJob.setLockExpirationTime(gregorianCalendar.getTime());\n-    asyncJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    \n-    return asyncJob;\n-  }\n-  \n-  protected void fillDefaultAsyncJobInfo(JobEntity jobEntity, ExecutionEntity execution, boolean exclusive) {\n-    jobEntity.setJobType(JobEntity.JOB_TYPE_MESSAGE);\n-    jobEntity.setRevision(1);\n-    jobEntity.setRetries(processEngineConfiguration.getAsyncExecutorNumberOfRetries());\n-    jobEntity.setExecutionId(execution.getId());\n-    jobEntity.setProcessInstanceId(execution.getProcessInstanceId());\n-    jobEntity.setProcessDefinitionId(execution.getProcessDefinitionId());\n-    jobEntity.setExclusive(exclusive);\n-    jobEntity.setJobHandlerType(AsyncContinuationJobHandler.TYPE);\n-    \n-    // Inherit tenant id (if applicable)\n-    if (execution.getTenantId() != null) {\n-      jobEntity.setTenantId(execution.getTenantId());\n-    }\n-  }\n-  \n-  protected JobEntity createExecutableJobFromOtherJob(AbstractJobEntity job) {\n-    JobEntity executableJob = processEngineConfiguration.getJobEntityManager().create();\n-    copyJobInfo(executableJob, job);\n-    \n-    if (isAsyncExecutorActive()) {\n-      GregorianCalendar gregorianCalendar = new GregorianCalendar();\n-      gregorianCalendar.setTime(processEngineConfiguration.getClock().getCurrentTime());\n-      gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n-      executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n-      executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n-    }\n-    \n-    return executableJob;\n-  }\n-  \n-  protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n-    TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n-    copyJobInfo(timerJob, otherJob);\n-    return timerJob;\n-  }\n-  \n-  protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n-    SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n-    copyJobInfo(suspendedJob, otherJob);\n-    return suspendedJob;\n-  }\n-  \n-  protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n-    DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n-    copyJobInfo(deadLetterJob, otherJob);\n-    return deadLetterJob;\n-  }\n-  \n-  protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n-    copyToJob.setDuedate(copyFromJob.getDuedate());\n-    copyToJob.setEndDate(copyFromJob.getEndDate());\n-    copyToJob.setExclusive(copyFromJob.isExclusive());\n-    copyToJob.setExecutionId(copyFromJob.getExecutionId());\n-    copyToJob.setId(copyFromJob.getId());\n-    copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n-    copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n-    copyToJob.setJobType(copyFromJob.getJobType());\n-    copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n-    copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n-    copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n-    copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n-    copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n-    copyToJob.setRepeat(copyFromJob.getRepeat());\n-    copyToJob.setRetries(copyFromJob.getRetries());\n-    copyToJob.setRevision(copyFromJob.getRevision());\n-    copyToJob.setTenantId(copyFromJob.getTenantId());\n-    \n-    return copyToJob;\n-  }\n-  \n-  public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n-    return processEngineConfiguration;\n+    gregorianCalendar.add(Calendar.MILLISECOND, getAsyncExecutor().getTimerLockTimeInMillis());\n+    executableJob.setLockExpirationTime(gregorianCalendar.getTime());\n+    executableJob.setLockOwner(getAsyncExecutor().getLockOwner());\n   }\n \n-  public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n-    this.processEngineConfiguration = processEngineConfiguration;\n-  }\n+  return executableJob;\n+}\n+\n+protected TimerJobEntity createTimerJobFromOtherJob(AbstractJobEntity otherJob) {\n+  TimerJobEntity timerJob = processEngineConfiguration.getTimerJobEntityManager().create();\n+  copyJobInfo(timerJob, otherJob);\n+  return timerJob;\n+}\n+\n+protected SuspendedJobEntity createSuspendedJobFromOtherJob(AbstractJobEntity otherJob) {\n+  SuspendedJobEntity suspendedJob = processEngineConfiguration.getSuspendedJobEntityManager().create();\n+  copyJobInfo(suspendedJob, otherJob);\n+  return suspendedJob;\n+}\n+\n+protected DeadLetterJobEntity createDeadLetterJobFromOtherJob(AbstractJobEntity otherJob) {\n+  DeadLetterJobEntity deadLetterJob = processEngineConfiguration.getDeadLetterJobEntityManager().create();\n+  copyJobInfo(deadLetterJob, otherJob);\n+  return deadLetterJob;\n+}\n+\n+protected AbstractJobEntity copyJobInfo(AbstractJobEntity copyToJob, AbstractJobEntity copyFromJob) {\n+  copyToJob.setDuedate(copyFromJob.getDuedate());\n+  copyToJob.setEndDate(copyFromJob.getEndDate());\n+  copyToJob.setExclusive(copyFromJob.isExclusive());\n+  copyToJob.setExecutionId(copyFromJob.getExecutionId());\n+  copyToJob.setId(copyFromJob.getId());\n+  copyToJob.setJobHandlerConfiguration(copyFromJob.getJobHandlerConfiguration());\n+  copyToJob.setJobHandlerType(copyFromJob.getJobHandlerType());\n+  copyToJob.setJobType(copyFromJob.getJobType());\n+  copyToJob.setExceptionMessage(copyFromJob.getExceptionMessage());\n+  copyToJob.setExceptionStacktrace(copyFromJob.getExceptionStacktrace());\n+  copyToJob.setMaxIterations(copyFromJob.getMaxIterations());\n+  copyToJob.setProcessDefinitionId(copyFromJob.getProcessDefinitionId());\n+  copyToJob.setProcessInstanceId(copyFromJob.getProcessInstanceId());\n+  copyToJob.setRepeat(copyFromJob.getRepeat());\n+  copyToJob.setRetries(copyFromJob.getRetries());\n+  copyToJob.setRevision(copyFromJob.getRevision());\n+  copyToJob.setTenantId(copyFromJob.getTenantId());\n+\n+  return copyToJob;\n+}\n+\n+public ProcessEngineConfigurationImpl getProcessEngineConfiguration() {\n+  return processEngineConfiguration;\n+}\n+\n+public void setProcessEngineConfiguration(ProcessEngineConfigurationImpl processEngineConfiguration) {\n+  this.processEngineConfiguration = processEngineConfiguration;\n+}\n+\n+protected boolean isAsyncExecutorActive() {\n+  return processEngineConfiguration.getAsyncExecutor().isActive();\n+}\n+\n+protected CommandContext getCommandContext() {\n+  return Context.getCommandContext();\n+}\n+\n+protected AsyncExecutor getAsyncExecutor() {\n+  return processEngineConfiguration.getAsyncExecutor();\n+}\n+\n+protected ExecutionEntityManager getExecutionEntityManager() {\n+  return processEngineConfiguration.getExecutionEntityManager();\n+}\n \n-  protected boolean isAsyncExecutorActive() {\n-    return processEngineConfiguration.getAsyncExecutor().isActive();\n-  }\n-  \n-  protected CommandContext getCommandContext() {\n-    return Context.getCommandContext();\n-  }\n-  \n-  protected AsyncExecutor getAsyncExecutor() {\n-    return processEngineConfiguration.getAsyncExecutor();\n-  }\n-  \n-  protected ExecutionEntityManager getExecutionEntityManager() {\n-    return processEngineConfiguration.getExecutionEntityManager();\n-  }\n-  \n }\n",
            "diff_size": 337
        }
    ]
}