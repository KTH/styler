{
    "error_id": "854",
    "information": {
        "errors": [
            {
                "line": "6",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 102).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/Apache-2.0",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "72",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/854/GBDTParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/854/GBDTParam.java\nindex 41552620c8..5245eb0bb7 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/854/GBDTParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/854/GBDTParam.java\n@@ -23,218 +23,221 @@ import com.tencent.angel.spark.ml.tree.util.Maths;\n \n public class GBDTParam extends RegTParam {\n \n-  public int numClass; // number of classes/labels\n-  public int numTree;  // number of trees\n-  public int numThread;  // parallelism\n-\n-  public boolean histSubtraction;\n-  public boolean lighterChildFirst;\n-  //public boolean leafwise;  // true if leaf-wise training, false if level-wise training\n-\n-  public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n-  public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n-  public int minNodeInstance;\n-  public float regAlpha;  // L1 regularization factor\n-  public float regLambda;  // L2 regularization factor\n-  public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n-\n-  public String lossFunc; // name of loss function\n-  public String[] evalMetrics; // name of eval metric\n-  public String multiStrategy; // strategy of multi-class classification (one-tree or multi-tree)\n-\n-  public int numClassPerTree() {\n-    if (numClass > 2 && multiStrategy.equalsIgnoreCase(MultiStrategy.ONE_TREE.toString())) {\n-      return numClass;\n-    } else {\n-      return 2;\n-    }\n-  }\n-\n-  public boolean isMultiClassMultiTree() {\n-    return numClass > 2 && multiStrategy.equalsIgnoreCase(MultiStrategy.MULTI_TREE.toString());\n-  }\n-\n-  /**\n-   * Whether the sum of hessian satisfies weight\n-   *\n-   * @param sumHess sum of hessian values\n-   * @return true if satisfied, false otherwise\n-   */\n-  public boolean satisfyWeight(double sumHess) {\n-    return sumHess >= minChildWeight;\n-  }\n-\n-  public boolean satisfyWeight(double sumGrad, double sumHess) {\n-    return sumGrad != 0.0f && satisfyWeight(sumHess);\n-  }\n-\n-  /**\n-   * Whether the sum of hessian satisfies weight Since hessian matrix is positive, we have det(hess)\n-   * <= a11*a22*...*akk, thus we approximate det(hess) with a11*a22*...*akk\n-   *\n-   * @param sumHess sum of hessian values\n-   * @return true if satisfied, false otherwise\n-   */\n-  public boolean satisfyWeight(double[] sumHess) {\n-    if (minChildWeight == 0.0f) {\n-      return true;\n+    public int numClass; // number of classes/labels\n+    public int numTree;  // number of trees\n+    public int numThread;  // parallelism\n+\n+    public boolean histSubtraction;\n+    public boolean lighterChildFirst;\n+    //public boolean leafwise;  // true if leaf-wise training, false if level-wise training\n+\n+    public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n+    public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n+    public int minNodeInstance;\n+    public float regAlpha;  // L1 regularization factor\n+    public float regLambda;  // L2 regularization factor\n+    public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n+\n+    public String lossFunc; // name of loss function\n+    public String[] evalMetrics; // name of eval metric\n+    public String multiStrategy; // strategy of multi-class classification (one-tree or multi-tree)\n+\n+    public int numClassPerTree() {\n+        if (numClass > 2 && multiStrategy.equalsIgnoreCase(MultiStrategy.ONE_TREE.toString())) {\n+            return numClass;\n+        } else {\n+            return 2;\n+        }\n     }\n-    double w = 1.0;\n-    if (!fullHessian) {\n-      for (double h : sumHess) {\n-        w *= h;\n-      }\n-    } else {\n-      for (int k = 0; k < numClass; k++) {\n-        int index = Maths.indexOfLowerTriangularMatrix(k, k);\n-        w *= sumHess[index];\n-      }\n+\n+    public boolean isMultiClassMultiTree() {\n+        return numClass > 2 && multiStrategy.equalsIgnoreCase(MultiStrategy.MULTI_TREE.toString());\n     }\n-    return w >= minChildWeight;\n-  }\n-\n-  public boolean satisfyWeight(double[] sumGrad, double[] sumHess) {\n-    return !Maths.areZeros(sumGrad) && satisfyWeight(sumHess);\n-  }\n-\n-  /**\n-   * Calculate leaf weight given the statistics\n-   *\n-   * @param sumGrad sum of gradient values\n-   * @param sumHess sum of hessian values\n-   * @return weight\n-   */\n-  public double calcWeight(double sumGrad, double sumHess) {\n-    if (!satisfyWeight(sumHess) || sumGrad == 0.0) {\n-      return 0.0;\n+\n+    /**\n+     * Whether the sum of hessian satisfies weight\n+     *\n+     * @param sumHess sum of hessian values\n+     * @return true if satisfied, false otherwise\n+     */\n+    public boolean satisfyWeight(double sumHess) {\n+        return sumHess >= minChildWeight;\n     }\n-    double dw;\n-    if (regAlpha == 0.0f) {\n-      dw = -sumGrad / (sumHess + regLambda);\n-    } else {\n-      dw = -Maths.thresholdL1(sumGrad, regAlpha) / (sumHess + regLambda);\n+\n+    public boolean satisfyWeight(double sumGrad, double sumHess) {\n+        return sumGrad != 0.0f && satisfyWeight(sumHess);\n     }\n-    if (maxLeafWeight != 0.0f) {\n-      if (dw > maxLeafWeight) {\n-        dw = maxLeafWeight;\n-      } else if (dw < -maxLeafWeight) {\n-        dw = -maxLeafWeight;\n-      }\n+\n+    /**\n+     * Whether the sum of hessian satisfies weight Since hessian matrix is positive, we have det(hess)\n+     * <= a11*a22*...*akk, thus we approximate det(hess) with a11*a22*...*akk\n+     *\n+     * @param sumHess sum of hessian values\n+     * @return true if satisfied, false otherwise\n+     */\n+    public boolean satisfyWeight(double[] sumHess) {\n+        if (minChildWeight == 0.0f) {\n+            return true;\n+        }\n+        double w = 1.0;\n+        if (!fullHessian) {\n+            for (double h : sumHess) {\n+                w *= h;\n+            }\n+        } else {\n+            for (int k = 0; k < numClass; k++) {\n+                int index = Maths.indexOfLowerTriangularMatrix(k, k);\n+                w *= sumHess[index];\n+            }\n+        }\n+        return w >= minChildWeight;\n     }\n-    return dw;\n-  }\n \n-  public double[] calcWeights(double[] sumGrad, double[] sumHess) {\n-    double[] weights = new double[numClass];\n-    if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n-      return weights;\n+    public boolean satisfyWeight(double[] sumGrad, double[] sumHess) {\n+        return !Maths.areZeros(sumGrad) && satisfyWeight(sumHess);\n     }\n-    // TODO: regularization\n-    if (!fullHessian) {\n-      if (regAlpha == 0.0f) {\n-        for (int k = 0; k < numClass; k++) {\n-          weights[k] = -sumGrad[k] / (sumHess[k] + regLambda);\n+\n+    /**\n+     * Calculate leaf weight given the statistics\n+     *\n+     * @param sumGrad sum of gradient values\n+     * @param sumHess sum of hessian values\n+     * @return weight\n+     */\n+    public double calcWeight(double sumGrad, double sumHess) {\n+        if (!satisfyWeight(sumHess) || sumGrad == 0.0) {\n+            return 0.0;\n         }\n-      } else {\n-        for (int k = 0; k < numClass; k++) {\n-          weights[k] = -Maths.thresholdL1(sumGrad[k], regAlpha) / (sumHess[k] + regLambda);\n+        double dw;\n+        if (regAlpha == 0.0f) {\n+            dw = -sumGrad / (sumHess + regLambda);\n+        } else {\n+            dw = -Maths.thresholdL1(sumGrad, regAlpha) / (sumHess + regLambda);\n         }\n-      }\n-    } else {\n-      addDiagonal(numClass, sumHess, regLambda);\n-      weights = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n-      for (int i = 0; i < numClass; i++) {\n-        weights[i] *= -1;\n-      }\n-      addDiagonal(numClass, sumHess, -regLambda);\n-    }\n-    if (maxLeafWeight != 0.0f) {\n-      for (int k = 0; k < numClass; k++) {\n-        if (weights[k] > maxLeafWeight) {\n-          weights[k] = maxLeafWeight;\n-        } else if (weights[k] < -maxLeafWeight) {\n-          weights[k] = -maxLeafWeight;\n+        if (maxLeafWeight != 0.0f) {\n+            if (dw > maxLeafWeight) {\n+                dw = maxLeafWeight;\n+            } else if (dw < -maxLeafWeight) {\n+                dw = -maxLeafWeight;\n+            }\n         }\n-      }\n-    }\n-    return weights;\n-  }\n-\n-  /**\n-   * Calculate the cost of loss function\n-   *\n-   * @param sumGrad sum of gradient values\n-   * @param sumHess sum of hessian values\n-   * @return loss gain\n-   */\n-  public double calcGain(double sumGrad, double sumHess) {\n-    if (!satisfyWeight(sumHess) || sumGrad == 0.0f) {\n-      return 0.0f;\n+        return dw;\n     }\n-    if (maxLeafWeight == 0.0f) {\n-      if (regAlpha == 0.0f) {\n-        return (sumGrad / (sumHess + regLambda)) * sumGrad;\n-      } else {\n-        return Maths.sqr(Maths.thresholdL1(sumGrad, regAlpha)) / (sumHess + regLambda);\n-      }\n-    } else {\n-      double w = calcWeight(sumGrad, sumHess);\n-      double ret = sumGrad * w + 0.5 * (sumHess + regLambda) * Maths.sqr(w);\n-      if (regAlpha == 0.0f) {\n-        return -2.0 * ret;\n-      } else {\n-        return -2.0 * (ret + regAlpha * Math.abs(w));\n-      }\n+\n+    public double[] calcWeights(double[] sumGrad, double[] sumHess) {\n+        double[] weights = new double[numClass];\n+        if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n+            return weights;\n+        }\n+        // TODO: regularization\n+        if (!fullHessian) {\n+            if (regAlpha == 0.0f) {\n+                for (int k = 0; k < numClass; k++) {\n+                    weights[k] = -sumGrad[k] / (sumHess[k] + regLambda);\n+                }\n+            } else {\n+                for (int k = 0; k < numClass; k++) {\n+                    weights[k] =\n+                            -Maths.thresholdL1(sumGrad[k], regAlpha) / (sumHess[k] + regLambda);\n+                }\n+            }\n+        } else {\n+            addDiagonal(numClass, sumHess, regLambda);\n+            weights = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n+            for (int i = 0; i < numClass; i++) {\n+                weights[i] *= -1;\n+            }\n+            addDiagonal(numClass, sumHess, -regLambda);\n+        }\n+        if (maxLeafWeight != 0.0f) {\n+            for (int k = 0; k < numClass; k++) {\n+                if (weights[k] > maxLeafWeight) {\n+                    weights[k] = maxLeafWeight;\n+                } else if (weights[k] < -maxLeafWeight) {\n+                    weights[k] = -maxLeafWeight;\n+                }\n+            }\n+        }\n+        return weights;\n     }\n-  }\n \n-  public double calcGain(double[] sumGrad, double[] sumHess) {\n-    double gain = 0.0;\n-    if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n-      return 0.0;\n+    /**\n+     * Calculate the cost of loss function\n+     *\n+     * @param sumGrad sum of gradient values\n+     * @param sumHess sum of hessian values\n+     * @return loss gain\n+     */\n+    public double calcGain(double sumGrad, double sumHess) {\n+        if (!satisfyWeight(sumHess) || sumGrad == 0.0f) {\n+            return 0.0f;\n+        }\n+        if (maxLeafWeight == 0.0f) {\n+            if (regAlpha == 0.0f) {\n+                return (sumGrad / (sumHess + regLambda)) * sumGrad;\n+            } else {\n+                return Maths.sqr(Maths.thresholdL1(sumGrad, regAlpha)) / (sumHess + regLambda);\n+            }\n+        } else {\n+            double w = calcWeight(sumGrad, sumHess);\n+            double ret = sumGrad * w + 0.5 * (sumHess + regLambda) * Maths.sqr(w);\n+            if (regAlpha == 0.0f) {\n+                return -2.0 * ret;\n+            } else {\n+                return -2.0 * (ret + regAlpha * Math.abs(w));\n+            }\n+        }\n     }\n-    // TODO: regularization\n-    if (!fullHessian) {\n-      if (regAlpha == 0.0f) {\n-        for (int k = 0; k < numClass; k++) {\n-          gain += sumGrad[k] / (sumHess[k] + regLambda) * sumGrad[k];\n+\n+    public double calcGain(double[] sumGrad, double[] sumHess) {\n+        double gain = 0.0;\n+        if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n+            return 0.0;\n+        }\n+        // TODO: regularization\n+        if (!fullHessian) {\n+            if (regAlpha == 0.0f) {\n+                for (int k = 0; k < numClass; k++) {\n+                    gain += sumGrad[k] / (sumHess[k] + regLambda) * sumGrad[k];\n+                }\n+            } else {\n+                for (int k = 0; k < numClass; k++) {\n+                    gain += Maths.sqr(Maths.thresholdL1(sumGrad[k], regAlpha)) *\n+                            (sumHess[k] + regLambda);\n+                }\n+            }\n+        } else {\n+            addDiagonal(numClass, sumHess, regLambda);\n+            double[] tmp =\n+                    Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n+            gain = Maths.dot(sumGrad, tmp);\n+            addDiagonal(numClass, sumHess, -regLambda);\n         }\n-      } else {\n-        for (int k = 0; k < numClass; k++) {\n-          gain += Maths.sqr(Maths.thresholdL1(sumGrad[k], regAlpha)) * (sumHess[k] + regLambda);\n+        return (float) (gain / numClass);\n+    }\n+\n+    private void addDiagonal(int n, double[] sumHess, double v) {\n+        for (int i = 0; i < n; i++) {\n+            int index = Maths.indexOfLowerTriangularMatrix(i, i);\n+            sumHess[index] += v;\n         }\n-      }\n-    } else {\n-      addDiagonal(numClass, sumHess, regLambda);\n-      double[] tmp = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n-      gain = Maths.dot(sumGrad, tmp);\n-      addDiagonal(numClass, sumHess, -regLambda);\n     }\n-    return (float) (gain / numClass);\n-  }\n \n-  private void addDiagonal(int n, double[] sumHess, double v) {\n-    for (int i = 0; i < n; i++) {\n-      int index = Maths.indexOfLowerTriangularMatrix(i, i);\n-      sumHess[index] += v;\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(super.toString());\n+        sb.append(String.format(\"|numClass = %d\\n\", numClass));\n+        sb.append(String.format(\"|numTree = %d\\n\", numTree));\n+        sb.append(String.format(\"|numThread = %d\\n\", numThread));\n+        sb.append(String.format(\"|fullHessian = %s\\n\", fullHessian));\n+        sb.append(String.format(\"|minChildWeight = %f\\n\", minChildWeight));\n+        sb.append(String.format(\"|minNodeInstance = %d\\n\", minNodeInstance));\n+        sb.append(String.format(\"|regAlpha = %s\\n\", regAlpha));\n+        sb.append(String.format(\"|regLambda = %s\\n\", regLambda));\n+        sb.append(String.format(\"|maxLeafWeight = %s\\n\", maxLeafWeight));\n+        sb.append(String.format(\"|lossFunc = %s\\n\", lossFunc));\n+        sb.append(String.format(\"|evalMetrics = %s\\n\", Arrays.toString(evalMetrics)));\n+        return sb.toString();\n     }\n-  }\n-\n-  @Override\n-  public String toString() {\n-    StringBuilder sb = new StringBuilder(super.toString());\n-    sb.append(String.format(\"|numClass = %d\\n\", numClass));\n-    sb.append(String.format(\"|numTree = %d\\n\", numTree));\n-    sb.append(String.format(\"|numThread = %d\\n\", numThread));\n-    sb.append(String.format(\"|fullHessian = %s\\n\", fullHessian));\n-    sb.append(String.format(\"|minChildWeight = %f\\n\", minChildWeight));\n-    sb.append(String.format(\"|minNodeInstance = %d\\n\", minNodeInstance));\n-    sb.append(String.format(\"|regAlpha = %s\\n\", regAlpha));\n-    sb.append(String.format(\"|regLambda = %s\\n\", regLambda));\n-    sb.append(String.format(\"|maxLeafWeight = %s\\n\", maxLeafWeight));\n-    sb.append(String.format(\"|lossFunc = %s\\n\", lossFunc));\n-    sb.append(String.format(\"|evalMetrics = %s\\n\", Arrays.toString(evalMetrics)));\n-    return sb.toString();\n-  }\n }\n \n",
            "diff_size": 298
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "35",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 37.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "67",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 74.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "82",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 90.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "113",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 121.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "181",
                    "severity": "error",
                    "message": "Block comment has incorrect indentation level 2, expected is 4, indentation should be the same level as line 189.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "225",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/854/GBDTParam.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/854/GBDTParam.java\nindex 41552620c8..aac8285c59 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/854/GBDTParam.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/854/GBDTParam.java\n@@ -23,36 +23,46 @@ import com.tencent.angel.spark.ml.tree.util.Maths;\n \n public class GBDTParam extends RegTParam {\n \n-  public int numClass; // number of classes/labels\n-  public int numTree;  // number of trees\n-  public int numThread;  // parallelism\n+    public int numClass; // number of classes/labels\n \n-  public boolean histSubtraction;\n-  public boolean lighterChildFirst;\n+    public int numTree;  // number of trees\n+\n+    public int numThread;  // parallelism\n+\n+    public boolean histSubtraction;\n+\n+    public boolean lighterChildFirst;\n   //public boolean leafwise;  // true if leaf-wise training, false if level-wise training\n \n-  public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n-  public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n-  public int minNodeInstance;\n-  public float regAlpha;  // L1 regularization factor\n-  public float regLambda;  // L2 regularization factor\n-  public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n+    public boolean fullHessian;  // whether to use full hessian matrix instead of diagonal\n+\n+    public float minChildWeight;  // minimum amount of hessian (weight) allowed for a child\n+\n+    public int minNodeInstance;\n+\n+    public float regAlpha;  // L1 regularization factor\n+\n+    public float regLambda;  // L2 regularization factor\n \n-  public String lossFunc; // name of loss function\n-  public String[] evalMetrics; // name of eval metric\n-  public String multiStrategy; // strategy of multi-class classification (one-tree or multi-tree)\n+    public float maxLeafWeight; // maximum leaf weight, default 0 means no constraints\n \n-  public int numClassPerTree() {\n+    public String lossFunc; // name of loss function\n+\n+    public String[] evalMetrics; // name of eval metric\n+\n+    public String multiStrategy; // strategy of multi-class classification (one-tree or multi-tree)\n+\n+    public int numClassPerTree() {\n     if (numClass > 2 && multiStrategy.equalsIgnoreCase(MultiStrategy.ONE_TREE.toString())) {\n-      return numClass;\n+        return numClass;\n     } else {\n       return 2;\n     }\n-  }\n+    }\n \n-  public boolean isMultiClassMultiTree() {\n+    public boolean isMultiClassMultiTree() {\n     return numClass > 2 && multiStrategy.equalsIgnoreCase(MultiStrategy.MULTI_TREE.toString());\n-  }\n+    }\n \n   /**\n    * Whether the sum of hessian satisfies weight\n@@ -60,13 +70,14 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return true if satisfied, false otherwise\n    */\n-  public boolean satisfyWeight(double sumHess) {\n+\n+    public boolean satisfyWeight(double sumHess) {\n     return sumHess >= minChildWeight;\n-  }\n+    }\n \n-  public boolean satisfyWeight(double sumGrad, double sumHess) {\n+    public boolean satisfyWeight(double sumGrad, double sumHess) {\n     return sumGrad != 0.0f && satisfyWeight(sumHess);\n-  }\n+    }\n \n   /**\n    * Whether the sum of hessian satisfies weight Since hessian matrix is positive, we have det(hess)\n@@ -75,27 +86,29 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return true if satisfied, false otherwise\n    */\n-  public boolean satisfyWeight(double[] sumHess) {\n+\n+    public boolean satisfyWeight(double[] sumHess) {\n     if (minChildWeight == 0.0f) {\n-      return true;\n+        return true;\n     }\n+\n     double w = 1.0;\n     if (!fullHessian) {\n-      for (double h : sumHess) {\n-        w *= h;\n-      }\n+        for (double h : sumHess) {\n+                          w *= h;\n+        }\n     } else {\n       for (int k = 0; k < numClass; k++) {\n-        int index = Maths.indexOfLowerTriangularMatrix(k, k);\n-        w *= sumHess[index];\n+               int index = Maths.indexOfLowerTriangularMatrix(k, k);\n+               w *= sumHess[index];\n       }\n     }\n     return w >= minChildWeight;\n-  }\n+    }\n \n-  public boolean satisfyWeight(double[] sumGrad, double[] sumHess) {\n+    public boolean satisfyWeight(double[] sumGrad, double[] sumHess) {\n     return !Maths.areZeros(sumGrad) && satisfyWeight(sumHess);\n-  }\n+    }\n \n   /**\n    * Calculate leaf weight given the statistics\n@@ -104,61 +117,66 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return weight\n    */\n-  public double calcWeight(double sumGrad, double sumHess) {\n+\n+    public double calcWeight(double sumGrad, double sumHess) {\n     if (!satisfyWeight(sumHess) || sumGrad == 0.0) {\n-      return 0.0;\n+        return 0.0;\n     }\n+\n     double dw;\n     if (regAlpha == 0.0f) {\n-      dw = -sumGrad / (sumHess + regLambda);\n+        dw = -sumGrad / (sumHess + regLambda);\n     } else {\n       dw = -Maths.thresholdL1(sumGrad, regAlpha) / (sumHess + regLambda);\n     }\n+\n     if (maxLeafWeight != 0.0f) {\n-      if (dw > maxLeafWeight) {\n+        if (dw > maxLeafWeight) {\n         dw = maxLeafWeight;\n-      } else if (dw < -maxLeafWeight) {\n-        dw = -maxLeafWeight;\n-      }\n+        } else if (dw < -maxLeafWeight) {\n+                                   dw = -maxLeafWeight;\n+               }\n     }\n     return dw;\n-  }\n+    }\n \n-  public double[] calcWeights(double[] sumGrad, double[] sumHess) {\n+    public double[] calcWeights(double[] sumGrad, double[] sumHess) {\n     double[] weights = new double[numClass];\n     if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n-      return weights;\n+        return weights;\n     }\n     // TODO: regularization\n+\n     if (!fullHessian) {\n-      if (regAlpha == 0.0f) {\n-        for (int k = 0; k < numClass; k++) {\n-          weights[k] = -sumGrad[k] / (sumHess[k] + regLambda);\n-        }\n-      } else {\n-        for (int k = 0; k < numClass; k++) {\n-          weights[k] = -Maths.thresholdL1(sumGrad[k], regAlpha) / (sumHess[k] + regLambda);\n+        if (regAlpha == 0.0f) {\n+                          for (int k = 0; k < numClass; k++) {\n+                                  weights[k] = -sumGrad[k] / (sumHess[k] + regLambda);\n+                          }\n+        } else {\n+          for (int k = 0; k < numClass; k++) {\n+                   weights[k] = -Maths.thresholdL1(sumGrad[k], regAlpha) / (sumHess[k] + regLambda);\n+          }\n         }\n-      }\n     } else {\n       addDiagonal(numClass, sumHess, regLambda);\n       weights = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n       for (int i = 0; i < numClass; i++) {\n-        weights[i] *= -1;\n+               weights[i] *= -1;\n       }\n       addDiagonal(numClass, sumHess, -regLambda);\n     }\n+\n     if (maxLeafWeight != 0.0f) {\n-      for (int k = 0; k < numClass; k++) {\n-        if (weights[k] > maxLeafWeight) {\n-          weights[k] = maxLeafWeight;\n-        } else if (weights[k] < -maxLeafWeight) {\n-          weights[k] = -maxLeafWeight;\n+        for (int k = 0; k < numClass; k++) {\n+                                   if (weights[k] > maxLeafWeight) {\n+            weights[k] = maxLeafWeight;\n+                                   } else if (weights[k] < -maxLeafWeight) {\n+                                               weights[k] = -maxLeafWeight;\n+                                          }\n         }\n-      }\n     }\n     return weights;\n-  }\n+    }\n \n   /**\n    * Calculate the cost of loss function\n@@ -167,43 +185,46 @@ public class GBDTParam extends RegTParam {\n    * @param sumHess sum of hessian values\n    * @return loss gain\n    */\n-  public double calcGain(double sumGrad, double sumHess) {\n+\n+    public double calcGain(double sumGrad, double sumHess) {\n     if (!satisfyWeight(sumHess) || sumGrad == 0.0f) {\n-      return 0.0f;\n+        return 0.0f;\n     }\n+\n     if (maxLeafWeight == 0.0f) {\n-      if (regAlpha == 0.0f) {\n-        return (sumGrad / (sumHess + regLambda)) * sumGrad;\n-      } else {\n-        return Maths.sqr(Maths.thresholdL1(sumGrad, regAlpha)) / (sumHess + regLambda);\n-      }\n+        if (regAlpha == 0.0f) {\n+                                   return (sumGrad / (sumHess + regLambda)) * sumGrad;\n+        } else {\n+          return Maths.sqr(Maths.thresholdL1(sumGrad, regAlpha)) / (sumHess + regLambda);\n+        }\n     } else {\n       double w = calcWeight(sumGrad, sumHess);\n       double ret = sumGrad * w + 0.5 * (sumHess + regLambda) * Maths.sqr(w);\n       if (regAlpha == 0.0f) {\n-        return -2.0 * ret;\n+               return -2.0 * ret;\n       } else {\n         return -2.0 * (ret + regAlpha * Math.abs(w));\n       }\n     }\n-  }\n+    }\n \n-  public double calcGain(double[] sumGrad, double[] sumHess) {\n+    public double calcGain(double[] sumGrad, double[] sumHess) {\n     double gain = 0.0;\n     if (!satisfyWeight(sumHess) || Maths.areZeros(sumGrad)) {\n-      return 0.0;\n+        return 0.0;\n     }\n     // TODO: regularization\n+\n     if (!fullHessian) {\n-      if (regAlpha == 0.0f) {\n-        for (int k = 0; k < numClass; k++) {\n-          gain += sumGrad[k] / (sumHess[k] + regLambda) * sumGrad[k];\n+        if (regAlpha == 0.0f) {\n+                          for (int k = 0; k < numClass; k++) {\n+                                  gain += sumGrad[k] / (sumHess[k] + regLambda) * sumGrad[k];\n+                          }\n+        } else {\n+          for (int k = 0; k < numClass; k++) {\n+                   gain += Maths.sqr(Maths.thresholdL1(sumGrad[k], regAlpha)) * (sumHess[k] + regLambda);\n+          }\n         }\n-      } else {\n-        for (int k = 0; k < numClass; k++) {\n-          gain += Maths.sqr(Maths.thresholdL1(sumGrad[k], regAlpha)) * (sumHess[k] + regLambda);\n-        }\n-      }\n     } else {\n       addDiagonal(numClass, sumHess, regLambda);\n       double[] tmp = Maths.solveLinearSystemWithCholeskyDecomposition(sumHess, sumGrad, numClass);\n@@ -211,17 +232,17 @@ public class GBDTParam extends RegTParam {\n       addDiagonal(numClass, sumHess, -regLambda);\n     }\n     return (float) (gain / numClass);\n-  }\n+    }\n \n-  private void addDiagonal(int n, double[] sumHess, double v) {\n+    private void addDiagonal(int n, double[] sumHess, double v) {\n     for (int i = 0; i < n; i++) {\n-      int index = Maths.indexOfLowerTriangularMatrix(i, i);\n-      sumHess[index] += v;\n+        int index = Maths.indexOfLowerTriangularMatrix(i, i);\n+        sumHess[index] += v;\n+    }\n     }\n-  }\n \n-  @Override\n-  public String toString() {\n+    @Override\n+    public String toString() {\n     StringBuilder sb = new StringBuilder(super.toString());\n     sb.append(String.format(\"|numClass = %d\\n\", numClass));\n     sb.append(String.format(\"|numTree = %d\\n\", numTree));\n@@ -235,6 +256,6 @@ public class GBDTParam extends RegTParam {\n     sb.append(String.format(\"|lossFunc = %s\\n\", lossFunc));\n     sb.append(String.format(\"|evalMetrics = %s\\n\", Arrays.toString(evalMetrics)));\n     return sb.toString();\n-  }\n-}\n+    }\n \n+}\n\\ No newline at end of file\n",
            "diff_size": 121
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "6",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 102).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}