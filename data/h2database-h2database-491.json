{
    "error_id": "491",
    "information": {
        "errors": [
            {
                "line": "1167",
                "column": "54",
                "severity": "warning",
                "message": "'{' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "                            add(rows, \"info.FILE_SIZE\",\n                                    Long.toString(fs.getFile().size()));\n                        } catch (IOException ignore) {/**/}\n                        add(rows, \"info.CHUNK_COUNT\",\n                                Long.toString(mvStore.getChunkCount()));\n                        add(rows, \"info.PAGE_COUNT\",",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/491/MetaTable.java\nindex c2124ac32e..7672402526 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/491/MetaTable.java\n@@ -1164,7 +1164,7 @@ public class MetaTable extends Table {\n                         try {\n                             add(rows, \"info.FILE_SIZE\",\n                                     Long.toString(fs.getFile().size()));\n-                        } catch (IOException ignore) {/**/}\n+                        } catch (IOException ignore) { /**/}\n                         add(rows, \"info.CHUNK_COUNT\",\n                                 Long.toString(mvStore.getChunkCount()));\n                         add(rows, \"info.PAGE_COUNT\",\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1179",
                    "column": "44",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/491/MetaTable.java\nindex c2124ac32e..8cbed9030f 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/491/MetaTable.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.table;\n \n import java.io.ByteArrayInputStream;\n@@ -77,2326 +78,2368 @@ import org.h2.value.ValueStringIgnoreCase;\n  */\n public class MetaTable extends Table {\n \n-    /**\n-     * The approximate number of rows of a meta table.\n-     */\n-    public static final long ROW_COUNT_APPROXIMATION = 1000;\n+  /**\n+   * The approximate number of rows of a meta table.\n+   */\n+  public static final long ROW_COUNT_APPROXIMATION = 1000;\n \n-    private static final String CHARACTER_SET_NAME = \"Unicode\";\n+  private static final String CHARACTER_SET_NAME = \"Unicode\";\n \n-    private static final int TABLES = 0;\n-    private static final int COLUMNS = 1;\n-    private static final int INDEXES = 2;\n-    private static final int TABLE_TYPES = 3;\n-    private static final int TYPE_INFO = 4;\n-    private static final int CATALOGS = 5;\n-    private static final int SETTINGS = 6;\n-    private static final int HELP = 7;\n-    private static final int SEQUENCES = 8;\n-    private static final int USERS = 9;\n-    private static final int ROLES = 10;\n-    private static final int RIGHTS = 11;\n-    private static final int FUNCTION_ALIASES = 12;\n-    private static final int SCHEMATA = 13;\n-    private static final int TABLE_PRIVILEGES = 14;\n-    private static final int COLUMN_PRIVILEGES = 15;\n-    private static final int COLLATIONS = 16;\n-    private static final int VIEWS = 17;\n-    private static final int IN_DOUBT = 18;\n-    private static final int CROSS_REFERENCES = 19;\n-    private static final int CONSTRAINTS = 20;\n-    private static final int FUNCTION_COLUMNS = 21;\n-    private static final int CONSTANTS = 22;\n-    private static final int DOMAINS = 23;\n-    private static final int TRIGGERS = 24;\n-    private static final int SESSIONS = 25;\n-    private static final int LOCKS = 26;\n-    private static final int SESSION_STATE = 27;\n-    private static final int QUERY_STATISTICS = 28;\n-    private static final int SYNONYMS = 29;\n-    private static final int TABLE_CONSTRAINTS = 30;\n-    private static final int KEY_COLUMN_USAGE = 31;\n-    private static final int REFERENTIAL_CONSTRAINTS = 32;\n-    private static final int META_TABLE_TYPE_COUNT = REFERENTIAL_CONSTRAINTS + 1;\n+  private static final int TABLES = 0;\n+  private static final int COLUMNS = 1;\n+  private static final int INDEXES = 2;\n+  private static final int TABLE_TYPES = 3;\n+  private static final int TYPE_INFO = 4;\n+  private static final int CATALOGS = 5;\n+  private static final int SETTINGS = 6;\n+  private static final int HELP = 7;\n+  private static final int SEQUENCES = 8;\n+  private static final int USERS = 9;\n+  private static final int ROLES = 10;\n+  private static final int RIGHTS = 11;\n+  private static final int FUNCTION_ALIASES = 12;\n+  private static final int SCHEMATA = 13;\n+  private static final int TABLE_PRIVILEGES = 14;\n+  private static final int COLUMN_PRIVILEGES = 15;\n+  private static final int COLLATIONS = 16;\n+  private static final int VIEWS = 17;\n+  private static final int IN_DOUBT = 18;\n+  private static final int CROSS_REFERENCES = 19;\n+  private static final int CONSTRAINTS = 20;\n+  private static final int FUNCTION_COLUMNS = 21;\n+  private static final int CONSTANTS = 22;\n+  private static final int DOMAINS = 23;\n+  private static final int TRIGGERS = 24;\n+  private static final int SESSIONS = 25;\n+  private static final int LOCKS = 26;\n+  private static final int SESSION_STATE = 27;\n+  private static final int QUERY_STATISTICS = 28;\n+  private static final int SYNONYMS = 29;\n+  private static final int TABLE_CONSTRAINTS = 30;\n+  private static final int KEY_COLUMN_USAGE = 31;\n+  private static final int REFERENTIAL_CONSTRAINTS = 32;\n+  private static final int META_TABLE_TYPE_COUNT = REFERENTIAL_CONSTRAINTS + 1;\n \n-    private final int type;\n-    private final int indexColumn;\n-    private final MetaIndex metaIndex;\n+  private final int type;\n+  private final int indexColumn;\n+  private final MetaIndex metaIndex;\n \n-    /**\n-     * Create a new metadata table.\n-     *\n-     * @param schema the schema\n-     * @param id the object id\n-     * @param type the meta table type\n-     */\n-    public MetaTable(Schema schema, int id, int type) {\n-        // tableName will be set later\n-        super(schema, id, null, true, true);\n-        this.type = type;\n-        Column[] cols;\n-        String indexColumnName = null;\n-        switch (type) {\n-        case TABLES:\n-            setMetaTableName(\"TABLES\");\n-            cols = createColumns(\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"TABLE_TYPE\",\n-                    // extensions\n-                    \"STORAGE_TYPE\",\n-                    \"SQL\",\n-                    \"REMARKS\",\n-                    \"LAST_MODIFICATION BIGINT\",\n-                    \"ID INT\",\n-                    \"TYPE_NAME\",\n-                    \"TABLE_CLASS\",\n-                    \"ROW_COUNT_ESTIMATE BIGINT\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case COLUMNS:\n-            setMetaTableName(\"COLUMNS\");\n-            cols = createColumns(\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"COLUMN_NAME\",\n-                    \"ORDINAL_POSITION INT\",\n-                    \"DOMAIN_CATALOG\",\n-                    \"DOMAIN_SCHEMA\",\n-                    \"DOMAIN_NAME\",\n-                    \"COLUMN_DEFAULT\",\n-                    \"IS_NULLABLE\",\n-                    \"DATA_TYPE INT\",\n-                    \"CHARACTER_MAXIMUM_LENGTH INT\",\n-                    \"CHARACTER_OCTET_LENGTH INT\",\n-                    \"NUMERIC_PRECISION INT\",\n-                    \"NUMERIC_PRECISION_RADIX INT\",\n-                    \"NUMERIC_SCALE INT\",\n-                    \"DATETIME_PRECISION INT\",\n-                    \"INTERVAL_TYPE\",\n-                    \"INTERVAL_PRECISION INT\",\n-                    \"CHARACTER_SET_NAME\",\n-                    \"COLLATION_NAME\",\n-                    // extensions\n-                    \"TYPE_NAME\",\n-                    \"NULLABLE INT\",\n-                    \"IS_COMPUTED BIT\",\n-                    \"SELECTIVITY INT\",\n-                    \"CHECK_CONSTRAINT\",\n-                    \"SEQUENCE_NAME\",\n-                    \"REMARKS\",\n-                    \"SOURCE_DATA_TYPE SMALLINT\",\n-                    \"COLUMN_TYPE\",\n-                    \"COLUMN_ON_UPDATE\",\n-                    \"IS_VISIBLE\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case INDEXES:\n-            setMetaTableName(\"INDEXES\");\n-            cols = createColumns(\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"NON_UNIQUE BIT\",\n-                    \"INDEX_NAME\",\n-                    \"ORDINAL_POSITION SMALLINT\",\n-                    \"COLUMN_NAME\",\n-                    \"CARDINALITY INT\",\n-                    \"PRIMARY_KEY BIT\",\n-                    \"INDEX_TYPE_NAME\",\n-                    \"IS_GENERATED BIT\",\n-                    \"INDEX_TYPE SMALLINT\",\n-                    \"ASC_OR_DESC\",\n-                    \"PAGES INT\",\n-                    \"FILTER_CONDITION\",\n-                    \"REMARKS\",\n-                    \"SQL\",\n-                    \"ID INT\",\n-                    \"SORT_TYPE INT\",\n-                    \"CONSTRAINT_NAME\",\n-                    \"INDEX_CLASS\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case TABLE_TYPES:\n-            setMetaTableName(\"TABLE_TYPES\");\n-            cols = createColumns(\"TYPE\");\n-            break;\n-        case TYPE_INFO:\n-            setMetaTableName(\"TYPE_INFO\");\n-            cols = createColumns(\n-                \"TYPE_NAME\",\n-                \"DATA_TYPE INT\",\n-                \"PRECISION INT\",\n-                \"PREFIX\",\n-                \"SUFFIX\",\n-                \"PARAMS\",\n-                \"AUTO_INCREMENT BIT\",\n-                \"MINIMUM_SCALE SMALLINT\",\n-                \"MAXIMUM_SCALE SMALLINT\",\n-                \"RADIX INT\",\n-                \"POS INT\",\n-                \"CASE_SENSITIVE BIT\",\n-                \"NULLABLE SMALLINT\",\n-                \"SEARCHABLE SMALLINT\"\n-            );\n-            break;\n-        case CATALOGS:\n-            setMetaTableName(\"CATALOGS\");\n-            cols = createColumns(\"CATALOG_NAME\");\n-            break;\n-        case SETTINGS:\n-            setMetaTableName(\"SETTINGS\");\n-            cols = createColumns(\"NAME\", \"VALUE\");\n-            break;\n-        case HELP:\n-            setMetaTableName(\"HELP\");\n-            cols = createColumns(\n-                    \"ID INT\",\n-                    \"SECTION\",\n-                    \"TOPIC\",\n-                    \"SYNTAX\",\n-                    \"TEXT\"\n-            );\n-            break;\n-        case SEQUENCES:\n-            setMetaTableName(\"SEQUENCES\");\n-            cols = createColumns(\n-                    \"SEQUENCE_CATALOG\",\n-                    \"SEQUENCE_SCHEMA\",\n-                    \"SEQUENCE_NAME\",\n-                    \"CURRENT_VALUE BIGINT\",\n-                    \"INCREMENT BIGINT\",\n-                    \"IS_GENERATED BIT\",\n-                    \"REMARKS\",\n-                    \"CACHE BIGINT\",\n-                    \"MIN_VALUE BIGINT\",\n-                    \"MAX_VALUE BIGINT\",\n-                    \"IS_CYCLE BIT\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case USERS:\n-            setMetaTableName(\"USERS\");\n-            cols = createColumns(\n-                    \"NAME\",\n-                    \"ADMIN\",\n-                    \"REMARKS\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case ROLES:\n-            setMetaTableName(\"ROLES\");\n-            cols = createColumns(\n-                    \"NAME\",\n-                    \"REMARKS\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case RIGHTS:\n-            setMetaTableName(\"RIGHTS\");\n-            cols = createColumns(\n-                    \"GRANTEE\",\n-                    \"GRANTEETYPE\",\n-                    \"GRANTEDROLE\",\n-                    \"RIGHTS\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"ID INT\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case FUNCTION_ALIASES:\n-            setMetaTableName(\"FUNCTION_ALIASES\");\n-            cols = createColumns(\n-                    \"ALIAS_CATALOG\",\n-                    \"ALIAS_SCHEMA\",\n-                    \"ALIAS_NAME\",\n-                    \"JAVA_CLASS\",\n-                    \"JAVA_METHOD\",\n-                    \"DATA_TYPE INT\",\n-                    \"TYPE_NAME\",\n-                    \"COLUMN_COUNT INT\",\n-                    \"RETURNS_RESULT SMALLINT\",\n-                    \"REMARKS\",\n-                    \"ID INT\",\n-                    \"SOURCE\"\n-            );\n-            break;\n-        case FUNCTION_COLUMNS:\n-            setMetaTableName(\"FUNCTION_COLUMNS\");\n-            cols = createColumns(\n-                    \"ALIAS_CATALOG\",\n-                    \"ALIAS_SCHEMA\",\n-                    \"ALIAS_NAME\",\n-                    \"JAVA_CLASS\",\n-                    \"JAVA_METHOD\",\n-                    \"COLUMN_COUNT INT\",\n-                    \"POS INT\",\n-                    \"COLUMN_NAME\",\n-                    \"DATA_TYPE INT\",\n-                    \"TYPE_NAME\",\n-                    \"PRECISION INT\",\n-                    \"SCALE SMALLINT\",\n-                    \"RADIX SMALLINT\",\n-                    \"NULLABLE SMALLINT\",\n-                    \"COLUMN_TYPE SMALLINT\",\n-                    \"REMARKS\",\n-                    \"COLUMN_DEFAULT\"\n-            );\n-            break;\n-        case SCHEMATA:\n-            setMetaTableName(\"SCHEMATA\");\n-            cols = createColumns(\n-                    \"CATALOG_NAME\",\n-                    \"SCHEMA_NAME\",\n-                    \"SCHEMA_OWNER\",\n-                    \"DEFAULT_CHARACTER_SET_NAME\",\n-                    \"DEFAULT_COLLATION_NAME\",\n-                    \"IS_DEFAULT BIT\",\n-                    \"REMARKS\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case TABLE_PRIVILEGES:\n-            setMetaTableName(\"TABLE_PRIVILEGES\");\n-            cols = createColumns(\n-                    \"GRANTOR\",\n-                    \"GRANTEE\",\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"PRIVILEGE_TYPE\",\n-                    \"IS_GRANTABLE\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case COLUMN_PRIVILEGES:\n-            setMetaTableName(\"COLUMN_PRIVILEGES\");\n-            cols = createColumns(\n-                    \"GRANTOR\",\n-                    \"GRANTEE\",\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"COLUMN_NAME\",\n-                    \"PRIVILEGE_TYPE\",\n-                    \"IS_GRANTABLE\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case COLLATIONS:\n-            setMetaTableName(\"COLLATIONS\");\n-            cols = createColumns(\n-                    \"NAME\",\n-                    \"KEY\"\n-            );\n-            break;\n-        case VIEWS:\n-            setMetaTableName(\"VIEWS\");\n-            cols = createColumns(\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"VIEW_DEFINITION\",\n-                    \"CHECK_OPTION\",\n-                    \"IS_UPDATABLE\",\n-                    \"STATUS\",\n-                    \"REMARKS\",\n-                    \"ID INT\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case IN_DOUBT:\n-            setMetaTableName(\"IN_DOUBT\");\n-            cols = createColumns(\n-                    \"TRANSACTION\",\n-                    \"STATE\"\n-            );\n-            break;\n-        case CROSS_REFERENCES:\n-            setMetaTableName(\"CROSS_REFERENCES\");\n-            cols = createColumns(\n-                    \"PKTABLE_CATALOG\",\n-                    \"PKTABLE_SCHEMA\",\n-                    \"PKTABLE_NAME\",\n-                    \"PKCOLUMN_NAME\",\n-                    \"FKTABLE_CATALOG\",\n-                    \"FKTABLE_SCHEMA\",\n-                    \"FKTABLE_NAME\",\n-                    \"FKCOLUMN_NAME\",\n-                    \"ORDINAL_POSITION SMALLINT\",\n-                    \"UPDATE_RULE SMALLINT\",\n-                    \"DELETE_RULE SMALLINT\",\n-                    \"FK_NAME\",\n-                    \"PK_NAME\",\n-                    \"DEFERRABILITY SMALLINT\"\n-            );\n-            indexColumnName = \"PKTABLE_NAME\";\n-            break;\n-        case CONSTRAINTS:\n-            setMetaTableName(\"CONSTRAINTS\");\n-            cols = createColumns(\n-                    \"CONSTRAINT_CATALOG\",\n-                    \"CONSTRAINT_SCHEMA\",\n-                    \"CONSTRAINT_NAME\",\n-                    \"CONSTRAINT_TYPE\",\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"UNIQUE_INDEX_NAME\",\n-                    \"CHECK_EXPRESSION\",\n-                    \"COLUMN_LIST\",\n-                    \"REMARKS\",\n-                    \"SQL\",\n-                    \"ID INT\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        case CONSTANTS:\n-            setMetaTableName(\"CONSTANTS\");\n-            cols = createColumns(\n-                    \"CONSTANT_CATALOG\",\n-                    \"CONSTANT_SCHEMA\",\n-                    \"CONSTANT_NAME\",\n-                    \"DATA_TYPE INT\",\n-                    \"REMARKS\",\n-                    \"SQL\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case DOMAINS:\n-            setMetaTableName(\"DOMAINS\");\n-            cols = createColumns(\n-                    \"DOMAIN_CATALOG\",\n-                    \"DOMAIN_SCHEMA\",\n-                    \"DOMAIN_NAME\",\n-                    \"COLUMN_DEFAULT\",\n-                    \"IS_NULLABLE\",\n-                    \"DATA_TYPE INT\",\n-                    \"PRECISION INT\",\n-                    \"SCALE INT\",\n-                    \"TYPE_NAME\",\n-                    \"SELECTIVITY INT\",\n-                    \"CHECK_CONSTRAINT\",\n-                    \"REMARKS\",\n-                    \"SQL\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case TRIGGERS:\n-            setMetaTableName(\"TRIGGERS\");\n-            cols = createColumns(\n-                    \"TRIGGER_CATALOG\",\n-                    \"TRIGGER_SCHEMA\",\n-                    \"TRIGGER_NAME\",\n-                    \"TRIGGER_TYPE\",\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"BEFORE BIT\",\n-                    \"JAVA_CLASS\",\n-                    \"QUEUE_SIZE INT\",\n-                    \"NO_WAIT BIT\",\n-                    \"REMARKS\",\n-                    \"SQL\",\n-                    \"ID INT\"\n-            );\n-            break;\n-        case SESSIONS: {\n-            setMetaTableName(\"SESSIONS\");\n-            cols = createColumns(\n-                    \"ID INT\",\n-                    \"USER_NAME\",\n-                    \"SERVER\",\n-                    \"CLIENT_ADDR\",\n-                    \"CLIENT_INFO\",\n-                    \"SESSION_START TIMESTAMP WITH TIME ZONE\",\n-                    \"ISOLATION_LEVEL\",\n-                    \"STATEMENT\",\n-                    \"STATEMENT_START TIMESTAMP WITH TIME ZONE\",\n-                    \"CONTAINS_UNCOMMITTED BIT\",\n-                    \"STATE\",\n-                    \"BLOCKER_ID INT\"\n-            );\n-            break;\n-        }\n-        case LOCKS: {\n-            setMetaTableName(\"LOCKS\");\n-            cols = createColumns(\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"SESSION_ID INT\",\n-                    \"LOCK_TYPE\"\n-            );\n-            break;\n-        }\n-        case SESSION_STATE: {\n-            setMetaTableName(\"SESSION_STATE\");\n-            cols = createColumns(\n-                    \"KEY\",\n-                    \"SQL\"\n-            );\n-            break;\n-        }\n-        case QUERY_STATISTICS: {\n-            setMetaTableName(\"QUERY_STATISTICS\");\n-            cols = createColumns(\n-                    \"SQL_STATEMENT\",\n-                    \"EXECUTION_COUNT INT\",\n-                    \"MIN_EXECUTION_TIME DOUBLE\",\n-                    \"MAX_EXECUTION_TIME DOUBLE\",\n-                    \"CUMULATIVE_EXECUTION_TIME DOUBLE\",\n-                    \"AVERAGE_EXECUTION_TIME DOUBLE\",\n-                    \"STD_DEV_EXECUTION_TIME DOUBLE\",\n-                    \"MIN_ROW_COUNT INT\",\n-                    \"MAX_ROW_COUNT INT\",\n-                    \"CUMULATIVE_ROW_COUNT LONG\",\n-                    \"AVERAGE_ROW_COUNT DOUBLE\",\n-                    \"STD_DEV_ROW_COUNT DOUBLE\"\n-            );\n-            break;\n-        }\n-        case SYNONYMS: {\n-            setMetaTableName(\"SYNONYMS\");\n-            cols = createColumns(\n-                    \"SYNONYM_CATALOG\",\n-                    \"SYNONYM_SCHEMA\",\n-                    \"SYNONYM_NAME\",\n-                    \"SYNONYM_FOR\",\n-                    \"SYNONYM_FOR_SCHEMA\",\n-                    \"TYPE_NAME\",\n-                    \"STATUS\",\n-                    \"REMARKS\",\n-                    \"ID INT\"\n-            );\n-            indexColumnName = \"SYNONYM_NAME\";\n-            break;\n-        }\n-        case TABLE_CONSTRAINTS: {\n-            setMetaTableName(\"TABLE_CONSTRAINTS\");\n-            cols = createColumns(\n-                    \"CONSTRAINT_CATALOG\",\n-                    \"CONSTRAINT_SCHEMA\",\n-                    \"CONSTRAINT_NAME\",\n-                    \"CONSTRAINT_TYPE\",\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"IS_DEFERRABLE\",\n-                    \"INITIALLY_DEFERRED\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        }\n-        case KEY_COLUMN_USAGE: {\n-            setMetaTableName(\"KEY_COLUMN_USAGE\");\n-            cols = createColumns(\n-                    \"CONSTRAINT_CATALOG\",\n-                    \"CONSTRAINT_SCHEMA\",\n-                    \"CONSTRAINT_NAME\",\n-                    \"TABLE_CATALOG\",\n-                    \"TABLE_SCHEMA\",\n-                    \"TABLE_NAME\",\n-                    \"COLUMN_NAME\",\n-                    \"ORDINAL_POSITION INT\",\n-                    \"POSITION_IN_UNIQUE_CONSTRAINT INT\"\n-            );\n-            indexColumnName = \"TABLE_NAME\";\n-            break;\n-        }\n-        case REFERENTIAL_CONSTRAINTS: {\n-            setMetaTableName(\"REFERENTIAL_CONSTRAINTS\");\n-            cols = createColumns(\n-                    \"CONSTRAINT_CATALOG\",\n-                    \"CONSTRAINT_SCHEMA\",\n-                    \"CONSTRAINT_NAME\",\n-                    \"UNIQUE_CONSTRAINT_CATALOG\",\n-                    \"UNIQUE_CONSTRAINT_SCHEMA\",\n-                    \"UNIQUE_CONSTRAINT_NAME\",\n-                    \"MATCH_OPTION\",\n-                    \"UPDATE_RULE\",\n-                    \"DELETE_RULE\"\n-            );\n-            break;\n-        }\n-        default:\n-            throw DbException.throwInternalError(\"type=\"+type);\n-        }\n-        setColumns(cols);\n-\n-        if (indexColumnName == null) {\n-            indexColumn = -1;\n-            metaIndex = null;\n-        } else {\n-            indexColumn = getColumn(database.sysIdentifier(indexColumnName)).getColumnId();\n-            IndexColumn[] indexCols = IndexColumn.wrap(\n-                    new Column[] { cols[indexColumn] });\n-            metaIndex = new MetaIndex(this, indexCols, false);\n-        }\n+  /**\n+   * Create a new metadata table.\n+   *\n+   * @param schema the schema\n+   * @param id     the object id\n+   * @param type   the meta table type\n+   */\n+  public MetaTable(Schema schema, int id, int type) {\n+    // tableName will be set later\n+    super(schema, id, null, true, true);\n+    this.type = type;\n+    Column[] cols;\n+    String indexColumnName = null;\n+    switch (type) {\n+      case TABLES:\n+        setMetaTableName(\"TABLES\");\n+        cols = createColumns(\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"TABLE_TYPE\",\n+            // extensions\n+            \"STORAGE_TYPE\",\n+            \"SQL\",\n+            \"REMARKS\",\n+            \"LAST_MODIFICATION BIGINT\",\n+            \"ID INT\",\n+            \"TYPE_NAME\",\n+            \"TABLE_CLASS\",\n+            \"ROW_COUNT_ESTIMATE BIGINT\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case COLUMNS:\n+        setMetaTableName(\"COLUMNS\");\n+        cols = createColumns(\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"COLUMN_NAME\",\n+            \"ORDINAL_POSITION INT\",\n+            \"DOMAIN_CATALOG\",\n+            \"DOMAIN_SCHEMA\",\n+            \"DOMAIN_NAME\",\n+            \"COLUMN_DEFAULT\",\n+            \"IS_NULLABLE\",\n+            \"DATA_TYPE INT\",\n+            \"CHARACTER_MAXIMUM_LENGTH INT\",\n+            \"CHARACTER_OCTET_LENGTH INT\",\n+            \"NUMERIC_PRECISION INT\",\n+            \"NUMERIC_PRECISION_RADIX INT\",\n+            \"NUMERIC_SCALE INT\",\n+            \"DATETIME_PRECISION INT\",\n+            \"INTERVAL_TYPE\",\n+            \"INTERVAL_PRECISION INT\",\n+            \"CHARACTER_SET_NAME\",\n+            \"COLLATION_NAME\",\n+            // extensions\n+            \"TYPE_NAME\",\n+            \"NULLABLE INT\",\n+            \"IS_COMPUTED BIT\",\n+            \"SELECTIVITY INT\",\n+            \"CHECK_CONSTRAINT\",\n+            \"SEQUENCE_NAME\",\n+            \"REMARKS\",\n+            \"SOURCE_DATA_TYPE SMALLINT\",\n+            \"COLUMN_TYPE\",\n+            \"COLUMN_ON_UPDATE\",\n+            \"IS_VISIBLE\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case INDEXES:\n+        setMetaTableName(\"INDEXES\");\n+        cols = createColumns(\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"NON_UNIQUE BIT\",\n+            \"INDEX_NAME\",\n+            \"ORDINAL_POSITION SMALLINT\",\n+            \"COLUMN_NAME\",\n+            \"CARDINALITY INT\",\n+            \"PRIMARY_KEY BIT\",\n+            \"INDEX_TYPE_NAME\",\n+            \"IS_GENERATED BIT\",\n+            \"INDEX_TYPE SMALLINT\",\n+            \"ASC_OR_DESC\",\n+            \"PAGES INT\",\n+            \"FILTER_CONDITION\",\n+            \"REMARKS\",\n+            \"SQL\",\n+            \"ID INT\",\n+            \"SORT_TYPE INT\",\n+            \"CONSTRAINT_NAME\",\n+            \"INDEX_CLASS\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case TABLE_TYPES:\n+        setMetaTableName(\"TABLE_TYPES\");\n+        cols = createColumns(\"TYPE\");\n+        break;\n+      case TYPE_INFO:\n+        setMetaTableName(\"TYPE_INFO\");\n+        cols = createColumns(\n+            \"TYPE_NAME\",\n+            \"DATA_TYPE INT\",\n+            \"PRECISION INT\",\n+            \"PREFIX\",\n+            \"SUFFIX\",\n+            \"PARAMS\",\n+            \"AUTO_INCREMENT BIT\",\n+            \"MINIMUM_SCALE SMALLINT\",\n+            \"MAXIMUM_SCALE SMALLINT\",\n+            \"RADIX INT\",\n+            \"POS INT\",\n+            \"CASE_SENSITIVE BIT\",\n+            \"NULLABLE SMALLINT\",\n+            \"SEARCHABLE SMALLINT\"\n+        );\n+        break;\n+      case CATALOGS:\n+        setMetaTableName(\"CATALOGS\");\n+        cols = createColumns(\"CATALOG_NAME\");\n+        break;\n+      case SETTINGS:\n+        setMetaTableName(\"SETTINGS\");\n+        cols = createColumns(\"NAME\", \"VALUE\");\n+        break;\n+      case HELP:\n+        setMetaTableName(\"HELP\");\n+        cols = createColumns(\n+            \"ID INT\",\n+            \"SECTION\",\n+            \"TOPIC\",\n+            \"SYNTAX\",\n+            \"TEXT\"\n+        );\n+        break;\n+      case SEQUENCES:\n+        setMetaTableName(\"SEQUENCES\");\n+        cols = createColumns(\n+            \"SEQUENCE_CATALOG\",\n+            \"SEQUENCE_SCHEMA\",\n+            \"SEQUENCE_NAME\",\n+            \"CURRENT_VALUE BIGINT\",\n+            \"INCREMENT BIGINT\",\n+            \"IS_GENERATED BIT\",\n+            \"REMARKS\",\n+            \"CACHE BIGINT\",\n+            \"MIN_VALUE BIGINT\",\n+            \"MAX_VALUE BIGINT\",\n+            \"IS_CYCLE BIT\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case USERS:\n+        setMetaTableName(\"USERS\");\n+        cols = createColumns(\n+            \"NAME\",\n+            \"ADMIN\",\n+            \"REMARKS\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case ROLES:\n+        setMetaTableName(\"ROLES\");\n+        cols = createColumns(\n+            \"NAME\",\n+            \"REMARKS\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case RIGHTS:\n+        setMetaTableName(\"RIGHTS\");\n+        cols = createColumns(\n+            \"GRANTEE\",\n+            \"GRANTEETYPE\",\n+            \"GRANTEDROLE\",\n+            \"RIGHTS\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"ID INT\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case FUNCTION_ALIASES:\n+        setMetaTableName(\"FUNCTION_ALIASES\");\n+        cols = createColumns(\n+            \"ALIAS_CATALOG\",\n+            \"ALIAS_SCHEMA\",\n+            \"ALIAS_NAME\",\n+            \"JAVA_CLASS\",\n+            \"JAVA_METHOD\",\n+            \"DATA_TYPE INT\",\n+            \"TYPE_NAME\",\n+            \"COLUMN_COUNT INT\",\n+            \"RETURNS_RESULT SMALLINT\",\n+            \"REMARKS\",\n+            \"ID INT\",\n+            \"SOURCE\"\n+        );\n+        break;\n+      case FUNCTION_COLUMNS:\n+        setMetaTableName(\"FUNCTION_COLUMNS\");\n+        cols = createColumns(\n+            \"ALIAS_CATALOG\",\n+            \"ALIAS_SCHEMA\",\n+            \"ALIAS_NAME\",\n+            \"JAVA_CLASS\",\n+            \"JAVA_METHOD\",\n+            \"COLUMN_COUNT INT\",\n+            \"POS INT\",\n+            \"COLUMN_NAME\",\n+            \"DATA_TYPE INT\",\n+            \"TYPE_NAME\",\n+            \"PRECISION INT\",\n+            \"SCALE SMALLINT\",\n+            \"RADIX SMALLINT\",\n+            \"NULLABLE SMALLINT\",\n+            \"COLUMN_TYPE SMALLINT\",\n+            \"REMARKS\",\n+            \"COLUMN_DEFAULT\"\n+        );\n+        break;\n+      case SCHEMATA:\n+        setMetaTableName(\"SCHEMATA\");\n+        cols = createColumns(\n+            \"CATALOG_NAME\",\n+            \"SCHEMA_NAME\",\n+            \"SCHEMA_OWNER\",\n+            \"DEFAULT_CHARACTER_SET_NAME\",\n+            \"DEFAULT_COLLATION_NAME\",\n+            \"IS_DEFAULT BIT\",\n+            \"REMARKS\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case TABLE_PRIVILEGES:\n+        setMetaTableName(\"TABLE_PRIVILEGES\");\n+        cols = createColumns(\n+            \"GRANTOR\",\n+            \"GRANTEE\",\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"PRIVILEGE_TYPE\",\n+            \"IS_GRANTABLE\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case COLUMN_PRIVILEGES:\n+        setMetaTableName(\"COLUMN_PRIVILEGES\");\n+        cols = createColumns(\n+            \"GRANTOR\",\n+            \"GRANTEE\",\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"COLUMN_NAME\",\n+            \"PRIVILEGE_TYPE\",\n+            \"IS_GRANTABLE\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case COLLATIONS:\n+        setMetaTableName(\"COLLATIONS\");\n+        cols = createColumns(\n+            \"NAME\",\n+            \"KEY\"\n+        );\n+        break;\n+      case VIEWS:\n+        setMetaTableName(\"VIEWS\");\n+        cols = createColumns(\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"VIEW_DEFINITION\",\n+            \"CHECK_OPTION\",\n+            \"IS_UPDATABLE\",\n+            \"STATUS\",\n+            \"REMARKS\",\n+            \"ID INT\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case IN_DOUBT:\n+        setMetaTableName(\"IN_DOUBT\");\n+        cols = createColumns(\n+            \"TRANSACTION\",\n+            \"STATE\"\n+        );\n+        break;\n+      case CROSS_REFERENCES:\n+        setMetaTableName(\"CROSS_REFERENCES\");\n+        cols = createColumns(\n+            \"PKTABLE_CATALOG\",\n+            \"PKTABLE_SCHEMA\",\n+            \"PKTABLE_NAME\",\n+            \"PKCOLUMN_NAME\",\n+            \"FKTABLE_CATALOG\",\n+            \"FKTABLE_SCHEMA\",\n+            \"FKTABLE_NAME\",\n+            \"FKCOLUMN_NAME\",\n+            \"ORDINAL_POSITION SMALLINT\",\n+            \"UPDATE_RULE SMALLINT\",\n+            \"DELETE_RULE SMALLINT\",\n+            \"FK_NAME\",\n+            \"PK_NAME\",\n+            \"DEFERRABILITY SMALLINT\"\n+        );\n+        indexColumnName = \"PKTABLE_NAME\";\n+        break;\n+      case CONSTRAINTS:\n+        setMetaTableName(\"CONSTRAINTS\");\n+        cols = createColumns(\n+            \"CONSTRAINT_CATALOG\",\n+            \"CONSTRAINT_SCHEMA\",\n+            \"CONSTRAINT_NAME\",\n+            \"CONSTRAINT_TYPE\",\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"UNIQUE_INDEX_NAME\",\n+            \"CHECK_EXPRESSION\",\n+            \"COLUMN_LIST\",\n+            \"REMARKS\",\n+            \"SQL\",\n+            \"ID INT\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      case CONSTANTS:\n+        setMetaTableName(\"CONSTANTS\");\n+        cols = createColumns(\n+            \"CONSTANT_CATALOG\",\n+            \"CONSTANT_SCHEMA\",\n+            \"CONSTANT_NAME\",\n+            \"DATA_TYPE INT\",\n+            \"REMARKS\",\n+            \"SQL\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case DOMAINS:\n+        setMetaTableName(\"DOMAINS\");\n+        cols = createColumns(\n+            \"DOMAIN_CATALOG\",\n+            \"DOMAIN_SCHEMA\",\n+            \"DOMAIN_NAME\",\n+            \"COLUMN_DEFAULT\",\n+            \"IS_NULLABLE\",\n+            \"DATA_TYPE INT\",\n+            \"PRECISION INT\",\n+            \"SCALE INT\",\n+            \"TYPE_NAME\",\n+            \"SELECTIVITY INT\",\n+            \"CHECK_CONSTRAINT\",\n+            \"REMARKS\",\n+            \"SQL\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case TRIGGERS:\n+        setMetaTableName(\"TRIGGERS\");\n+        cols = createColumns(\n+            \"TRIGGER_CATALOG\",\n+            \"TRIGGER_SCHEMA\",\n+            \"TRIGGER_NAME\",\n+            \"TRIGGER_TYPE\",\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"BEFORE BIT\",\n+            \"JAVA_CLASS\",\n+            \"QUEUE_SIZE INT\",\n+            \"NO_WAIT BIT\",\n+            \"REMARKS\",\n+            \"SQL\",\n+            \"ID INT\"\n+        );\n+        break;\n+      case SESSIONS: {\n+        setMetaTableName(\"SESSIONS\");\n+        cols = createColumns(\n+            \"ID INT\",\n+            \"USER_NAME\",\n+            \"SERVER\",\n+            \"CLIENT_ADDR\",\n+            \"CLIENT_INFO\",\n+            \"SESSION_START TIMESTAMP WITH TIME ZONE\",\n+            \"ISOLATION_LEVEL\",\n+            \"STATEMENT\",\n+            \"STATEMENT_START TIMESTAMP WITH TIME ZONE\",\n+            \"CONTAINS_UNCOMMITTED BIT\",\n+            \"STATE\",\n+            \"BLOCKER_ID INT\"\n+        );\n+        break;\n+      }\n+      case LOCKS: {\n+        setMetaTableName(\"LOCKS\");\n+        cols = createColumns(\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"SESSION_ID INT\",\n+            \"LOCK_TYPE\"\n+        );\n+        break;\n+      }\n+      case SESSION_STATE: {\n+        setMetaTableName(\"SESSION_STATE\");\n+        cols = createColumns(\n+            \"KEY\",\n+            \"SQL\"\n+        );\n+        break;\n+      }\n+      case QUERY_STATISTICS: {\n+        setMetaTableName(\"QUERY_STATISTICS\");\n+        cols = createColumns(\n+            \"SQL_STATEMENT\",\n+            \"EXECUTION_COUNT INT\",\n+            \"MIN_EXECUTION_TIME DOUBLE\",\n+            \"MAX_EXECUTION_TIME DOUBLE\",\n+            \"CUMULATIVE_EXECUTION_TIME DOUBLE\",\n+            \"AVERAGE_EXECUTION_TIME DOUBLE\",\n+            \"STD_DEV_EXECUTION_TIME DOUBLE\",\n+            \"MIN_ROW_COUNT INT\",\n+            \"MAX_ROW_COUNT INT\",\n+            \"CUMULATIVE_ROW_COUNT LONG\",\n+            \"AVERAGE_ROW_COUNT DOUBLE\",\n+            \"STD_DEV_ROW_COUNT DOUBLE\"\n+        );\n+        break;\n+      }\n+      case SYNONYMS: {\n+        setMetaTableName(\"SYNONYMS\");\n+        cols = createColumns(\n+            \"SYNONYM_CATALOG\",\n+            \"SYNONYM_SCHEMA\",\n+            \"SYNONYM_NAME\",\n+            \"SYNONYM_FOR\",\n+            \"SYNONYM_FOR_SCHEMA\",\n+            \"TYPE_NAME\",\n+            \"STATUS\",\n+            \"REMARKS\",\n+            \"ID INT\"\n+        );\n+        indexColumnName = \"SYNONYM_NAME\";\n+        break;\n+      }\n+      case TABLE_CONSTRAINTS: {\n+        setMetaTableName(\"TABLE_CONSTRAINTS\");\n+        cols = createColumns(\n+            \"CONSTRAINT_CATALOG\",\n+            \"CONSTRAINT_SCHEMA\",\n+            \"CONSTRAINT_NAME\",\n+            \"CONSTRAINT_TYPE\",\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"IS_DEFERRABLE\",\n+            \"INITIALLY_DEFERRED\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      }\n+      case KEY_COLUMN_USAGE: {\n+        setMetaTableName(\"KEY_COLUMN_USAGE\");\n+        cols = createColumns(\n+            \"CONSTRAINT_CATALOG\",\n+            \"CONSTRAINT_SCHEMA\",\n+            \"CONSTRAINT_NAME\",\n+            \"TABLE_CATALOG\",\n+            \"TABLE_SCHEMA\",\n+            \"TABLE_NAME\",\n+            \"COLUMN_NAME\",\n+            \"ORDINAL_POSITION INT\",\n+            \"POSITION_IN_UNIQUE_CONSTRAINT INT\"\n+        );\n+        indexColumnName = \"TABLE_NAME\";\n+        break;\n+      }\n+      case REFERENTIAL_CONSTRAINTS: {\n+        setMetaTableName(\"REFERENTIAL_CONSTRAINTS\");\n+        cols = createColumns(\n+            \"CONSTRAINT_CATALOG\",\n+            \"CONSTRAINT_SCHEMA\",\n+            \"CONSTRAINT_NAME\",\n+            \"UNIQUE_CONSTRAINT_CATALOG\",\n+            \"UNIQUE_CONSTRAINT_SCHEMA\",\n+            \"UNIQUE_CONSTRAINT_NAME\",\n+            \"MATCH_OPTION\",\n+            \"UPDATE_RULE\",\n+            \"DELETE_RULE\"\n+        );\n+        break;\n+      }\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + type);\n     }\n+    setColumns(cols);\n \n-    private void setMetaTableName(String upperName) {\n-        setObjectName(database.sysIdentifier(upperName));\n+    if (indexColumnName == null) {\n+      indexColumn = -1;\n+      metaIndex = null;\n+    } else {\n+      indexColumn =\n+          getColumn(database.sysIdentifier(indexColumnName)).getColumnId();\n+      IndexColumn[] indexCols = IndexColumn.wrap(\n+          new Column[] {cols[indexColumn]});\n+      metaIndex = new MetaIndex(this, indexCols, false);\n     }\n+  }\n \n-    private Column[] createColumns(String... names) {\n-        Column[] cols = new Column[names.length];\n-        int defaultType = database.getSettings().caseInsensitiveIdentifiers ? Value.STRING_IGNORECASE : Value.STRING;\n-        for (int i = 0; i < names.length; i++) {\n-            String nameType = names[i];\n-            int idx = nameType.indexOf(' ');\n-            int dataType;\n-            String name;\n-            if (idx < 0) {\n-                dataType = defaultType;\n-                name = nameType;\n-            } else {\n-                dataType = DataType.getTypeByName(nameType.substring(idx + 1), database.getMode()).type;\n-                name = nameType.substring(0, idx);\n-            }\n-            cols[i] = new Column(database.sysIdentifier(name), dataType);\n-        }\n-        return cols;\n-    }\n+  private void setMetaTableName(String upperName) {\n+    setObjectName(database.sysIdentifier(upperName));\n+  }\n \n-    @Override\n-    public String getCreateSQL() {\n-        return null;\n+  private Column[] createColumns(String... names) {\n+    Column[] cols = new Column[names.length];\n+    int defaultType = database.getSettings().caseInsensitiveIdentifiers ?\n+        Value.STRING_IGNORECASE : Value.STRING;\n+    for (int i = 0; i < names.length; i++) {\n+      String nameType = names[i];\n+      int idx = nameType.indexOf(' ');\n+      int dataType;\n+      String name;\n+      if (idx < 0) {\n+        dataType = defaultType;\n+        name = nameType;\n+      } else {\n+        dataType = DataType.getTypeByName(nameType.substring(idx + 1),\n+            database.getMode()).type;\n+        name = nameType.substring(0, idx);\n+      }\n+      cols[i] = new Column(database.sysIdentifier(name), dataType);\n     }\n+    return cols;\n+  }\n \n-    @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n-        throw DbException.getUnsupportedException(\"META\");\n-    }\n+  @Override\n+  public String getCreateSQL() {\n+    return null;\n+  }\n \n-    @Override\n-    public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n-        // nothing to do\n-        return false;\n-    }\n+  @Override\n+  public Index addIndex(Session session, String indexName, int indexId,\n+                        IndexColumn[] cols, IndexType indexType, boolean create,\n+                        String indexComment) {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public boolean isLockedExclusively() {\n-        return false;\n-    }\n+  @Override\n+  public boolean lock(Session session, boolean exclusive,\n+                      boolean forceLockEvenInMvcc) {\n+    // nothing to do\n+    return false;\n+  }\n \n-    private String identifier(String s) {\n-        if (database.getSettings().databaseToLower) {\n-            s = s == null ? null : StringUtils.toLowerEnglish(s);\n-        }\n-        return s;\n-    }\n+  @Override\n+  public boolean isLockedExclusively() {\n+    return false;\n+  }\n \n-    private ArrayList<Table> getAllTables(Session session) {\n-        ArrayList<Table> tables = database.getAllTablesAndViews(true);\n-        ArrayList<Table> tempTables = session.getLocalTempTables();\n-        tables.addAll(tempTables);\n-        return tables;\n+  private String identifier(String s) {\n+    if (database.getSettings().databaseToLower) {\n+      s = s == null ? null : StringUtils.toLowerEnglish(s);\n     }\n+    return s;\n+  }\n \n-    private ArrayList<Table> getTablesByName(Session session, String tableName) {\n-        ArrayList<Table> tables = database.getTableOrViewByName(tableName);\n-        for (Table temp : session.getLocalTempTables()) {\n-            if (temp.getName().equals(tableName)) {\n-                tables.add(temp);\n-            }\n-        }\n-        return tables;\n-    }\n+  private ArrayList<Table> getAllTables(Session session) {\n+    ArrayList<Table> tables = database.getAllTablesAndViews(true);\n+    ArrayList<Table> tempTables = session.getLocalTempTables();\n+    tables.addAll(tempTables);\n+    return tables;\n+  }\n \n-    private boolean checkIndex(Session session, String value, Value indexFrom,\n-            Value indexTo) {\n-        if (value == null || (indexFrom == null && indexTo == null)) {\n-            return true;\n-        }\n-        Database db = session.getDatabase();\n-        Value v;\n-        if (database.getSettings().caseInsensitiveIdentifiers) {\n-            v = ValueStringIgnoreCase.get(value);\n-        } else {\n-            v = ValueString.get(value);\n-        }\n-        if (indexFrom != null && db.compare(v, indexFrom) < 0) {\n-            return false;\n-        }\n-        if (indexTo != null && db.compare(v, indexTo) > 0) {\n-            return false;\n-        }\n-        return true;\n+  private ArrayList<Table> getTablesByName(Session session, String tableName) {\n+    ArrayList<Table> tables = database.getTableOrViewByName(tableName);\n+    for (Table temp : session.getLocalTempTables()) {\n+      if (temp.getName().equals(tableName)) {\n+        tables.add(temp);\n+      }\n     }\n+    return tables;\n+  }\n \n-    private static String replaceNullWithEmpty(String s) {\n-        return s == null ? \"\" : s;\n+  private boolean checkIndex(Session session, String value, Value indexFrom,\n+                             Value indexTo) {\n+    if (value == null || (indexFrom == null && indexTo == null)) {\n+      return true;\n     }\n-\n-    private boolean hideTable(Table table, Session session) {\n-        return table.isHidden() && session != database.getSystemSession();\n+    Database db = session.getDatabase();\n+    Value v;\n+    if (database.getSettings().caseInsensitiveIdentifiers) {\n+      v = ValueStringIgnoreCase.get(value);\n+    } else {\n+      v = ValueString.get(value);\n     }\n+    if (indexFrom != null && db.compare(v, indexFrom) < 0) {\n+      return false;\n+    }\n+    if (indexTo != null && db.compare(v, indexTo) > 0) {\n+      return false;\n+    }\n+    return true;\n+  }\n \n-    /**\n-     * Generate the data for the given metadata table using the given first and\n-     * last row filters.\n-     *\n-     * @param session the session\n-     * @param first the first row to return\n-     * @param last the last row to return\n-     * @return the generated rows\n-     */\n-    public ArrayList<Row> generateRows(Session session, SearchRow first,\n-            SearchRow last) {\n-        Value indexFrom = null, indexTo = null;\n+  private static String replaceNullWithEmpty(String s) {\n+    return s == null ? \"\" : s;\n+  }\n \n-        if (indexColumn >= 0) {\n-            if (first != null) {\n-                indexFrom = first.getValue(indexColumn);\n-            }\n-            if (last != null) {\n-                indexTo = last.getValue(indexColumn);\n-            }\n-        }\n+  private boolean hideTable(Table table, Session session) {\n+    return table.isHidden() && session != database.getSystemSession();\n+  }\n \n-        ArrayList<Row> rows = Utils.newSmallArrayList();\n-        String catalog = database.getShortName();\n-        boolean admin = session.getUser().isAdmin();\n-        switch (type) {\n-        case TABLES: {\n-            for (Table table : getAllTables(session)) {\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                String storageType;\n-                if (table.isTemporary()) {\n-                    if (table.isGlobalTemporary()) {\n-                        storageType = \"GLOBAL TEMPORARY\";\n-                    } else {\n-                        storageType = \"LOCAL TEMPORARY\";\n-                    }\n-                } else {\n-                    storageType = table.isPersistIndexes() ?\n-                            \"CACHED\" : \"MEMORY\";\n-                }\n-                String sql = table.getCreateSQL();\n-                if (!admin) {\n-                    if (sql != null && sql.contains(DbException.HIDE_SQL)) {\n-                        // hide the password of linked tables\n-                        sql = \"-\";\n-                    }\n-                }\n-                add(rows,\n-                        // TABLE_CATALOG\n-                        catalog,\n-                        // TABLE_SCHEMA\n-                        table.getSchema().getName(),\n-                        // TABLE_NAME\n-                        tableName,\n-                        // TABLE_TYPE\n-                        table.getTableType().toString(),\n-                        // STORAGE_TYPE\n-                        storageType,\n-                        // SQL\n-                        sql,\n-                        // REMARKS\n-                        replaceNullWithEmpty(table.getComment()),\n-                        // LAST_MODIFICATION\n-                        ValueLong.get(table.getMaxDataModificationId()),\n-                        // ID\n-                        ValueInt.get(table.getId()),\n-                        // TYPE_NAME\n-                        null,\n-                        // TABLE_CLASS\n-                        table.getClass().getName(),\n-                        // ROW_COUNT_ESTIMATE\n-                        ValueLong.get(table.getRowCountApproximation())\n-                );\n-            }\n-            break;\n-        }\n-        case COLUMNS: {\n-            // reduce the number of tables to scan - makes some metadata queries\n-            // 10x faster\n-            final ArrayList<Table> tablesToList;\n-            if (indexFrom != null && indexFrom.equals(indexTo)) {\n-                String tableName = indexFrom.getString();\n-                if (tableName == null) {\n-                    break;\n-                }\n-                tablesToList = getTablesByName(session, tableName);\n-            } else {\n-                tablesToList = getAllTables(session);\n-            }\n-            for (Table table : tablesToList) {\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                Column[] cols = table.getColumns();\n-                String collation = database.getCompareMode().getName();\n-                for (int j = 0; j < cols.length; j++) {\n-                    Column c = cols[j];\n-                    Domain domain = c.getDomain();\n-                    DataType dataType = c.getDataType();\n-                    ValueInt precision = ValueInt.get(c.getPrecisionAsInt());\n-                    ValueInt scale = ValueInt.get(c.getType().getScale());\n-                    Sequence sequence = c.getSequence();\n-                    boolean hasDateTimePrecision;\n-                    int type = dataType.type;\n-                    switch (type) {\n-                    case Value.TIME:\n-                    case Value.TIME_TZ:\n-                    case Value.DATE:\n-                    case Value.TIMESTAMP:\n-                    case Value.TIMESTAMP_TZ:\n-                    case Value.INTERVAL_SECOND:\n-                    case Value.INTERVAL_DAY_TO_SECOND:\n-                    case Value.INTERVAL_HOUR_TO_SECOND:\n-                    case Value.INTERVAL_MINUTE_TO_SECOND:\n-                        hasDateTimePrecision = true;\n-                        break;\n-                    default:\n-                        hasDateTimePrecision = false;\n-                    }\n-                    boolean isInterval = DataType.isIntervalType(type);\n-                    String createSQLWithoutName = c.getCreateSQLWithoutName();\n-                    add(rows,\n-                            // TABLE_CATALOG\n-                            catalog,\n-                            // TABLE_SCHEMA\n-                            table.getSchema().getName(),\n-                            // TABLE_NAME\n-                            tableName,\n-                            // COLUMN_NAME\n-                            c.getName(),\n-                            // ORDINAL_POSITION\n-                            ValueInt.get(j + 1),\n-                            // DOMAIN_CATALOG\n-                            domain != null ? catalog : null,\n-                            // DOMAIN_SCHEMA\n-                            domain != null ? database.getMainSchema().getName() : null,\n-                            // DOMAIN_NAME\n-                            domain != null ? domain.getName() : null,\n-                            // COLUMN_DEFAULT\n-                            c.getDefaultSQL(),\n-                            // IS_NULLABLE\n-                            c.isNullable() ? \"YES\" : \"NO\",\n-                            // DATA_TYPE\n-                            ValueInt.get(dataType.sqlType),\n-                            // CHARACTER_MAXIMUM_LENGTH\n-                            precision,\n-                            // CHARACTER_OCTET_LENGTH\n-                            precision,\n-                            // NUMERIC_PRECISION\n-                            precision,\n-                            // NUMERIC_PRECISION_RADIX\n-                            ValueInt.get(10),\n-                            // NUMERIC_SCALE\n-                            scale,\n-                            // DATETIME_PRECISION\n-                            hasDateTimePrecision ? scale : null,\n-                            // INTERVAL_TYPE\n-                            isInterval ? createSQLWithoutName.substring(9) : null,\n-                            // INTERVAL_PRECISION\n-                            isInterval ? precision : null,\n-                            // CHARACTER_SET_NAME\n-                            CHARACTER_SET_NAME,\n-                            // COLLATION_NAME\n-                            collation,\n-                            // TYPE_NAME\n-                            identifier(isInterval ? \"INTERVAL\" : dataType.name),\n-                            // NULLABLE\n-                            ValueInt.get(c.isNullable()\n-                                    ? DatabaseMetaData.columnNullable : DatabaseMetaData.columnNoNulls),\n-                            // IS_COMPUTED\n-                            ValueBoolean.get(c.getComputed()),\n-                            // SELECTIVITY\n-                            ValueInt.get(c.getSelectivity()),\n-                            // CHECK_CONSTRAINT\n-                            c.getCheckConstraintSQL(session, c.getName()),\n-                            // SEQUENCE_NAME\n-                            sequence == null ? null : sequence.getName(),\n-                            // REMARKS\n-                            replaceNullWithEmpty(c.getComment()),\n-                            // SOURCE_DATA_TYPE\n-                            // SMALLINT\n-                            null,\n-                            // COLUMN_TYPE\n-                            createSQLWithoutName,\n-                            // COLUMN_ON_UPDATE\n-                            c.getOnUpdateSQL(),\n-                            // IS_VISIBLE\n-                            ValueBoolean.get(c.getVisible())\n-                    );\n-                }\n-            }\n-            break;\n-        }\n-        case INDEXES: {\n-            // reduce the number of tables to scan - makes some metadata queries\n-            // 10x faster\n-            final ArrayList<Table> tablesToList;\n-            if (indexFrom != null && indexFrom.equals(indexTo)) {\n-                String tableName = indexFrom.getString();\n-                if (tableName == null) {\n-                    break;\n-                }\n-                tablesToList = getTablesByName(session, tableName);\n+  /**\n+   * Generate the data for the given metadata table using the given first and\n+   * last row filters.\n+   *\n+   * @param session the session\n+   * @param first   the first row to return\n+   * @param last    the last row to return\n+   * @return the generated rows\n+   */\n+  public ArrayList<Row> generateRows(Session session, SearchRow first,\n+                                     SearchRow last) {\n+    Value indexFrom = null, indexTo = null;\n+\n+    if (indexColumn >= 0) {\n+      if (first != null) {\n+        indexFrom = first.getValue(indexColumn);\n+      }\n+      if (last != null) {\n+        indexTo = last.getValue(indexColumn);\n+      }\n+    }\n+\n+    ArrayList<Row> rows = Utils.newSmallArrayList();\n+    String catalog = database.getShortName();\n+    boolean admin = session.getUser().isAdmin();\n+    switch (type) {\n+      case TABLES: {\n+        for (Table table : getAllTables(session)) {\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          String storageType;\n+          if (table.isTemporary()) {\n+            if (table.isGlobalTemporary()) {\n+              storageType = \"GLOBAL TEMPORARY\";\n             } else {\n-                tablesToList = getAllTables(session);\n+              storageType = \"LOCAL TEMPORARY\";\n             }\n-            for (Table table : tablesToList) {\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                ArrayList<Index> indexes = table.getIndexes();\n-                ArrayList<Constraint> constraints = table.getConstraints();\n-                for (int j = 0; indexes != null && j < indexes.size(); j++) {\n-                    Index index = indexes.get(j);\n-                    if (index.getCreateSQL() == null) {\n-                        continue;\n-                    }\n-                    String constraintName = null;\n-                    for (int k = 0; constraints != null && k < constraints.size(); k++) {\n-                        Constraint constraint = constraints.get(k);\n-                        if (constraint.usesIndex(index)) {\n-                            if (index.getIndexType().isPrimaryKey()) {\n-                                if (constraint.getConstraintType() == Constraint.Type.PRIMARY_KEY) {\n-                                    constraintName = constraint.getName();\n-                                }\n-                            } else {\n-                                constraintName = constraint.getName();\n-                            }\n-                        }\n-                    }\n-                    IndexColumn[] cols = index.getIndexColumns();\n-                    String indexClass = index.getClass().getName();\n-                    for (int k = 0; k < cols.length; k++) {\n-                        IndexColumn idxCol = cols[k];\n-                        Column column = idxCol.column;\n-                        add(rows,\n-                                // TABLE_CATALOG\n-                                catalog,\n-                                // TABLE_SCHEMA\n-                                table.getSchema().getName(),\n-                                // TABLE_NAME\n-                                tableName,\n-                                // NON_UNIQUE\n-                                ValueBoolean.get(!index.getIndexType().isUnique()),\n-                                // INDEX_NAME\n-                                index.getName(),\n-                                // ORDINAL_POSITION\n-                                ValueShort.get((short) (k + 1)),\n-                                // COLUMN_NAME\n-                                column.getName(),\n-                                // CARDINALITY\n-                                ValueInt.get(0),\n-                                // PRIMARY_KEY\n-                                ValueBoolean.get(index.getIndexType().isPrimaryKey()),\n-                                // INDEX_TYPE_NAME\n-                                index.getIndexType().getSQL(),\n-                                // IS_GENERATED\n-                                ValueBoolean.get(index.getIndexType().getBelongsToConstraint()),\n-                                // INDEX_TYPE\n-                                ValueShort.get(DatabaseMetaData.tableIndexOther),\n-                                // ASC_OR_DESC\n-                                (idxCol.sortType & SortOrder.DESCENDING) != 0 ? \"D\" : \"A\",\n-                                // PAGES\n-                                ValueInt.get(0),\n-                                // FILTER_CONDITION\n-                                \"\",\n-                                // REMARKS\n-                                replaceNullWithEmpty(index.getComment()),\n-                                // SQL\n-                                index.getCreateSQL(),\n-                                // ID\n-                                ValueInt.get(index.getId()),\n-                                // SORT_TYPE\n-                                ValueInt.get(idxCol.sortType),\n-                                // CONSTRAINT_NAME\n-                                constraintName,\n-                                // INDEX_CLASS\n-                                indexClass\n-                            );\n-                    }\n-                }\n+          } else {\n+            storageType = table.isPersistIndexes() ?\n+                \"CACHED\" : \"MEMORY\";\n+          }\n+          String sql = table.getCreateSQL();\n+          if (!admin) {\n+            if (sql != null && sql.contains(DbException.HIDE_SQL)) {\n+              // hide the password of linked tables\n+              sql = \"-\";\n             }\n-            break;\n+          }\n+          add(rows,\n+              // TABLE_CATALOG\n+              catalog,\n+              // TABLE_SCHEMA\n+              table.getSchema().getName(),\n+              // TABLE_NAME\n+              tableName,\n+              // TABLE_TYPE\n+              table.getTableType().toString(),\n+              // STORAGE_TYPE\n+              storageType,\n+              // SQL\n+              sql,\n+              // REMARKS\n+              replaceNullWithEmpty(table.getComment()),\n+              // LAST_MODIFICATION\n+              ValueLong.get(table.getMaxDataModificationId()),\n+              // ID\n+              ValueInt.get(table.getId()),\n+              // TYPE_NAME\n+              null,\n+              // TABLE_CLASS\n+              table.getClass().getName(),\n+              // ROW_COUNT_ESTIMATE\n+              ValueLong.get(table.getRowCountApproximation())\n+          );\n         }\n-        case TABLE_TYPES: {\n-            add(rows, TableType.TABLE.toString());\n-            add(rows, TableType.TABLE_LINK.toString());\n-            add(rows, TableType.SYSTEM_TABLE.toString());\n-            add(rows, TableType.VIEW.toString());\n-            add(rows, TableType.EXTERNAL_TABLE_ENGINE.toString());\n-            break;\n+        break;\n+      }\n+      case COLUMNS: {\n+        // reduce the number of tables to scan - makes some metadata queries\n+        // 10x faster\n+        final ArrayList<Table> tablesToList;\n+        if (indexFrom != null && indexFrom.equals(indexTo)) {\n+          String tableName = indexFrom.getString();\n+          if (tableName == null) {\n+            break;\n+          }\n+          tablesToList = getTablesByName(session, tableName);\n+        } else {\n+          tablesToList = getAllTables(session);\n         }\n-        case TYPE_INFO: {\n-            for (DataType t : DataType.getTypes()) {\n-                if (t.hidden || t.sqlType == Value.NULL) {\n-                    continue;\n-                }\n-                add(rows,\n-                        // TYPE_NAME\n-                        t.name,\n-                        // DATA_TYPE\n-                        ValueInt.get(t.sqlType),\n-                        // PRECISION\n-                        ValueInt.get(MathUtils.convertLongToInt(t.maxPrecision)),\n-                        // PREFIX\n-                        t.prefix,\n-                        // SUFFIX\n-                        t.suffix,\n-                        // PARAMS\n-                        t.params,\n-                        // AUTO_INCREMENT\n-                        ValueBoolean.get(t.autoIncrement),\n-                        // MINIMUM_SCALE\n-                        ValueShort.get((short) t.minScale),\n-                        // MAXIMUM_SCALE\n-                        ValueShort.get((short) t.maxScale),\n-                        // RADIX\n-                        t.decimal ? ValueInt.get(10) : null,\n-                        // POS\n-                        ValueInt.get(t.sqlTypePos),\n-                        // CASE_SENSITIVE\n-                        ValueBoolean.get(t.caseSensitive),\n-                        // NULLABLE\n-                        ValueShort.get((short) DatabaseMetaData.typeNullable),\n-                        // SEARCHABLE\n-                        ValueShort.get((short) DatabaseMetaData.typeSearchable)\n-                );\n+        for (Table table : tablesToList) {\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          Column[] cols = table.getColumns();\n+          String collation = database.getCompareMode().getName();\n+          for (int j = 0; j < cols.length; j++) {\n+            Column c = cols[j];\n+            Domain domain = c.getDomain();\n+            DataType dataType = c.getDataType();\n+            ValueInt precision = ValueInt.get(c.getPrecisionAsInt());\n+            ValueInt scale = ValueInt.get(c.getType().getScale());\n+            Sequence sequence = c.getSequence();\n+            boolean hasDateTimePrecision;\n+            int type = dataType.type;\n+            switch (type) {\n+              case Value.TIME:\n+              case Value.TIME_TZ:\n+              case Value.DATE:\n+              case Value.TIMESTAMP:\n+              case Value.TIMESTAMP_TZ:\n+              case Value.INTERVAL_SECOND:\n+              case Value.INTERVAL_DAY_TO_SECOND:\n+              case Value.INTERVAL_HOUR_TO_SECOND:\n+              case Value.INTERVAL_MINUTE_TO_SECOND:\n+                hasDateTimePrecision = true;\n+                break;\n+              default:\n+                hasDateTimePrecision = false;\n             }\n-            break;\n+            boolean isInterval = DataType.isIntervalType(type);\n+            String createSQLWithoutName = c.getCreateSQLWithoutName();\n+            add(rows,\n+                // TABLE_CATALOG\n+                catalog,\n+                // TABLE_SCHEMA\n+                table.getSchema().getName(),\n+                // TABLE_NAME\n+                tableName,\n+                // COLUMN_NAME\n+                c.getName(),\n+                // ORDINAL_POSITION\n+                ValueInt.get(j + 1),\n+                // DOMAIN_CATALOG\n+                domain != null ? catalog : null,\n+                // DOMAIN_SCHEMA\n+                domain != null ? database.getMainSchema().getName() : null,\n+                // DOMAIN_NAME\n+                domain != null ? domain.getName() : null,\n+                // COLUMN_DEFAULT\n+                c.getDefaultSQL(),\n+                // IS_NULLABLE\n+                c.isNullable() ? \"YES\" : \"NO\",\n+                // DATA_TYPE\n+                ValueInt.get(dataType.sqlType),\n+                // CHARACTER_MAXIMUM_LENGTH\n+                precision,\n+                // CHARACTER_OCTET_LENGTH\n+                precision,\n+                // NUMERIC_PRECISION\n+                precision,\n+                // NUMERIC_PRECISION_RADIX\n+                ValueInt.get(10),\n+                // NUMERIC_SCALE\n+                scale,\n+                // DATETIME_PRECISION\n+                hasDateTimePrecision ? scale : null,\n+                // INTERVAL_TYPE\n+                isInterval ? createSQLWithoutName.substring(9) : null,\n+                // INTERVAL_PRECISION\n+                isInterval ? precision : null,\n+                // CHARACTER_SET_NAME\n+                CHARACTER_SET_NAME,\n+                // COLLATION_NAME\n+                collation,\n+                // TYPE_NAME\n+                identifier(isInterval ? \"INTERVAL\" : dataType.name),\n+                // NULLABLE\n+                ValueInt.get(c.isNullable()\n+                    ? DatabaseMetaData.columnNullable :\n+                    DatabaseMetaData.columnNoNulls),\n+                // IS_COMPUTED\n+                ValueBoolean.get(c.getComputed()),\n+                // SELECTIVITY\n+                ValueInt.get(c.getSelectivity()),\n+                // CHECK_CONSTRAINT\n+                c.getCheckConstraintSQL(session, c.getName()),\n+                // SEQUENCE_NAME\n+                sequence == null ? null : sequence.getName(),\n+                // REMARKS\n+                replaceNullWithEmpty(c.getComment()),\n+                // SOURCE_DATA_TYPE\n+                // SMALLINT\n+                null,\n+                // COLUMN_TYPE\n+                createSQLWithoutName,\n+                // COLUMN_ON_UPDATE\n+                c.getOnUpdateSQL(),\n+                // IS_VISIBLE\n+                ValueBoolean.get(c.getVisible())\n+            );\n+          }\n         }\n-        case CATALOGS: {\n-            add(rows, catalog);\n-            break;\n+        break;\n+      }\n+      case INDEXES: {\n+        // reduce the number of tables to scan - makes some metadata queries\n+        // 10x faster\n+        final ArrayList<Table> tablesToList;\n+        if (indexFrom != null && indexFrom.equals(indexTo)) {\n+          String tableName = indexFrom.getString();\n+          if (tableName == null) {\n+            break;\n+          }\n+          tablesToList = getTablesByName(session, tableName);\n+        } else {\n+          tablesToList = getAllTables(session);\n         }\n-        case SETTINGS: {\n-            for (Setting s : database.getAllSettings()) {\n-                String value = s.getStringValue();\n-                if (value == null) {\n-                    value = Integer.toString(s.getIntValue());\n-                }\n-                add(rows,\n-                        identifier(s.getName()),\n-                        value\n-                );\n+        for (Table table : tablesToList) {\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          ArrayList<Index> indexes = table.getIndexes();\n+          ArrayList<Constraint> constraints = table.getConstraints();\n+          for (int j = 0; indexes != null && j < indexes.size(); j++) {\n+            Index index = indexes.get(j);\n+            if (index.getCreateSQL() == null) {\n+              continue;\n             }\n-            add(rows, \"info.BUILD_ID\", \"\" + Constants.BUILD_ID);\n-            add(rows, \"info.VERSION_MAJOR\", \"\" + Constants.VERSION_MAJOR);\n-            add(rows, \"info.VERSION_MINOR\", \"\" + Constants.VERSION_MINOR);\n-            add(rows, \"info.VERSION\", Constants.FULL_VERSION);\n-            if (admin) {\n-                String[] settings = {\n-                        \"java.runtime.version\", \"java.vm.name\",\n-                        \"java.vendor\", \"os.name\", \"os.arch\", \"os.version\",\n-                        \"sun.os.patch.level\", \"file.separator\",\n-                        \"path.separator\", \"line.separator\", \"user.country\",\n-                        \"user.language\", \"user.variant\", \"file.encoding\"                };\n-                for (String s : settings) {\n-                    add(rows, \"property.\" + s, Utils.getProperty(s, \"\"));\n+            String constraintName = null;\n+            for (int k = 0; constraints != null && k < constraints.size();\n+                 k++) {\n+              Constraint constraint = constraints.get(k);\n+              if (constraint.usesIndex(index)) {\n+                if (index.getIndexType().isPrimaryKey()) {\n+                  if (constraint.getConstraintType() ==\n+                      Constraint.Type.PRIMARY_KEY) {\n+                    constraintName = constraint.getName();\n+                  }\n+                } else {\n+                  constraintName = constraint.getName();\n                 }\n+              }\n             }\n-            add(rows, \"EXCLUSIVE\", database.getExclusiveSession() == null ?\n-                    \"FALSE\" : \"TRUE\");\n-            add(rows, \"MODE\", database.getMode().getName());\n-            add(rows, \"QUERY_TIMEOUT\", Integer.toString(session.getQueryTimeout()));\n-            add(rows, \"RETENTION_TIME\", Integer.toString(database.getRetentionTime()));\n-            add(rows, \"LOG\", Integer.toString(database.getLogMode()));\n-            // database settings\n-            for (Map.Entry<String, String> entry : database.getSettings().getSortedSettings()) {\n-                add(rows, entry.getKey(), entry.getValue());\n+            IndexColumn[] cols = index.getIndexColumns();\n+            String indexClass = index.getClass().getName();\n+            for (int k = 0; k < cols.length; k++) {\n+              IndexColumn idxCol = cols[k];\n+              Column column = idxCol.column;\n+              add(rows,\n+                  // TABLE_CATALOG\n+                  catalog,\n+                  // TABLE_SCHEMA\n+                  table.getSchema().getName(),\n+                  // TABLE_NAME\n+                  tableName,\n+                  // NON_UNIQUE\n+                  ValueBoolean.get(!index.getIndexType().isUnique()),\n+                  // INDEX_NAME\n+                  index.getName(),\n+                  // ORDINAL_POSITION\n+                  ValueShort.get((short) (k + 1)),\n+                  // COLUMN_NAME\n+                  column.getName(),\n+                  // CARDINALITY\n+                  ValueInt.get(0),\n+                  // PRIMARY_KEY\n+                  ValueBoolean.get(index.getIndexType().isPrimaryKey()),\n+                  // INDEX_TYPE_NAME\n+                  index.getIndexType().getSQL(),\n+                  // IS_GENERATED\n+                  ValueBoolean\n+                      .get(index.getIndexType().getBelongsToConstraint()),\n+                  // INDEX_TYPE\n+                  ValueShort.get(DatabaseMetaData.tableIndexOther),\n+                  // ASC_OR_DESC\n+                  (idxCol.sortType & SortOrder.DESCENDING) != 0 ? \"D\" : \"A\",\n+                  // PAGES\n+                  ValueInt.get(0),\n+                  // FILTER_CONDITION\n+                  \"\",\n+                  // REMARKS\n+                  replaceNullWithEmpty(index.getComment()),\n+                  // SQL\n+                  index.getCreateSQL(),\n+                  // ID\n+                  ValueInt.get(index.getId()),\n+                  // SORT_TYPE\n+                  ValueInt.get(idxCol.sortType),\n+                  // CONSTRAINT_NAME\n+                  constraintName,\n+                  // INDEX_CLASS\n+                  indexClass\n+              );\n             }\n-            if (database.isPersistent()) {\n-                PageStore pageStore = database.getPageStore();\n-                if (pageStore != null) {\n-                    add(rows, \"info.FILE_WRITE_TOTAL\",\n-                            Long.toString(pageStore.getWriteCountTotal()));\n-                    add(rows, \"info.FILE_WRITE\",\n-                            Long.toString(pageStore.getWriteCount()));\n-                    add(rows, \"info.FILE_READ\",\n-                            Long.toString(pageStore.getReadCount()));\n-                    add(rows, \"info.PAGE_COUNT\",\n-                            Integer.toString(pageStore.getPageCount()));\n-                    add(rows, \"info.PAGE_SIZE\",\n-                            Integer.toString(pageStore.getPageSize()));\n-                    add(rows, \"info.CACHE_MAX_SIZE\",\n-                            Integer.toString(pageStore.getCache().getMaxMemory()));\n-                    add(rows, \"info.CACHE_SIZE\",\n-                            Integer.toString(pageStore.getCache().getMemory()));\n-                }\n-                Store store = database.getStore();\n-                if (store != null) {\n-                    MVStore mvStore = store.getMvStore();\n-                    FileStore fs = mvStore.getFileStore();\n-                    if (fs != null) {\n-                        add(rows, \"info.FILE_WRITE\",\n-                                Long.toString(fs.getWriteCount()));\n-                        add(rows, \"info.FILE_WRITE_BYTES\",\n-                                Long.toString(fs.getWriteBytes()));\n-                        add(rows, \"info.FILE_READ\",\n-                                Long.toString(fs.getReadCount()));\n-                        add(rows, \"info.FILE_READ_BYTES\",\n-                                Long.toString(fs.getReadBytes()));\n-                        add(rows, \"info.UPDATE_FAILURE_PERCENT\",\n-                                String.format(Locale.ENGLISH, \"%.2f%%\", 100 * mvStore.getUpdateFailureRatio()));\n-                        add(rows, \"info.FILL_RATE\",\n-                                Integer.toString(mvStore.getFillRate()));\n-                        add(rows, \"info.CHUNKS_FILL_RATE\",\n-                                Integer.toString(mvStore.getChunksFillRate()));\n-                        try {\n-                            add(rows, \"info.FILE_SIZE\",\n-                                    Long.toString(fs.getFile().size()));\n-                        } catch (IOException ignore) {/**/}\n-                        add(rows, \"info.CHUNK_COUNT\",\n-                                Long.toString(mvStore.getChunkCount()));\n-                        add(rows, \"info.PAGE_COUNT\",\n-                                Long.toString(mvStore.getPageCount()));\n-                        add(rows, \"info.PAGE_COUNT_LIVE\",\n-                                Long.toString(mvStore.getLivePageCount()));\n-                        add(rows, \"info.PAGE_SIZE\",\n-                                Integer.toString(mvStore.getPageSplitSize()));\n-                        add(rows, \"info.CACHE_MAX_SIZE\",\n-                                Integer.toString(mvStore.getCacheSize()));\n-                        add(rows, \"info.CACHE_SIZE\",\n-                                Integer.toString(mvStore.getCacheSizeUsed()));\n-                        add(rows, \"info.CACHE_HIT_RATIO\",\n-                                Integer.toString(mvStore.getCacheHitRatio()));\n-                    }\n-                }\n-            }\n-            break;\n+          }\n         }\n-        case HELP: {\n-            String resource = \"/org/h2/res/help.csv\";\n-            try {\n-                byte[] data = Utils.getResource(resource);\n-                Reader reader = new InputStreamReader(\n-                        new ByteArrayInputStream(data));\n-                Csv csv = new Csv();\n-                csv.setLineCommentCharacter('#');\n-                ResultSet rs = csv.read(reader, null);\n-                for (int i = 0; rs.next(); i++) {\n-                    add(rows,\n-                        // ID\n-                        ValueInt.get(i),\n-                        // SECTION\n-                        rs.getString(1).trim(),\n-                        // TOPIC\n-                        rs.getString(2).trim(),\n-                        // SYNTAX\n-                        rs.getString(3).trim(),\n-                        // TEXT\n-                        rs.getString(4).trim()\n-                    );\n-                }\n-            } catch (Exception e) {\n-                throw DbException.convert(e);\n-            }\n-            break;\n+        break;\n+      }\n+      case TABLE_TYPES: {\n+        add(rows, TableType.TABLE.toString());\n+        add(rows, TableType.TABLE_LINK.toString());\n+        add(rows, TableType.SYSTEM_TABLE.toString());\n+        add(rows, TableType.VIEW.toString());\n+        add(rows, TableType.EXTERNAL_TABLE_ENGINE.toString());\n+        break;\n+      }\n+      case TYPE_INFO: {\n+        for (DataType t : DataType.getTypes()) {\n+          if (t.hidden || t.sqlType == Value.NULL) {\n+            continue;\n+          }\n+          add(rows,\n+              // TYPE_NAME\n+              t.name,\n+              // DATA_TYPE\n+              ValueInt.get(t.sqlType),\n+              // PRECISION\n+              ValueInt.get(MathUtils.convertLongToInt(t.maxPrecision)),\n+              // PREFIX\n+              t.prefix,\n+              // SUFFIX\n+              t.suffix,\n+              // PARAMS\n+              t.params,\n+              // AUTO_INCREMENT\n+              ValueBoolean.get(t.autoIncrement),\n+              // MINIMUM_SCALE\n+              ValueShort.get((short) t.minScale),\n+              // MAXIMUM_SCALE\n+              ValueShort.get((short) t.maxScale),\n+              // RADIX\n+              t.decimal ? ValueInt.get(10) : null,\n+              // POS\n+              ValueInt.get(t.sqlTypePos),\n+              // CASE_SENSITIVE\n+              ValueBoolean.get(t.caseSensitive),\n+              // NULLABLE\n+              ValueShort.get((short) DatabaseMetaData.typeNullable),\n+              // SEARCHABLE\n+              ValueShort.get((short) DatabaseMetaData.typeSearchable)\n+          );\n         }\n-        case SEQUENCES: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(\n-                    DbObject.SEQUENCE)) {\n-                Sequence s = (Sequence) obj;\n-                add(rows,\n-                        // SEQUENCE_CATALOG\n-                        catalog,\n-                        // SEQUENCE_SCHEMA\n-                        s.getSchema().getName(),\n-                        // SEQUENCE_NAME\n-                        s.getName(),\n-                        // CURRENT_VALUE\n-                        ValueLong.get(s.getCurrentValue()),\n-                        // INCREMENT\n-                        ValueLong.get(s.getIncrement()),\n-                        // IS_GENERATED\n-                        ValueBoolean.get(s.getBelongsToTable()),\n-                        // REMARKS\n-                        replaceNullWithEmpty(s.getComment()),\n-                        // CACHE\n-                        ValueLong.get(s.getCacheSize()),\n-                        // MIN_VALUE\n-                        ValueLong.get(s.getMinValue()),\n-                        // MAX_VALUE\n-                        ValueLong.get(s.getMaxValue()),\n-                        // IS_CYCLE\n-                        ValueBoolean.get(s.getCycle()),\n-                        // ID\n-                        ValueInt.get(s.getId())\n-                    );\n-            }\n-            break;\n+        break;\n+      }\n+      case CATALOGS: {\n+        add(rows, catalog);\n+        break;\n+      }\n+      case SETTINGS: {\n+        for (Setting s : database.getAllSettings()) {\n+          String value = s.getStringValue();\n+          if (value == null) {\n+            value = Integer.toString(s.getIntValue());\n+          }\n+          add(rows,\n+              identifier(s.getName()),\n+              value\n+          );\n         }\n-        case USERS: {\n-            for (User u : database.getAllUsers()) {\n-                if (admin || session.getUser() == u) {\n-                    add(rows,\n-                            // NAME\n-                            identifier(u.getName()),\n-                            // ADMIN\n-                            String.valueOf(u.isAdmin()),\n-                            // REMARKS\n-                            replaceNullWithEmpty(u.getComment()),\n-                            // ID\n-                            ValueInt.get(u.getId())\n-                    );\n-                }\n-            }\n-            break;\n+        add(rows, \"info.BUILD_ID\", \"\" + Constants.BUILD_ID);\n+        add(rows, \"info.VERSION_MAJOR\", \"\" + Constants.VERSION_MAJOR);\n+        add(rows, \"info.VERSION_MINOR\", \"\" + Constants.VERSION_MINOR);\n+        add(rows, \"info.VERSION\", Constants.FULL_VERSION);\n+        if (admin) {\n+          String[] settings = {\n+              \"java.runtime.version\", \"java.vm.name\",\n+              \"java.vendor\", \"os.name\", \"os.arch\", \"os.version\",\n+              \"sun.os.patch.level\", \"file.separator\",\n+              \"path.separator\", \"line.separator\", \"user.country\",\n+              \"user.language\", \"user.variant\", \"file.encoding\"};\n+          for (String s : settings) {\n+            add(rows, \"property.\" + s, Utils.getProperty(s, \"\"));\n+          }\n         }\n-        case ROLES: {\n-            for (Role r : database.getAllRoles()) {\n-                if (admin || session.getUser().isRoleGranted(r)) {\n-                    add(rows,\n-                            // NAME\n-                            identifier(r.getName()),\n-                            // REMARKS\n-                            replaceNullWithEmpty(r.getComment()),\n-                            // ID\n-                            ValueInt.get(r.getId())\n-                    );\n-                }\n+        add(rows, \"EXCLUSIVE\", database.getExclusiveSession() == null ?\n+            \"FALSE\" : \"TRUE\");\n+        add(rows, \"MODE\", database.getMode().getName());\n+        add(rows, \"QUERY_TIMEOUT\", Integer.toString(session.getQueryTimeout()));\n+        add(rows, \"RETENTION_TIME\",\n+            Integer.toString(database.getRetentionTime()));\n+        add(rows, \"LOG\", Integer.toString(database.getLogMode()));\n+        // database settings\n+        for (Map.Entry<String, String> entry : database.getSettings()\n+            .getSortedSettings()) {\n+          add(rows, entry.getKey(), entry.getValue());\n+        }\n+        if (database.isPersistent()) {\n+          PageStore pageStore = database.getPageStore();\n+          if (pageStore != null) {\n+            add(rows, \"info.FILE_WRITE_TOTAL\",\n+                Long.toString(pageStore.getWriteCountTotal()));\n+            add(rows, \"info.FILE_WRITE\",\n+                Long.toString(pageStore.getWriteCount()));\n+            add(rows, \"info.FILE_READ\",\n+                Long.toString(pageStore.getReadCount()));\n+            add(rows, \"info.PAGE_COUNT\",\n+                Integer.toString(pageStore.getPageCount()));\n+            add(rows, \"info.PAGE_SIZE\",\n+                Integer.toString(pageStore.getPageSize()));\n+            add(rows, \"info.CACHE_MAX_SIZE\",\n+                Integer.toString(pageStore.getCache().getMaxMemory()));\n+            add(rows, \"info.CACHE_SIZE\",\n+                Integer.toString(pageStore.getCache().getMemory()));\n+          }\n+          Store store = database.getStore();\n+          if (store != null) {\n+            MVStore mvStore = store.getMvStore();\n+            FileStore fs = mvStore.getFileStore();\n+            if (fs != null) {\n+              add(rows, \"info.FILE_WRITE\",\n+                  Long.toString(fs.getWriteCount()));\n+              add(rows, \"info.FILE_WRITE_BYTES\",\n+                  Long.toString(fs.getWriteBytes()));\n+              add(rows, \"info.FILE_READ\",\n+                  Long.toString(fs.getReadCount()));\n+              add(rows, \"info.FILE_READ_BYTES\",\n+                  Long.toString(fs.getReadBytes()));\n+              add(rows, \"info.UPDATE_FAILURE_PERCENT\",\n+                  String.format(Locale.ENGLISH, \"%.2f%%\",\n+                      100 * mvStore.getUpdateFailureRatio()));\n+              add(rows, \"info.FILL_RATE\",\n+                  Integer.toString(mvStore.getFillRate()));\n+              add(rows, \"info.CHUNKS_FILL_RATE\",\n+                  Integer.toString(mvStore.getChunksFillRate()));\n+              try {\n+                add(rows, \"info.FILE_SIZE\",\n+                    Long.toString(fs.getFile().size()));\n+              } catch (IOException ignore) {/**/}\n+              add(rows, \"info.CHUNK_COUNT\",\n+                  Long.toString(mvStore.getChunkCount()));\n+              add(rows, \"info.PAGE_COUNT\",\n+                  Long.toString(mvStore.getPageCount()));\n+              add(rows, \"info.PAGE_COUNT_LIVE\",\n+                  Long.toString(mvStore.getLivePageCount()));\n+              add(rows, \"info.PAGE_SIZE\",\n+                  Integer.toString(mvStore.getPageSplitSize()));\n+              add(rows, \"info.CACHE_MAX_SIZE\",\n+                  Integer.toString(mvStore.getCacheSize()));\n+              add(rows, \"info.CACHE_SIZE\",\n+                  Integer.toString(mvStore.getCacheSizeUsed()));\n+              add(rows, \"info.CACHE_HIT_RATIO\",\n+                  Integer.toString(mvStore.getCacheHitRatio()));\n             }\n-            break;\n+          }\n+        }\n+        break;\n+      }\n+      case HELP: {\n+        String resource = \"/org/h2/res/help.csv\";\n+        try {\n+          byte[] data = Utils.getResource(resource);\n+          Reader reader = new InputStreamReader(\n+              new ByteArrayInputStream(data));\n+          Csv csv = new Csv();\n+          csv.setLineCommentCharacter('#');\n+          ResultSet rs = csv.read(reader, null);\n+          for (int i = 0; rs.next(); i++) {\n+            add(rows,\n+                // ID\n+                ValueInt.get(i),\n+                // SECTION\n+                rs.getString(1).trim(),\n+                // TOPIC\n+                rs.getString(2).trim(),\n+                // SYNTAX\n+                rs.getString(3).trim(),\n+                // TEXT\n+                rs.getString(4).trim()\n+            );\n+          }\n+        } catch (Exception e) {\n+          throw DbException.convert(e);\n         }\n-        case RIGHTS: {\n-            if (admin) {\n-                for (Right r : database.getAllRights()) {\n-                    Role role = r.getGrantedRole();\n-                    DbObject grantee = r.getGrantee();\n-                    String rightType = grantee.getType() == DbObject.USER ? \"USER\" : \"ROLE\";\n-                    if (role == null) {\n-                        DbObject object = r.getGrantedObject();\n-                        Schema schema = null;\n-                        Table table = null;\n-                        if (object != null) {\n-                            if (object instanceof Schema) {\n-                                schema = (Schema) object;\n-                            } else if (object instanceof Table) {\n-                                table = (Table) object;\n-                                schema = table.getSchema();\n-                            }\n-                        }\n-                        String tableName = (table != null) ? table.getName() : \"\";\n-                        String schemaName = (schema != null) ? schema.getName() : \"\";\n-                        if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                            continue;\n-                        }\n-                        add(rows,\n-                                // GRANTEE\n-                                identifier(grantee.getName()),\n-                                // GRANTEETYPE\n-                                rightType,\n-                                // GRANTEDROLE\n-                                \"\",\n-                                // RIGHTS\n-                                r.getRights(),\n-                                // TABLE_SCHEMA\n-                                schemaName,\n-                                // TABLE_NAME\n-                                tableName,\n-                                // ID\n-                                ValueInt.get(r.getId())\n-                        );\n-                    } else {\n-                        add(rows,\n-                                // GRANTEE\n-                                identifier(grantee.getName()),\n-                                // GRANTEETYPE\n-                                rightType,\n-                                // GRANTEDROLE\n-                                identifier(role.getName()),\n-                                // RIGHTS\n-                                \"\",\n-                                // TABLE_SCHEMA\n-                                \"\",\n-                                // TABLE_NAME\n-                                \"\",\n-                                // ID\n-                                ValueInt.get(r.getId())\n-                        );\n-                    }\n+        break;\n+      }\n+      case SEQUENCES: {\n+        for (SchemaObject obj : database.getAllSchemaObjects(\n+            DbObject.SEQUENCE)) {\n+          Sequence s = (Sequence) obj;\n+          add(rows,\n+              // SEQUENCE_CATALOG\n+              catalog,\n+              // SEQUENCE_SCHEMA\n+              s.getSchema().getName(),\n+              // SEQUENCE_NAME\n+              s.getName(),\n+              // CURRENT_VALUE\n+              ValueLong.get(s.getCurrentValue()),\n+              // INCREMENT\n+              ValueLong.get(s.getIncrement()),\n+              // IS_GENERATED\n+              ValueBoolean.get(s.getBelongsToTable()),\n+              // REMARKS\n+              replaceNullWithEmpty(s.getComment()),\n+              // CACHE\n+              ValueLong.get(s.getCacheSize()),\n+              // MIN_VALUE\n+              ValueLong.get(s.getMinValue()),\n+              // MAX_VALUE\n+              ValueLong.get(s.getMaxValue()),\n+              // IS_CYCLE\n+              ValueBoolean.get(s.getCycle()),\n+              // ID\n+              ValueInt.get(s.getId())\n+          );\n+        }\n+        break;\n+      }\n+      case USERS: {\n+        for (User u : database.getAllUsers()) {\n+          if (admin || session.getUser() == u) {\n+            add(rows,\n+                // NAME\n+                identifier(u.getName()),\n+                // ADMIN\n+                String.valueOf(u.isAdmin()),\n+                // REMARKS\n+                replaceNullWithEmpty(u.getComment()),\n+                // ID\n+                ValueInt.get(u.getId())\n+            );\n+          }\n+        }\n+        break;\n+      }\n+      case ROLES: {\n+        for (Role r : database.getAllRoles()) {\n+          if (admin || session.getUser().isRoleGranted(r)) {\n+            add(rows,\n+                // NAME\n+                identifier(r.getName()),\n+                // REMARKS\n+                replaceNullWithEmpty(r.getComment()),\n+                // ID\n+                ValueInt.get(r.getId())\n+            );\n+          }\n+        }\n+        break;\n+      }\n+      case RIGHTS: {\n+        if (admin) {\n+          for (Right r : database.getAllRights()) {\n+            Role role = r.getGrantedRole();\n+            DbObject grantee = r.getGrantee();\n+            String rightType =\n+                grantee.getType() == DbObject.USER ? \"USER\" : \"ROLE\";\n+            if (role == null) {\n+              DbObject object = r.getGrantedObject();\n+              Schema schema = null;\n+              Table table = null;\n+              if (object != null) {\n+                if (object instanceof Schema) {\n+                  schema = (Schema) object;\n+                } else if (object instanceof Table) {\n+                  table = (Table) object;\n+                  schema = table.getSchema();\n                 }\n+              }\n+              String tableName = (table != null) ? table.getName() : \"\";\n+              String schemaName = (schema != null) ? schema.getName() : \"\";\n+              if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+                continue;\n+              }\n+              add(rows,\n+                  // GRANTEE\n+                  identifier(grantee.getName()),\n+                  // GRANTEETYPE\n+                  rightType,\n+                  // GRANTEDROLE\n+                  \"\",\n+                  // RIGHTS\n+                  r.getRights(),\n+                  // TABLE_SCHEMA\n+                  schemaName,\n+                  // TABLE_NAME\n+                  tableName,\n+                  // ID\n+                  ValueInt.get(r.getId())\n+              );\n+            } else {\n+              add(rows,\n+                  // GRANTEE\n+                  identifier(grantee.getName()),\n+                  // GRANTEETYPE\n+                  rightType,\n+                  // GRANTEDROLE\n+                  identifier(role.getName()),\n+                  // RIGHTS\n+                  \"\",\n+                  // TABLE_SCHEMA\n+                  \"\",\n+                  // TABLE_NAME\n+                  \"\",\n+                  // ID\n+                  ValueInt.get(r.getId())\n+              );\n             }\n-            break;\n+          }\n         }\n-        case FUNCTION_ALIASES: {\n-            for (SchemaObject aliasAsSchemaObject :\n-                    database.getAllSchemaObjects(DbObject.FUNCTION_ALIAS)) {\n-                FunctionAlias alias = (FunctionAlias) aliasAsSchemaObject;\n-                JavaMethod[] methods;\n-                try {\n-                    methods = alias.getJavaMethods();\n-                } catch (DbException e) {\n-                    methods = new JavaMethod[0];\n-                }\n-                for (FunctionAlias.JavaMethod method : methods) {\n-                    add(rows,\n-                            // ALIAS_CATALOG\n-                            catalog,\n-                            // ALIAS_SCHEMA\n-                            alias.getSchema().getName(),\n-                            // ALIAS_NAME\n-                            alias.getName(),\n-                            // JAVA_CLASS\n-                            alias.getJavaClassName(),\n-                            // JAVA_METHOD\n-                            alias.getJavaMethodName(),\n-                            // DATA_TYPE\n-                            ValueInt.get(DataType.convertTypeToSQLType(method.getDataType())),\n-                            // TYPE_NAME\n-                            DataType.getDataType(method.getDataType()).name,\n-                            // COLUMN_COUNT\n-                            ValueInt.get(method.getParameterCount()),\n-                            // RETURNS_RESULT\n-                            ValueShort.get(method.getDataType() == Value.NULL\n-                                    ? (short) DatabaseMetaData.procedureNoResult\n-                                    : (short) DatabaseMetaData.procedureReturnsResult),\n-                            // REMARKS\n-                            replaceNullWithEmpty(alias.getComment()),\n-                            // ID\n-                            ValueInt.get(alias.getId()),\n-                            // SOURCE\n-                            alias.getSource()\n-                            // when adding more columns, see also below\n-                    );\n-                }\n+        break;\n+      }\n+      case FUNCTION_ALIASES: {\n+        for (SchemaObject aliasAsSchemaObject :\n+            database.getAllSchemaObjects(DbObject.FUNCTION_ALIAS)) {\n+          FunctionAlias alias = (FunctionAlias) aliasAsSchemaObject;\n+          JavaMethod[] methods;\n+          try {\n+            methods = alias.getJavaMethods();\n+          } catch (DbException e) {\n+            methods = new JavaMethod[0];\n+          }\n+          for (FunctionAlias.JavaMethod method : methods) {\n+            add(rows,\n+                // ALIAS_CATALOG\n+                catalog,\n+                // ALIAS_SCHEMA\n+                alias.getSchema().getName(),\n+                // ALIAS_NAME\n+                alias.getName(),\n+                // JAVA_CLASS\n+                alias.getJavaClassName(),\n+                // JAVA_METHOD\n+                alias.getJavaMethodName(),\n+                // DATA_TYPE\n+                ValueInt\n+                    .get(DataType.convertTypeToSQLType(method.getDataType())),\n+                // TYPE_NAME\n+                DataType.getDataType(method.getDataType()).name,\n+                // COLUMN_COUNT\n+                ValueInt.get(method.getParameterCount()),\n+                // RETURNS_RESULT\n+                ValueShort.get(method.getDataType() == Value.NULL\n+                    ? (short) DatabaseMetaData.procedureNoResult\n+                    : (short) DatabaseMetaData.procedureReturnsResult),\n+                // REMARKS\n+                replaceNullWithEmpty(alias.getComment()),\n+                // ID\n+                ValueInt.get(alias.getId()),\n+                // SOURCE\n+                alias.getSource()\n+                // when adding more columns, see also below\n+            );\n+          }\n+        }\n+        for (UserAggregate agg : database.getAllAggregates()) {\n+          add(rows,\n+              // ALIAS_CATALOG\n+              catalog,\n+              // ALIAS_SCHEMA\n+              database.getMainSchema().getName(),\n+              // ALIAS_NAME\n+              agg.getName(),\n+              // JAVA_CLASS\n+              agg.getJavaClassName(),\n+              // JAVA_METHOD\n+              \"\",\n+              // DATA_TYPE\n+              ValueInt.get(Types.NULL),\n+              // TYPE_NAME\n+              DataType.getDataType(Value.NULL).name,\n+              // COLUMN_COUNT\n+              ValueInt.get(1),\n+              // RETURNS_RESULT\n+              ValueShort.get((short) DatabaseMetaData.procedureReturnsResult),\n+              // REMARKS\n+              replaceNullWithEmpty(agg.getComment()),\n+              // ID\n+              ValueInt.get(agg.getId()),\n+              // SOURCE\n+              \"\"\n+              // when adding more columns, see also below\n+          );\n+        }\n+        break;\n+      }\n+      case FUNCTION_COLUMNS: {\n+        for (SchemaObject aliasAsSchemaObject :\n+            database.getAllSchemaObjects(DbObject.FUNCTION_ALIAS)) {\n+          FunctionAlias alias = (FunctionAlias) aliasAsSchemaObject;\n+          JavaMethod[] methods;\n+          try {\n+            methods = alias.getJavaMethods();\n+          } catch (DbException e) {\n+            methods = new JavaMethod[0];\n+          }\n+          for (FunctionAlias.JavaMethod method : methods) {\n+            // Add return column index 0\n+            if (method.getDataType() != Value.NULL) {\n+              DataType dt = DataType.getDataType(method.getDataType());\n+              add(rows,\n+                  // ALIAS_CATALOG\n+                  catalog,\n+                  // ALIAS_SCHEMA\n+                  alias.getSchema().getName(),\n+                  // ALIAS_NAME\n+                  alias.getName(),\n+                  // JAVA_CLASS\n+                  alias.getJavaClassName(),\n+                  // JAVA_METHOD\n+                  alias.getJavaMethodName(),\n+                  // COLUMN_COUNT\n+                  ValueInt.get(method.getParameterCount()),\n+                  // POS\n+                  ValueInt.get(0),\n+                  // COLUMN_NAME\n+                  \"P0\",\n+                  // DATA_TYPE\n+                  ValueInt\n+                      .get(DataType.convertTypeToSQLType(method.getDataType())),\n+                  // TYPE_NAME\n+                  dt.name,\n+                  // PRECISION\n+                  ValueInt.get(MathUtils.convertLongToInt(dt.defaultPrecision)),\n+                  // SCALE\n+                  ValueShort.get((short) dt.defaultScale),\n+                  // RADIX\n+                  ValueShort.get((short) 10),\n+                  // NULLABLE\n+                  ValueShort\n+                      .get((short) DatabaseMetaData.columnNullableUnknown),\n+                  // COLUMN_TYPE\n+                  ValueShort\n+                      .get((short) DatabaseMetaData.procedureColumnReturn),\n+                  // REMARKS\n+                  \"\",\n+                  // COLUMN_DEFAULT\n+                  null\n+              );\n             }\n-            for (UserAggregate agg : database.getAllAggregates()) {\n-                add(rows,\n-                        // ALIAS_CATALOG\n-                        catalog,\n-                        // ALIAS_SCHEMA\n-                        database.getMainSchema().getName(),\n-                        // ALIAS_NAME\n-                        agg.getName(),\n-                        // JAVA_CLASS\n-                        agg.getJavaClassName(),\n-                        // JAVA_METHOD\n-                        \"\",\n-                        // DATA_TYPE\n-                        ValueInt.get(Types.NULL),\n-                        // TYPE_NAME\n-                        DataType.getDataType(Value.NULL).name,\n-                        // COLUMN_COUNT\n-                        ValueInt.get(1),\n-                        // RETURNS_RESULT\n-                        ValueShort.get((short) DatabaseMetaData.procedureReturnsResult),\n-                        // REMARKS\n-                        replaceNullWithEmpty(agg.getComment()),\n-                        // ID\n-                        ValueInt.get(agg.getId()),\n-                        // SOURCE\n-                        \"\"\n-                        // when adding more columns, see also below\n-                );\n+            Class<?>[] columnList = method.getColumnClasses();\n+            for (int k = 0; k < columnList.length; k++) {\n+              if (method.hasConnectionParam() && k == 0) {\n+                continue;\n+              }\n+              Class<?> clazz = columnList[k];\n+              int dataType = DataType.getTypeFromClass(clazz);\n+              DataType dt = DataType.getDataType(dataType);\n+              add(rows,\n+                  // ALIAS_CATALOG\n+                  catalog,\n+                  // ALIAS_SCHEMA\n+                  alias.getSchema().getName(),\n+                  // ALIAS_NAME\n+                  alias.getName(),\n+                  // JAVA_CLASS\n+                  alias.getJavaClassName(),\n+                  // JAVA_METHOD\n+                  alias.getJavaMethodName(),\n+                  // COLUMN_COUNT\n+                  ValueInt.get(method.getParameterCount()),\n+                  // POS\n+                  ValueInt.get(k + (method.hasConnectionParam() ? 0 : 1)),\n+                  // COLUMN_NAME\n+                  \"P\" + (k + 1),\n+                  // DATA_TYPE\n+                  ValueInt.get(DataType.convertTypeToSQLType(dt.type)),\n+                  // TYPE_NAME\n+                  dt.name,\n+                  // PRECISION\n+                  ValueInt.get(MathUtils.convertLongToInt(dt.defaultPrecision)),\n+                  // SCALE\n+                  ValueShort.get((short) dt.defaultScale),\n+                  // RADIX\n+                  ValueShort.get((short) 10),\n+                  // NULLABLE\n+                  ValueShort.get(clazz.isPrimitive()\n+                      ? (short) DatabaseMetaData.columnNoNulls\n+                      : (short) DatabaseMetaData.columnNullable),\n+                  // COLUMN_TYPE\n+                  ValueShort.get((short) DatabaseMetaData.procedureColumnIn),\n+                  // REMARKS\n+                  \"\",\n+                  // COLUMN_DEFAULT\n+                  null\n+              );\n             }\n-            break;\n+          }\n         }\n-        case FUNCTION_COLUMNS: {\n-            for (SchemaObject aliasAsSchemaObject :\n-                    database.getAllSchemaObjects(DbObject.FUNCTION_ALIAS)) {\n-                FunctionAlias alias = (FunctionAlias) aliasAsSchemaObject;\n-                JavaMethod[] methods;\n-                try {\n-                    methods = alias.getJavaMethods();\n-                } catch (DbException e) {\n-                    methods = new JavaMethod[0];\n-                }\n-                for (FunctionAlias.JavaMethod method : methods) {\n-                    // Add return column index 0\n-                    if (method.getDataType() != Value.NULL) {\n-                        DataType dt = DataType.getDataType(method.getDataType());\n-                        add(rows,\n-                                // ALIAS_CATALOG\n-                                catalog,\n-                                // ALIAS_SCHEMA\n-                                alias.getSchema().getName(),\n-                                // ALIAS_NAME\n-                                alias.getName(),\n-                                // JAVA_CLASS\n-                                alias.getJavaClassName(),\n-                                // JAVA_METHOD\n-                                alias.getJavaMethodName(),\n-                                // COLUMN_COUNT\n-                                ValueInt.get(method.getParameterCount()),\n-                                // POS\n-                                ValueInt.get(0),\n-                                // COLUMN_NAME\n-                                \"P0\",\n-                                // DATA_TYPE\n-                                ValueInt.get(DataType.convertTypeToSQLType(method.getDataType())),\n-                                // TYPE_NAME\n-                                dt.name,\n-                                // PRECISION\n-                                ValueInt.get(MathUtils.convertLongToInt(dt.defaultPrecision)),\n-                                // SCALE\n-                                ValueShort.get((short) dt.defaultScale),\n-                                // RADIX\n-                                ValueShort.get((short) 10),\n-                                // NULLABLE\n-                                ValueShort.get((short) DatabaseMetaData.columnNullableUnknown),\n-                                // COLUMN_TYPE\n-                                ValueShort.get((short) DatabaseMetaData.procedureColumnReturn),\n-                                // REMARKS\n-                                \"\",\n-                                // COLUMN_DEFAULT\n-                                null\n-                        );\n-                    }\n-                    Class<?>[] columnList = method.getColumnClasses();\n-                    for (int k = 0; k < columnList.length; k++) {\n-                        if (method.hasConnectionParam() && k == 0) {\n-                            continue;\n-                        }\n-                        Class<?> clazz = columnList[k];\n-                        int dataType = DataType.getTypeFromClass(clazz);\n-                        DataType dt = DataType.getDataType(dataType);\n-                        add(rows,\n-                                // ALIAS_CATALOG\n-                                catalog,\n-                                // ALIAS_SCHEMA\n-                                alias.getSchema().getName(),\n-                                // ALIAS_NAME\n-                                alias.getName(),\n-                                // JAVA_CLASS\n-                                alias.getJavaClassName(),\n-                                // JAVA_METHOD\n-                                alias.getJavaMethodName(),\n-                                // COLUMN_COUNT\n-                                ValueInt.get(method.getParameterCount()),\n-                                // POS\n-                                ValueInt.get(k + (method.hasConnectionParam() ? 0 : 1)),\n-                                // COLUMN_NAME\n-                                \"P\" + (k + 1),\n-                                // DATA_TYPE\n-                                ValueInt.get(DataType.convertTypeToSQLType(dt.type)),\n-                                // TYPE_NAME\n-                                dt.name,\n-                                // PRECISION\n-                                ValueInt.get(MathUtils.convertLongToInt(dt.defaultPrecision)),\n-                                // SCALE\n-                                ValueShort.get((short) dt.defaultScale),\n-                                // RADIX\n-                                ValueShort.get((short) 10),\n-                                // NULLABLE\n-                                ValueShort.get(clazz.isPrimitive()\n-                                        ? (short) DatabaseMetaData.columnNoNulls\n-                                        : (short) DatabaseMetaData.columnNullable),\n-                                // COLUMN_TYPE\n-                                ValueShort.get((short) DatabaseMetaData.procedureColumnIn),\n-                                // REMARKS\n-                                \"\",\n-                                // COLUMN_DEFAULT\n-                                null\n-                        );\n-                    }\n-                }\n-            }\n-            break;\n+        break;\n+      }\n+      case SCHEMATA: {\n+        String collation = database.getCompareMode().getName();\n+        for (Schema schema : database.getAllSchemas()) {\n+          add(rows,\n+              // CATALOG_NAME\n+              catalog,\n+              // SCHEMA_NAME\n+              schema.getName(),\n+              // SCHEMA_OWNER\n+              identifier(schema.getOwner().getName()),\n+              // DEFAULT_CHARACTER_SET_NAME\n+              CHARACTER_SET_NAME,\n+              // DEFAULT_COLLATION_NAME\n+              collation,\n+              // IS_DEFAULT\n+              ValueBoolean.get(schema.getId() == Constants.MAIN_SCHEMA_ID),\n+              // REMARKS\n+              replaceNullWithEmpty(schema.getComment()),\n+              // ID\n+              ValueInt.get(schema.getId())\n+          );\n         }\n-        case SCHEMATA: {\n-            String collation = database.getCompareMode().getName();\n-            for (Schema schema : database.getAllSchemas()) {\n-                add(rows,\n-                        // CATALOG_NAME\n-                        catalog,\n-                        // SCHEMA_NAME\n-                        schema.getName(),\n-                        // SCHEMA_OWNER\n-                        identifier(schema.getOwner().getName()),\n-                        // DEFAULT_CHARACTER_SET_NAME\n-                        CHARACTER_SET_NAME,\n-                        // DEFAULT_COLLATION_NAME\n-                        collation,\n-                        // IS_DEFAULT\n-                        ValueBoolean.get(schema.getId() == Constants.MAIN_SCHEMA_ID),\n-                        // REMARKS\n-                        replaceNullWithEmpty(schema.getComment()),\n-                        // ID\n-                        ValueInt.get(schema.getId())\n-                );\n-            }\n-            break;\n+        break;\n+      }\n+      case TABLE_PRIVILEGES: {\n+        for (Right r : database.getAllRights()) {\n+          DbObject object = r.getGrantedObject();\n+          if (!(object instanceof Table)) {\n+            continue;\n+          }\n+          Table table = (Table) object;\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          addPrivileges(rows, r.getGrantee(), catalog, table, null,\n+              r.getRightMask());\n         }\n-        case TABLE_PRIVILEGES: {\n-            for (Right r : database.getAllRights()) {\n-                DbObject object = r.getGrantedObject();\n-                if (!(object instanceof Table)) {\n-                    continue;\n-                }\n-                Table table = (Table) object;\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                addPrivileges(rows, r.getGrantee(), catalog, table, null,\n-                        r.getRightMask());\n-            }\n-            break;\n+        break;\n+      }\n+      case COLUMN_PRIVILEGES: {\n+        for (Right r : database.getAllRights()) {\n+          DbObject object = r.getGrantedObject();\n+          if (!(object instanceof Table)) {\n+            continue;\n+          }\n+          Table table = (Table) object;\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          DbObject grantee = r.getGrantee();\n+          int mask = r.getRightMask();\n+          for (Column column : table.getColumns()) {\n+            addPrivileges(rows, grantee, catalog, table,\n+                column.getName(), mask);\n+          }\n         }\n-        case COLUMN_PRIVILEGES: {\n-            for (Right r : database.getAllRights()) {\n-                DbObject object = r.getGrantedObject();\n-                if (!(object instanceof Table)) {\n-                    continue;\n-                }\n-                Table table = (Table) object;\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                DbObject grantee = r.getGrantee();\n-                int mask = r.getRightMask();\n-                for (Column column : table.getColumns()) {\n-                    addPrivileges(rows, grantee, catalog, table,\n-                            column.getName(), mask);\n-                }\n-            }\n-            break;\n+        break;\n+      }\n+      case COLLATIONS: {\n+        for (Locale l : Collator.getAvailableLocales()) {\n+          add(rows,\n+              // NAME\n+              CompareMode.getName(l),\n+              // KEY\n+              l.toString()\n+          );\n         }\n-        case COLLATIONS: {\n-            for (Locale l : Collator.getAvailableLocales()) {\n-                add(rows,\n-                        // NAME\n-                        CompareMode.getName(l),\n-                        // KEY\n-                        l.toString()\n-                );\n-            }\n-            break;\n+        break;\n+      }\n+      case VIEWS: {\n+        for (Table table : getAllTables(session)) {\n+          if (table.getTableType() != TableType.VIEW) {\n+            continue;\n+          }\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          TableView view = (TableView) table;\n+          add(rows,\n+              // TABLE_CATALOG\n+              catalog,\n+              // TABLE_SCHEMA\n+              table.getSchema().getName(),\n+              // TABLE_NAME\n+              tableName,\n+              // VIEW_DEFINITION\n+              table.getCreateSQL(),\n+              // CHECK_OPTION\n+              \"NONE\",\n+              // IS_UPDATABLE\n+              \"NO\",\n+              // STATUS\n+              view.isInvalid() ? \"INVALID\" : \"VALID\",\n+              // REMARKS\n+              replaceNullWithEmpty(view.getComment()),\n+              // ID\n+              ValueInt.get(view.getId())\n+          );\n         }\n-        case VIEWS: {\n-            for (Table table : getAllTables(session)) {\n-                if (table.getTableType() != TableType.VIEW) {\n-                    continue;\n-                }\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                TableView view = (TableView) table;\n-                add(rows,\n-                        // TABLE_CATALOG\n-                        catalog,\n-                        // TABLE_SCHEMA\n-                        table.getSchema().getName(),\n-                        // TABLE_NAME\n-                        tableName,\n-                        // VIEW_DEFINITION\n-                        table.getCreateSQL(),\n-                        // CHECK_OPTION\n-                        \"NONE\",\n-                        // IS_UPDATABLE\n-                        \"NO\",\n-                        // STATUS\n-                        view.isInvalid() ? \"INVALID\" : \"VALID\",\n-                        // REMARKS\n-                        replaceNullWithEmpty(view.getComment()),\n-                        // ID\n-                        ValueInt.get(view.getId())\n-                );\n-            }\n-            break;\n+        break;\n+      }\n+      case IN_DOUBT: {\n+        ArrayList<InDoubtTransaction> prepared =\n+            database.getInDoubtTransactions();\n+        if (prepared != null && admin) {\n+          for (InDoubtTransaction prep : prepared) {\n+            add(rows,\n+                // TRANSACTION\n+                prep.getTransactionName(),\n+                // STATE\n+                prep.getState()\n+            );\n+          }\n         }\n-        case IN_DOUBT: {\n-            ArrayList<InDoubtTransaction> prepared = database.getInDoubtTransactions();\n-            if (prepared != null && admin) {\n-                for (InDoubtTransaction prep : prepared) {\n-                    add(rows,\n-                            // TRANSACTION\n-                            prep.getTransactionName(),\n-                            // STATE\n-                            prep.getState()\n-                    );\n-                }\n-            }\n-            break;\n+        break;\n+      }\n+      case CROSS_REFERENCES: {\n+        for (SchemaObject obj : database.getAllSchemaObjects(\n+            DbObject.CONSTRAINT)) {\n+          Constraint constraint = (Constraint) obj;\n+          if (constraint.getConstraintType() != Constraint.Type.REFERENTIAL) {\n+            continue;\n+          }\n+          ConstraintReferential ref = (ConstraintReferential) constraint;\n+          IndexColumn[] cols = ref.getColumns();\n+          IndexColumn[] refCols = ref.getRefColumns();\n+          Table tab = ref.getTable();\n+          Table refTab = ref.getRefTable();\n+          String tableName = refTab.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          ValueShort update =\n+              ValueShort.get(getRefAction(ref.getUpdateAction()));\n+          ValueShort delete =\n+              ValueShort.get(getRefAction(ref.getDeleteAction()));\n+          for (int j = 0; j < cols.length; j++) {\n+            add(rows,\n+                // PKTABLE_CATALOG\n+                catalog,\n+                // PKTABLE_SCHEMA\n+                refTab.getSchema().getName(),\n+                // PKTABLE_NAME\n+                refTab.getName(),\n+                // PKCOLUMN_NAME\n+                refCols[j].column.getName(),\n+                // FKTABLE_CATALOG\n+                catalog,\n+                // FKTABLE_SCHEMA\n+                tab.getSchema().getName(),\n+                // FKTABLE_NAME\n+                tab.getName(),\n+                // FKCOLUMN_NAME\n+                cols[j].column.getName(),\n+                // ORDINAL_POSITION\n+                ValueShort.get((short) (j + 1)),\n+                // UPDATE_RULE\n+                update,\n+                // DELETE_RULE\n+                delete,\n+                // FK_NAME\n+                ref.getName(),\n+                // PK_NAME\n+                ref.getUniqueIndex().getName(),\n+                // DEFERRABILITY\n+                ValueShort\n+                    .get((short) DatabaseMetaData.importedKeyNotDeferrable)\n+            );\n+          }\n         }\n-        case CROSS_REFERENCES: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(\n-                    DbObject.CONSTRAINT)) {\n-                Constraint constraint = (Constraint) obj;\n-                if (constraint.getConstraintType() != Constraint.Type.REFERENTIAL) {\n-                    continue;\n-                }\n-                ConstraintReferential ref = (ConstraintReferential) constraint;\n-                IndexColumn[] cols = ref.getColumns();\n-                IndexColumn[] refCols = ref.getRefColumns();\n-                Table tab = ref.getTable();\n-                Table refTab = ref.getRefTable();\n-                String tableName = refTab.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                ValueShort update = ValueShort.get(getRefAction(ref.getUpdateAction()));\n-                ValueShort delete = ValueShort.get(getRefAction(ref.getDeleteAction()));\n-                for (int j = 0; j < cols.length; j++) {\n-                    add(rows,\n-                            // PKTABLE_CATALOG\n-                            catalog,\n-                            // PKTABLE_SCHEMA\n-                            refTab.getSchema().getName(),\n-                            // PKTABLE_NAME\n-                            refTab.getName(),\n-                            // PKCOLUMN_NAME\n-                            refCols[j].column.getName(),\n-                            // FKTABLE_CATALOG\n-                            catalog,\n-                            // FKTABLE_SCHEMA\n-                            tab.getSchema().getName(),\n-                            // FKTABLE_NAME\n-                            tab.getName(),\n-                            // FKCOLUMN_NAME\n-                            cols[j].column.getName(),\n-                            // ORDINAL_POSITION\n-                            ValueShort.get((short) (j + 1)),\n-                            // UPDATE_RULE\n-                            update,\n-                            // DELETE_RULE\n-                            delete,\n-                            // FK_NAME\n-                            ref.getName(),\n-                            // PK_NAME\n-                            ref.getUniqueIndex().getName(),\n-                            // DEFERRABILITY\n-                            ValueShort.get((short) DatabaseMetaData.importedKeyNotDeferrable)\n-                    );\n-                }\n+        break;\n+      }\n+      case CONSTRAINTS: {\n+        for (SchemaObject obj : database.getAllSchemaObjects(\n+            DbObject.CONSTRAINT)) {\n+          Constraint constraint = (Constraint) obj;\n+          Constraint.Type constraintType = constraint.getConstraintType();\n+          String checkExpression = null;\n+          IndexColumn[] indexColumns = null;\n+          Table table = constraint.getTable();\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          Index index = constraint.getUniqueIndex();\n+          String uniqueIndexName = null;\n+          if (index != null) {\n+            uniqueIndexName = index.getName();\n+          }\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          if (constraintType == Constraint.Type.CHECK) {\n+            checkExpression =\n+                ((ConstraintCheck) constraint).getExpression().getSQL(true);\n+          } else if (constraintType == Constraint.Type.UNIQUE ||\n+              constraintType == Constraint.Type.PRIMARY_KEY) {\n+            indexColumns = ((ConstraintUnique) constraint).getColumns();\n+          } else if (constraintType == Constraint.Type.REFERENTIAL) {\n+            indexColumns = ((ConstraintReferential) constraint).getColumns();\n+          }\n+          String columnList = null;\n+          if (indexColumns != null) {\n+            StringBuilder builder = new StringBuilder();\n+            for (int i = 0, length = indexColumns.length; i < length; i++) {\n+              if (i > 0) {\n+                builder.append(',');\n+              }\n+              builder.append(indexColumns[i].column.getName());\n             }\n-            break;\n+            columnList = builder.toString();\n+          }\n+          add(rows,\n+              // CONSTRAINT_CATALOG\n+              catalog,\n+              // CONSTRAINT_SCHEMA\n+              constraint.getSchema().getName(),\n+              // CONSTRAINT_NAME\n+              constraint.getName(),\n+              // CONSTRAINT_TYPE\n+              constraintType == Constraint.Type.PRIMARY_KEY ?\n+                  constraintType.getSqlName() : constraintType.name(),\n+              // TABLE_CATALOG\n+              catalog,\n+              // TABLE_SCHEMA\n+              table.getSchema().getName(),\n+              // TABLE_NAME\n+              tableName,\n+              // UNIQUE_INDEX_NAME\n+              uniqueIndexName,\n+              // CHECK_EXPRESSION\n+              checkExpression,\n+              // COLUMN_LIST\n+              columnList,\n+              // REMARKS\n+              replaceNullWithEmpty(constraint.getComment()),\n+              // SQL\n+              constraint.getCreateSQL(),\n+              // ID\n+              ValueInt.get(constraint.getId())\n+          );\n         }\n-        case CONSTRAINTS: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(\n-                    DbObject.CONSTRAINT)) {\n-                Constraint constraint = (Constraint) obj;\n-                Constraint.Type constraintType = constraint.getConstraintType();\n-                String checkExpression = null;\n-                IndexColumn[] indexColumns = null;\n-                Table table = constraint.getTable();\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                Index index = constraint.getUniqueIndex();\n-                String uniqueIndexName = null;\n-                if (index != null) {\n-                    uniqueIndexName = index.getName();\n-                }\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                if (constraintType == Constraint.Type.CHECK) {\n-                    checkExpression = ((ConstraintCheck) constraint).getExpression().getSQL(true);\n-                } else if (constraintType == Constraint.Type.UNIQUE ||\n-                        constraintType == Constraint.Type.PRIMARY_KEY) {\n-                    indexColumns = ((ConstraintUnique) constraint).getColumns();\n-                } else if (constraintType == Constraint.Type.REFERENTIAL) {\n-                    indexColumns = ((ConstraintReferential) constraint).getColumns();\n-                }\n-                String columnList = null;\n-                if (indexColumns != null) {\n-                    StringBuilder builder = new StringBuilder();\n-                    for (int i = 0, length = indexColumns.length; i < length; i++) {\n-                        if (i > 0) {\n-                            builder.append(',');\n-                        }\n-                        builder.append(indexColumns[i].column.getName());\n-                    }\n-                    columnList = builder.toString();\n-                }\n-                add(rows,\n-                        // CONSTRAINT_CATALOG\n-                        catalog,\n-                        // CONSTRAINT_SCHEMA\n-                        constraint.getSchema().getName(),\n-                        // CONSTRAINT_NAME\n-                        constraint.getName(),\n-                        // CONSTRAINT_TYPE\n-                        constraintType == Constraint.Type.PRIMARY_KEY ?\n-                                constraintType.getSqlName() : constraintType.name(),\n-                        // TABLE_CATALOG\n-                        catalog,\n-                        // TABLE_SCHEMA\n-                        table.getSchema().getName(),\n-                        // TABLE_NAME\n-                        tableName,\n-                        // UNIQUE_INDEX_NAME\n-                        uniqueIndexName,\n-                        // CHECK_EXPRESSION\n-                        checkExpression,\n-                        // COLUMN_LIST\n-                        columnList,\n-                        // REMARKS\n-                        replaceNullWithEmpty(constraint.getComment()),\n-                        // SQL\n-                        constraint.getCreateSQL(),\n-                        // ID\n-                        ValueInt.get(constraint.getId())\n-                    );\n-            }\n-            break;\n+        break;\n+      }\n+      case CONSTANTS: {\n+        for (SchemaObject obj : database.getAllSchemaObjects(\n+            DbObject.CONSTANT)) {\n+          Constant constant = (Constant) obj;\n+          ValueExpression expr = constant.getValue();\n+          add(rows,\n+              // CONSTANT_CATALOG\n+              catalog,\n+              // CONSTANT_SCHEMA\n+              constant.getSchema().getName(),\n+              // CONSTANT_NAME\n+              constant.getName(),\n+              // DATA_TYPE\n+              ValueInt.get(\n+                  DataType.convertTypeToSQLType(expr.getType().getValueType())),\n+              // REMARKS\n+              replaceNullWithEmpty(constant.getComment()),\n+              // SQL\n+              expr.getSQL(true),\n+              // ID\n+              ValueInt.get(constant.getId())\n+          );\n         }\n-        case CONSTANTS: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(\n-                    DbObject.CONSTANT)) {\n-                Constant constant = (Constant) obj;\n-                ValueExpression expr = constant.getValue();\n-                add(rows,\n-                        // CONSTANT_CATALOG\n-                        catalog,\n-                        // CONSTANT_SCHEMA\n-                        constant.getSchema().getName(),\n-                        // CONSTANT_NAME\n-                        constant.getName(),\n-                        // DATA_TYPE\n-                        ValueInt.get(DataType.convertTypeToSQLType(expr.getType().getValueType())),\n-                        // REMARKS\n-                        replaceNullWithEmpty(constant.getComment()),\n-                        // SQL\n-                        expr.getSQL(true),\n-                        // ID\n-                        ValueInt.get(constant.getId())\n-                    );\n-            }\n-            break;\n+        break;\n+      }\n+      case DOMAINS: {\n+        for (Domain dt : database.getAllDomains()) {\n+          Column col = dt.getColumn();\n+          add(rows,\n+              // DOMAIN_CATALOG\n+              catalog,\n+              // DOMAIN_SCHEMA\n+              database.getMainSchema().getName(),\n+              // DOMAIN_NAME\n+              dt.getName(),\n+              // COLUMN_DEFAULT\n+              col.getDefaultSQL(),\n+              // IS_NULLABLE\n+              col.isNullable() ? \"YES\" : \"NO\",\n+              // DATA_TYPE\n+              ValueInt.get(col.getDataType().sqlType),\n+              // PRECISION\n+              ValueInt.get(col.getPrecisionAsInt()),\n+              // SCALE\n+              ValueInt.get(col.getType().getScale()),\n+              // TYPE_NAME\n+              col.getDataType().name,\n+              // SELECTIVITY INT\n+              ValueInt.get(col.getSelectivity()),\n+              // CHECK_CONSTRAINT\n+              col.getCheckConstraintSQL(session, \"VALUE\"),\n+              // REMARKS\n+              replaceNullWithEmpty(dt.getComment()),\n+              // SQL\n+              dt.getCreateSQL(),\n+              // ID\n+              ValueInt.get(dt.getId())\n+          );\n         }\n-        case DOMAINS: {\n-            for (Domain dt : database.getAllDomains()) {\n-                Column col = dt.getColumn();\n-                add(rows,\n-                        // DOMAIN_CATALOG\n-                        catalog,\n-                        // DOMAIN_SCHEMA\n-                        database.getMainSchema().getName(),\n-                        // DOMAIN_NAME\n-                        dt.getName(),\n-                        // COLUMN_DEFAULT\n-                        col.getDefaultSQL(),\n-                        // IS_NULLABLE\n-                        col.isNullable() ? \"YES\" : \"NO\",\n-                        // DATA_TYPE\n-                        ValueInt.get(col.getDataType().sqlType),\n-                        // PRECISION\n-                        ValueInt.get(col.getPrecisionAsInt()),\n-                        // SCALE\n-                        ValueInt.get(col.getType().getScale()),\n-                        // TYPE_NAME\n-                        col.getDataType().name,\n-                        // SELECTIVITY INT\n-                        ValueInt.get(col.getSelectivity()),\n-                        // CHECK_CONSTRAINT\n-                        col.getCheckConstraintSQL(session, \"VALUE\"),\n-                        // REMARKS\n-                        replaceNullWithEmpty(dt.getComment()),\n-                        // SQL\n-                        dt.getCreateSQL(),\n-                        // ID\n-                        ValueInt.get(dt.getId())\n-                );\n-            }\n-            break;\n+        break;\n+      }\n+      case TRIGGERS: {\n+        for (SchemaObject obj : database.getAllSchemaObjects(\n+            DbObject.TRIGGER)) {\n+          TriggerObject trigger = (TriggerObject) obj;\n+          Table table = trigger.getTable();\n+          add(rows,\n+              // TRIGGER_CATALOG\n+              catalog,\n+              // TRIGGER_SCHEMA\n+              trigger.getSchema().getName(),\n+              // TRIGGER_NAME\n+              trigger.getName(),\n+              // TRIGGER_TYPE\n+              trigger.getTypeNameList(new StringBuilder()).toString(),\n+              // TABLE_CATALOG\n+              catalog,\n+              // TABLE_SCHEMA\n+              table.getSchema().getName(),\n+              // TABLE_NAME\n+              table.getName(),\n+              // BEFORE\n+              ValueBoolean.get(trigger.isBefore()),\n+              // JAVA_CLASS\n+              trigger.getTriggerClassName(),\n+              // QUEUE_SIZE\n+              ValueInt.get(trigger.getQueueSize()),\n+              // NO_WAIT\n+              ValueBoolean.get(trigger.isNoWait()),\n+              // REMARKS\n+              replaceNullWithEmpty(trigger.getComment()),\n+              // SQL\n+              trigger.getCreateSQL(),\n+              // ID\n+              ValueInt.get(trigger.getId())\n+          );\n         }\n-        case TRIGGERS: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(\n-                    DbObject.TRIGGER)) {\n-                TriggerObject trigger = (TriggerObject) obj;\n-                Table table = trigger.getTable();\n-                add(rows,\n-                        // TRIGGER_CATALOG\n-                        catalog,\n-                        // TRIGGER_SCHEMA\n-                        trigger.getSchema().getName(),\n-                        // TRIGGER_NAME\n-                        trigger.getName(),\n-                        // TRIGGER_TYPE\n-                        trigger.getTypeNameList(new StringBuilder()).toString(),\n-                        // TABLE_CATALOG\n-                        catalog,\n-                        // TABLE_SCHEMA\n-                        table.getSchema().getName(),\n-                        // TABLE_NAME\n-                        table.getName(),\n-                        // BEFORE\n-                        ValueBoolean.get(trigger.isBefore()),\n-                        // JAVA_CLASS\n-                        trigger.getTriggerClassName(),\n-                        // QUEUE_SIZE\n-                        ValueInt.get(trigger.getQueueSize()),\n-                        // NO_WAIT\n-                        ValueBoolean.get(trigger.isNoWait()),\n-                        // REMARKS\n-                        replaceNullWithEmpty(trigger.getComment()),\n-                        // SQL\n-                        trigger.getCreateSQL(),\n-                        // ID\n-                        ValueInt.get(trigger.getId())\n-                );\n-            }\n-            break;\n+        break;\n+      }\n+      case SESSIONS: {\n+        for (Session s : database.getSessions(false)) {\n+          if (admin || s == session) {\n+            NetworkConnectionInfo networkConnectionInfo =\n+                s.getNetworkConnectionInfo();\n+            Command command = s.getCurrentCommand();\n+            int blockingSessionId = s.getBlockingSessionId();\n+            add(rows,\n+                // ID\n+                ValueInt.get(s.getId()),\n+                // USER_NAME\n+                s.getUser().getName(),\n+                // SERVER\n+                networkConnectionInfo == null ? null :\n+                    networkConnectionInfo.getServer(),\n+                // CLIENT_ADDR\n+                networkConnectionInfo == null ? null :\n+                    networkConnectionInfo.getClient(),\n+                // CLIENT_INFO\n+                networkConnectionInfo == null ? null :\n+                    networkConnectionInfo.getClientInfo(),\n+                // SESSION_START\n+                DateTimeUtils.timestampTimeZoneFromMillis(s.getSessionStart()),\n+                // ISOLATION_LEVEL\n+                session.getIsolationLevel().getSQL(),\n+                // STATEMENT\n+                command == null ? null : command.toString(),\n+                // STATEMENT_START\n+                command == null ? null : s.getCurrentCommandStart(),\n+                // CONTAINS_UNCOMMITTED\n+                ValueBoolean.get(s.containsUncommitted()),\n+                // STATE\n+                String.valueOf(s.getState()),\n+                // BLOCKER_ID\n+                blockingSessionId == 0 ? null : ValueInt.get(blockingSessionId)\n+            );\n+          }\n         }\n-        case SESSIONS: {\n-            for (Session s : database.getSessions(false)) {\n-                if (admin || s == session) {\n-                    NetworkConnectionInfo networkConnectionInfo = s.getNetworkConnectionInfo();\n-                    Command command = s.getCurrentCommand();\n-                    int blockingSessionId = s.getBlockingSessionId();\n-                    add(rows,\n-                            // ID\n-                            ValueInt.get(s.getId()),\n-                            // USER_NAME\n-                            s.getUser().getName(),\n-                            // SERVER\n-                            networkConnectionInfo == null ? null : networkConnectionInfo.getServer(),\n-                            // CLIENT_ADDR\n-                            networkConnectionInfo == null ? null : networkConnectionInfo.getClient(),\n-                            // CLIENT_INFO\n-                            networkConnectionInfo == null ? null : networkConnectionInfo.getClientInfo(),\n-                            // SESSION_START\n-                            DateTimeUtils.timestampTimeZoneFromMillis(s.getSessionStart()),\n-                            // ISOLATION_LEVEL\n-                            session.getIsolationLevel().getSQL(),\n-                            // STATEMENT\n-                            command == null ? null : command.toString(),\n-                            // STATEMENT_START\n-                            command == null ? null : s.getCurrentCommandStart(),\n-                            // CONTAINS_UNCOMMITTED\n-                            ValueBoolean.get(s.containsUncommitted()),\n-                            // STATE\n-                            String.valueOf(s.getState()),\n-                            // BLOCKER_ID\n-                            blockingSessionId == 0 ? null : ValueInt.get(blockingSessionId)\n-                    );\n-                }\n+        break;\n+      }\n+      case LOCKS: {\n+        for (Session s : database.getSessions(false)) {\n+          if (admin || s == session) {\n+            for (Table table : s.getLocks()) {\n+              add(rows,\n+                  // TABLE_SCHEMA\n+                  table.getSchema().getName(),\n+                  // TABLE_NAME\n+                  table.getName(),\n+                  // SESSION_ID\n+                  ValueInt.get(s.getId()),\n+                  // LOCK_TYPE\n+                  table.isLockedExclusivelyBy(s) ? \"WRITE\" : \"READ\"\n+              );\n             }\n-            break;\n+          }\n         }\n-        case LOCKS: {\n-            for (Session s : database.getSessions(false)) {\n-                if (admin || s == session) {\n-                    for (Table table : s.getLocks()) {\n-                        add(rows,\n-                                // TABLE_SCHEMA\n-                                table.getSchema().getName(),\n-                                // TABLE_NAME\n-                                table.getName(),\n-                                // SESSION_ID\n-                                ValueInt.get(s.getId()),\n-                                // LOCK_TYPE\n-                                table.isLockedExclusivelyBy(s) ? \"WRITE\" : \"READ\"\n-                        );\n-                    }\n-                }\n-            }\n-            break;\n+        break;\n+      }\n+      case SESSION_STATE: {\n+        for (String name : session.getVariableNames()) {\n+          Value v = session.getVariable(name);\n+          StringBuilder builder =\n+              new StringBuilder().append(\"SET @\").append(name).append(' ');\n+          v.getSQL(builder);\n+          add(rows,\n+              // KEY\n+              \"@\" + name,\n+              builder.toString()\n+          );\n         }\n-        case SESSION_STATE: {\n-            for (String name : session.getVariableNames()) {\n-                Value v = session.getVariable(name);\n-                StringBuilder builder = new StringBuilder().append(\"SET @\").append(name).append(' ');\n-                v.getSQL(builder);\n-                add(rows,\n-                        // KEY\n-                        \"@\" + name,\n-                        builder.toString()\n-                );\n-            }\n-            for (Table table : session.getLocalTempTables()) {\n-                add(rows,\n-                        // KEY\n-                        \"TABLE \" + table.getName(),\n-                        // SQL\n-                        table.getCreateSQL()\n-                );\n-            }\n-            String[] path = session.getSchemaSearchPath();\n-            if (path != null && path.length > 0) {\n-                StringBuilder builder = new StringBuilder(\"SET SCHEMA_SEARCH_PATH \");\n-                for (int i = 0, l = path.length; i < l; i++) {\n-                    if (i > 0) {\n-                        builder.append(\", \");\n-                    }\n-                    StringUtils.quoteIdentifier(builder, path[i]);\n-                }\n-                add(rows,\n-                        // KEY\n-                        \"SCHEMA_SEARCH_PATH\",\n-                        // SQL\n-                        builder.toString()\n-                );\n-            }\n-            String schema = session.getCurrentSchemaName();\n-            if (schema != null) {\n-                add(rows,\n-                        // KEY\n-                        \"SCHEMA\",\n-                        // SQL\n-                        StringUtils.quoteIdentifier(new StringBuilder(\"SET SCHEMA \"), schema).toString()\n-                );\n-            }\n-            break;\n+        for (Table table : session.getLocalTempTables()) {\n+          add(rows,\n+              // KEY\n+              \"TABLE \" + table.getName(),\n+              // SQL\n+              table.getCreateSQL()\n+          );\n         }\n-        case QUERY_STATISTICS: {\n-            QueryStatisticsData control = database.getQueryStatisticsData();\n-            if (control != null) {\n-                for (QueryStatisticsData.QueryEntry entry : control.getQueries()) {\n-                    add(rows,\n-                            // SQL_STATEMENT\n-                            entry.sqlStatement,\n-                            // EXECUTION_COUNT\n-                            ValueInt.get(entry.count),\n-                            // MIN_EXECUTION_TIME\n-                            ValueDouble.get(entry.executionTimeMinNanos / 1_000_000d),\n-                            // MAX_EXECUTION_TIME\n-                            ValueDouble.get(entry.executionTimeMaxNanos / 1_000_000d),\n-                            // CUMULATIVE_EXECUTION_TIME\n-                            ValueDouble.get(entry.executionTimeCumulativeNanos / 1_000_000d),\n-                            // AVERAGE_EXECUTION_TIME\n-                            ValueDouble.get(entry.executionTimeMeanNanos / 1_000_000d),\n-                            // STD_DEV_EXECUTION_TIME\n-                            ValueDouble.get(entry.getExecutionTimeStandardDeviation() / 1_000_000d),\n-                            // MIN_ROW_COUNT\n-                            ValueInt.get(entry.rowCountMin),\n-                            // MAX_ROW_COUNT\n-                            ValueInt.get(entry.rowCountMax),\n-                            // CUMULATIVE_ROW_COUNT\n-                            ValueLong.get(entry.rowCountCumulative),\n-                            // AVERAGE_ROW_COUNT\n-                            ValueDouble.get(entry.rowCountMean),\n-                            // STD_DEV_ROW_COUNT\n-                            ValueDouble.get(entry.getRowCountStandardDeviation())\n-                    );\n-                }\n+        String[] path = session.getSchemaSearchPath();\n+        if (path != null && path.length > 0) {\n+          StringBuilder builder = new StringBuilder(\"SET SCHEMA_SEARCH_PATH \");\n+          for (int i = 0, l = path.length; i < l; i++) {\n+            if (i > 0) {\n+              builder.append(\", \");\n             }\n-            break;\n+            StringUtils.quoteIdentifier(builder, path[i]);\n+          }\n+          add(rows,\n+              // KEY\n+              \"SCHEMA_SEARCH_PATH\",\n+              // SQL\n+              builder.toString()\n+          );\n         }\n-        case SYNONYMS: {\n-            for (TableSynonym synonym : database.getAllSynonyms()) {\n-                add(rows,\n-                        // SYNONYM_CATALOG\n-                        catalog,\n-                        // SYNONYM_SCHEMA\n-                        synonym.getSchema().getName(),\n-                        // SYNONYM_NAME\n-                        synonym.getName(),\n-                        // SYNONYM_FOR\n-                        synonym.getSynonymForName(),\n-                        // SYNONYM_FOR_SCHEMA\n-                        synonym.getSynonymForSchema().getName(),\n-                        // TYPE NAME\n-                        \"SYNONYM\",\n-                        // STATUS\n-                        \"VALID\",\n-                        // REMARKS\n-                        replaceNullWithEmpty(synonym.getComment()),\n-                        // ID\n-                        ValueInt.get(synonym.getId())\n-                );\n-            }\n-            break;\n+        String schema = session.getCurrentSchemaName();\n+        if (schema != null) {\n+          add(rows,\n+              // KEY\n+              \"SCHEMA\",\n+              // SQL\n+              StringUtils\n+                  .quoteIdentifier(new StringBuilder(\"SET SCHEMA \"), schema)\n+                  .toString()\n+          );\n         }\n-        case TABLE_CONSTRAINTS: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(DbObject.CONSTRAINT)) {\n-                Constraint constraint = (Constraint) obj;\n-                Constraint.Type constraintType = constraint.getConstraintType();\n-                Table table = constraint.getTable();\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                add(rows,\n-                        // CONSTRAINT_CATALOG\n-                        catalog,\n-                        // CONSTRAINT_SCHEMA\n-                        constraint.getSchema().getName(),\n-                        // CONSTRAINT_NAME\n-                        constraint.getName(),\n-                        // CONSTRAINT_TYPE\n-                        constraintType.getSqlName(),\n-                        // TABLE_CATALOG\n-                        catalog,\n-                        // TABLE_SCHEMA\n-                        table.getSchema().getName(),\n-                        // TABLE_NAME\n-                        tableName,\n-                        // IS_DEFERRABLE\n-                        \"NO\",\n-                        // INITIALLY_DEFERRED\n-                        \"NO\"\n-                );\n-            }\n-            break;\n+        break;\n+      }\n+      case QUERY_STATISTICS: {\n+        QueryStatisticsData control = database.getQueryStatisticsData();\n+        if (control != null) {\n+          for (QueryStatisticsData.QueryEntry entry : control.getQueries()) {\n+            add(rows,\n+                // SQL_STATEMENT\n+                entry.sqlStatement,\n+                // EXECUTION_COUNT\n+                ValueInt.get(entry.count),\n+                // MIN_EXECUTION_TIME\n+                ValueDouble.get(entry.executionTimeMinNanos / 1_000_000d),\n+                // MAX_EXECUTION_TIME\n+                ValueDouble.get(entry.executionTimeMaxNanos / 1_000_000d),\n+                // CUMULATIVE_EXECUTION_TIME\n+                ValueDouble\n+                    .get(entry.executionTimeCumulativeNanos / 1_000_000d),\n+                // AVERAGE_EXECUTION_TIME\n+                ValueDouble.get(entry.executionTimeMeanNanos / 1_000_000d),\n+                // STD_DEV_EXECUTION_TIME\n+                ValueDouble.get(\n+                    entry.getExecutionTimeStandardDeviation() / 1_000_000d),\n+                // MIN_ROW_COUNT\n+                ValueInt.get(entry.rowCountMin),\n+                // MAX_ROW_COUNT\n+                ValueInt.get(entry.rowCountMax),\n+                // CUMULATIVE_ROW_COUNT\n+                ValueLong.get(entry.rowCountCumulative),\n+                // AVERAGE_ROW_COUNT\n+                ValueDouble.get(entry.rowCountMean),\n+                // STD_DEV_ROW_COUNT\n+                ValueDouble.get(entry.getRowCountStandardDeviation())\n+            );\n+          }\n         }\n-        case KEY_COLUMN_USAGE: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(DbObject.CONSTRAINT)) {\n-                Constraint constraint = (Constraint) obj;\n-                Constraint.Type constraintType = constraint.getConstraintType();\n-                IndexColumn[] indexColumns = null;\n-                Table table = constraint.getTable();\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                String tableName = table.getName();\n-                if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n-                    continue;\n-                }\n-                if (constraintType == Constraint.Type.UNIQUE ||\n-                        constraintType == Constraint.Type.PRIMARY_KEY) {\n-                    indexColumns = ((ConstraintUnique) constraint).getColumns();\n-                } else if (constraintType == Constraint.Type.REFERENTIAL) {\n-                    indexColumns = ((ConstraintReferential) constraint).getColumns();\n-                }\n-                if (indexColumns == null) {\n-                    continue;\n-                }\n-                ConstraintUnique referenced;\n-                if (constraintType == Constraint.Type.REFERENTIAL) {\n-                    referenced = lookupUniqueForReferential((ConstraintReferential) constraint);\n-                } else {\n-                    referenced = null;\n-                }\n-                for (int i = 0; i < indexColumns.length; i++) {\n-                    IndexColumn indexColumn = indexColumns[i];\n-                    ValueInt ordinalPosition = ValueInt.get(i + 1);\n-                    ValueInt positionInUniqueConstraint;\n-                    if (constraintType == Constraint.Type.REFERENTIAL) {\n-                        positionInUniqueConstraint = ordinalPosition;\n-                        if (referenced != null) {\n-                            Column c = ((ConstraintReferential) constraint).getRefColumns()[i].column;\n-                            IndexColumn[] refColumns = referenced.getColumns();\n-                            for (int j = 0; j < refColumns.length; j++) {\n-                                if (refColumns[j].column.equals(c)) {\n-                                    positionInUniqueConstraint = ValueInt.get(j + 1);\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        positionInUniqueConstraint = null;\n-                    }\n-                    add(rows,\n-                            // CONSTRAINT_CATALOG\n-                            catalog,\n-                            // CONSTRAINT_SCHEMA\n-                            constraint.getSchema().getName(),\n-                            // CONSTRAINT_NAME\n-                            constraint.getName(),\n-                            // TABLE_CATALOG\n-                            catalog,\n-                            // TABLE_SCHEMA\n-                            table.getSchema().getName(),\n-                            // TABLE_NAME\n-                            tableName,\n-                            // COLUMN_NAME\n-                            indexColumn.columnName,\n-                            // ORDINAL_POSITION\n-                            ordinalPosition,\n-                            // POSITION_IN_UNIQUE_CONSTRAINT\n-                            positionInUniqueConstraint\n-                    );\n-                }\n-            }\n-            break;\n+        break;\n+      }\n+      case SYNONYMS: {\n+        for (TableSynonym synonym : database.getAllSynonyms()) {\n+          add(rows,\n+              // SYNONYM_CATALOG\n+              catalog,\n+              // SYNONYM_SCHEMA\n+              synonym.getSchema().getName(),\n+              // SYNONYM_NAME\n+              synonym.getName(),\n+              // SYNONYM_FOR\n+              synonym.getSynonymForName(),\n+              // SYNONYM_FOR_SCHEMA\n+              synonym.getSynonymForSchema().getName(),\n+              // TYPE NAME\n+              \"SYNONYM\",\n+              // STATUS\n+              \"VALID\",\n+              // REMARKS\n+              replaceNullWithEmpty(synonym.getComment()),\n+              // ID\n+              ValueInt.get(synonym.getId())\n+          );\n         }\n-        case REFERENTIAL_CONSTRAINTS: {\n-            for (SchemaObject obj : database.getAllSchemaObjects(DbObject.CONSTRAINT)) {\n-                if (((Constraint) obj).getConstraintType() != Constraint.Type.REFERENTIAL) {\n-                    continue;\n-                }\n-                ConstraintReferential constraint = (ConstraintReferential) obj;\n-                Table table = constraint.getTable();\n-                if (hideTable(table, session)) {\n-                    continue;\n-                }\n-                // Should be referenced unique constraint, but H2 uses indexes instead.\n-                // So try to find matching unique constraint first and there is no such\n-                // constraint use index name to return something.\n-                SchemaObject unique = lookupUniqueForReferential(constraint);\n-                if (unique == null) {\n-                    unique = constraint.getUniqueIndex();\n+        break;\n+      }\n+      case TABLE_CONSTRAINTS: {\n+        for (SchemaObject obj : database\n+            .getAllSchemaObjects(DbObject.CONSTRAINT)) {\n+          Constraint constraint = (Constraint) obj;\n+          Constraint.Type constraintType = constraint.getConstraintType();\n+          Table table = constraint.getTable();\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          add(rows,\n+              // CONSTRAINT_CATALOG\n+              catalog,\n+              // CONSTRAINT_SCHEMA\n+              constraint.getSchema().getName(),\n+              // CONSTRAINT_NAME\n+              constraint.getName(),\n+              // CONSTRAINT_TYPE\n+              constraintType.getSqlName(),\n+              // TABLE_CATALOG\n+              catalog,\n+              // TABLE_SCHEMA\n+              table.getSchema().getName(),\n+              // TABLE_NAME\n+              tableName,\n+              // IS_DEFERRABLE\n+              \"NO\",\n+              // INITIALLY_DEFERRED\n+              \"NO\"\n+          );\n+        }\n+        break;\n+      }\n+      case KEY_COLUMN_USAGE: {\n+        for (SchemaObject obj : database\n+            .getAllSchemaObjects(DbObject.CONSTRAINT)) {\n+          Constraint constraint = (Constraint) obj;\n+          Constraint.Type constraintType = constraint.getConstraintType();\n+          IndexColumn[] indexColumns = null;\n+          Table table = constraint.getTable();\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          String tableName = table.getName();\n+          if (!checkIndex(session, tableName, indexFrom, indexTo)) {\n+            continue;\n+          }\n+          if (constraintType == Constraint.Type.UNIQUE ||\n+              constraintType == Constraint.Type.PRIMARY_KEY) {\n+            indexColumns = ((ConstraintUnique) constraint).getColumns();\n+          } else if (constraintType == Constraint.Type.REFERENTIAL) {\n+            indexColumns = ((ConstraintReferential) constraint).getColumns();\n+          }\n+          if (indexColumns == null) {\n+            continue;\n+          }\n+          ConstraintUnique referenced;\n+          if (constraintType == Constraint.Type.REFERENTIAL) {\n+            referenced =\n+                lookupUniqueForReferential((ConstraintReferential) constraint);\n+          } else {\n+            referenced = null;\n+          }\n+          for (int i = 0; i < indexColumns.length; i++) {\n+            IndexColumn indexColumn = indexColumns[i];\n+            ValueInt ordinalPosition = ValueInt.get(i + 1);\n+            ValueInt positionInUniqueConstraint;\n+            if (constraintType == Constraint.Type.REFERENTIAL) {\n+              positionInUniqueConstraint = ordinalPosition;\n+              if (referenced != null) {\n+                Column c = ((ConstraintReferential) constraint)\n+                    .getRefColumns()[i].column;\n+                IndexColumn[] refColumns = referenced.getColumns();\n+                for (int j = 0; j < refColumns.length; j++) {\n+                  if (refColumns[j].column.equals(c)) {\n+                    positionInUniqueConstraint = ValueInt.get(j + 1);\n+                    break;\n+                  }\n                 }\n-                add(rows,\n-                        // CONSTRAINT_CATALOG\n-                        catalog,\n-                        // CONSTRAINT_SCHEMA\n-                        constraint.getSchema().getName(),\n-                        // CONSTRAINT_NAME\n-                        constraint.getName(),\n-                        // UNIQUE_CONSTRAINT_CATALOG\n-                        catalog,\n-                        // UNIQUE_CONSTRAINT_SCHEMA\n-                        unique.getSchema().getName(),\n-                        // UNIQUE_CONSTRAINT_NAME\n-                        unique.getName(),\n-                        // MATCH_OPTION\n-                        \"NONE\",\n-                        // UPDATE_RULE\n-                        constraint.getUpdateAction().getSqlName(),\n-                        // DELETE_RULE\n-                        constraint.getDeleteAction().getSqlName()\n-                );\n+              }\n+            } else {\n+              positionInUniqueConstraint = null;\n             }\n-            break;\n+            add(rows,\n+                // CONSTRAINT_CATALOG\n+                catalog,\n+                // CONSTRAINT_SCHEMA\n+                constraint.getSchema().getName(),\n+                // CONSTRAINT_NAME\n+                constraint.getName(),\n+                // TABLE_CATALOG\n+                catalog,\n+                // TABLE_SCHEMA\n+                table.getSchema().getName(),\n+                // TABLE_NAME\n+                tableName,\n+                // COLUMN_NAME\n+                indexColumn.columnName,\n+                // ORDINAL_POSITION\n+                ordinalPosition,\n+                // POSITION_IN_UNIQUE_CONSTRAINT\n+                positionInUniqueConstraint\n+            );\n+          }\n         }\n-        default:\n-            DbException.throwInternalError(\"type=\"+type);\n+        break;\n+      }\n+      case REFERENTIAL_CONSTRAINTS: {\n+        for (SchemaObject obj : database\n+            .getAllSchemaObjects(DbObject.CONSTRAINT)) {\n+          if (((Constraint) obj).getConstraintType() !=\n+              Constraint.Type.REFERENTIAL) {\n+            continue;\n+          }\n+          ConstraintReferential constraint = (ConstraintReferential) obj;\n+          Table table = constraint.getTable();\n+          if (hideTable(table, session)) {\n+            continue;\n+          }\n+          // Should be referenced unique constraint, but H2 uses indexes instead.\n+          // So try to find matching unique constraint first and there is no such\n+          // constraint use index name to return something.\n+          SchemaObject unique = lookupUniqueForReferential(constraint);\n+          if (unique == null) {\n+            unique = constraint.getUniqueIndex();\n+          }\n+          add(rows,\n+              // CONSTRAINT_CATALOG\n+              catalog,\n+              // CONSTRAINT_SCHEMA\n+              constraint.getSchema().getName(),\n+              // CONSTRAINT_NAME\n+              constraint.getName(),\n+              // UNIQUE_CONSTRAINT_CATALOG\n+              catalog,\n+              // UNIQUE_CONSTRAINT_SCHEMA\n+              unique.getSchema().getName(),\n+              // UNIQUE_CONSTRAINT_NAME\n+              unique.getName(),\n+              // MATCH_OPTION\n+              \"NONE\",\n+              // UPDATE_RULE\n+              constraint.getUpdateAction().getSqlName(),\n+              // DELETE_RULE\n+              constraint.getDeleteAction().getSqlName()\n+          );\n         }\n-        return rows;\n+        break;\n+      }\n+      default:\n+        DbException.throwInternalError(\"type=\" + type);\n     }\n+    return rows;\n+  }\n \n-    private static short getRefAction(ConstraintActionType action) {\n-        switch (action) {\n-        case CASCADE:\n-            return DatabaseMetaData.importedKeyCascade;\n-        case RESTRICT:\n-            return DatabaseMetaData.importedKeyRestrict;\n-        case SET_DEFAULT:\n-            return DatabaseMetaData.importedKeySetDefault;\n-        case SET_NULL:\n-            return DatabaseMetaData.importedKeySetNull;\n-        default:\n-            throw DbException.throwInternalError(\"action=\"+action);\n-        }\n+  private static short getRefAction(ConstraintActionType action) {\n+    switch (action) {\n+      case CASCADE:\n+        return DatabaseMetaData.importedKeyCascade;\n+      case RESTRICT:\n+        return DatabaseMetaData.importedKeyRestrict;\n+      case SET_DEFAULT:\n+        return DatabaseMetaData.importedKeySetDefault;\n+      case SET_NULL:\n+        return DatabaseMetaData.importedKeySetNull;\n+      default:\n+        throw DbException.throwInternalError(\"action=\" + action);\n     }\n+  }\n \n-    private static ConstraintUnique lookupUniqueForReferential(ConstraintReferential referential) {\n-        Table table = referential.getRefTable();\n-        for (Constraint c : table.getConstraints()) {\n-            if (c.getConstraintType() == Constraint.Type.UNIQUE) {\n-                ConstraintUnique unique = (ConstraintUnique) c;\n-                if (unique.getReferencedColumns(table).equals(referential.getReferencedColumns(table))) {\n-                    return unique;\n-                }\n-            }\n+  private static ConstraintUnique lookupUniqueForReferential(\n+      ConstraintReferential referential) {\n+    Table table = referential.getRefTable();\n+    for (Constraint c : table.getConstraints()) {\n+      if (c.getConstraintType() == Constraint.Type.UNIQUE) {\n+        ConstraintUnique unique = (ConstraintUnique) c;\n+        if (unique.getReferencedColumns(table)\n+            .equals(referential.getReferencedColumns(table))) {\n+          return unique;\n         }\n-        return null;\n+      }\n     }\n+    return null;\n+  }\n \n-    @Override\n-    public void removeRow(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"META\");\n-    }\n+  @Override\n+  public void removeRow(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public void addRow(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"META\");\n-    }\n+  @Override\n+  public void addRow(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        throw DbException.getUnsupportedException(\"META\");\n-    }\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public void close(Session session) {\n-        // nothing to do\n-    }\n+  @Override\n+  public void close(Session session) {\n+    // nothing to do\n+  }\n \n-    @Override\n-    public void unlock(Session s) {\n-        // nothing to do\n-    }\n+  @Override\n+  public void unlock(Session s) {\n+    // nothing to do\n+  }\n \n-    private void addPrivileges(ArrayList<Row> rows, DbObject grantee,\n-            String catalog, Table table, String column, int rightMask) {\n-        if ((rightMask & Right.SELECT) != 0) {\n-            addPrivilege(rows, grantee, catalog, table, column, \"SELECT\");\n-        }\n-        if ((rightMask & Right.INSERT) != 0) {\n-            addPrivilege(rows, grantee, catalog, table, column, \"INSERT\");\n-        }\n-        if ((rightMask & Right.UPDATE) != 0) {\n-            addPrivilege(rows, grantee, catalog, table, column, \"UPDATE\");\n-        }\n-        if ((rightMask & Right.DELETE) != 0) {\n-            addPrivilege(rows, grantee, catalog, table, column, \"DELETE\");\n-        }\n+  private void addPrivileges(ArrayList<Row> rows, DbObject grantee,\n+                             String catalog, Table table, String column,\n+                             int rightMask) {\n+    if ((rightMask & Right.SELECT) != 0) {\n+      addPrivilege(rows, grantee, catalog, table, column, \"SELECT\");\n     }\n-\n-    private void addPrivilege(ArrayList<Row> rows, DbObject grantee,\n-            String catalog, Table table, String column, String right) {\n-        String isGrantable = \"NO\";\n-        if (grantee.getType() == DbObject.USER) {\n-            User user = (User) grantee;\n-            if (user.isAdmin()) {\n-                // the right is grantable if the grantee is an admin\n-                isGrantable = \"YES\";\n-            }\n-        }\n-        if (column == null) {\n-            add(rows,\n-                    // GRANTOR\n-                    null,\n-                    // GRANTEE\n-                    identifier(grantee.getName()),\n-                    // TABLE_CATALOG\n-                    catalog,\n-                    // TABLE_SCHEMA\n-                    table.getSchema().getName(),\n-                    // TABLE_NAME\n-                    table.getName(),\n-                    // PRIVILEGE_TYPE\n-                    right,\n-                    // IS_GRANTABLE\n-                    isGrantable\n-            );\n-        } else {\n-            add(rows,\n-                    // GRANTOR\n-                    null,\n-                    // GRANTEE\n-                    identifier(grantee.getName()),\n-                    // TABLE_CATALOG\n-                    catalog,\n-                    // TABLE_SCHEMA\n-                    table.getSchema().getName(),\n-                    // TABLE_NAME\n-                    table.getName(),\n-                    // COLUMN_NAME\n-                    column,\n-                    // PRIVILEGE_TYPE\n-                    right,\n-                    // IS_GRANTABLE\n-                    isGrantable\n-            );\n-        }\n+    if ((rightMask & Right.INSERT) != 0) {\n+      addPrivilege(rows, grantee, catalog, table, column, \"INSERT\");\n     }\n-\n-    private void add(ArrayList<Row> rows, Object... stringsOrValues) {\n-        Value[] values = new Value[stringsOrValues.length];\n-        for (int i = 0; i < stringsOrValues.length; i++) {\n-            Object s = stringsOrValues[i];\n-            Value v = s == null ? ValueNull.INSTANCE : s instanceof String ? ValueString.get((String) s) : (Value) s;\n-            values[i] = columns[i].convert(v, false);\n-        }\n-        rows.add(Row.get(values, 1, rows.size()));\n+    if ((rightMask & Right.UPDATE) != 0) {\n+      addPrivilege(rows, grantee, catalog, table, column, \"UPDATE\");\n     }\n-\n-    @Override\n-    public void checkRename() {\n-        throw DbException.getUnsupportedException(\"META\");\n+    if ((rightMask & Right.DELETE) != 0) {\n+      addPrivilege(rows, grantee, catalog, table, column, \"DELETE\");\n     }\n+  }\n \n-    @Override\n-    public void checkSupportAlter() {\n-        throw DbException.getUnsupportedException(\"META\");\n+  private void addPrivilege(ArrayList<Row> rows, DbObject grantee,\n+                            String catalog, Table table, String column,\n+                            String right) {\n+    String isGrantable = \"NO\";\n+    if (grantee.getType() == DbObject.USER) {\n+      User user = (User) grantee;\n+      if (user.isAdmin()) {\n+        // the right is grantable if the grantee is an admin\n+        isGrantable = \"YES\";\n+      }\n     }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        throw DbException.getUnsupportedException(\"META\");\n+    if (column == null) {\n+      add(rows,\n+          // GRANTOR\n+          null,\n+          // GRANTEE\n+          identifier(grantee.getName()),\n+          // TABLE_CATALOG\n+          catalog,\n+          // TABLE_SCHEMA\n+          table.getSchema().getName(),\n+          // TABLE_NAME\n+          table.getName(),\n+          // PRIVILEGE_TYPE\n+          right,\n+          // IS_GRANTABLE\n+          isGrantable\n+      );\n+    } else {\n+      add(rows,\n+          // GRANTOR\n+          null,\n+          // GRANTEE\n+          identifier(grantee.getName()),\n+          // TABLE_CATALOG\n+          catalog,\n+          // TABLE_SCHEMA\n+          table.getSchema().getName(),\n+          // TABLE_NAME\n+          table.getName(),\n+          // COLUMN_NAME\n+          column,\n+          // PRIVILEGE_TYPE\n+          right,\n+          // IS_GRANTABLE\n+          isGrantable\n+      );\n     }\n+  }\n \n-    @Override\n-    public long getRowCount(Session session) {\n-        throw DbException.throwInternalError(toString());\n+  private void add(ArrayList<Row> rows, Object... stringsOrValues) {\n+    Value[] values = new Value[stringsOrValues.length];\n+    for (int i = 0; i < stringsOrValues.length; i++) {\n+      Object s = stringsOrValues[i];\n+      Value v = s == null ? ValueNull.INSTANCE :\n+          s instanceof String ? ValueString.get((String) s) : (Value) s;\n+      values[i] = columns[i].convert(v, false);\n     }\n+    rows.add(Row.get(values, 1, rows.size()));\n+  }\n \n-    @Override\n-    public boolean canGetRowCount() {\n-        return false;\n-    }\n+  @Override\n+  public void checkRename() {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public boolean canDrop() {\n-        return false;\n-    }\n+  @Override\n+  public void checkSupportAlter() {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public TableType getTableType() {\n-        return TableType.SYSTEM_TABLE;\n-    }\n+  @Override\n+  public void truncate(Session session) {\n+    throw DbException.getUnsupportedException(\"META\");\n+  }\n \n-    @Override\n-    public Index getScanIndex(Session session) {\n-        return new MetaIndex(this, IndexColumn.wrap(columns), true);\n-    }\n+  @Override\n+  public long getRowCount(Session session) {\n+    throw DbException.throwInternalError(toString());\n+  }\n \n-    @Override\n-    public ArrayList<Index> getIndexes() {\n-        ArrayList<Index> list = new ArrayList<>(2);\n-        if (metaIndex == null) {\n-            return list;\n-        }\n-        list.add(new MetaIndex(this, IndexColumn.wrap(columns), true));\n-        // TODO re-use the index\n-        list.add(metaIndex);\n-        return list;\n-    }\n+  @Override\n+  public boolean canGetRowCount() {\n+    return false;\n+  }\n \n-    @Override\n-    public long getMaxDataModificationId() {\n-        switch (type) {\n-        case SETTINGS:\n-        case IN_DOUBT:\n-        case SESSIONS:\n-        case LOCKS:\n-        case SESSION_STATE:\n-            return Long.MAX_VALUE;\n-        }\n-        return database.getModificationDataId();\n-    }\n+  @Override\n+  public boolean canDrop() {\n+    return false;\n+  }\n \n-    @Override\n-    public Index getUniqueIndex() {\n-        return null;\n-    }\n+  @Override\n+  public TableType getTableType() {\n+    return TableType.SYSTEM_TABLE;\n+  }\n \n-    /**\n-     * Get the number of meta table types. Supported meta table\n-     * types are 0 .. this value - 1.\n-     *\n-     * @return the number of meta table types\n-     */\n-    public static int getMetaTableTypeCount() {\n-        return META_TABLE_TYPE_COUNT;\n-    }\n+  @Override\n+  public Index getScanIndex(Session session) {\n+    return new MetaIndex(this, IndexColumn.wrap(columns), true);\n+  }\n \n-    @Override\n-    public long getRowCountApproximation() {\n-        return ROW_COUNT_APPROXIMATION;\n+  @Override\n+  public ArrayList<Index> getIndexes() {\n+    ArrayList<Index> list = new ArrayList<>(2);\n+    if (metaIndex == null) {\n+      return list;\n     }\n+    list.add(new MetaIndex(this, IndexColumn.wrap(columns), true));\n+    // TODO re-use the index\n+    list.add(metaIndex);\n+    return list;\n+  }\n \n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return 0;\n+  @Override\n+  public long getMaxDataModificationId() {\n+    switch (type) {\n+      case SETTINGS:\n+      case IN_DOUBT:\n+      case SESSIONS:\n+      case LOCKS:\n+      case SESSION_STATE:\n+        return Long.MAX_VALUE;\n     }\n+    return database.getModificationDataId();\n+  }\n \n-    @Override\n-    public boolean isDeterministic() {\n-        return true;\n-    }\n+  @Override\n+  public Index getUniqueIndex() {\n+    return null;\n+  }\n \n-    @Override\n-    public boolean canReference() {\n-        return false;\n-    }\n+  /**\n+   * Get the number of meta table types. Supported meta table\n+   * types are 0 .. this value - 1.\n+   *\n+   * @return the number of meta table types\n+   */\n+  public static int getMetaTableTypeCount() {\n+    return META_TABLE_TYPE_COUNT;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return ROW_COUNT_APPROXIMATION;\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return 0;\n+  }\n+\n+  @Override\n+  public boolean isDeterministic() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean canReference() {\n+    return false;\n+  }\n \n }\n",
            "diff_size": 3036
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/491/MetaTable.java\nindex c2124ac32e..7672402526 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/491/MetaTable.java\n@@ -1164,7 +1164,7 @@ public class MetaTable extends Table {\n                         try {\n                             add(rows, \"info.FILE_SIZE\",\n                                     Long.toString(fs.getFile().size()));\n-                        } catch (IOException ignore) {/**/}\n+                        } catch (IOException ignore) { /**/}\n                         add(rows, \"info.CHUNK_COUNT\",\n                                 Long.toString(mvStore.getChunkCount()));\n                         add(rows, \"info.PAGE_COUNT\",\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/491/MetaTable.java\nindex c2124ac32e..7672402526 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/491/MetaTable.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/491/MetaTable.java\n@@ -1164,7 +1164,7 @@ public class MetaTable extends Table {\n                         try {\n                             add(rows, \"info.FILE_SIZE\",\n                                     Long.toString(fs.getFile().size()));\n-                        } catch (IOException ignore) {/**/}\n+                        } catch (IOException ignore) { /**/}\n                         add(rows, \"info.CHUNK_COUNT\",\n                                 Long.toString(mvStore.getChunkCount()));\n                         add(rows, \"info.PAGE_COUNT\",\n",
            "diff_size": 1
        }
    ]
}