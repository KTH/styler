{
    "error_id": "25",
    "information": {
        "errors": [
            {
                "line": "532",
                "severity": "warning",
                "message": "Line is longer than 80 characters (found 103).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                throw new GXDLMSException(\"Invalid Exception.\");\n            }\n            switch (id) { // RX / TX are delivered from the partner's point of view => reversed to ours\n            case HDLCInfo.MAX_INFO_RX:\n                getLimits().setMaxInfoTX(val);\n                break;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "532",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "509",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 97).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "710",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "810",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 84).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "832",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1588",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/errored/1/25/GXDLMSClient.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/intellij/25/GXDLMSClient.java\nindex b9d36272ac..789a3745f2 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/errored/1/25/GXDLMSClient.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/intellij/25/GXDLMSClient.java\n@@ -64,1662 +64,1573 @@ import gurux.dlms.secure.GXSecure;\n  * GXDLMS implements methods to communicate with DLMS/COSEM metering devices.\n  */\n public class GXDLMSClient {\n-    /**\n-     * DLMS settings.\n-     */\n-    private final GXDLMSSettings settings = new GXDLMSSettings(false);\n-    private GXObisCodeCollection obisCodes;\n-    private static final Logger LOGGER =\n-            Logger.getLogger(GXDLMSClient.class.getName());\n-\n-    /**\n-     * Is authentication required.\n-     */\n-    private boolean isAuthenticationRequired = false;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public GXDLMSClient() {\n-    }\n-\n-    /**\n-     * Constructor.\n-     * \n-     * @param useLogicalNameReferencing\n-     *            Is Logical Name referencing used.\n-     * @param clientAddress\n-     *            Server address.\n-     * @param serverAddress\n-     *            Client address.\n-     * @param forAuthentication\n-     *            Authentication type.\n-     * @param password\n-     *            Password if authentication is used.\n-     * @param interfaceType\n-     *            Object type.\n-     */\n-    public GXDLMSClient(final boolean useLogicalNameReferencing,\n-            final int clientAddress, final int serverAddress,\n-            final Authentication forAuthentication, final String password,\n-            final InterfaceType interfaceType) {\n-        this.setUseLogicalNameReferencing(useLogicalNameReferencing);\n-        this.setClientAddress(clientAddress);\n-        this.setServerAddress(serverAddress);\n-        setAuthentication(forAuthentication);\n-        setPassword(GXCommon.getBytes(password));\n-        setInterfaceType(interfaceType);\n-    }\n-\n-    /**\n-     * @param value\n-     *            Cipher interface that is used to cipher PDU.\n-     */\n-    protected final void setCipher(final GXICipher value) {\n-        settings.setCipher(value);\n-    }\n-\n-    /**\n-     * @return Get settings.\n-     */\n-    protected final GXDLMSSettings getSettings() {\n-        return settings;\n-    }\n-\n-    /**\n-     * @return Get list of meter's objects.\n-     */\n-    public final GXDLMSObjectCollection getObjects() {\n-        return settings.getObjects();\n-    }\n-\n-    /**\n-     * This list is used when Association view is read from the meter and\n-     * description of the object is needed. If collection is not set description\n-     * of object is empty.\n-     * \n-     * @return List of available OBIS codes.\n-     */\n-    public final GXObisCodeCollection getObisCodes() {\n-        return obisCodes;\n-    }\n-\n-    public final void setObisCodes(final GXObisCodeCollection value) {\n-        obisCodes = value;\n-    }\n-\n-    /**\n-     * Set starting packet index. Default is One based, but some meters use Zero\n-     * based value. Usually this is not used.\n-     * \n-     * @param value\n-     *            Zero based starting index.\n-     */\n-    public final void setStartingPacketIndex(final int value) {\n-        settings.setStartingPacketIndex(value);\n-    }\n-\n-    /**\n-     * @return Client address.\n-     */\n-    public final int getClientAddress() {\n-        return settings.getClientAddress();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Client address\n-     */\n-    public final void setClientAddress(final int value) {\n-        settings.setClientAddress(value);\n-    }\n-\n-    /**\n-     * @return Server Address.\n-     */\n-    public final int getServerAddress() {\n-        return settings.getServerAddress();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Server address.\n-     */\n-    public final void setServerAddress(final int value) {\n-        settings.setServerAddress(value);\n-    }\n-\n-    /**\n-     * @return Server address size in bytes. If it is Zero it is counted\n-     *         automatically.\n-     */\n-    public final int getServerAddressSize() {\n-        return settings.getServerAddressSize();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Server address size in bytes. If it is Zero it is counted\n-     *            automatically.\n-     */\n-    public final void setServerAddressSize(final int value) {\n-        settings.setServerAddressSize(value);\n-    }\n-\n-    /**\n-     * DLMS version number. Gurux DLMS component supports DLMS version number 6.\n-     * \n-     * @return DLMS version number.\n-     */\n-    public final byte getDLMSVersion() {\n-        return settings.getDLMSVersion();\n-    }\n-\n-    /**\n-     * @param value\n-     *            DLMS version number.\n-     */\n-    public final void setDLMSVersion(final byte value) {\n-        settings.setDLMSVersion(value);\n-    }\n-\n-    /**\n-     * Retrieves the maximum size of received PDU. PDU size tells maximum size\n-     * of PDU packet. Value can be from 0 to 0xFFFF. By default the value is\n-     * 0xFFFF.\n-     * \n-     * @see GXDLMSClient#getClientAddress\n-     * @see GXDLMSClient#getServerAddress\n-     * @see GXDLMSClient#getDLMSVersion\n-     * @see GXDLMSClient#getUseLogicalNameReferencing\n-     * @return Maximum size of received PDU.\n-     */\n-    public final int getMaxReceivePDUSize() {\n-        return settings.getMaxReceivePDUSize();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Maximum size of received PDU.\n-     */\n-    public final void setMaxReceivePDUSize(final int value) {\n-        settings.setMaxReceivePDUSize(value);\n-    }\n-\n-    /**\n-     * Determines, whether Logical, or Short name, referencing is used.\n-     * Referencing depends on the device to communicate with. Normally, a device\n-     * supports only either Logical or Short name referencing. The referencing\n-     * is defined by the device manufacturer. If the referencing is wrong, the\n-     * SNMR message will fail.\n-     * \n-     * @return Is Logical Name referencing used.\n-     */\n-    public final boolean getUseLogicalNameReferencing() {\n-        return settings.getUseLogicalNameReferencing();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Is Logical Name referencing used.\n-     */\n-    public final void setUseLogicalNameReferencing(final boolean value) {\n-        settings.setUseLogicalNameReferencing(value);\n-    }\n-\n-    /// <summary>\n-    /// Client to Server custom challenge.\n-    /// </summary>\n-    /// <remarks>\n-    /// This is for debugging purposes. Reset custom challenge settings\n-    /// CtoSChallenge to null.\n-    /// </remarks>\n-\n-    /**\n-     * Client to Server custom challenge.\n-     * \n-     * @return Client to Server custom challenge.\n-     */\n-    public final byte[] getCtoSChallenge() {\n-        return settings.getCtoSChallenge();\n-    }\n-\n-    /**\n-     * Client to Server custom challenge. This is for debugging purposes. Reset\n-     * custom challenge settings CtoSChallenge to null.\n-     * \n-     * @param value\n-     *            Client to Server challenge.\n-     */\n-    public final void setCtoSChallenge(final byte[] value) {\n-        settings.setUseCustomChallenge(value != null);\n-        settings.setCtoSChallenge(value);\n-    }\n-\n-    /**\n-     * Retrieves the password that is used in communication. If authentication\n-     * is set to none, password is not used.\n-     * \n-     * @see GXDLMSClient#getAuthentication\n-     * @return Used password.\n-     */\n-    public final byte[] getPassword() {\n-        return settings.getPassword();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Used password as byte array.\n-     */\n-    public final void setPassword(final byte[] value) {\n-        settings.setPassword(value);\n-    }\n-\n-    /**\n-     * @param value\n-     *            Used password as string value.\n-     */\n-    public final void setPassword(final String value) {\n-        settings.setPassword(value.getBytes());\n-    }\n-\n-    /**\n-     * @return Logical Name settings.\n-     */\n-    public final GXDLMSLNSettings getLNSettings() {\n-        return settings.getLnSettings();\n-    }\n-\n-    /**\n-     * @return Short Name settings.\n-     */\n-    public final GXDLMSSNSettings getSNSettings() {\n-        return settings.getSnSettings();\n-    }\n-\n-    /**\n-     * Retrieves the authentication used in communicating with the device. By\n-     * default authentication is not used. If authentication is used, set the\n-     * password with the Password property.\n-     * \n-     * @see GXDLMSClient#getPassword\n-     * @see GXDLMSClient#getClientAddress\n-     * @return Used authentication.\n-     */\n-    public final Authentication getAuthentication() {\n-        return settings.getAuthentication();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Used authentication.\n-     */\n-    public final void setAuthentication(final Authentication value) {\n-        settings.setAuthentication(value);\n-    }\n-\n-    /**\n-     * @return Used Priority.\n-     */\n-    public final Priority getPriority() {\n-        return settings.getPriority();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Used Priority.\n-     */\n-    public final void setPriority(final Priority value) {\n-        settings.setPriority(value);\n-    }\n-\n-    /**\n-     * @return Used service class.\n-     */\n-    public final ServiceClass getServiceClass() {\n-        return settings.getServiceClass();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Used service class.\n-     */\n-    public final void setServiceClass(final ServiceClass value) {\n-        settings.setServiceClass(value);\n-    }\n-\n-    /**\n-     * @return Invoke ID.\n-     */\n-    public final int getInvokeID() {\n-        return settings.getInvokeID();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Invoke ID.\n-     */\n-    public final void setInvokeID(final int value) {\n-        settings.setInvokeID(value);\n-    }\n-\n-    /**\n-     * @return Interface type.\n-     */\n-    public final InterfaceType getInterfaceType() {\n-        return settings.getInterfaceType();\n-    }\n-\n-    /**\n-     * @param value\n-     *            Interface type.\n-     */\n-    public final void setInterfaceType(final InterfaceType value) {\n-        settings.setInterfaceType(value);\n-    }\n-\n-    /**\n-     * @return Information from the connection size that server can handle.\n-     */\n-    public final GXDLMSLimits getLimits() {\n-        return settings.getLimits();\n-    }\n-\n-    /**\n-     * Generates SNRM request. his method is used to generate send SNRMRequest.\n-     * Before the SNRM request can be generated, at least the following\n-     * properties must be set:\n-     * <ul>\n-     * <li>ClientAddress</li>\n-     * <li>ServerAddress</li>\n-     * </ul>\n-     * <b>Note! </b>According to IEC 62056-47: when communicating using TCP/IP,\n-     * the SNRM request is not send.\n-     * \n-     * @see GXDLMSClient#getClientAddress\n-     * @see GXDLMSClient#getServerAddress\n-     * @see GXDLMSClient#parseUAResponse\n-     * @return SNRM request as byte array.\n-     */\n-    public final byte[] snrmRequest() {\n-        settings.setConnected(false);\n-\n-        isAuthenticationRequired = false;\n-        settings.setMaxReceivePDUSize(0xFFFF);\n-        // SNRM request is not used in network connections.\n-        if (this.getInterfaceType() == InterfaceType.WRAPPER) {\n-            return new byte[0];\n-        }\n-        GXByteBuffer data = new GXByteBuffer(25);\n-        data.setUInt8(0x81); // FromatID\n-        data.setUInt8(0x80); // GroupID\n-        data.setUInt8(0); // Length.\n-\n-        // If custom HDLC parameters are used.\n-        if (!GXDLMSLimits.DEFAULT_MAX_INFO_TX\n-                .equals(this.getLimits().getMaxInfoTX())) {\n-            data.setUInt8(HDLCInfo.MAX_INFO_TX);\n-            data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoTX()));\n-            data.add(getLimits().getMaxInfoTX());\n-        }\n-        if (!GXDLMSLimits.DEFAULT_MAX_INFO_RX\n-                .equals(this.getLimits().getMaxInfoRX())) {\n-            data.setUInt8(HDLCInfo.MAX_INFO_RX);\n-            data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoRX()));\n-            data.add(getLimits().getMaxInfoRX());\n-        }\n-        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n-                .equals(this.getLimits().getWindowSizeTX())) {\n-            data.setUInt8(HDLCInfo.WINDOW_SIZE_TX);\n-            data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeTX()));\n-            data.add(getLimits().getWindowSizeTX());\n-        }\n-        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n-                .equals(this.getLimits().getWindowSizeRX())) {\n-            data.setUInt8(HDLCInfo.WINDOW_SIZE_RX);\n-            data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeRX()));\n-            data.add(getLimits().getWindowSizeRX());\n-        }\n-        // If default HDLC parameters are not used.\n-        if (data.size() != 3) {\n-            data.setUInt8(2, data.position() - 3); // Length.\n+  /**\n+   * DLMS settings.\n+   */\n+  private final GXDLMSSettings settings = new GXDLMSSettings(false);\n+  private GXObisCodeCollection obisCodes;\n+  private static final Logger LOGGER =\n+      Logger.getLogger(GXDLMSClient.class.getName());\n+\n+  /**\n+   * Is authentication required.\n+   */\n+  private boolean isAuthenticationRequired = false;\n+\n+  /**\n+   * Constructor.\n+   */\n+  public GXDLMSClient() {\n+  }\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param useLogicalNameReferencing Is Logical Name referencing used.\n+   * @param clientAddress             Server address.\n+   * @param serverAddress             Client address.\n+   * @param forAuthentication         Authentication type.\n+   * @param password                  Password if authentication is used.\n+   * @param interfaceType             Object type.\n+   */\n+  public GXDLMSClient(final boolean useLogicalNameReferencing,\n+                      final int clientAddress, final int serverAddress,\n+                      final Authentication forAuthentication,\n+                      final String password,\n+                      final InterfaceType interfaceType) {\n+    this.setUseLogicalNameReferencing(useLogicalNameReferencing);\n+    this.setClientAddress(clientAddress);\n+    this.setServerAddress(serverAddress);\n+    setAuthentication(forAuthentication);\n+    setPassword(GXCommon.getBytes(password));\n+    setInterfaceType(interfaceType);\n+  }\n+\n+  /**\n+   * @param value Cipher interface that is used to cipher PDU.\n+   */\n+  protected final void setCipher(final GXICipher value) {\n+    settings.setCipher(value);\n+  }\n+\n+  /**\n+   * @return Get settings.\n+   */\n+  protected final GXDLMSSettings getSettings() {\n+    return settings;\n+  }\n+\n+  /**\n+   * @return Get list of meter's objects.\n+   */\n+  public final GXDLMSObjectCollection getObjects() {\n+    return settings.getObjects();\n+  }\n+\n+  /**\n+   * This list is used when Association view is read from the meter and\n+   * description of the object is needed. If collection is not set description\n+   * of object is empty.\n+   *\n+   * @return List of available OBIS codes.\n+   */\n+  public final GXObisCodeCollection getObisCodes() {\n+    return obisCodes;\n+  }\n+\n+  public final void setObisCodes(final GXObisCodeCollection value) {\n+    obisCodes = value;\n+  }\n+\n+  /**\n+   * Set starting packet index. Default is One based, but some meters use Zero\n+   * based value. Usually this is not used.\n+   *\n+   * @param value Zero based starting index.\n+   */\n+  public final void setStartingPacketIndex(final int value) {\n+    settings.setStartingPacketIndex(value);\n+  }\n+\n+  /**\n+   * @return Client address.\n+   */\n+  public final int getClientAddress() {\n+    return settings.getClientAddress();\n+  }\n+\n+  /**\n+   * @param value Client address\n+   */\n+  public final void setClientAddress(final int value) {\n+    settings.setClientAddress(value);\n+  }\n+\n+  /**\n+   * @return Server Address.\n+   */\n+  public final int getServerAddress() {\n+    return settings.getServerAddress();\n+  }\n+\n+  /**\n+   * @param value Server address.\n+   */\n+  public final void setServerAddress(final int value) {\n+    settings.setServerAddress(value);\n+  }\n+\n+  /**\n+   * @return Server address size in bytes. If it is Zero it is counted\n+   * automatically.\n+   */\n+  public final int getServerAddressSize() {\n+    return settings.getServerAddressSize();\n+  }\n+\n+  /**\n+   * @param value Server address size in bytes. If it is Zero it is counted\n+   *              automatically.\n+   */\n+  public final void setServerAddressSize(final int value) {\n+    settings.setServerAddressSize(value);\n+  }\n+\n+  /**\n+   * DLMS version number. Gurux DLMS component supports DLMS version number 6.\n+   *\n+   * @return DLMS version number.\n+   */\n+  public final byte getDLMSVersion() {\n+    return settings.getDLMSVersion();\n+  }\n+\n+  /**\n+   * @param value DLMS version number.\n+   */\n+  public final void setDLMSVersion(final byte value) {\n+    settings.setDLMSVersion(value);\n+  }\n+\n+  /**\n+   * Retrieves the maximum size of received PDU. PDU size tells maximum size\n+   * of PDU packet. Value can be from 0 to 0xFFFF. By default the value is\n+   * 0xFFFF.\n+   *\n+   * @return Maximum size of received PDU.\n+   * @see GXDLMSClient#getClientAddress\n+   * @see GXDLMSClient#getServerAddress\n+   * @see GXDLMSClient#getDLMSVersion\n+   * @see GXDLMSClient#getUseLogicalNameReferencing\n+   */\n+  public final int getMaxReceivePDUSize() {\n+    return settings.getMaxReceivePDUSize();\n+  }\n+\n+  /**\n+   * @param value Maximum size of received PDU.\n+   */\n+  public final void setMaxReceivePDUSize(final int value) {\n+    settings.setMaxReceivePDUSize(value);\n+  }\n+\n+  /**\n+   * Determines, whether Logical, or Short name, referencing is used.\n+   * Referencing depends on the device to communicate with. Normally, a device\n+   * supports only either Logical or Short name referencing. The referencing\n+   * is defined by the device manufacturer. If the referencing is wrong, the\n+   * SNMR message will fail.\n+   *\n+   * @return Is Logical Name referencing used.\n+   */\n+  public final boolean getUseLogicalNameReferencing() {\n+    return settings.getUseLogicalNameReferencing();\n+  }\n+\n+  /**\n+   * @param value Is Logical Name referencing used.\n+   */\n+  public final void setUseLogicalNameReferencing(final boolean value) {\n+    settings.setUseLogicalNameReferencing(value);\n+  }\n+\n+  /// <summary>\n+  /// Client to Server custom challenge.\n+  /// </summary>\n+  /// <remarks>\n+  /// This is for debugging purposes. Reset custom challenge settings\n+  /// CtoSChallenge to null.\n+  /// </remarks>\n+\n+  /**\n+   * Client to Server custom challenge.\n+   *\n+   * @return Client to Server custom challenge.\n+   */\n+  public final byte[] getCtoSChallenge() {\n+    return settings.getCtoSChallenge();\n+  }\n+\n+  /**\n+   * Client to Server custom challenge. This is for debugging purposes. Reset\n+   * custom challenge settings CtoSChallenge to null.\n+   *\n+   * @param value Client to Server challenge.\n+   */\n+  public final void setCtoSChallenge(final byte[] value) {\n+    settings.setUseCustomChallenge(value != null);\n+    settings.setCtoSChallenge(value);\n+  }\n+\n+  /**\n+   * Retrieves the password that is used in communication. If authentication\n+   * is set to none, password is not used.\n+   *\n+   * @return Used password.\n+   * @see GXDLMSClient#getAuthentication\n+   */\n+  public final byte[] getPassword() {\n+    return settings.getPassword();\n+  }\n+\n+  /**\n+   * @param value Used password as byte array.\n+   */\n+  public final void setPassword(final byte[] value) {\n+    settings.setPassword(value);\n+  }\n+\n+  /**\n+   * @param value Used password as string value.\n+   */\n+  public final void setPassword(final String value) {\n+    settings.setPassword(value.getBytes());\n+  }\n+\n+  /**\n+   * @return Logical Name settings.\n+   */\n+  public final GXDLMSLNSettings getLNSettings() {\n+    return settings.getLnSettings();\n+  }\n+\n+  /**\n+   * @return Short Name settings.\n+   */\n+  public final GXDLMSSNSettings getSNSettings() {\n+    return settings.getSnSettings();\n+  }\n+\n+  /**\n+   * Retrieves the authentication used in communicating with the device. By\n+   * default authentication is not used. If authentication is used, set the\n+   * password with the Password property.\n+   *\n+   * @return Used authentication.\n+   * @see GXDLMSClient#getPassword\n+   * @see GXDLMSClient#getClientAddress\n+   */\n+  public final Authentication getAuthentication() {\n+    return settings.getAuthentication();\n+  }\n+\n+  /**\n+   * @param value Used authentication.\n+   */\n+  public final void setAuthentication(final Authentication value) {\n+    settings.setAuthentication(value);\n+  }\n+\n+  /**\n+   * @return Used Priority.\n+   */\n+  public final Priority getPriority() {\n+    return settings.getPriority();\n+  }\n+\n+  /**\n+   * @param value Used Priority.\n+   */\n+  public final void setPriority(final Priority value) {\n+    settings.setPriority(value);\n+  }\n+\n+  /**\n+   * @return Used service class.\n+   */\n+  public final ServiceClass getServiceClass() {\n+    return settings.getServiceClass();\n+  }\n+\n+  /**\n+   * @param value Used service class.\n+   */\n+  public final void setServiceClass(final ServiceClass value) {\n+    settings.setServiceClass(value);\n+  }\n+\n+  /**\n+   * @return Invoke ID.\n+   */\n+  public final int getInvokeID() {\n+    return settings.getInvokeID();\n+  }\n+\n+  /**\n+   * @param value Invoke ID.\n+   */\n+  public final void setInvokeID(final int value) {\n+    settings.setInvokeID(value);\n+  }\n+\n+  /**\n+   * @return Interface type.\n+   */\n+  public final InterfaceType getInterfaceType() {\n+    return settings.getInterfaceType();\n+  }\n+\n+  /**\n+   * @param value Interface type.\n+   */\n+  public final void setInterfaceType(final InterfaceType value) {\n+    settings.setInterfaceType(value);\n+  }\n+\n+  /**\n+   * @return Information from the connection size that server can handle.\n+   */\n+  public final GXDLMSLimits getLimits() {\n+    return settings.getLimits();\n+  }\n+\n+  /**\n+   * Generates SNRM request. his method is used to generate send SNRMRequest.\n+   * Before the SNRM request can be generated, at least the following\n+   * properties must be set:\n+   * <ul>\n+   * <li>ClientAddress</li>\n+   * <li>ServerAddress</li>\n+   * </ul>\n+   * <b>Note! </b>According to IEC 62056-47: when communicating using TCP/IP,\n+   * the SNRM request is not send.\n+   *\n+   * @return SNRM request as byte array.\n+   * @see GXDLMSClient#getClientAddress\n+   * @see GXDLMSClient#getServerAddress\n+   * @see GXDLMSClient#parseUAResponse\n+   */\n+  public final byte[] snrmRequest() {\n+    settings.setConnected(false);\n+\n+    isAuthenticationRequired = false;\n+    settings.setMaxReceivePDUSize(0xFFFF);\n+    // SNRM request is not used in network connections.\n+    if (this.getInterfaceType() == InterfaceType.WRAPPER) {\n+      return new byte[0];\n+    }\n+    GXByteBuffer data = new GXByteBuffer(25);\n+    data.setUInt8(0x81); // FromatID\n+    data.setUInt8(0x80); // GroupID\n+    data.setUInt8(0); // Length.\n+\n+    // If custom HDLC parameters are used.\n+    if (!GXDLMSLimits.DEFAULT_MAX_INFO_TX\n+        .equals(this.getLimits().getMaxInfoTX())) {\n+      data.setUInt8(HDLCInfo.MAX_INFO_TX);\n+      data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoTX()));\n+      data.add(getLimits().getMaxInfoTX());\n+    }\n+    if (!GXDLMSLimits.DEFAULT_MAX_INFO_RX\n+        .equals(this.getLimits().getMaxInfoRX())) {\n+      data.setUInt8(HDLCInfo.MAX_INFO_RX);\n+      data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoRX()));\n+      data.add(getLimits().getMaxInfoRX());\n+    }\n+    if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n+        .equals(this.getLimits().getWindowSizeTX())) {\n+      data.setUInt8(HDLCInfo.WINDOW_SIZE_TX);\n+      data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeTX()));\n+      data.add(getLimits().getWindowSizeTX());\n+    }\n+    if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n+        .equals(this.getLimits().getWindowSizeRX())) {\n+      data.setUInt8(HDLCInfo.WINDOW_SIZE_RX);\n+      data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeRX()));\n+      data.add(getLimits().getWindowSizeRX());\n+    }\n+    // If default HDLC parameters are not used.\n+    if (data.size() != 3) {\n+      data.setUInt8(2, data.position() - 3); // Length.\n+    } else {\n+      data = null;\n+    }\n+    return GXDLMS.getHdlcFrame(settings, (byte) Command.SNRM.getValue(),\n+        null);\n+  }\n+\n+  /**\n+   * Parses UAResponse from byte array.\n+   *\n+   * @param data Received message from the server.\n+   * @see GXDLMSClient#snrmRequest\n+   */\n+  public final void parseUAResponse(final byte[] data) {\n+    parseUAResponse(new GXByteBuffer(data));\n+  }\n+\n+  /**\n+   * Parses UAResponse from byte array.\n+   *\n+   * @param data Received message from the server.\n+   * @see GXDLMSClient#snrmRequest\n+   */\n+  public final void parseUAResponse(final GXByteBuffer data) {\n+    data.getUInt8(); // Skip FromatID\n+    data.getUInt8(); // Skip Group ID.\n+    data.getUInt8(); // Skip Group len\n+    Object val;\n+    while (data.position() < data.size()) {\n+      int id = data.getUInt8();\n+      short len = data.getUInt8();\n+      switch (len) {\n+        case 1:\n+          val = data.getUInt8();\n+          break;\n+        case 2:\n+          val = data.getUInt16();\n+          break;\n+        case 4:\n+          val = data.getUInt32();\n+          break;\n+        default:\n+          throw new GXDLMSException(\"Invalid Exception.\");\n+      }\n+      switch (id) { // RX / TX are delivered from the partner's point of view => reversed to ours\n+        case HDLCInfo.MAX_INFO_RX:\n+          getLimits().setMaxInfoTX(val);\n+          break;\n+        case HDLCInfo.MAX_INFO_TX:\n+          getLimits().setMaxInfoRX(val);\n+          break;\n+        case HDLCInfo.WINDOW_SIZE_RX:\n+          getLimits().setWindowSizeTX(val);\n+          break;\n+        case HDLCInfo.WINDOW_SIZE_TX:\n+          getLimits().setWindowSizeRX(val);\n+          break;\n+        default:\n+          throw new GXDLMSException(\"Invalid UA response.\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Generate AARQ request. Because all meters can't read all data in one\n+   * packet, the packet must be split first, by using SplitDataToPackets\n+   * method.\n+   *\n+   * @return AARQ request as byte array.\n+   * @see GXDLMSClient#parseAareResponse\n+   */\n+  public final byte[][] aarqRequest() {\n+    GXByteBuffer buff = new GXByteBuffer(20);\n+    settings.resetBlockIndex();\n+    GXDLMS.checkInit(settings);\n+    settings.setStoCChallenge(null);\n+    // If authentication or ciphering is used.\n+    if (getAuthentication().ordinal() > Authentication.LOW.ordinal()) {\n+      settings.setCtoSChallenge(\n+          GXSecure.generateChallenge(settings.getAuthentication()));\n+    } else {\n+      settings.setCtoSChallenge(null);\n+    }\n+    GXAPDU.generateAarq(settings, settings.getCipher(), buff);\n+    return GXDLMS.getMessages(settings, Command.AARQ, 0, buff, null);\n+  }\n+\n+  /**\n+   * Parses the AARE response. Parse method will update the following data:\n+   * <ul>\n+   * <li>DLMSVersion</li>\n+   * <li>MaxReceivePDUSize</li>\n+   * <li>UseLogicalNameReferencing</li>\n+   * <li>LNSettings or SNSettings</li>\n+   * </ul>\n+   * LNSettings or SNSettings will be updated, depending on the referencing,\n+   * Logical name or Short name.\n+   *\n+   * @param reply Received data.\n+   * @see GXDLMSClient#aarqRequest\n+   * @see GXDLMSClient#getUseLogicalNameReferencing\n+   * @see GXDLMSClient#getLNSettings\n+   * @see GXDLMSClient#getSNSettings\n+   */\n+  public final void parseAareResponse(final GXByteBuffer reply) {\n+    settings.setConnected(true);\n+    isAuthenticationRequired =\n+        GXAPDU.parsePDU(settings, settings.getCipher(),\n+            reply) == SourceDiagnostic.AUTHENTICATION_REQUIRED;\n+    if (getDLMSVersion() != 6) {\n+      throw new GXDLMSException(\"Invalid DLMS version number.\");\n+    }\n+  }\n+\n+  /**\n+   * @return Is authentication Required.\n+   */\n+  public final boolean getIsAuthenticationRequired() {\n+    return isAuthenticationRequired;\n+  }\n+\n+  /**\n+   * @return Get challenge request if HLS authentication is used.\n+   */\n+  public final byte[][] getApplicationAssociationRequest() {\n+    if (settings.getPassword() == null\n+        || settings.getPassword().length == 0) {\n+      throw new IllegalArgumentException(\"Password is invalid.\");\n+    }\n+    settings.resetBlockIndex();\n+    byte[] pw;\n+    if (settings.getAuthentication() == Authentication.HIGH_GMAC) {\n+      pw = settings.getCipher().getSystemTitle();\n+    } else {\n+      pw = settings.getPassword();\n+    }\n+    long ic = 0;\n+    if (settings.getCipher() != null) {\n+      ic = settings.getCipher().getFrameCounter();\n+    }\n+    byte[] challenge = GXSecure.secure(settings, settings.getCipher(), ic,\n+        settings.getStoCChallenge(), pw);\n+    GXByteBuffer bb = new GXByteBuffer();\n+    bb.setUInt8(DataType.OCTET_STRING.getValue());\n+    GXCommon.setObjectCount(challenge.length, bb);\n+    bb.set(challenge);\n+    if (getUseLogicalNameReferencing()) {\n+      return method(\"0.0.40.0.0.255\", ObjectType.ASSOCIATION_LOGICAL_NAME,\n+          1, bb.array(), DataType.OCTET_STRING);\n+    }\n+    return method(0xFA00, ObjectType.ASSOCIATION_SHORT_NAME, 8, bb.array(),\n+        DataType.OCTET_STRING);\n+  }\n+\n+  /**\n+   * Parse server's challenge if HLS authentication is used.\n+   *\n+   * @param reply Received reply from the server.\n+   */\n+  public final void\n+  parseApplicationAssociationResponse(final GXByteBuffer reply) {\n+    GXDataInfo info = new GXDataInfo();\n+    boolean equals = false;\n+    byte[] secret;\n+    long ic = 0;\n+    byte[] value = (byte[]) GXCommon.getData(reply, info);\n+    if (value != null) {\n+      if (settings.getAuthentication() == Authentication.HIGH_GMAC) {\n+        secret = settings.getSourceSystemTitle();\n+        GXByteBuffer bb = new GXByteBuffer(value);\n+        bb.getUInt8();\n+        ic = bb.getUInt32();\n+      } else {\n+        secret = settings.getPassword();\n+      }\n+      byte[] tmp = GXSecure.secure(settings, settings.getCipher(), ic,\n+          settings.getCtoSChallenge(), secret);\n+      GXByteBuffer challenge = new GXByteBuffer(tmp);\n+      equals = challenge.compare(value);\n+      if (!equals) {\n+        LOGGER.info(\"Invalid StoC:\" + GXCommon.toHex(value) + \"-\"\n+            + GXCommon.toHex(tmp));\n+      }\n+    } else {\n+      LOGGER.info(\"Server did not accept CtoS.\");\n+    }\n+\n+    if (!equals) {\n+      throw new GXDLMSException(\n+          \"parseApplicationAssociationResponse failed. \"\n+              + \" Server to Client do not match.\");\n+    }\n+  }\n+\n+  /**\n+   * Generates a disconnect request.\n+   *\n+   * @return Disconnected request, as byte array.\n+   */\n+  public final byte[] disconnectRequest() {\n+    // If connection is not established, there is no need to send\n+    // DisconnectRequest.\n+    if (settings.getSnSettings() == null\n+        && settings.getLnSettings() == null) {\n+      return new byte[0];\n+    }\n+    if (this.getInterfaceType() == InterfaceType.HDLC) {\n+      return GXDLMS.getHdlcFrame(settings, (byte) Command.DISC.getValue(),\n+          null);\n+    }\n+    GXByteBuffer bb = new GXByteBuffer(2);\n+    bb.setUInt8(Command.DISCONNECT_REQUEST.getValue());\n+    bb.setUInt8(0x0);\n+    return GXDLMS.getWrapperFrame(settings, bb);\n+  }\n+\n+  /**\n+   * Reserved for internal use.\n+   *\n+   * @param classID      Class ID.\n+   * @param version      Version number.\n+   * @param baseName     Short name.\n+   * @param ln           Logical name.\n+   * @param accessRights Array of access rights.\n+   * @return Created COSEM object.\n+   */\n+  static GXDLMSObject createDLMSObject(final int classID,\n+                                       final Object version, final int baseName,\n+                                       final Object ln,\n+                                       final Object accessRights) {\n+    ObjectType type = ObjectType.forValue(classID);\n+    GXDLMSObject obj = createObject(type);\n+    updateObjectData(obj, type, version, baseName, (byte[]) ln,\n+        accessRights);\n+    return obj;\n+  }\n+\n+  /**\n+   * Parse SN objects.\n+   *\n+   * @param buff             Byte stream where objects are parsed.\n+   * @param onlyKnownObjects Only known objects are parsed.\n+   * @return Collection of COSEM objects.\n+   */\n+  private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff,\n+                                                final boolean onlyKnownObjects) {\n+    // Get array tag.\n+    short size = buff.getUInt8();\n+    // Check that data is in the array\n+    if (size != 0x01) {\n+      throw new GXDLMSException(\"Invalid response.\");\n+    }\n+    GXDLMSObjectCollection items = new GXDLMSObjectCollection(this);\n+    long cnt = GXCommon.getObjectCount(buff);\n+    GXDataInfo info = new GXDataInfo();\n+    for (long objPos = 0; objPos != cnt; ++objPos) {\n+      // Some meters give wrong item count.\n+      if (buff.position() == buff.size()) {\n+        break;\n+      }\n+      info.setCount(0);\n+      info.setIndex(0);\n+      info.setType(DataType.NONE);\n+      Object[] objects = (Object[]) GXCommon.getData(buff, info);\n+      if (objects.length != 4) {\n+        throw new GXDLMSException(\"Invalid structure format.\");\n+      }\n+      int classID = ((Number) (objects[1])).intValue() & 0xFFFF;\n+      int baseName = ((Number) (objects[0])).intValue() & 0xFFFF;\n+      if (baseName > 0) {\n+        GXDLMSObject comp = createDLMSObject(classID, objects[2],\n+            baseName, objects[3], null);\n+        if (!onlyKnownObjects\n+            || comp.getClass() != GXDLMSObject.class) {\n+          items.add(comp);\n         } else {\n-            data = null;\n-        }\n-        return GXDLMS.getHdlcFrame(settings, (byte) Command.SNRM.getValue(),\n-                null);\n-    }\n-\n-    /**\n-     * Parses UAResponse from byte array.\n-     * \n-     * @param data\n-     *            Received message from the server.\n-     * @see GXDLMSClient#snrmRequest\n-     */\n-    public final void parseUAResponse(final byte[] data) {\n-        parseUAResponse(new GXByteBuffer(data));\n-    }\n-\n-    /**\n-     * Parses UAResponse from byte array.\n-     * \n-     * @param data\n-     *            Received message from the server.\n-     * @see GXDLMSClient#snrmRequest\n-     */\n-    public final void parseUAResponse(final GXByteBuffer data) {\n-        data.getUInt8(); // Skip FromatID\n-        data.getUInt8(); // Skip Group ID.\n-        data.getUInt8(); // Skip Group len\n-        Object val;\n-        while (data.position() < data.size()) {\n-            int id = data.getUInt8();\n-            short len = data.getUInt8();\n-            switch (len) {\n-            case 1:\n-                val = data.getUInt8();\n-                break;\n-            case 2:\n-                val = data.getUInt16();\n-                break;\n-            case 4:\n-                val = data.getUInt32();\n-                break;\n-            default:\n-                throw new GXDLMSException(\"Invalid Exception.\");\n-            }\n-            switch (id) { // RX / TX are delivered from the partner's point of view => reversed to ours\n-            case HDLCInfo.MAX_INFO_RX:\n-                getLimits().setMaxInfoTX(val);\n-                break;\n-            case HDLCInfo.MAX_INFO_TX:\n-                getLimits().setMaxInfoRX(val);\n-                break;\n-            case HDLCInfo.WINDOW_SIZE_RX:\n-                getLimits().setWindowSizeTX(val);\n-                break;\n-            case HDLCInfo.WINDOW_SIZE_TX:\n-                getLimits().setWindowSizeRX(val);\n-                break;\n-            default:\n-                throw new GXDLMSException(\"Invalid UA response.\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Generate AARQ request. Because all meters can't read all data in one\n-     * packet, the packet must be split first, by using SplitDataToPackets\n-     * method.\n-     * \n-     * @return AARQ request as byte array.\n-     * @see GXDLMSClient#parseAareResponse\n-     */\n-    public final byte[][] aarqRequest() {\n-        GXByteBuffer buff = new GXByteBuffer(20);\n-        settings.resetBlockIndex();\n-        GXDLMS.checkInit(settings);\n-        settings.setStoCChallenge(null);\n-        // If authentication or ciphering is used.\n-        if (getAuthentication().ordinal() > Authentication.LOW.ordinal()) {\n-            settings.setCtoSChallenge(\n-                    GXSecure.generateChallenge(settings.getAuthentication()));\n-        } else {\n-            settings.setCtoSChallenge(null);\n-        }\n-        GXAPDU.generateAarq(settings, settings.getCipher(), buff);\n-        return GXDLMS.getMessages(settings, Command.AARQ, 0, buff, null);\n-    }\n-\n-    /**\n-     * Parses the AARE response. Parse method will update the following data:\n-     * <ul>\n-     * <li>DLMSVersion</li>\n-     * <li>MaxReceivePDUSize</li>\n-     * <li>UseLogicalNameReferencing</li>\n-     * <li>LNSettings or SNSettings</li>\n-     * </ul>\n-     * LNSettings or SNSettings will be updated, depending on the referencing,\n-     * Logical name or Short name.\n-     * \n-     * @param reply\n-     *            Received data.\n-     * @see GXDLMSClient#aarqRequest\n-     * @see GXDLMSClient#getUseLogicalNameReferencing\n-     * @see GXDLMSClient#getLNSettings\n-     * @see GXDLMSClient#getSNSettings\n-     */\n-    public final void parseAareResponse(final GXByteBuffer reply) {\n-        settings.setConnected(true);\n-        isAuthenticationRequired =\n-                GXAPDU.parsePDU(settings, settings.getCipher(),\n-                        reply) == SourceDiagnostic.AUTHENTICATION_REQUIRED;\n-        if (getDLMSVersion() != 6) {\n-            throw new GXDLMSException(\"Invalid DLMS version number.\");\n-        }\n-    }\n-\n-    /**\n-     * @return Is authentication Required.\n-     */\n-    public final boolean getIsAuthenticationRequired() {\n-        return isAuthenticationRequired;\n-    }\n-\n-    /**\n-     * @return Get challenge request if HLS authentication is used.\n-     */\n-    public final byte[][] getApplicationAssociationRequest() {\n-        if (settings.getPassword() == null\n-                || settings.getPassword().length == 0) {\n-            throw new IllegalArgumentException(\"Password is invalid.\");\n-        }\n-        settings.resetBlockIndex();\n-        byte[] pw;\n-        if (settings.getAuthentication() == Authentication.HIGH_GMAC) {\n-            pw = settings.getCipher().getSystemTitle();\n-        } else {\n-            pw = settings.getPassword();\n-        }\n-        long ic = 0;\n-        if (settings.getCipher() != null) {\n-            ic = settings.getCipher().getFrameCounter();\n-        }\n-        byte[] challenge = GXSecure.secure(settings, settings.getCipher(), ic,\n-                settings.getStoCChallenge(), pw);\n-        GXByteBuffer bb = new GXByteBuffer();\n-        bb.setUInt8(DataType.OCTET_STRING.getValue());\n-        GXCommon.setObjectCount(challenge.length, bb);\n-        bb.set(challenge);\n-        if (getUseLogicalNameReferencing()) {\n-            return method(\"0.0.40.0.0.255\", ObjectType.ASSOCIATION_LOGICAL_NAME,\n-                    1, bb.array(), DataType.OCTET_STRING);\n-        }\n-        return method(0xFA00, ObjectType.ASSOCIATION_SHORT_NAME, 8, bb.array(),\n-                DataType.OCTET_STRING);\n-    }\n-\n-    /**\n-     * Parse server's challenge if HLS authentication is used.\n-     * \n-     * @param reply\n-     *            Received reply from the server.\n-     */\n-    public final void\n-            parseApplicationAssociationResponse(final GXByteBuffer reply) {\n-        GXDataInfo info = new GXDataInfo();\n-        boolean equals = false;\n-        byte[] secret;\n-        long ic = 0;\n-        byte[] value = (byte[]) GXCommon.getData(reply, info);\n-        if (value != null) {\n-            if (settings.getAuthentication() == Authentication.HIGH_GMAC) {\n-                secret = settings.getSourceSystemTitle();\n-                GXByteBuffer bb = new GXByteBuffer(value);\n-                bb.getUInt8();\n-                ic = bb.getUInt32();\n-            } else {\n-                secret = settings.getPassword();\n-            }\n-            byte[] tmp = GXSecure.secure(settings, settings.getCipher(), ic,\n-                    settings.getCtoSChallenge(), secret);\n-            GXByteBuffer challenge = new GXByteBuffer(tmp);\n-            equals = challenge.compare(value);\n-            if (!equals) {\n-                LOGGER.info(\"Invalid StoC:\" + GXCommon.toHex(value) + \"-\"\n-                        + GXCommon.toHex(tmp));\n-            }\n-        } else {\n-            LOGGER.info(\"Server did not accept CtoS.\");\n-        }\n-\n-        if (!equals) {\n-            throw new GXDLMSException(\n-                    \"parseApplicationAssociationResponse failed. \"\n-                            + \" Server to Client do not match.\");\n+          System.out.println(String.format(\"Unknown object : %d %d\",\n+              classID, baseName));\n         }\n-    }\n-\n-    /**\n-     * Generates a disconnect request.\n-     * \n-     * @return Disconnected request, as byte array.\n-     */\n-    public final byte[] disconnectRequest() {\n-        // If connection is not established, there is no need to send\n-        // DisconnectRequest.\n-        if (settings.getSnSettings() == null\n-                && settings.getLnSettings() == null) {\n-            return new byte[0];\n-        }\n-        if (this.getInterfaceType() == InterfaceType.HDLC) {\n-            return GXDLMS.getHdlcFrame(settings, (byte) Command.DISC.getValue(),\n-                    null);\n-        }\n-        GXByteBuffer bb = new GXByteBuffer(2);\n-        bb.setUInt8(Command.DISCONNECT_REQUEST.getValue());\n-        bb.setUInt8(0x0);\n-        return GXDLMS.getWrapperFrame(settings, bb);\n-    }\n-\n-    /**\n-     * Reserved for internal use.\n-     * \n-     * @param classID\n-     *            Class ID.\n-     * @param version\n-     *            Version number.\n-     * @param baseName\n-     *            Short name.\n-     * @param ln\n-     *            Logical name.\n-     * @param accessRights\n-     *            Array of access rights.\n-     * @return Created COSEM object.\n-     */\n-    static GXDLMSObject createDLMSObject(final int classID,\n-            final Object version, final int baseName, final Object ln,\n-            final Object accessRights) {\n-        ObjectType type = ObjectType.forValue(classID);\n-        GXDLMSObject obj = createObject(type);\n-        updateObjectData(obj, type, version, baseName, (byte[]) ln,\n-                accessRights);\n-        return obj;\n-    }\n-\n-    /**\n-     * Parse SN objects.\n-     * \n-     * @param buff\n-     *            Byte stream where objects are parsed.\n-     * @param onlyKnownObjects\n-     *            Only known objects are parsed.\n-     * @return Collection of COSEM objects.\n-     */\n-    private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n-        // Get array tag.\n-        short size = buff.getUInt8();\n-        // Check that data is in the array\n-        if (size != 0x01) {\n-            throw new GXDLMSException(\"Invalid response.\");\n-        }\n-        GXDLMSObjectCollection items = new GXDLMSObjectCollection(this);\n-        long cnt = GXCommon.getObjectCount(buff);\n-        GXDataInfo info = new GXDataInfo();\n-        for (long objPos = 0; objPos != cnt; ++objPos) {\n-            // Some meters give wrong item count.\n-            if (buff.position() == buff.size()) {\n-                break;\n-            }\n-            info.setCount(0);\n-            info.setIndex(0);\n-            info.setType(DataType.NONE);\n-            Object[] objects = (Object[]) GXCommon.getData(buff, info);\n-            if (objects.length != 4) {\n-                throw new GXDLMSException(\"Invalid structure format.\");\n-            }\n-            int classID = ((Number) (objects[1])).intValue() & 0xFFFF;\n-            int baseName = ((Number) (objects[0])).intValue() & 0xFFFF;\n-            if (baseName > 0) {\n-                GXDLMSObject comp = createDLMSObject(classID, objects[2],\n-                        baseName, objects[3], null);\n-                if (!onlyKnownObjects\n-                        || comp.getClass() != GXDLMSObject.class) {\n-                    items.add(comp);\n-                } else {\n-                    System.out.println(String.format(\"Unknown object : %d %d\",\n-                            classID, baseName));\n-                }\n-            }\n-        }\n-        return items;\n-    }\n-\n-    /**\n-     * Reserved for internal use.\n-     * \n-     * @param objectType\n-     * @param version\n-     * @param baseName\n-     * @param logicalName\n-     * @param accessRights\n-     */\n-    static void updateObjectData(final GXDLMSObject obj,\n-            final ObjectType objectType, final Object version,\n-            final Object baseName, final byte[] logicalName,\n-            final Object accessRights) {\n-        obj.setObjectType(objectType);\n-        // Check access rights.\n-        if (accessRights instanceof Object[]\n-                && ((Object[]) accessRights).length == 2) {\n-            // access_rights: access_right\n-            Object[] access = (Object[]) accessRights;\n-            for (Object attributeAccess : (Object[]) access[0]) {\n-                int id = ((Number) ((Object[]) attributeAccess)[0]).intValue();\n-                int tmp = ((Number) ((Object[]) attributeAccess)[1]).intValue();\n-                AccessMode mode = AccessMode.forValue(tmp);\n-                obj.setAccess(id, mode);\n-            }\n-            for (Object methodAccess : (Object[]) access[1]) {\n-                int id = ((Number) ((Object[]) methodAccess)[0]).intValue();\n-                int tmp;\n-                // If version is 0\n-                if (((Object[]) methodAccess)[1] instanceof Boolean) {\n-                    if ((Boolean) ((Object[]) methodAccess)[1]) {\n-                        tmp = 1;\n-                    } else {\n-                        tmp = 0;\n-                    }\n-                } else {\n-                    // If version is 1.\n-                    tmp = ((Number) ((Object[]) methodAccess)[1]).intValue();\n-                }\n-                MethodAccessMode mode = MethodAccessMode.forValue(tmp);\n-                obj.setMethodAccess(id, mode);\n-            }\n-        }\n-        if (baseName != null) {\n-            obj.setShortName(((Number) baseName).intValue());\n-        }\n-        if (version != null) {\n-            obj.setVersion(((Number) version).intValue());\n-        }\n-        obj.setLogicalName(GXDLMSObject.toLogicalName(logicalName));\n-    }\n-\n-    /**\n-     * Parses the COSEM objects of the received data.\n-     * \n-     * @param data\n-     *            Received data, from the device, as byte array.\n-     * @param onlyKnownObjects\n-     *            Only known objects are parsed.\n-     * @return Collection of COSEM objects.\n-     */\n-    public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data,\n-            final boolean onlyKnownObjects) {\n-        if (data == null) {\n-            throw new GXDLMSException(\"Invalid parameter.\");\n-        }\n-        GXDLMSObjectCollection objects;\n-        if (getUseLogicalNameReferencing()) {\n-            objects = parseLNObjects(data, onlyKnownObjects);\n+      }\n+    }\n+    return items;\n+  }\n+\n+  /**\n+   * Reserved for internal use.\n+   *\n+   * @param objectType\n+   * @param version\n+   * @param baseName\n+   * @param logicalName\n+   * @param accessRights\n+   */\n+  static void updateObjectData(final GXDLMSObject obj,\n+                               final ObjectType objectType,\n+                               final Object version,\n+                               final Object baseName, final byte[] logicalName,\n+                               final Object accessRights) {\n+    obj.setObjectType(objectType);\n+    // Check access rights.\n+    if (accessRights instanceof Object[]\n+        && ((Object[]) accessRights).length == 2) {\n+      // access_rights: access_right\n+      Object[] access = (Object[]) accessRights;\n+      for (Object attributeAccess : (Object[]) access[0]) {\n+        int id = ((Number) ((Object[]) attributeAccess)[0]).intValue();\n+        int tmp = ((Number) ((Object[]) attributeAccess)[1]).intValue();\n+        AccessMode mode = AccessMode.forValue(tmp);\n+        obj.setAccess(id, mode);\n+      }\n+      for (Object methodAccess : (Object[]) access[1]) {\n+        int id = ((Number) ((Object[]) methodAccess)[0]).intValue();\n+        int tmp;\n+        // If version is 0\n+        if (((Object[]) methodAccess)[1] instanceof Boolean) {\n+          if ((Boolean) ((Object[]) methodAccess)[1]) {\n+            tmp = 1;\n+          } else {\n+            tmp = 0;\n+          }\n         } else {\n-            objects = parseSNObjects(data, onlyKnownObjects);\n-        }\n-        settings.getObjects().addAll(objects);\n-        return objects;\n-    }\n-\n-    /**\n-     * Parse LN objects.\n-     * \n-     * @param buff\n-     *            Byte stream where objects are parsed.\n-     * @param onlyKnownObjects\n-     *            Only known objects are parsed.\n-     * @return Collection of COSEM objects.\n-     */\n-    private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n-        // Get array tag.\n-        byte size = buff.getInt8();\n-        // Check that data is in the array\n-        if (size != 0x01) {\n-            throw new GXDLMSException(\"Invalid response.\");\n-        }\n-        GXDLMSObjectCollection items = new GXDLMSObjectCollection(this);\n-        GXDataInfo info = new GXDataInfo();\n-        long cnt = GXCommon.getObjectCount(buff);\n-        for (long objPos = 0; objPos != cnt; ++objPos) {\n-            // Some meters give wrong item count.\n-            // This fix Iskraemeco (MT-880) bug.\n-            if (buff.position() == buff.size()) {\n-                break;\n-            }\n-            info.setType(DataType.NONE);\n-            info.setIndex(0);\n-            info.setCount(0);\n-            Object[] objects = (Object[]) GXCommon.getData(buff, info);\n-            if (objects.length != 4) {\n-                throw new GXDLMSException(\"Invalid structure format.\");\n-            }\n-            int classID = ((Number) (objects[0])).intValue() & 0xFFFF;\n-            if (classID > 0) {\n-                GXDLMSObject comp = createDLMSObject(classID, objects[1], 0,\n-                        objects[2], objects[3]);\n-                if (!onlyKnownObjects\n-                        || comp.getClass() != GXDLMSObject.class) {\n-                    items.add(comp);\n-                } else {\n-                    System.out.println(String.format(\"Unknown object : %d %s\",\n-                            classID,\n-                            GXDLMSObject.toLogicalName((byte[]) objects[2])));\n-                }\n-            }\n-        }\n-        return items;\n-    }\n-\n-    /*\n-     * Get Value from byte array received from the meter.\n-     */\n-    public final Object updateValue(final GXDLMSObject target,\n-            final int attributeIndex, final Object value) {\n-        Object val = value;\n-        if (val instanceof byte[]) {\n-            DataType type = target.getUIDataType(attributeIndex);\n-            if (type == DataType.DATETIME && ((byte[]) val).length == 5) {\n-                type = DataType.DATE;\n-                target.setUIDataType(attributeIndex, type);\n-            }\n-            if (type != DataType.NONE) {\n-                val = changeType((byte[]) value, type);\n-            }\n-        }\n-        ValueEventArgs e =\n-                new ValueEventArgs(settings, target, attributeIndex, 0, null);\n-        e.setValue(val);\n-        target.setValue(settings, e);\n-        return target.getValues()[attributeIndex - 1];\n-    }\n-\n-    /**\n-     * Get Value from byte array received from the meter.\n-     * \n-     * @param data\n-     *            Byte array received from the meter.\n-     * @return Received data.\n-     */\n-    public final Object getValue(final GXByteBuffer data) {\n-        GXDataInfo info = new GXDataInfo();\n-        return GXCommon.getData(data, info);\n-    }\n-\n-    /**\n-     * Update list of values.\n-     * \n-     * @param list\n-     *            read objects.\n-     * @param data\n-     *            Received reply from the meter.\n-     */\n-    public final void updateValues(\n-            final List<Entry<GXDLMSObject, Integer>> list,\n-            final GXByteBuffer data) {\n-        Object value;\n-        GXDataInfo info = new GXDataInfo();\n-        for (Entry<GXDLMSObject, Integer> it : list) {\n-            int ret = data.getUInt8();\n-            if (ret == 0) {\n-                value = GXCommon.getData(data, info);\n-                ValueEventArgs e = new ValueEventArgs(settings, it.getKey(),\n-                        it.getValue(), 0, null);\n-                e.setValue(value);\n-                it.getKey().setValue(settings, e);\n-                info.clear();\n-            } else {\n-                throw new GXDLMSException(ret);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Update list of values.\n-     * \n-     * @param list\n-     *            read objects.\n-     * @param reply\n-     *            Received reply from the meter.\n-     */\n-    public final void updateValues(\n-            final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n-        updateValues(list, new GXByteBuffer(reply));\n-    }\n-\n-    /**\n-     * Changes byte array received from the meter to given type.\n-     * \n-     * @param value\n-     *            Byte array received from the meter.\n-     * @param type\n-     *            Wanted type.\n-     * @return Value changed by type.\n-     */\n-    public static Object changeType(final byte[] value, final DataType type) {\n-        if (value == null) {\n-            return null;\n-        }\n-        if (type == DataType.NONE) {\n-            return GXCommon.toHex(value);\n-        }\n-        if (value.length == 0\n-                && (type == DataType.STRING || type == DataType.OCTET_STRING)) {\n-            return \"\";\n-        }\n-        GXDataInfo info = new GXDataInfo();\n-        info.setType(type);\n-        Object ret = GXCommon.getData(new GXByteBuffer(value), info);\n-        if (!info.isCompleate()) {\n-            throw new OutOfMemoryError();\n+          // If version is 1.\n+          tmp = ((Number) ((Object[]) methodAccess)[1]).intValue();\n         }\n-        if (type == DataType.OCTET_STRING && ret instanceof byte[]) {\n-            String str;\n-            byte[] arr = (byte[]) ret;\n-            if (arr.length == 0) {\n-                str = \"\";\n-            } else {\n-                StringBuilder bcd = new StringBuilder(arr.length * 4);\n-                for (int it : arr) {\n-                    if (bcd.length() != 0) {\n-                        bcd.append(\".\");\n-                    }\n-                    bcd.append(String.format(\"%d\", it & 0xFF));\n-                }\n-                str = bcd.toString();\n-            }\n-            return str;\n-        }\n-        return ret;\n-    }\n-\n-    /**\n-     * Reads the Association view from the device. This method is used to get\n-     * all objects in the device.\n-     * \n-     * @return Read request, as byte array.\n-     */\n-    public final byte[] getObjectsRequest() {\n-        Object name;\n-        settings.resetBlockIndex();\n-        if (getUseLogicalNameReferencing()) {\n-            name = \"0.0.40.0.0.255\";\n+        MethodAccessMode mode = MethodAccessMode.forValue(tmp);\n+        obj.setMethodAccess(id, mode);\n+      }\n+    }\n+    if (baseName != null) {\n+      obj.setShortName(((Number) baseName).intValue());\n+    }\n+    if (version != null) {\n+      obj.setVersion(((Number) version).intValue());\n+    }\n+    obj.setLogicalName(GXDLMSObject.toLogicalName(logicalName));\n+  }\n+\n+  /**\n+   * Parses the COSEM objects of the received data.\n+   *\n+   * @param data             Received data, from the device, as byte array.\n+   * @param onlyKnownObjects Only known objects are parsed.\n+   * @return Collection of COSEM objects.\n+   */\n+  public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data,\n+                                                   final boolean onlyKnownObjects) {\n+    if (data == null) {\n+      throw new GXDLMSException(\"Invalid parameter.\");\n+    }\n+    GXDLMSObjectCollection objects;\n+    if (getUseLogicalNameReferencing()) {\n+      objects = parseLNObjects(data, onlyKnownObjects);\n+    } else {\n+      objects = parseSNObjects(data, onlyKnownObjects);\n+    }\n+    settings.getObjects().addAll(objects);\n+    return objects;\n+  }\n+\n+  /**\n+   * Parse LN objects.\n+   *\n+   * @param buff             Byte stream where objects are parsed.\n+   * @param onlyKnownObjects Only known objects are parsed.\n+   * @return Collection of COSEM objects.\n+   */\n+  private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff,\n+                                                final boolean onlyKnownObjects) {\n+    // Get array tag.\n+    byte size = buff.getInt8();\n+    // Check that data is in the array\n+    if (size != 0x01) {\n+      throw new GXDLMSException(\"Invalid response.\");\n+    }\n+    GXDLMSObjectCollection items = new GXDLMSObjectCollection(this);\n+    GXDataInfo info = new GXDataInfo();\n+    long cnt = GXCommon.getObjectCount(buff);\n+    for (long objPos = 0; objPos != cnt; ++objPos) {\n+      // Some meters give wrong item count.\n+      // This fix Iskraemeco (MT-880) bug.\n+      if (buff.position() == buff.size()) {\n+        break;\n+      }\n+      info.setType(DataType.NONE);\n+      info.setIndex(0);\n+      info.setCount(0);\n+      Object[] objects = (Object[]) GXCommon.getData(buff, info);\n+      if (objects.length != 4) {\n+        throw new GXDLMSException(\"Invalid structure format.\");\n+      }\n+      int classID = ((Number) (objects[0])).intValue() & 0xFFFF;\n+      if (classID > 0) {\n+        GXDLMSObject comp = createDLMSObject(classID, objects[1], 0,\n+            objects[2], objects[3]);\n+        if (!onlyKnownObjects\n+            || comp.getClass() != GXDLMSObject.class) {\n+          items.add(comp);\n         } else {\n-            name = (short) 0xFA00;\n+          System.out.println(String.format(\"Unknown object : %d %s\",\n+              classID,\n+              GXDLMSObject.toLogicalName((byte[]) objects[2])));\n         }\n-        return read(name, ObjectType.ASSOCIATION_LOGICAL_NAME, 2)[0];\n-    }\n-\n-    /**\n-     * Generate Method (Action) request.\n-     * \n-     * @param item\n-     *            Method object short name or Logical Name.\n-     * @param index\n-     *            Method index.\n-     * @param data\n-     *            Method data.\n-     * @param type\n-     *            Data type.\n-     * @return DLMS action message.\n-     */\n-    public final byte[][] method(final GXDLMSObject item, final int index,\n-            final Object data, final DataType type) {\n-        return method(item.getName(), item.getObjectType(), index, data, type);\n-    }\n-\n-    /**\n-     * Generate Method (Action) request..\n-     * \n-     * @param name\n-     *            Method object short name or Logical Name.\n-     * @param objectType\n-     *            Object type.\n-     * @param methodIndex\n-     *            Method index.\n-     * @param value\n-     *            Method data.\n-     * @param dataType\n-     *            Data type.\n-     * @return DLMS action message.\n-     */\n-    public final byte[][] method(final Object name, final ObjectType objectType,\n-            final int methodIndex, final Object value,\n-            final DataType dataType) {\n-        if (name == null || methodIndex < 1) {\n-            throw new IllegalArgumentException(\"Invalid parameter\");\n+      }\n+    }\n+    return items;\n+  }\n+\n+  /*\n+   * Get Value from byte array received from the meter.\n+   */\n+  public final Object updateValue(final GXDLMSObject target,\n+                                  final int attributeIndex,\n+                                  final Object value) {\n+    Object val = value;\n+    if (val instanceof byte[]) {\n+      DataType type = target.getUIDataType(attributeIndex);\n+      if (type == DataType.DATETIME && ((byte[]) val).length == 5) {\n+        type = DataType.DATE;\n+        target.setUIDataType(attributeIndex, type);\n+      }\n+      if (type != DataType.NONE) {\n+        val = changeType((byte[]) value, type);\n+      }\n+    }\n+    ValueEventArgs e =\n+        new ValueEventArgs(settings, target, attributeIndex, 0, null);\n+    e.setValue(val);\n+    target.setValue(settings, e);\n+    return target.getValues()[attributeIndex - 1];\n+  }\n+\n+  /**\n+   * Get Value from byte array received from the meter.\n+   *\n+   * @param data Byte array received from the meter.\n+   * @return Received data.\n+   */\n+  public final Object getValue(final GXByteBuffer data) {\n+    GXDataInfo info = new GXDataInfo();\n+    return GXCommon.getData(data, info);\n+  }\n+\n+  /**\n+   * Update list of values.\n+   *\n+   * @param list read objects.\n+   * @param data Received reply from the meter.\n+   */\n+  public final void updateValues(\n+      final List<Entry<GXDLMSObject, Integer>> list,\n+      final GXByteBuffer data) {\n+    Object value;\n+    GXDataInfo info = new GXDataInfo();\n+    for (Entry<GXDLMSObject, Integer> it : list) {\n+      int ret = data.getUInt8();\n+      if (ret == 0) {\n+        value = GXCommon.getData(data, info);\n+        ValueEventArgs e = new ValueEventArgs(settings, it.getKey(),\n+            it.getValue(), 0, null);\n+        e.setValue(value);\n+        it.getKey().setValue(settings, e);\n+        info.clear();\n+      } else {\n+        throw new GXDLMSException(ret);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update list of values.\n+   *\n+   * @param list  read objects.\n+   * @param reply Received reply from the meter.\n+   */\n+  public final void updateValues(\n+      final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n+    updateValues(list, new GXByteBuffer(reply));\n+  }\n+\n+  /**\n+   * Changes byte array received from the meter to given type.\n+   *\n+   * @param value Byte array received from the meter.\n+   * @param type  Wanted type.\n+   * @return Value changed by type.\n+   */\n+  public static Object changeType(final byte[] value, final DataType type) {\n+    if (value == null) {\n+      return null;\n+    }\n+    if (type == DataType.NONE) {\n+      return GXCommon.toHex(value);\n+    }\n+    if (value.length == 0\n+        && (type == DataType.STRING || type == DataType.OCTET_STRING)) {\n+      return \"\";\n+    }\n+    GXDataInfo info = new GXDataInfo();\n+    info.setType(type);\n+    Object ret = GXCommon.getData(new GXByteBuffer(value), info);\n+    if (!info.isCompleate()) {\n+      throw new OutOfMemoryError();\n+    }\n+    if (type == DataType.OCTET_STRING && ret instanceof byte[]) {\n+      String str;\n+      byte[] arr = (byte[]) ret;\n+      if (arr.length == 0) {\n+        str = \"\";\n+      } else {\n+        StringBuilder bcd = new StringBuilder(arr.length * 4);\n+        for (int it : arr) {\n+          if (bcd.length() != 0) {\n+            bcd.append(\".\");\n+          }\n+          bcd.append(String.format(\"%d\", it & 0xFF));\n         }\n-        settings.resetBlockIndex();\n-        int index = methodIndex;\n-        DataType type = dataType;\n-        if (type == DataType.NONE && value != null) {\n-            type = GXCommon.getValueType(value);\n-            if (type == DataType.NONE) {\n-                throw new GXDLMSException(\n-                        \"Invalid parameter. In java value type must give.\");\n-            }\n-        }\n-        GXByteBuffer bb = new GXByteBuffer();\n-        Command cmd;\n-        if (getUseLogicalNameReferencing()) {\n-            cmd = Command.METHOD_REQUEST;\n-            // CI\n-            bb.setUInt16(objectType.getValue());\n-            // Add LN\n-            List<String> items = GXCommon.split((String) name, '.');\n-            if (items.size() != 6) {\n-                throw new IllegalArgumentException(\"Invalid Logical Name.\");\n-            }\n-            for (String it2 : items) {\n-                bb.setUInt8(Integer.valueOf(it2).byteValue());\n-            }\n-            // Attribute ID.\n-            bb.setUInt8(index);\n-            // Method Invocation Parameters is not used.\n-            if (type == DataType.NONE) {\n-                bb.setUInt8(0);\n-            } else {\n-                bb.setUInt8(1);\n-            }\n-        } else {\n-            int[] data = new int[1], count = new int[1];\n-            GXDLMS.getActionInfo(objectType, data, count);\n-            if (index > count[0]) {\n-                throw new IllegalArgumentException(\"methodIndex\");\n-            }\n-            int sn = GXCommon.intValue(name);\n-            index = (data[0] + (index - 1) * 0x8);\n-            sn += index;\n-            cmd = Command.READ_REQUEST;\n-            // Add SN count.\n-            bb.setUInt8(1);\n-            // Add name length.\n-            bb.setUInt8(4);\n-            // Add name.\n-            bb.setUInt16(sn);\n-            // Method Invocation Parameters is not used.\n-            if (type == DataType.NONE) {\n-                bb.setUInt8(0);\n-            } else {\n-                bb.setUInt8(1);\n-            }\n+        str = bcd.toString();\n+      }\n+      return str;\n+    }\n+    return ret;\n+  }\n+\n+  /**\n+   * Reads the Association view from the device. This method is used to get\n+   * all objects in the device.\n+   *\n+   * @return Read request, as byte array.\n+   */\n+  public final byte[] getObjectsRequest() {\n+    Object name;\n+    settings.resetBlockIndex();\n+    if (getUseLogicalNameReferencing()) {\n+      name = \"0.0.40.0.0.255\";\n+    } else {\n+      name = (short) 0xFA00;\n+    }\n+    return read(name, ObjectType.ASSOCIATION_LOGICAL_NAME, 2)[0];\n+  }\n+\n+  /**\n+   * Generate Method (Action) request.\n+   *\n+   * @param item  Method object short name or Logical Name.\n+   * @param index Method index.\n+   * @param data  Method data.\n+   * @param type  Data type.\n+   * @return DLMS action message.\n+   */\n+  public final byte[][] method(final GXDLMSObject item, final int index,\n+                               final Object data, final DataType type) {\n+    return method(item.getName(), item.getObjectType(), index, data, type);\n+  }\n+\n+  /**\n+   * Generate Method (Action) request..\n+   *\n+   * @param name        Method object short name or Logical Name.\n+   * @param objectType  Object type.\n+   * @param methodIndex Method index.\n+   * @param value       Method data.\n+   * @param dataType    Data type.\n+   * @return DLMS action message.\n+   */\n+  public final byte[][] method(final Object name, final ObjectType objectType,\n+                               final int methodIndex, final Object value,\n+                               final DataType dataType) {\n+    if (name == null || methodIndex < 1) {\n+      throw new IllegalArgumentException(\"Invalid parameter\");\n+    }\n+    settings.resetBlockIndex();\n+    int index = methodIndex;\n+    DataType type = dataType;\n+    if (type == DataType.NONE && value != null) {\n+      type = GXCommon.getValueType(value);\n+      if (type == DataType.NONE) {\n+        throw new GXDLMSException(\n+            \"Invalid parameter. In java value type must give.\");\n+      }\n+    }\n+    GXByteBuffer bb = new GXByteBuffer();\n+    Command cmd;\n+    if (getUseLogicalNameReferencing()) {\n+      cmd = Command.METHOD_REQUEST;\n+      // CI\n+      bb.setUInt16(objectType.getValue());\n+      // Add LN\n+      List<String> items = GXCommon.split((String) name, '.');\n+      if (items.size() != 6) {\n+        throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+      }\n+      for (String it2 : items) {\n+        bb.setUInt8(Integer.valueOf(it2).byteValue());\n+      }\n+      // Attribute ID.\n+      bb.setUInt8(index);\n+      // Method Invocation Parameters is not used.\n+      if (type == DataType.NONE) {\n+        bb.setUInt8(0);\n+      } else {\n+        bb.setUInt8(1);\n+      }\n+    } else {\n+      int[] data = new int[1], count = new int[1];\n+      GXDLMS.getActionInfo(objectType, data, count);\n+      if (index > count[0]) {\n+        throw new IllegalArgumentException(\"methodIndex\");\n+      }\n+      int sn = GXCommon.intValue(name);\n+      index = (data[0] + (index - 1) * 0x8);\n+      sn += index;\n+      cmd = Command.READ_REQUEST;\n+      // Add SN count.\n+      bb.setUInt8(1);\n+      // Add name length.\n+      bb.setUInt8(4);\n+      // Add name.\n+      bb.setUInt16(sn);\n+      // Method Invocation Parameters is not used.\n+      if (type == DataType.NONE) {\n+        bb.setUInt8(0);\n+      } else {\n+        bb.setUInt8(1);\n+      }\n+    }\n+    if ((value instanceof byte[])) {\n+      bb.set((byte[]) value);\n+    } else if (type != DataType.NONE) {\n+      GXCommon.setData(bb, type, value);\n+    }\n+    return GXDLMS.getMessages(settings, cmd, 1, bb, null);\n+  }\n+\n+  /**\n+   * Generates a write message.\n+   *\n+   * @param item  COSEM object to read.\n+   * @param index Attribute index.\n+   * @return Generated write message(s).\n+   */\n+  public final byte[][] write(final GXDLMSObject item, final int index) {\n+    ValueEventArgs e = new ValueEventArgs(settings, item, index, 0, null);\n+    Object value = item.getValue(settings, e);\n+    DataType type = item.getDataType(index);\n+    return write(item.getName(), value, type, item.getObjectType(), index);\n+  }\n+\n+  /**\n+   * Generates a write message.\n+   *\n+   * @param name       Short or Logical Name.\n+   * @param value      Data to Write.\n+   * @param dataType   Data type of write object.\n+   * @param objectType Object type.\n+   * @param index      Attribute index where data is write.\n+   * @return Generated write message(s).\n+   */\n+  public final byte[][] write(final Object name, final Object value,\n+                              final DataType dataType,\n+                              final ObjectType objectType,\n+                              final int index) {\n+    if (index < 1) {\n+      throw new GXDLMSException(\"Invalid parameter\");\n+    }\n+    settings.resetBlockIndex();\n+    DataType type = dataType;\n+    if (type == DataType.NONE && value != null) {\n+      type = GXCommon.getValueType(value);\n+      if (type == DataType.NONE) {\n+        throw new GXDLMSException(\n+            \"Invalid parameter. In java value type must give.\");\n+      }\n+    }\n+    GXByteBuffer bb = new GXByteBuffer();\n+    Command cmd;\n+    if (getUseLogicalNameReferencing()) {\n+      cmd = Command.SET_REQUEST;\n+      // Add CI.\n+      bb.setUInt16(objectType.getValue());\n+      // Add LN.\n+      List<String> items = GXCommon.split((String) name, '.');\n+      if (items.size() != 6) {\n+        throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+      }\n+      for (String it2 : items) {\n+        bb.setUInt8(Integer.valueOf(it2).byteValue());\n+      }\n+      // Attribute ID.\n+      bb.setUInt8(index);\n+      // Access selection is not used.\n+      bb.setUInt8(0);\n+    } else {\n+      cmd = Command.WRITE_REQUEST;\n+      // Add SN count.\n+      bb.setUInt8(1);\n+      // Add name length.\n+      bb.setUInt8(2);\n+      // Add name.\n+      int sn = GXCommon.intValue(name);\n+      sn += (index - 1) * 8;\n+      bb.setUInt16(sn);\n+      // Add data count.\n+      bb.setUInt8(1);\n+    }\n+    GXCommon.setData(bb, type, value);\n+    return GXDLMS.getMessages(settings, cmd, 1, bb, null);\n+  }\n+\n+  /**\n+   * Write list of COSEM objects.\n+   *\n+   * @param list DLMS objects to write.\n+   * @return Write request as byte array.\n+   */\n+  public final byte[][] writeList(final List<GXWriteItem> list) {\n+    if (list == null || list.isEmpty()) {\n+      throw new IllegalArgumentException(\"Invalid parameter.\");\n+    }\n+    Object value;\n+    Command cmd;\n+    settings.resetBlockIndex();\n+    GXByteBuffer bb = new GXByteBuffer();\n+    if (this.getUseLogicalNameReferencing()) {\n+      cmd = Command.SET_REQUEST;\n+      // Add length.\n+      bb.setUInt8(list.size());\n+      for (GXWriteItem it : list) {\n+        // CI.\n+        bb.setUInt16(it.getTarget().getObjectType().getValue());\n+        List<String> items =\n+            GXCommon.split(it.getTarget().getLogicalName(), '.');\n+        if (items.size() != 6) {\n+          throw new IllegalArgumentException(\"Invalid Logical Name.\");\n         }\n-        if ((value instanceof byte[])) {\n-            bb.set((byte[]) value);\n-        } else if (type != DataType.NONE) {\n-            GXCommon.setData(bb, type, value);\n+        for (String it2 : items) {\n+          bb.setUInt8(Integer.valueOf(it2).byteValue());\n         }\n-        return GXDLMS.getMessages(settings, cmd, 1, bb, null);\n-    }\n-\n-    /**\n-     * Generates a write message.\n-     * \n-     * @param item\n-     *            COSEM object to read.\n-     * @param index\n-     *            Attribute index.\n-     * @return Generated write message(s).\n-     */\n-    public final byte[][] write(final GXDLMSObject item, final int index) {\n-        ValueEventArgs e = new ValueEventArgs(settings, item, index, 0, null);\n-        Object value = item.getValue(settings, e);\n-        DataType type = item.getDataType(index);\n-        return write(item.getName(), value, type, item.getObjectType(), index);\n-    }\n-\n-    /**\n-     * Generates a write message.\n-     * \n-     * @param name\n-     *            Short or Logical Name.\n-     * @param value\n-     *            Data to Write.\n-     * @param dataType\n-     *            Data type of write object.\n-     * @param objectType\n-     *            Object type.\n-     * @param index\n-     *            Attribute index where data is write.\n-     * @return Generated write message(s).\n-     */\n-    public final byte[][] write(final Object name, final Object value,\n-            final DataType dataType, final ObjectType objectType,\n-            final int index) {\n-        if (index < 1) {\n-            throw new GXDLMSException(\"Invalid parameter\");\n-        }\n-        settings.resetBlockIndex();\n-        DataType type = dataType;\n+        // Attribute ID.\n+        bb.setUInt8(it.getIndex());\n+        // Attribute selector is not used.\n+        bb.setUInt8(0);\n+      }\n+    } else {\n+      cmd = Command.WRITE_REQUEST;\n+      // Add length.\n+      bb.setUInt8(list.size());\n+      for (GXWriteItem it : list) {\n+        // Add variable type.\n+        bb.setUInt8(2);\n+        int sn = GXCommon.intValue(it.getTarget().getShortName());\n+        sn += (it.getIndex() - 1) * 8;\n+        bb.setUInt16(sn);\n+      }\n+    }\n+    // Write values.\n+    bb.setUInt8(list.size());\n+    for (GXWriteItem it : list) {\n+      ValueEventArgs e = new ValueEventArgs(settings, it.getTarget(),\n+          it.getIndex(), it.getSelector(), it.getParameters());\n+      value = it.getTarget().getValue(settings, e);\n+      if ((value instanceof byte[])) {\n+        bb.set((byte[]) value);\n+      } else {\n+        DataType type = it.getDataType();\n         if (type == DataType.NONE && value != null) {\n-            type = GXCommon.getValueType(value);\n-            if (type == DataType.NONE) {\n-                throw new GXDLMSException(\n-                        \"Invalid parameter. In java value type must give.\");\n-            }\n-        }\n-        GXByteBuffer bb = new GXByteBuffer();\n-        Command cmd;\n-        if (getUseLogicalNameReferencing()) {\n-            cmd = Command.SET_REQUEST;\n-            // Add CI.\n-            bb.setUInt16(objectType.getValue());\n-            // Add LN.\n-            List<String> items = GXCommon.split((String) name, '.');\n-            if (items.size() != 6) {\n-                throw new IllegalArgumentException(\"Invalid Logical Name.\");\n-            }\n-            for (String it2 : items) {\n-                bb.setUInt8(Integer.valueOf(it2).byteValue());\n-            }\n-            // Attribute ID.\n-            bb.setUInt8(index);\n-            // Access selection is not used.\n-            bb.setUInt8(0);\n-        } else {\n-            cmd = Command.WRITE_REQUEST;\n-            // Add SN count.\n-            bb.setUInt8(1);\n-            // Add name length.\n-            bb.setUInt8(2);\n-            // Add name.\n-            int sn = GXCommon.intValue(name);\n-            sn += (index - 1) * 8;\n-            bb.setUInt16(sn);\n-            // Add data count.\n-            bb.setUInt8(1);\n+          type = GXCommon.getValueType(value);\n+          if (type == DataType.NONE) {\n+            throw new GXDLMSException(\"Invalid parameter. \"\n+                + \" In java value type must give.\");\n+          }\n         }\n         GXCommon.setData(bb, type, value);\n-        return GXDLMS.getMessages(settings, cmd, 1, bb, null);\n-    }\n-\n-    /**\n-     * Write list of COSEM objects.\n-     * \n-     * @param list\n-     *            DLMS objects to write.\n-     * @return Write request as byte array.\n-     */\n-    public final byte[][] writeList(final List<GXWriteItem> list) {\n-        if (list == null || list.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid parameter.\");\n-        }\n-        Object value;\n-        Command cmd;\n-        settings.resetBlockIndex();\n-        GXByteBuffer bb = new GXByteBuffer();\n-        if (this.getUseLogicalNameReferencing()) {\n-            cmd = Command.SET_REQUEST;\n-            // Add length.\n-            bb.setUInt8(list.size());\n-            for (GXWriteItem it : list) {\n-                // CI.\n-                bb.setUInt16(it.getTarget().getObjectType().getValue());\n-                List<String> items =\n-                        GXCommon.split(it.getTarget().getLogicalName(), '.');\n-                if (items.size() != 6) {\n-                    throw new IllegalArgumentException(\"Invalid Logical Name.\");\n-                }\n-                for (String it2 : items) {\n-                    bb.setUInt8(Integer.valueOf(it2).byteValue());\n-                }\n-                // Attribute ID.\n-                bb.setUInt8(it.getIndex());\n-                // Attribute selector is not used.\n-                bb.setUInt8(0);\n-            }\n-        } else {\n-            cmd = Command.WRITE_REQUEST;\n-            // Add length.\n-            bb.setUInt8(list.size());\n-            for (GXWriteItem it : list) {\n-                // Add variable type.\n-                bb.setUInt8(2);\n-                int sn = GXCommon.intValue(it.getTarget().getShortName());\n-                sn += (it.getIndex() - 1) * 8;\n-                bb.setUInt16(sn);\n-            }\n-        }\n-        // Write values.\n-        bb.setUInt8(list.size());\n-        for (GXWriteItem it : list) {\n-            ValueEventArgs e = new ValueEventArgs(settings, it.getTarget(),\n-                    it.getIndex(), it.getSelector(), it.getParameters());\n-            value = it.getTarget().getValue(settings, e);\n-            if ((value instanceof byte[])) {\n-                bb.set((byte[]) value);\n-            } else {\n-                DataType type = it.getDataType();\n-                if (type == DataType.NONE && value != null) {\n-                    type = GXCommon.getValueType(value);\n-                    if (type == DataType.NONE) {\n-                        throw new GXDLMSException(\"Invalid parameter. \"\n-                                + \" In java value type must give.\");\n-                    }\n-                }\n-                GXCommon.setData(bb, type, value);\n-            }\n-        }\n-        return GXDLMS.getMessages(settings, cmd, 4, bb, null);\n-    }\n-\n-    /**\n-     * Generates a read message.\n-     * \n-     * @param name\n-     *            Short or Logical Name.\n-     * @param objectType\n-     *            COSEM object type.\n-     * @param attributeOrdinal\n-     *            Attribute index of the object.\n-     * @return Generated read message(s).\n-     */\n-    public final byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal) {\n-        return read(name, objectType, attributeOrdinal, null);\n-    }\n-\n-    /**\n-     * Generates a read message.\n-     * \n-     * @param name\n-     *            Short or Logical Name.\n-     * @param objectType\n-     *            COSEM object type.\n-     * @param attributeOrdinal\n-     *            Attribute index of the object.\n-     * @param data\n-     *            Read data parameter.\n-     * @return Generated read message(s).\n-     */\n-    private byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal, final GXByteBuffer data) {\n-        if ((attributeOrdinal < 1)) {\n-            throw new IllegalArgumentException(\"Invalid parameter\");\n+      }\n+    }\n+    return GXDLMS.getMessages(settings, cmd, 4, bb, null);\n+  }\n+\n+  /**\n+   * Generates a read message.\n+   *\n+   * @param name             Short or Logical Name.\n+   * @param objectType       COSEM object type.\n+   * @param attributeOrdinal Attribute index of the object.\n+   * @return Generated read message(s).\n+   */\n+  public final byte[][] read(final Object name, final ObjectType objectType,\n+                             final int attributeOrdinal) {\n+    return read(name, objectType, attributeOrdinal, null);\n+  }\n+\n+  /**\n+   * Generates a read message.\n+   *\n+   * @param name             Short or Logical Name.\n+   * @param objectType       COSEM object type.\n+   * @param attributeOrdinal Attribute index of the object.\n+   * @param data             Read data parameter.\n+   * @return Generated read message(s).\n+   */\n+  private byte[][] read(final Object name, final ObjectType objectType,\n+                        final int attributeOrdinal, final GXByteBuffer data) {\n+    if ((attributeOrdinal < 1)) {\n+      throw new IllegalArgumentException(\"Invalid parameter\");\n+    }\n+    Command cmd;\n+    GXByteBuffer bb = new GXByteBuffer();\n+    settings.resetBlockIndex();\n+    if (this.getUseLogicalNameReferencing()) {\n+      cmd = Command.GET_REQUEST;\n+      // CI\n+      bb.setUInt16(objectType.getValue());\n+      // Add LN\n+      List<String> items = GXCommon.split((String) name, '.');\n+      if (items.size() != 6) {\n+        throw new IllegalArgumentException(\"Invalid Logical Name.\");\n+      }\n+      for (String it2 : items) {\n+        bb.setUInt8(Integer.valueOf(it2).byteValue());\n+      }\n+      // Attribute ID.\n+      bb.setUInt8(attributeOrdinal);\n+      if (data == null || data.size() == 0) {\n+        // Access selection is not used.\n+        bb.setUInt8(0);\n+      } else {\n+        // Access selection is used.\n+        bb.setUInt8(1);\n+        // Add data.\n+        bb.set(data.getData(), 0, data.size());\n+      }\n+    } else {\n+      cmd = Command.READ_REQUEST;\n+      // Add length.\n+      bb.setUInt8(1);\n+      // Add Selector.\n+      if (data != null && data.size() != 0) {\n+        bb.setUInt8(4);\n+      } else {\n+        bb.setUInt8(2);\n+      }\n+      int sn = GXCommon.intValue(name);\n+      sn += (attributeOrdinal - 1) * 8;\n+      bb.setUInt16(sn);\n+      // Add data.\n+      if (data != null && data.size() != 0) {\n+        bb.set(data.getData(), 0, data.size());\n+      }\n+    }\n+    return GXDLMS.getMessages(settings, cmd, 1, bb, null);\n+  }\n+\n+  /**\n+   * Generates a read message.\n+   *\n+   * @param item             DLMS object to read.\n+   * @param attributeOrdinal Read attribute index.\n+   * @return Read request as byte array.\n+   */\n+  public final byte[][] read(final GXDLMSObject item,\n+                             final int attributeOrdinal) {\n+    return read(item.getName(), item.getObjectType(), attributeOrdinal);\n+  }\n+\n+  /**\n+   * Read list of COSEM objects.\n+   *\n+   * @param list DLMS objects to read.\n+   * @return Read request as byte array.\n+   */\n+  public final byte[][]\n+  readList(final List<Entry<GXDLMSObject, Integer>> list) {\n+    if (list == null || list.isEmpty()) {\n+      throw new IllegalArgumentException(\"Invalid parameter.\");\n+    }\n+    Command cmd;\n+    List<byte[]> messages = new ArrayList<byte[]>();\n+    GXByteBuffer bb = new GXByteBuffer();\n+    settings.resetBlockIndex();\n+    if (this.getUseLogicalNameReferencing()) {\n+      cmd = Command.GET_REQUEST;\n+\n+      // Request service primitive shall always fit in a single APDU.\n+      int pos = 0, count = (settings.getMaxReceivePDUSize() - 12) / 10;\n+      if (list.size() < count) {\n+        count = list.size();\n+      }\n+      // All meters can handle 10 items.\n+      if (count > 10) {\n+        count = 10;\n+      }\n+      // Add length.\n+      GXCommon.setObjectCount(count, bb);\n+      for (Entry<GXDLMSObject, Integer> it : list) {\n+        // CI.\n+        bb.setUInt16(it.getKey().getObjectType().getValue());\n+        List<String> items =\n+            GXCommon.split(it.getKey().getLogicalName(), '.');\n+        if (items.size() != 6) {\n+          throw new IllegalArgumentException(\"Invalid Logical Name.\");\n         }\n-        Command cmd;\n-        GXByteBuffer bb = new GXByteBuffer();\n-        settings.resetBlockIndex();\n-        if (this.getUseLogicalNameReferencing()) {\n-            cmd = Command.GET_REQUEST;\n-            // CI\n-            bb.setUInt16(objectType.getValue());\n-            // Add LN\n-            List<String> items = GXCommon.split((String) name, '.');\n-            if (items.size() != 6) {\n-                throw new IllegalArgumentException(\"Invalid Logical Name.\");\n-            }\n-            for (String it2 : items) {\n-                bb.setUInt8(Integer.valueOf(it2).byteValue());\n-            }\n-            // Attribute ID.\n-            bb.setUInt8(attributeOrdinal);\n-            if (data == null || data.size() == 0) {\n-                // Access selection is not used.\n-                bb.setUInt8(0);\n-            } else {\n-                // Access selection is used.\n-                bb.setUInt8(1);\n-                // Add data.\n-                bb.set(data.getData(), 0, data.size());\n-            }\n-        } else {\n-            cmd = Command.READ_REQUEST;\n-            // Add length.\n-            bb.setUInt8(1);\n-            // Add Selector.\n-            if (data != null && data.size() != 0) {\n-                bb.setUInt8(4);\n-            } else {\n-                bb.setUInt8(2);\n-            }\n-            int sn = GXCommon.intValue(name);\n-            sn += (attributeOrdinal - 1) * 8;\n-            bb.setUInt16(sn);\n-            // Add data.\n-            if (data != null && data.size() != 0) {\n-                bb.set(data.getData(), 0, data.size());\n-            }\n+        for (String it2 : items) {\n+          bb.setUInt8(Integer.valueOf(it2).byteValue());\n         }\n-        return GXDLMS.getMessages(settings, cmd, 1, bb, null);\n-    }\n-\n-    /**\n-     * Generates a read message.\n-     * \n-     * @param item\n-     *            DLMS object to read.\n-     * @param attributeOrdinal\n-     *            Read attribute index.\n-     * @return Read request as byte array.\n-     */\n-    public final byte[][] read(final GXDLMSObject item,\n-            final int attributeOrdinal) {\n-        return read(item.getName(), item.getObjectType(), attributeOrdinal);\n-    }\n-\n-    /**\n-     * Read list of COSEM objects.\n-     * \n-     * @param list\n-     *            DLMS objects to read.\n-     * @return Read request as byte array.\n-     */\n-    public final byte[][]\n-            readList(final List<Entry<GXDLMSObject, Integer>> list) {\n-        if (list == null || list.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid parameter.\");\n-        }\n-        Command cmd;\n-        List<byte[]> messages = new ArrayList<byte[]>();\n-        GXByteBuffer bb = new GXByteBuffer();\n-        settings.resetBlockIndex();\n-        if (this.getUseLogicalNameReferencing()) {\n-            cmd = Command.GET_REQUEST;\n-\n-            // Request service primitive shall always fit in a single APDU.\n-            int pos = 0, count = (settings.getMaxReceivePDUSize() - 12) / 10;\n-            if (list.size() < count) {\n-                count = list.size();\n-            }\n-            // All meters can handle 10 items.\n-            if (count > 10) {\n-                count = 10;\n-            }\n-            // Add length.\n+        // Attribute ID.\n+        bb.setUInt8(it.getValue());\n+        // Attribute selector is not used.\n+        bb.setUInt8(0);\n+\n+        ++pos;\n+        if (pos % count == 0 && list.size() != pos) {\n+          messages.addAll(Arrays.asList(\n+              GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n+          bb.clear();\n+          if (list.size() - pos < count) {\n+            GXCommon.setObjectCount(list.size() - pos, bb);\n+          } else {\n             GXCommon.setObjectCount(count, bb);\n-            for (Entry<GXDLMSObject, Integer> it : list) {\n-                // CI.\n-                bb.setUInt16(it.getKey().getObjectType().getValue());\n-                List<String> items =\n-                        GXCommon.split(it.getKey().getLogicalName(), '.');\n-                if (items.size() != 6) {\n-                    throw new IllegalArgumentException(\"Invalid Logical Name.\");\n-                }\n-                for (String it2 : items) {\n-                    bb.setUInt8(Integer.valueOf(it2).byteValue());\n-                }\n-                // Attribute ID.\n-                bb.setUInt8(it.getValue());\n-                // Attribute selector is not used.\n-                bb.setUInt8(0);\n-\n-                ++pos;\n-                if (pos % count == 0 && list.size() != pos) {\n-                    messages.addAll(Arrays.asList(\n-                            GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n-                    bb.clear();\n-                    if (list.size() - pos < count) {\n-                        GXCommon.setObjectCount(list.size() - pos, bb);\n-                    } else {\n-                        GXCommon.setObjectCount(count, bb);\n-                    }\n-                }\n-            }\n-        } else {\n-            cmd = Command.READ_REQUEST;\n-            // Add length.\n-            bb.setUInt8(list.size());\n-            for (Entry<GXDLMSObject, Integer> it : list) {\n-                // Add variable type.\n-                bb.setUInt8(2);\n-                int sn = GXCommon.intValue(it.getKey().getShortName());\n-                sn += (it.getValue() - 1) * 8;\n-                bb.setUInt16(sn);\n-            }\n-        }\n-\n-        messages.addAll(\n-                Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n-        return messages.toArray(new byte[0][0]);\n-    }\n-\n-    /**\n-     * Generates the keep alive message. Keep alive message is sent to keep the\n-     * connection to the device alive.\n-     * \n-     * @return Returns Keep alive message, as byte array.\n-     */\n-    public final byte[] keepAlive() {\n-        // There is no need for keep alive in IEC 62056-47.\n-        if (this.getInterfaceType() == InterfaceType.WRAPPER) {\n-            return new byte[0];\n-        }\n-        return GXDLMS.getHdlcFrame(settings, settings.getReceiverReady(), null);\n-    }\n-\n-    /**\n-     * Read rows by entry.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param index\n-     *            Zero bases start index.\n-     * @param count\n-     *            Rows count to read.\n-     * @return Read message as byte array.\n-     */\n-    public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg,\n-            final int index, final int count) {\n-        GXByteBuffer buff = new GXByteBuffer(19);\n-        // Add AccessSelector value\n-        buff.setUInt8(0x02);\n-        // Add enum tag.\n-        buff.setUInt8(DataType.STRUCTURE.getValue());\n-        // Add item count\n-        buff.setUInt8(0x04);\n-        // Add start index\n-        GXCommon.setData(buff, DataType.UINT32, index);\n-        // Add Count\n-        GXCommon.setData(buff, DataType.UINT32, count);\n-        // Read all columns.\n-        if (this.getUseLogicalNameReferencing()) {\n-            GXCommon.setData(buff, DataType.UINT16, 1);\n-        } else {\n-            GXCommon.setData(buff, DataType.UINT16, 0);\n-        }\n-        GXCommon.setData(buff, DataType.UINT16, 0);\n-        return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n-    }\n-\n-    /**\n-     * Read rows by range. Use this method to read Profile Generic table between\n-     * dates.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param start\n-     *            Start time.\n-     * @param end\n-     *            End time.\n-     * @return Generated read message.\n-     */\n-    public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final java.util.Date start, final java.util.Date end) {\n-        return readByRange(pg, start, end);\n-    }\n-\n-    /**\n-     * Read rows by range. Use this method to read Profile Generic table between\n-     * dates.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param start\n-     *            Start time.\n-     * @param end\n-     *            End time.\n-     * @return Generated read message.\n-     */\n-    public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final Calendar start, final Calendar end) {\n-        return readByRange(pg, start, end);\n-    }\n-\n-    /**\n-     * Read rows by range. Use this method to read Profile Generic table between\n-     * dates.\n-     * \n-     * @param pg\n-     *            Profile generic object to read.\n-     * @param start\n-     *            Start time.\n-     * @param end\n-     *            End time.\n-     * @return Generated read message.\n-     */\n-    private byte[][] readByRange(final GXDLMSProfileGeneric pg,\n-            final Object start, final Object end) {\n-        settings.resetBlockIndex();\n-        GXDLMSObject sort = pg.getSortObject();\n-        if (sort == null && pg.getCaptureObjects().size() != 0) {\n-            sort = pg.getCaptureObjects().get(0).getKey();\n-        }\n-        // If sort object is not found or it is not clock object read all.\n-        if (sort == null || sort.getObjectType() != ObjectType.CLOCK) {\n-            return read(pg, 2);\n+          }\n         }\n-        GXByteBuffer buff = new GXByteBuffer(51);\n-        // Add AccessSelector value.\n-        buff.setUInt8(0x01);\n-        // Add enum tag.\n-        buff.setUInt8(DataType.STRUCTURE.getValue());\n-        // Add item count\n-        buff.setUInt8(0x04);\n-        // Add enum tag.\n-        buff.setUInt8(DataType.STRUCTURE.getValue());\n-        // Add item count\n-        buff.setUInt8(0x04);\n-        // CI\n-        GXCommon.setData(buff, DataType.UINT16,\n-                sort.getObjectType().getValue());\n-        // LN\n-        GXCommon.setData(buff, DataType.OCTET_STRING, sort.getLogicalName());\n-        // Add attribute index.\n-        GXCommon.setData(buff, DataType.INT8, 2);\n-        // Add version\n-        GXCommon.setData(buff, DataType.UINT16, sort.getVersion());\n-        GXCommon.setData(buff, DataType.OCTET_STRING, start); // Add start time\n-        GXCommon.setData(buff, DataType.OCTET_STRING, end); // Add start time\n-        // Add array of read columns. Read All...\n-        buff.setUInt8(0x01);\n-        // Add item count\n-        buff.setUInt8(0x00);\n-        return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n-    }\n-\n-    /**\n-     * Create object by object type.\n-     * \n-     * @param type\n-     *            Object type.\n-     * @return Created object.\n-     */\n-    public static GXDLMSObject createObject(final ObjectType type) {\n-        return GXDLMS.createObject(type);\n-    }\n-\n-    /**\n-     * Generates an acknowledgment message, with which the server is informed to\n-     * send next packets.\n-     * \n-     * @param type\n-     *            Frame type\n-     * @return Acknowledgment message as byte array.\n-     */\n-    public final byte[] receiverReady(final RequestTypes type) {\n-        return GXDLMS.receiverReady(settings, type);\n-    }\n-\n-    /**\n-     * Removes the HDLC frame from the packet, and returns COSEM data only.\n-     * \n-     * @param reply\n-     *            The received data from the device.\n-     * @param data\n-     *            Information from the received data.\n-     * @return Is frame complete.\n-     */\n-    public final boolean getData(final byte[] reply, final GXReplyData data) {\n-        return GXDLMS.getData(settings, new GXByteBuffer(reply), data);\n-    }\n-\n-    /**\n-     * Removes the HDLC frame from the packet, and returns COSEM data only.\n-     * \n-     * @param reply\n-     *            The received data from the device.\n-     * @param data\n-     *            The exported reply information.\n-     */\n-    public final void getData(final GXByteBuffer reply,\n-            final GXReplyData data) {\n-        GXDLMS.getData(settings, reply, data);\n-    }\n-\n-    /**\n-     * Converts meter serial number to server address. Default formula is used.\n-     * All meters do not use standard formula or support serial number\n-     * addressing at all.\n-     * \n-     * @param serialNumber\n-     *            Meter serial number\n-     * @return Server address.\n-     */\n-    public static int getServerAddress(final int serialNumber) {\n-        return getServerAddress(serialNumber, null);\n-    }\n-\n-    /**\n-     * Converts meter serial number to server address. Default formula is used.\n-     * All meters do not use standard formula or support serial number\n-     * addressing at all.\n-     * \n-     * @param serialNumber\n-     *            Meter serial number\n-     * @param formula\n-     *            Formula used to convert serial number to server address.\n-     * @return Server address.\n-     */\n-\n-    public static int getServerAddress(final int serialNumber,\n-            final String formula) {\n-        // If formula is not given use default formula.\n-        // This formula is defined in DLMS specification.\n-        if (formula == null || formula.length() == 0) {\n-            return 0x4000 | SerialNumberCounter.count(serialNumber,\n-                    \"SN % 10000 + 1000\");\n-        }\n-        return 0x4000 | SerialNumberCounter.count(serialNumber, formula);\n-    }\n-\n-    /**\n-     * Convert physical address and logical address to server address.\n-     * \n-     * @param logicalAddress\n-     *            Server logical address.\n-     * @param physicalAddress\n-     *            Server physical address.\n-     * @return Server address.\n-     */\n-    public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress) {\n-        return getServerAddress(logicalAddress, physicalAddress, 0);\n-    }\n-\n-    /**\n-     * Convert physical address and logical address to server address.\n-     * \n-     * @param logicalAddress\n-     *            Server logical address.\n-     * @param physicalAddress\n-     *            Server physical address.\n-     * @param addressSize\n-     *            Address size in bytes.\n-     * @return Server address.\n-     */\n-    public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress, final int addressSize) {\n-        if (addressSize < 4 && physicalAddress < 0x80\n-                && logicalAddress < 0x80) {\n-            return logicalAddress << 7 | physicalAddress;\n-        }\n-        if (physicalAddress < 0x4000 && logicalAddress < 0x4000) {\n-            return logicalAddress << 14 | physicalAddress;\n-        }\n-        throw new IllegalArgumentException(\n-                \"Invalid logical or physical address.\");\n-    }\n+      }\n+    } else {\n+      cmd = Command.READ_REQUEST;\n+      // Add length.\n+      bb.setUInt8(list.size());\n+      for (Entry<GXDLMSObject, Integer> it : list) {\n+        // Add variable type.\n+        bb.setUInt8(2);\n+        int sn = GXCommon.intValue(it.getKey().getShortName());\n+        sn += (it.getValue() - 1) * 8;\n+        bb.setUInt16(sn);\n+      }\n+    }\n+\n+    messages.addAll(\n+        Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n+    return messages.toArray(new byte[0][0]);\n+  }\n+\n+  /**\n+   * Generates the keep alive message. Keep alive message is sent to keep the\n+   * connection to the device alive.\n+   *\n+   * @return Returns Keep alive message, as byte array.\n+   */\n+  public final byte[] keepAlive() {\n+    // There is no need for keep alive in IEC 62056-47.\n+    if (this.getInterfaceType() == InterfaceType.WRAPPER) {\n+      return new byte[0];\n+    }\n+    return GXDLMS.getHdlcFrame(settings, settings.getReceiverReady(), null);\n+  }\n+\n+  /**\n+   * Read rows by entry.\n+   *\n+   * @param pg    Profile generic object to read.\n+   * @param index Zero bases start index.\n+   * @param count Rows count to read.\n+   * @return Read message as byte array.\n+   */\n+  public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg,\n+                                        final int index, final int count) {\n+    GXByteBuffer buff = new GXByteBuffer(19);\n+    // Add AccessSelector value\n+    buff.setUInt8(0x02);\n+    // Add enum tag.\n+    buff.setUInt8(DataType.STRUCTURE.getValue());\n+    // Add item count\n+    buff.setUInt8(0x04);\n+    // Add start index\n+    GXCommon.setData(buff, DataType.UINT32, index);\n+    // Add Count\n+    GXCommon.setData(buff, DataType.UINT32, count);\n+    // Read all columns.\n+    if (this.getUseLogicalNameReferencing()) {\n+      GXCommon.setData(buff, DataType.UINT16, 1);\n+    } else {\n+      GXCommon.setData(buff, DataType.UINT16, 0);\n+    }\n+    GXCommon.setData(buff, DataType.UINT16, 0);\n+    return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n+  }\n+\n+  /**\n+   * Read rows by range. Use this method to read Profile Generic table between\n+   * dates.\n+   *\n+   * @param pg    Profile generic object to read.\n+   * @param start Start time.\n+   * @param end   End time.\n+   * @return Generated read message.\n+   */\n+  public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n+                                        final java.util.Date start,\n+                                        final java.util.Date end) {\n+    return readByRange(pg, start, end);\n+  }\n+\n+  /**\n+   * Read rows by range. Use this method to read Profile Generic table between\n+   * dates.\n+   *\n+   * @param pg    Profile generic object to read.\n+   * @param start Start time.\n+   * @param end   End time.\n+   * @return Generated read message.\n+   */\n+  public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n+                                        final Calendar start,\n+                                        final Calendar end) {\n+    return readByRange(pg, start, end);\n+  }\n+\n+  /**\n+   * Read rows by range. Use this method to read Profile Generic table between\n+   * dates.\n+   *\n+   * @param pg    Profile generic object to read.\n+   * @param start Start time.\n+   * @param end   End time.\n+   * @return Generated read message.\n+   */\n+  private byte[][] readByRange(final GXDLMSProfileGeneric pg,\n+                               final Object start, final Object end) {\n+    settings.resetBlockIndex();\n+    GXDLMSObject sort = pg.getSortObject();\n+    if (sort == null && pg.getCaptureObjects().size() != 0) {\n+      sort = pg.getCaptureObjects().get(0).getKey();\n+    }\n+    // If sort object is not found or it is not clock object read all.\n+    if (sort == null || sort.getObjectType() != ObjectType.CLOCK) {\n+      return read(pg, 2);\n+    }\n+    GXByteBuffer buff = new GXByteBuffer(51);\n+    // Add AccessSelector value.\n+    buff.setUInt8(0x01);\n+    // Add enum tag.\n+    buff.setUInt8(DataType.STRUCTURE.getValue());\n+    // Add item count\n+    buff.setUInt8(0x04);\n+    // Add enum tag.\n+    buff.setUInt8(DataType.STRUCTURE.getValue());\n+    // Add item count\n+    buff.setUInt8(0x04);\n+    // CI\n+    GXCommon.setData(buff, DataType.UINT16,\n+        sort.getObjectType().getValue());\n+    // LN\n+    GXCommon.setData(buff, DataType.OCTET_STRING, sort.getLogicalName());\n+    // Add attribute index.\n+    GXCommon.setData(buff, DataType.INT8, 2);\n+    // Add version\n+    GXCommon.setData(buff, DataType.UINT16, sort.getVersion());\n+    GXCommon.setData(buff, DataType.OCTET_STRING, start); // Add start time\n+    GXCommon.setData(buff, DataType.OCTET_STRING, end); // Add start time\n+    // Add array of read columns. Read All...\n+    buff.setUInt8(0x01);\n+    // Add item count\n+    buff.setUInt8(0x00);\n+    return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n+  }\n+\n+  /**\n+   * Create object by object type.\n+   *\n+   * @param type Object type.\n+   * @return Created object.\n+   */\n+  public static GXDLMSObject createObject(final ObjectType type) {\n+    return GXDLMS.createObject(type);\n+  }\n+\n+  /**\n+   * Generates an acknowledgment message, with which the server is informed to\n+   * send next packets.\n+   *\n+   * @param type Frame type\n+   * @return Acknowledgment message as byte array.\n+   */\n+  public final byte[] receiverReady(final RequestTypes type) {\n+    return GXDLMS.receiverReady(settings, type);\n+  }\n+\n+  /**\n+   * Removes the HDLC frame from the packet, and returns COSEM data only.\n+   *\n+   * @param reply The received data from the device.\n+   * @param data  Information from the received data.\n+   * @return Is frame complete.\n+   */\n+  public final boolean getData(final byte[] reply, final GXReplyData data) {\n+    return GXDLMS.getData(settings, new GXByteBuffer(reply), data);\n+  }\n+\n+  /**\n+   * Removes the HDLC frame from the packet, and returns COSEM data only.\n+   *\n+   * @param reply The received data from the device.\n+   * @param data  The exported reply information.\n+   */\n+  public final void getData(final GXByteBuffer reply,\n+                            final GXReplyData data) {\n+    GXDLMS.getData(settings, reply, data);\n+  }\n+\n+  /**\n+   * Converts meter serial number to server address. Default formula is used.\n+   * All meters do not use standard formula or support serial number\n+   * addressing at all.\n+   *\n+   * @param serialNumber Meter serial number\n+   * @return Server address.\n+   */\n+  public static int getServerAddress(final int serialNumber) {\n+    return getServerAddress(serialNumber, null);\n+  }\n+\n+  /**\n+   * Converts meter serial number to server address. Default formula is used.\n+   * All meters do not use standard formula or support serial number\n+   * addressing at all.\n+   *\n+   * @param serialNumber Meter serial number\n+   * @param formula      Formula used to convert serial number to server address.\n+   * @return Server address.\n+   */\n+\n+  public static int getServerAddress(final int serialNumber,\n+                                     final String formula) {\n+    // If formula is not given use default formula.\n+    // This formula is defined in DLMS specification.\n+    if (formula == null || formula.length() == 0) {\n+      return 0x4000 | SerialNumberCounter.count(serialNumber,\n+          \"SN % 10000 + 1000\");\n+    }\n+    return 0x4000 | SerialNumberCounter.count(serialNumber, formula);\n+  }\n+\n+  /**\n+   * Convert physical address and logical address to server address.\n+   *\n+   * @param logicalAddress  Server logical address.\n+   * @param physicalAddress Server physical address.\n+   * @return Server address.\n+   */\n+  public static int getServerAddress(final int logicalAddress,\n+                                     final int physicalAddress) {\n+    return getServerAddress(logicalAddress, physicalAddress, 0);\n+  }\n+\n+  /**\n+   * Convert physical address and logical address to server address.\n+   *\n+   * @param logicalAddress  Server logical address.\n+   * @param physicalAddress Server physical address.\n+   * @param addressSize     Address size in bytes.\n+   * @return Server address.\n+   */\n+  public static int getServerAddress(final int logicalAddress,\n+                                     final int physicalAddress,\n+                                     final int addressSize) {\n+    if (addressSize < 4 && physicalAddress < 0x80\n+        && logicalAddress < 0x80) {\n+      return logicalAddress << 7 | physicalAddress;\n+    }\n+    if (physicalAddress < 0x4000 && logicalAddress < 0x4000) {\n+      return logicalAddress << 14 | physicalAddress;\n+    }\n+    throw new IllegalArgumentException(\n+        \"Invalid logical or physical address.\");\n+  }\n }\n\\ No newline at end of file\n",
            "diff_size": 2297
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "72",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "105",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 214).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "531",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "536",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "541",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 95).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "546",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 95).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "557",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "603",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "639",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 96).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "669",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "690",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "704",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 112).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "710",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 119).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "712",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "723",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 85).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "738",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "749",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "763",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "767",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 87).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "792",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "814",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "843",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "866",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 185).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "869",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 88).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "916",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 111).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "941",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "966",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "967",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "970",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 138).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "982",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 110).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "994",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 89).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1024",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1031",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 101).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1051",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1165",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 150).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1176",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 94).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1271",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1280",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 94).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1343",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 90).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1371",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1380",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1402",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1421",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1483",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 85).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1498",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1524",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 87).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1538",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 99).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1560",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 87).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1594",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 108).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1651",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1669",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1765",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 81).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1797",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 86).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1801",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 89).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1817",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 93).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1834",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 116).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1844",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 83).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/errored/1/25/GXDLMSClient.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/codebuff/25/GXDLMSClient.java\nindex b9d36272ac..63255ccbe1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/errored/1/25/GXDLMSClient.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Gurux-gurux.dlms.java/codebuff/25/GXDLMSClient.java\n@@ -40,7 +40,6 @@ import java.util.Calendar;\n import java.util.List;\n import java.util.Map.Entry;\n import java.util.logging.Logger;\n-\n import gurux.dlms.enums.AccessMode;\n import gurux.dlms.enums.Authentication;\n import gurux.dlms.enums.Command;\n@@ -63,14 +62,14 @@ import gurux.dlms.secure.GXSecure;\n /**\n  * GXDLMS implements methods to communicate with DLMS/COSEM metering devices.\n  */\n+\n public class GXDLMSClient {\n     /**\n      * DLMS settings.\n      */\n     private final GXDLMSSettings settings = new GXDLMSSettings(false);\n     private GXObisCodeCollection obisCodes;\n-    private static final Logger LOGGER =\n-            Logger.getLogger(GXDLMSClient.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(GXDLMSClient.class.getName());\n \n     /**\n      * Is authentication required.\n@@ -80,6 +79,8 @@ public class GXDLMSClient {\n     /**\n      * Constructor.\n      */\n+\n+\n     public GXDLMSClient() {\n     }\n \n@@ -99,10 +100,9 @@ public class GXDLMSClient {\n      * @param interfaceType\n      *            Object type.\n      */\n-    public GXDLMSClient(final boolean useLogicalNameReferencing,\n-            final int clientAddress, final int serverAddress,\n-            final Authentication forAuthentication, final String password,\n-            final InterfaceType interfaceType) {\n+\n+\n+    public GXDLMSClient(final boolean useLogicalNameReferencing, final int clientAddress, final int serverAddress, final Authentication forAuthentication, final String password, final InterfaceType interfaceType) {\n         this.setUseLogicalNameReferencing(useLogicalNameReferencing);\n         this.setClientAddress(clientAddress);\n         this.setServerAddress(serverAddress);\n@@ -115,6 +115,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Cipher interface that is used to cipher PDU.\n      */\n+\n+\n     protected final void setCipher(final GXICipher value) {\n         settings.setCipher(value);\n     }\n@@ -122,6 +124,8 @@ public class GXDLMSClient {\n     /**\n      * @return Get settings.\n      */\n+\n+\n     protected final GXDLMSSettings getSettings() {\n         return settings;\n     }\n@@ -129,6 +133,8 @@ public class GXDLMSClient {\n     /**\n      * @return Get list of meter's objects.\n      */\n+\n+\n     public final GXDLMSObjectCollection getObjects() {\n         return settings.getObjects();\n     }\n@@ -140,10 +146,13 @@ public class GXDLMSClient {\n      * \n      * @return List of available OBIS codes.\n      */\n+\n+\n     public final GXObisCodeCollection getObisCodes() {\n         return obisCodes;\n     }\n \n+\n     public final void setObisCodes(final GXObisCodeCollection value) {\n         obisCodes = value;\n     }\n@@ -155,6 +164,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Zero based starting index.\n      */\n+\n+\n     public final void setStartingPacketIndex(final int value) {\n         settings.setStartingPacketIndex(value);\n     }\n@@ -162,6 +173,8 @@ public class GXDLMSClient {\n     /**\n      * @return Client address.\n      */\n+\n+\n     public final int getClientAddress() {\n         return settings.getClientAddress();\n     }\n@@ -170,6 +183,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Client address\n      */\n+\n+\n     public final void setClientAddress(final int value) {\n         settings.setClientAddress(value);\n     }\n@@ -177,6 +192,8 @@ public class GXDLMSClient {\n     /**\n      * @return Server Address.\n      */\n+\n+\n     public final int getServerAddress() {\n         return settings.getServerAddress();\n     }\n@@ -185,6 +202,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Server address.\n      */\n+\n+\n     public final void setServerAddress(final int value) {\n         settings.setServerAddress(value);\n     }\n@@ -193,6 +212,8 @@ public class GXDLMSClient {\n      * @return Server address size in bytes. If it is Zero it is counted\n      *         automatically.\n      */\n+\n+\n     public final int getServerAddressSize() {\n         return settings.getServerAddressSize();\n     }\n@@ -202,6 +223,8 @@ public class GXDLMSClient {\n      *            Server address size in bytes. If it is Zero it is counted\n      *            automatically.\n      */\n+\n+\n     public final void setServerAddressSize(final int value) {\n         settings.setServerAddressSize(value);\n     }\n@@ -211,6 +234,8 @@ public class GXDLMSClient {\n      * \n      * @return DLMS version number.\n      */\n+\n+\n     public final byte getDLMSVersion() {\n         return settings.getDLMSVersion();\n     }\n@@ -219,6 +244,8 @@ public class GXDLMSClient {\n      * @param value\n      *            DLMS version number.\n      */\n+\n+\n     public final void setDLMSVersion(final byte value) {\n         settings.setDLMSVersion(value);\n     }\n@@ -234,6 +261,8 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getUseLogicalNameReferencing\n      * @return Maximum size of received PDU.\n      */\n+\n+\n     public final int getMaxReceivePDUSize() {\n         return settings.getMaxReceivePDUSize();\n     }\n@@ -242,6 +271,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Maximum size of received PDU.\n      */\n+\n+\n     public final void setMaxReceivePDUSize(final int value) {\n         settings.setMaxReceivePDUSize(value);\n     }\n@@ -255,6 +286,8 @@ public class GXDLMSClient {\n      * \n      * @return Is Logical Name referencing used.\n      */\n+\n+\n     public final boolean getUseLogicalNameReferencing() {\n         return settings.getUseLogicalNameReferencing();\n     }\n@@ -263,6 +296,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Is Logical Name referencing used.\n      */\n+\n+\n     public final void setUseLogicalNameReferencing(final boolean value) {\n         settings.setUseLogicalNameReferencing(value);\n     }\n@@ -280,6 +315,8 @@ public class GXDLMSClient {\n      * \n      * @return Client to Server custom challenge.\n      */\n+\n+\n     public final byte[] getCtoSChallenge() {\n         return settings.getCtoSChallenge();\n     }\n@@ -291,6 +328,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Client to Server challenge.\n      */\n+\n+\n     public final void setCtoSChallenge(final byte[] value) {\n         settings.setUseCustomChallenge(value != null);\n         settings.setCtoSChallenge(value);\n@@ -303,6 +342,8 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getAuthentication\n      * @return Used password.\n      */\n+\n+\n     public final byte[] getPassword() {\n         return settings.getPassword();\n     }\n@@ -311,6 +352,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used password as byte array.\n      */\n+\n+\n     public final void setPassword(final byte[] value) {\n         settings.setPassword(value);\n     }\n@@ -319,6 +362,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used password as string value.\n      */\n+\n+\n     public final void setPassword(final String value) {\n         settings.setPassword(value.getBytes());\n     }\n@@ -326,6 +371,8 @@ public class GXDLMSClient {\n     /**\n      * @return Logical Name settings.\n      */\n+\n+\n     public final GXDLMSLNSettings getLNSettings() {\n         return settings.getLnSettings();\n     }\n@@ -333,6 +380,8 @@ public class GXDLMSClient {\n     /**\n      * @return Short Name settings.\n      */\n+\n+\n     public final GXDLMSSNSettings getSNSettings() {\n         return settings.getSnSettings();\n     }\n@@ -346,6 +395,8 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getClientAddress\n      * @return Used authentication.\n      */\n+\n+\n     public final Authentication getAuthentication() {\n         return settings.getAuthentication();\n     }\n@@ -354,6 +405,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used authentication.\n      */\n+\n+\n     public final void setAuthentication(final Authentication value) {\n         settings.setAuthentication(value);\n     }\n@@ -361,6 +414,8 @@ public class GXDLMSClient {\n     /**\n      * @return Used Priority.\n      */\n+\n+\n     public final Priority getPriority() {\n         return settings.getPriority();\n     }\n@@ -369,6 +424,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used Priority.\n      */\n+\n+\n     public final void setPriority(final Priority value) {\n         settings.setPriority(value);\n     }\n@@ -376,6 +433,8 @@ public class GXDLMSClient {\n     /**\n      * @return Used service class.\n      */\n+\n+\n     public final ServiceClass getServiceClass() {\n         return settings.getServiceClass();\n     }\n@@ -384,6 +443,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Used service class.\n      */\n+\n+\n     public final void setServiceClass(final ServiceClass value) {\n         settings.setServiceClass(value);\n     }\n@@ -391,6 +452,8 @@ public class GXDLMSClient {\n     /**\n      * @return Invoke ID.\n      */\n+\n+\n     public final int getInvokeID() {\n         return settings.getInvokeID();\n     }\n@@ -399,6 +462,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Invoke ID.\n      */\n+\n+\n     public final void setInvokeID(final int value) {\n         settings.setInvokeID(value);\n     }\n@@ -406,6 +471,8 @@ public class GXDLMSClient {\n     /**\n      * @return Interface type.\n      */\n+\n+\n     public final InterfaceType getInterfaceType() {\n         return settings.getInterfaceType();\n     }\n@@ -414,6 +481,8 @@ public class GXDLMSClient {\n      * @param value\n      *            Interface type.\n      */\n+\n+\n     public final void setInterfaceType(final InterfaceType value) {\n         settings.setInterfaceType(value);\n     }\n@@ -421,6 +490,8 @@ public class GXDLMSClient {\n     /**\n      * @return Information from the connection size that server can handle.\n      */\n+\n+\n     public final GXDLMSLimits getLimits() {\n         return settings.getLimits();\n     }\n@@ -441,9 +512,10 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#parseUAResponse\n      * @return SNRM request as byte array.\n      */\n+\n+\n     public final byte[] snrmRequest() {\n         settings.setConnected(false);\n-\n         isAuthenticationRequired = false;\n         settings.setMaxReceivePDUSize(0xFFFF);\n         // SNRM request is not used in network connections.\n@@ -456,26 +528,22 @@ public class GXDLMSClient {\n         data.setUInt8(0); // Length.\n \n         // If custom HDLC parameters are used.\n-        if (!GXDLMSLimits.DEFAULT_MAX_INFO_TX\n-                .equals(this.getLimits().getMaxInfoTX())) {\n+        if (!GXDLMSLimits.DEFAULT_MAX_INFO_TX.equals(this.getLimits().getMaxInfoTX())) {\n             data.setUInt8(HDLCInfo.MAX_INFO_TX);\n             data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoTX()));\n             data.add(getLimits().getMaxInfoTX());\n         }\n-        if (!GXDLMSLimits.DEFAULT_MAX_INFO_RX\n-                .equals(this.getLimits().getMaxInfoRX())) {\n+        if (!GXDLMSLimits.DEFAULT_MAX_INFO_RX.equals(this.getLimits().getMaxInfoRX())) {\n             data.setUInt8(HDLCInfo.MAX_INFO_RX);\n             data.setUInt8(GXCommon.getSize(getLimits().getMaxInfoRX()));\n             data.add(getLimits().getMaxInfoRX());\n         }\n-        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n-                .equals(this.getLimits().getWindowSizeTX())) {\n+        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX.equals(this.getLimits().getWindowSizeTX())) {\n             data.setUInt8(HDLCInfo.WINDOW_SIZE_TX);\n             data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeTX()));\n             data.add(getLimits().getWindowSizeTX());\n         }\n-        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX\n-                .equals(this.getLimits().getWindowSizeRX())) {\n+        if (!GXDLMSLimits.DEFAULT_WINDOWS_SIZE_TX.equals(this.getLimits().getWindowSizeRX())) {\n             data.setUInt8(HDLCInfo.WINDOW_SIZE_RX);\n             data.setUInt8(GXCommon.getSize(getLimits().getWindowSizeRX()));\n             data.add(getLimits().getWindowSizeRX());\n@@ -486,8 +554,7 @@ public class GXDLMSClient {\n         } else {\n             data = null;\n         }\n-        return GXDLMS.getHdlcFrame(settings, (byte) Command.SNRM.getValue(),\n-                null);\n+        return GXDLMS.getHdlcFrame(settings, (byte) Command.SNRM.getValue(), null);\n     }\n \n     /**\n@@ -497,6 +564,8 @@ public class GXDLMSClient {\n      *            Received message from the server.\n      * @see GXDLMSClient#snrmRequest\n      */\n+\n+\n     public final void parseUAResponse(final byte[] data) {\n         parseUAResponse(new GXByteBuffer(data));\n     }\n@@ -508,6 +577,8 @@ public class GXDLMSClient {\n      *            Received message from the server.\n      * @see GXDLMSClient#snrmRequest\n      */\n+\n+\n     public final void parseUAResponse(final GXByteBuffer data) {\n         data.getUInt8(); // Skip FromatID\n         data.getUInt8(); // Skip Group ID.\n@@ -556,6 +627,8 @@ public class GXDLMSClient {\n      * @return AARQ request as byte array.\n      * @see GXDLMSClient#parseAareResponse\n      */\n+\n+\n     public final byte[][] aarqRequest() {\n         GXByteBuffer buff = new GXByteBuffer(20);\n         settings.resetBlockIndex();\n@@ -563,8 +636,7 @@ public class GXDLMSClient {\n         settings.setStoCChallenge(null);\n         // If authentication or ciphering is used.\n         if (getAuthentication().ordinal() > Authentication.LOW.ordinal()) {\n-            settings.setCtoSChallenge(\n-                    GXSecure.generateChallenge(settings.getAuthentication()));\n+            settings.setCtoSChallenge(GXSecure.generateChallenge(settings.getAuthentication()));\n         } else {\n             settings.setCtoSChallenge(null);\n         }\n@@ -590,11 +662,11 @@ public class GXDLMSClient {\n      * @see GXDLMSClient#getLNSettings\n      * @see GXDLMSClient#getSNSettings\n      */\n+\n+\n     public final void parseAareResponse(final GXByteBuffer reply) {\n         settings.setConnected(true);\n-        isAuthenticationRequired =\n-                GXAPDU.parsePDU(settings, settings.getCipher(),\n-                        reply) == SourceDiagnostic.AUTHENTICATION_REQUIRED;\n+        isAuthenticationRequired = GXAPDU.parsePDU(settings, settings.getCipher(), reply) == SourceDiagnostic.AUTHENTICATION_REQUIRED;\n         if (getDLMSVersion() != 6) {\n             throw new GXDLMSException(\"Invalid DLMS version number.\");\n         }\n@@ -603,6 +675,8 @@ public class GXDLMSClient {\n     /**\n      * @return Is authentication Required.\n      */\n+\n+\n     public final boolean getIsAuthenticationRequired() {\n         return isAuthenticationRequired;\n     }\n@@ -610,9 +684,10 @@ public class GXDLMSClient {\n     /**\n      * @return Get challenge request if HLS authentication is used.\n      */\n+\n+\n     public final byte[][] getApplicationAssociationRequest() {\n-        if (settings.getPassword() == null\n-                || settings.getPassword().length == 0) {\n+        if (settings.getPassword() == null || settings.getPassword().length == 0) {\n             throw new IllegalArgumentException(\"Password is invalid.\");\n         }\n         settings.resetBlockIndex();\n@@ -626,18 +701,15 @@ public class GXDLMSClient {\n         if (settings.getCipher() != null) {\n             ic = settings.getCipher().getFrameCounter();\n         }\n-        byte[] challenge = GXSecure.secure(settings, settings.getCipher(), ic,\n-                settings.getStoCChallenge(), pw);\n+        byte[] challenge = GXSecure.secure(settings, settings.getCipher(), ic, settings.getStoCChallenge(), pw);\n         GXByteBuffer bb = new GXByteBuffer();\n         bb.setUInt8(DataType.OCTET_STRING.getValue());\n         GXCommon.setObjectCount(challenge.length, bb);\n         bb.set(challenge);\n         if (getUseLogicalNameReferencing()) {\n-            return method(\"0.0.40.0.0.255\", ObjectType.ASSOCIATION_LOGICAL_NAME,\n-                    1, bb.array(), DataType.OCTET_STRING);\n+            return method(\"0.0.40.0.0.255\", ObjectType.ASSOCIATION_LOGICAL_NAME, 1, bb.array(), DataType.OCTET_STRING);\n         }\n-        return method(0xFA00, ObjectType.ASSOCIATION_SHORT_NAME, 8, bb.array(),\n-                DataType.OCTET_STRING);\n+        return method(0xFA00, ObjectType.ASSOCIATION_SHORT_NAME, 8, bb.array(), DataType.OCTET_STRING);\n     }\n \n     /**\n@@ -646,8 +718,9 @@ public class GXDLMSClient {\n      * @param reply\n      *            Received reply from the server.\n      */\n-    public final void\n-            parseApplicationAssociationResponse(final GXByteBuffer reply) {\n+\n+\n+    public final void parseApplicationAssociationResponse(final GXByteBuffer reply) {\n         GXDataInfo info = new GXDataInfo();\n         boolean equals = false;\n         byte[] secret;\n@@ -662,22 +735,18 @@ public class GXDLMSClient {\n             } else {\n                 secret = settings.getPassword();\n             }\n-            byte[] tmp = GXSecure.secure(settings, settings.getCipher(), ic,\n-                    settings.getCtoSChallenge(), secret);\n+            byte[] tmp = GXSecure.secure(settings, settings.getCipher(), ic, settings.getCtoSChallenge(), secret);\n             GXByteBuffer challenge = new GXByteBuffer(tmp);\n             equals = challenge.compare(value);\n             if (!equals) {\n                 LOGGER.info(\"Invalid StoC:\" + GXCommon.toHex(value) + \"-\"\n-                        + GXCommon.toHex(tmp));\n+                + GXCommon.toHex(tmp));\n             }\n         } else {\n             LOGGER.info(\"Server did not accept CtoS.\");\n         }\n-\n         if (!equals) {\n-            throw new GXDLMSException(\n-                    \"parseApplicationAssociationResponse failed. \"\n-                            + \" Server to Client do not match.\");\n+            throw new GXDLMSException(\"parseApplicationAssociationResponse failed. \" + \" Server to Client do not match.\");\n         }\n     }\n \n@@ -686,16 +755,16 @@ public class GXDLMSClient {\n      * \n      * @return Disconnected request, as byte array.\n      */\n+\n+\n     public final byte[] disconnectRequest() {\n         // If connection is not established, there is no need to send\n         // DisconnectRequest.\n-        if (settings.getSnSettings() == null\n-                && settings.getLnSettings() == null) {\n+        if (settings.getSnSettings() == null && settings.getLnSettings() == null) {\n             return new byte[0];\n         }\n         if (this.getInterfaceType() == InterfaceType.HDLC) {\n-            return GXDLMS.getHdlcFrame(settings, (byte) Command.DISC.getValue(),\n-                    null);\n+            return GXDLMS.getHdlcFrame(settings, (byte) Command.DISC.getValue(), null);\n         }\n         GXByteBuffer bb = new GXByteBuffer(2);\n         bb.setUInt8(Command.DISCONNECT_REQUEST.getValue());\n@@ -718,13 +787,16 @@ public class GXDLMSClient {\n      *            Array of access rights.\n      * @return Created COSEM object.\n      */\n-    static GXDLMSObject createDLMSObject(final int classID,\n-            final Object version, final int baseName, final Object ln,\n-            final Object accessRights) {\n+\n+\n+    static GXDLMSObject createDLMSObject(final int classID, final Object version, final int baseName, final Object ln, final Object accessRights) {\n         ObjectType type = ObjectType.forValue(classID);\n         GXDLMSObject obj = createObject(type);\n-        updateObjectData(obj, type, version, baseName, (byte[]) ln,\n-                accessRights);\n+        updateObjectData(obj,\n+type,\n+version,\n+baseName, (byte[]) ln,\n+accessRights);\n         return obj;\n     }\n \n@@ -737,8 +809,9 @@ public class GXDLMSClient {\n      *            Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n-    private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n+\n+\n+    private GXDLMSObjectCollection parseSNObjects(final GXByteBuffer buff, final boolean onlyKnownObjects) {\n         // Get array tag.\n         short size = buff.getUInt8();\n         // Check that data is in the array\n@@ -763,14 +836,16 @@ public class GXDLMSClient {\n             int classID = ((Number) (objects[1])).intValue() & 0xFFFF;\n             int baseName = ((Number) (objects[0])).intValue() & 0xFFFF;\n             if (baseName > 0) {\n-                GXDLMSObject comp = createDLMSObject(classID, objects[2],\n-                        baseName, objects[3], null);\n-                if (!onlyKnownObjects\n-                        || comp.getClass() != GXDLMSObject.class) {\n+                GXDLMSObject comp = createDLMSObject(classID,\n+                    objects[2],\n+                        baseName,\n+                            objects[3], null);\n+                if (!onlyKnownObjects || comp.getClass() != GXDLMSObject.class) {\n                     items.add(comp);\n                 } else {\n                     System.out.println(String.format(\"Unknown object : %d %d\",\n-                            classID, baseName));\n+classID,\n+baseName));\n                 }\n             }\n         }\n@@ -786,14 +861,12 @@ public class GXDLMSClient {\n      * @param logicalName\n      * @param accessRights\n      */\n-    static void updateObjectData(final GXDLMSObject obj,\n-            final ObjectType objectType, final Object version,\n-            final Object baseName, final byte[] logicalName,\n-            final Object accessRights) {\n+\n+\n+    static void updateObjectData(final GXDLMSObject obj, final ObjectType objectType, final Object version, final Object baseName, final byte[] logicalName, final Object accessRights) {\n         obj.setObjectType(objectType);\n         // Check access rights.\n-        if (accessRights instanceof Object[]\n-                && ((Object[]) accessRights).length == 2) {\n+        if (accessRights instanceof Object[] && ((Object[]) accessRights).length == 2) {\n             // access_rights: access_right\n             Object[] access = (Object[]) accessRights;\n             for (Object attributeAccess : (Object[]) access[0]) {\n@@ -838,8 +911,9 @@ public class GXDLMSClient {\n      *            Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n-    public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data,\n-            final boolean onlyKnownObjects) {\n+\n+\n+    public final GXDLMSObjectCollection parseObjects(final GXByteBuffer data, final boolean onlyKnownObjects) {\n         if (data == null) {\n             throw new GXDLMSException(\"Invalid parameter.\");\n         }\n@@ -862,8 +936,9 @@ public class GXDLMSClient {\n      *            Only known objects are parsed.\n      * @return Collection of COSEM objects.\n      */\n-    private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff,\n-            final boolean onlyKnownObjects) {\n+\n+\n+    private GXDLMSObjectCollection parseLNObjects(final GXByteBuffer buff, final boolean onlyKnownObjects) {\n         // Get array tag.\n         byte size = buff.getInt8();\n         // Check that data is in the array\n@@ -888,15 +963,11 @@ public class GXDLMSClient {\n             }\n             int classID = ((Number) (objects[0])).intValue() & 0xFFFF;\n             if (classID > 0) {\n-                GXDLMSObject comp = createDLMSObject(classID, objects[1], 0,\n-                        objects[2], objects[3]);\n-                if (!onlyKnownObjects\n-                        || comp.getClass() != GXDLMSObject.class) {\n+                GXDLMSObject comp = createDLMSObject(classID, objects[1], 0, objects[2], objects[3]);\n+                if (!onlyKnownObjects || comp.getClass() != GXDLMSObject.class) {\n                     items.add(comp);\n                 } else {\n-                    System.out.println(String.format(\"Unknown object : %d %s\",\n-                            classID,\n-                            GXDLMSObject.toLogicalName((byte[]) objects[2])));\n+                    System.out.println(String.format(\"Unknown object : %d %s\", classID, GXDLMSObject.toLogicalName((byte[]) objects[2])));\n                 }\n             }\n         }\n@@ -906,8 +977,9 @@ public class GXDLMSClient {\n     /*\n      * Get Value from byte array received from the meter.\n      */\n-    public final Object updateValue(final GXDLMSObject target,\n-            final int attributeIndex, final Object value) {\n+\n+\n+    public final Object updateValue(final GXDLMSObject target, final int attributeIndex, final Object value) {\n         Object val = value;\n         if (val instanceof byte[]) {\n             DataType type = target.getUIDataType(attributeIndex);\n@@ -919,8 +991,7 @@ public class GXDLMSClient {\n                 val = changeType((byte[]) value, type);\n             }\n         }\n-        ValueEventArgs e =\n-                new ValueEventArgs(settings, target, attributeIndex, 0, null);\n+        ValueEventArgs e = new ValueEventArgs(settings, target, attributeIndex, 0, null);\n         e.setValue(val);\n         target.setValue(settings, e);\n         return target.getValues()[attributeIndex - 1];\n@@ -933,6 +1004,8 @@ public class GXDLMSClient {\n      *            Byte array received from the meter.\n      * @return Received data.\n      */\n+\n+\n     public final Object getValue(final GXByteBuffer data) {\n         GXDataInfo info = new GXDataInfo();\n         return GXCommon.getData(data, info);\n@@ -946,17 +1019,16 @@ public class GXDLMSClient {\n      * @param data\n      *            Received reply from the meter.\n      */\n-    public final void updateValues(\n-            final List<Entry<GXDLMSObject, Integer>> list,\n-            final GXByteBuffer data) {\n+\n+\n+    public final void updateValues(final List<Entry<GXDLMSObject, Integer>> list, final GXByteBuffer data) {\n         Object value;\n         GXDataInfo info = new GXDataInfo();\n         for (Entry<GXDLMSObject, Integer> it : list) {\n             int ret = data.getUInt8();\n             if (ret == 0) {\n                 value = GXCommon.getData(data, info);\n-                ValueEventArgs e = new ValueEventArgs(settings, it.getKey(),\n-                        it.getValue(), 0, null);\n+                ValueEventArgs e = new ValueEventArgs(settings, it.getKey(), it.getValue(), 0, null);\n                 e.setValue(value);\n                 it.getKey().setValue(settings, e);\n                 info.clear();\n@@ -974,8 +1046,9 @@ public class GXDLMSClient {\n      * @param reply\n      *            Received reply from the meter.\n      */\n-    public final void updateValues(\n-            final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n+\n+\n+    public final void updateValues(final List<Entry<GXDLMSObject, Integer>> list, final byte[] reply) {\n         updateValues(list, new GXByteBuffer(reply));\n     }\n \n@@ -988,6 +1061,8 @@ public class GXDLMSClient {\n      *            Wanted type.\n      * @return Value changed by type.\n      */\n+\n+\n     public static Object changeType(final byte[] value, final DataType type) {\n         if (value == null) {\n             return null;\n@@ -1031,6 +1106,8 @@ public class GXDLMSClient {\n      * \n      * @return Read request, as byte array.\n      */\n+\n+\n     public final byte[] getObjectsRequest() {\n         Object name;\n         settings.resetBlockIndex();\n@@ -1039,7 +1116,8 @@ public class GXDLMSClient {\n         } else {\n             name = (short) 0xFA00;\n         }\n-        return read(name, ObjectType.ASSOCIATION_LOGICAL_NAME, 2)[0];\n+        return read(name,\n+            ObjectType.ASSOCIATION_LOGICAL_NAME, 2)[0];\n     }\n \n     /**\n@@ -1055,9 +1133,16 @@ public class GXDLMSClient {\n      *            Data type.\n      * @return DLMS action message.\n      */\n-    public final byte[][] method(final GXDLMSObject item, final int index,\n+\n+\n+    public final byte[][] method(final GXDLMSObject item,\n+        final int index,\n             final Object data, final DataType type) {\n-        return method(item.getName(), item.getObjectType(), index, data, type);\n+        return method(item.getName(),\n+            item.getObjectType(),\n+                index,\n+                    data,\n+                        type);\n     }\n \n     /**\n@@ -1075,20 +1160,20 @@ public class GXDLMSClient {\n      *            Data type.\n      * @return DLMS action message.\n      */\n-    public final byte[][] method(final Object name, final ObjectType objectType,\n-            final int methodIndex, final Object value,\n-            final DataType dataType) {\n+\n+\n+    public final byte[][] method(final Object name, final ObjectType objectType, final int methodIndex, final Object value, final DataType dataType) {\n         if (name == null || methodIndex < 1) {\n             throw new IllegalArgumentException(\"Invalid parameter\");\n         }\n         settings.resetBlockIndex();\n+\n         int index = methodIndex;\n         DataType type = dataType;\n         if (type == DataType.NONE && value != null) {\n             type = GXCommon.getValueType(value);\n             if (type == DataType.NONE) {\n-                throw new GXDLMSException(\n-                        \"Invalid parameter. In java value type must give.\");\n+                throw new GXDLMSException(\"Invalid parameter. In java value type must give.\");\n             }\n         }\n         GXByteBuffer bb = new GXByteBuffer();\n@@ -1153,11 +1238,17 @@ public class GXDLMSClient {\n      *            Attribute index.\n      * @return Generated write message(s).\n      */\n+\n+\n     public final byte[][] write(final GXDLMSObject item, final int index) {\n         ValueEventArgs e = new ValueEventArgs(settings, item, index, 0, null);\n         Object value = item.getValue(settings, e);\n         DataType type = item.getDataType(index);\n-        return write(item.getName(), value, type, item.getObjectType(), index);\n+        return write(item.getName(),\n+            value,\n+                type,\n+                    item.getObjectType(),\n+                        index);\n     }\n \n     /**\n@@ -1175,9 +1266,9 @@ public class GXDLMSClient {\n      *            Attribute index where data is write.\n      * @return Generated write message(s).\n      */\n-    public final byte[][] write(final Object name, final Object value,\n-            final DataType dataType, final ObjectType objectType,\n-            final int index) {\n+\n+\n+    public final byte[][] write(final Object name, final Object value, final DataType dataType, final ObjectType objectType, final int index) {\n         if (index < 1) {\n             throw new GXDLMSException(\"Invalid parameter\");\n         }\n@@ -1186,8 +1277,7 @@ public class GXDLMSClient {\n         if (type == DataType.NONE && value != null) {\n             type = GXCommon.getValueType(value);\n             if (type == DataType.NONE) {\n-                throw new GXDLMSException(\n-                        \"Invalid parameter. In java value type must give.\");\n+                throw new GXDLMSException(\"Invalid parameter. In java value type must give.\");\n             }\n         }\n         GXByteBuffer bb = new GXByteBuffer();\n@@ -1215,6 +1305,7 @@ public class GXDLMSClient {\n             // Add name length.\n             bb.setUInt8(2);\n             // Add name.\n+\n             int sn = GXCommon.intValue(name);\n             sn += (index - 1) * 8;\n             bb.setUInt16(sn);\n@@ -1232,6 +1323,8 @@ public class GXDLMSClient {\n      *            DLMS objects to write.\n      * @return Write request as byte array.\n      */\n+\n+\n     public final byte[][] writeList(final List<GXWriteItem> list) {\n         if (list == null || list.isEmpty()) {\n             throw new IllegalArgumentException(\"Invalid parameter.\");\n@@ -1247,8 +1340,7 @@ public class GXDLMSClient {\n             for (GXWriteItem it : list) {\n                 // CI.\n                 bb.setUInt16(it.getTarget().getObjectType().getValue());\n-                List<String> items =\n-                        GXCommon.split(it.getTarget().getLogicalName(), '.');\n+                List<String> items = GXCommon.split(it.getTarget().getLogicalName(), '.');\n                 if (items.size() != 6) {\n                     throw new IllegalArgumentException(\"Invalid Logical Name.\");\n                 }\n@@ -1267,6 +1359,7 @@ public class GXDLMSClient {\n             for (GXWriteItem it : list) {\n                 // Add variable type.\n                 bb.setUInt8(2);\n+\n                 int sn = GXCommon.intValue(it.getTarget().getShortName());\n                 sn += (it.getIndex() - 1) * 8;\n                 bb.setUInt16(sn);\n@@ -1275,8 +1368,7 @@ public class GXDLMSClient {\n         // Write values.\n         bb.setUInt8(list.size());\n         for (GXWriteItem it : list) {\n-            ValueEventArgs e = new ValueEventArgs(settings, it.getTarget(),\n-                    it.getIndex(), it.getSelector(), it.getParameters());\n+            ValueEventArgs e = new ValueEventArgs(settings, it.getTarget(), it.getIndex(), it.getSelector(), it.getParameters());\n             value = it.getTarget().getValue(settings, e);\n             if ((value instanceof byte[])) {\n                 bb.set((byte[]) value);\n@@ -1285,8 +1377,7 @@ public class GXDLMSClient {\n                 if (type == DataType.NONE && value != null) {\n                     type = GXCommon.getValueType(value);\n                     if (type == DataType.NONE) {\n-                        throw new GXDLMSException(\"Invalid parameter. \"\n-                                + \" In java value type must give.\");\n+                        throw new GXDLMSException(\"Invalid parameter. \" + \" In java value type must give.\");\n                     }\n                 }\n                 GXCommon.setData(bb, type, value);\n@@ -1306,8 +1397,9 @@ public class GXDLMSClient {\n      *            Attribute index of the object.\n      * @return Generated read message(s).\n      */\n-    public final byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal) {\n+\n+\n+    public final byte[][] read(final Object name, final ObjectType objectType, final int attributeOrdinal) {\n         return read(name, objectType, attributeOrdinal, null);\n     }\n \n@@ -1324,8 +1416,9 @@ public class GXDLMSClient {\n      *            Read data parameter.\n      * @return Generated read message(s).\n      */\n-    private byte[][] read(final Object name, final ObjectType objectType,\n-            final int attributeOrdinal, final GXByteBuffer data) {\n+\n+\n+    private byte[][] read(final Object name, final ObjectType objectType, final int attributeOrdinal, final GXByteBuffer data) {\n         if ((attributeOrdinal < 1)) {\n             throw new IllegalArgumentException(\"Invalid parameter\");\n         }\n@@ -1385,9 +1478,12 @@ public class GXDLMSClient {\n      *            Read attribute index.\n      * @return Read request as byte array.\n      */\n-    public final byte[][] read(final GXDLMSObject item,\n-            final int attributeOrdinal) {\n-        return read(item.getName(), item.getObjectType(), attributeOrdinal);\n+\n+\n+    public final byte[][] read(final GXDLMSObject item, final int attributeOrdinal) {\n+        return read(item.getName(),\n+            item.getObjectType(),\n+                attributeOrdinal);\n     }\n \n     /**\n@@ -1397,8 +1493,9 @@ public class GXDLMSClient {\n      *            DLMS objects to read.\n      * @return Read request as byte array.\n      */\n-    public final byte[][]\n-            readList(final List<Entry<GXDLMSObject, Integer>> list) {\n+\n+\n+    public final byte[][] readList(final List<Entry<GXDLMSObject, Integer>> list) {\n         if (list == null || list.isEmpty()) {\n             throw new IllegalArgumentException(\"Invalid parameter.\");\n         }\n@@ -1410,6 +1507,7 @@ public class GXDLMSClient {\n             cmd = Command.GET_REQUEST;\n \n             // Request service primitive shall always fit in a single APDU.\n+\n             int pos = 0, count = (settings.getMaxReceivePDUSize() - 12) / 10;\n             if (list.size() < count) {\n                 count = list.size();\n@@ -1423,8 +1521,7 @@ public class GXDLMSClient {\n             for (Entry<GXDLMSObject, Integer> it : list) {\n                 // CI.\n                 bb.setUInt16(it.getKey().getObjectType().getValue());\n-                List<String> items =\n-                        GXCommon.split(it.getKey().getLogicalName(), '.');\n+                List<String> items = GXCommon.split(it.getKey().getLogicalName(), '.');\n                 if (items.size() != 6) {\n                     throw new IllegalArgumentException(\"Invalid Logical Name.\");\n                 }\n@@ -1435,11 +1532,10 @@ public class GXDLMSClient {\n                 bb.setUInt8(it.getValue());\n                 // Attribute selector is not used.\n                 bb.setUInt8(0);\n-\n                 ++pos;\n-                if (pos % count == 0 && list.size() != pos) {\n-                    messages.addAll(Arrays.asList(\n-                            GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n+                if (pos % count == 0\n+                        && list.size() != pos) {\n+                    messages.addAll(Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n                     bb.clear();\n                     if (list.size() - pos < count) {\n                         GXCommon.setObjectCount(list.size() - pos, bb);\n@@ -1455,14 +1551,13 @@ public class GXDLMSClient {\n             for (Entry<GXDLMSObject, Integer> it : list) {\n                 // Add variable type.\n                 bb.setUInt8(2);\n+\n                 int sn = GXCommon.intValue(it.getKey().getShortName());\n                 sn += (it.getValue() - 1) * 8;\n                 bb.setUInt16(sn);\n             }\n         }\n-\n-        messages.addAll(\n-                Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n+        messages.addAll(Arrays.asList(GXDLMS.getMessages(settings, cmd, 3, bb, null)));\n         return messages.toArray(new byte[0][0]);\n     }\n \n@@ -1472,12 +1567,15 @@ public class GXDLMSClient {\n      * \n      * @return Returns Keep alive message, as byte array.\n      */\n+\n+\n     public final byte[] keepAlive() {\n         // There is no need for keep alive in IEC 62056-47.\n         if (this.getInterfaceType() == InterfaceType.WRAPPER) {\n             return new byte[0];\n         }\n-        return GXDLMS.getHdlcFrame(settings, settings.getReceiverReady(), null);\n+        return GXDLMS.getHdlcFrame(settings,\n+settings.getReceiverReady(), null);\n     }\n \n     /**\n@@ -1491,8 +1589,9 @@ public class GXDLMSClient {\n      *            Rows count to read.\n      * @return Read message as byte array.\n      */\n-    public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg,\n-            final int index, final int count) {\n+\n+\n+    public final byte[][] readRowsByEntry(final GXDLMSProfileGeneric pg, final int index, final int count) {\n         GXByteBuffer buff = new GXByteBuffer(19);\n         // Add AccessSelector value\n         buff.setUInt8(0x02);\n@@ -1511,7 +1610,9 @@ public class GXDLMSClient {\n             GXCommon.setData(buff, DataType.UINT16, 0);\n         }\n         GXCommon.setData(buff, DataType.UINT16, 0);\n-        return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n+        return read(pg.getName(),\n+            ObjectType.PROFILE_GENERIC, 2,\n+                buff);\n     }\n \n     /**\n@@ -1526,8 +1627,10 @@ public class GXDLMSClient {\n      *            End time.\n      * @return Generated read message.\n      */\n+\n+\n     public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final java.util.Date start, final java.util.Date end) {\n+        final java.util.Date start, final java.util.Date end) {\n         return readByRange(pg, start, end);\n     }\n \n@@ -1543,8 +1646,9 @@ public class GXDLMSClient {\n      *            End time.\n      * @return Generated read message.\n      */\n-    public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg,\n-            final Calendar start, final Calendar end) {\n+\n+\n+    public final byte[][] readRowsByRange(final GXDLMSProfileGeneric pg, final Calendar start, final Calendar end) {\n         return readByRange(pg, start, end);\n     }\n \n@@ -1560,8 +1664,9 @@ public class GXDLMSClient {\n      *            End time.\n      * @return Generated read message.\n      */\n-    private byte[][] readByRange(final GXDLMSProfileGeneric pg,\n-            final Object start, final Object end) {\n+\n+\n+    private byte[][] readByRange(final GXDLMSProfileGeneric pg, final Object start, final Object end) {\n         settings.resetBlockIndex();\n         GXDLMSObject sort = pg.getSortObject();\n         if (sort == null && pg.getCaptureObjects().size() != 0) {\n@@ -1583,10 +1688,13 @@ public class GXDLMSClient {\n         // Add item count\n         buff.setUInt8(0x04);\n         // CI\n-        GXCommon.setData(buff, DataType.UINT16,\n+        GXCommon.setData(buff,\n+                DataType.UINT16,\n                 sort.getObjectType().getValue());\n         // LN\n-        GXCommon.setData(buff, DataType.OCTET_STRING, sort.getLogicalName());\n+        GXCommon.setData(buff,\n+                DataType.OCTET_STRING,\n+                sort.getLogicalName());\n         // Add attribute index.\n         GXCommon.setData(buff, DataType.INT8, 2);\n         // Add version\n@@ -1597,7 +1705,9 @@ public class GXDLMSClient {\n         buff.setUInt8(0x01);\n         // Add item count\n         buff.setUInt8(0x00);\n-        return read(pg.getName(), ObjectType.PROFILE_GENERIC, 2, buff);\n+        return read(pg.getName(),\n+            ObjectType.PROFILE_GENERIC, 2,\n+                buff);\n     }\n \n     /**\n@@ -1607,6 +1717,8 @@ public class GXDLMSClient {\n      *            Object type.\n      * @return Created object.\n      */\n+\n+\n     public static GXDLMSObject createObject(final ObjectType type) {\n         return GXDLMS.createObject(type);\n     }\n@@ -1619,6 +1731,8 @@ public class GXDLMSClient {\n      *            Frame type\n      * @return Acknowledgment message as byte array.\n      */\n+\n+\n     public final byte[] receiverReady(final RequestTypes type) {\n         return GXDLMS.receiverReady(settings, type);\n     }\n@@ -1632,6 +1746,8 @@ public class GXDLMSClient {\n      *            Information from the received data.\n      * @return Is frame complete.\n      */\n+\n+\n     public final boolean getData(final byte[] reply, final GXReplyData data) {\n         return GXDLMS.getData(settings, new GXByteBuffer(reply), data);\n     }\n@@ -1644,8 +1760,9 @@ public class GXDLMSClient {\n      * @param data\n      *            The exported reply information.\n      */\n-    public final void getData(final GXByteBuffer reply,\n-            final GXReplyData data) {\n+\n+\n+    public final void getData(final GXByteBuffer reply, final GXReplyData data) {\n         GXDLMS.getData(settings, reply, data);\n     }\n \n@@ -1658,6 +1775,8 @@ public class GXDLMSClient {\n      *            Meter serial number\n      * @return Server address.\n      */\n+\n+\n     public static int getServerAddress(final int serialNumber) {\n         return getServerAddress(serialNumber, null);\n     }\n@@ -1674,13 +1793,12 @@ public class GXDLMSClient {\n      * @return Server address.\n      */\n \n-    public static int getServerAddress(final int serialNumber,\n-            final String formula) {\n+\n+    public static int getServerAddress(final int serialNumber, final String formula) {\n         // If formula is not given use default formula.\n         // This formula is defined in DLMS specification.\n         if (formula == null || formula.length() == 0) {\n-            return 0x4000 | SerialNumberCounter.count(serialNumber,\n-                    \"SN % 10000 + 1000\");\n+            return 0x4000 | SerialNumberCounter.count(serialNumber, \"SN % 10000 + 1000\");\n         }\n         return 0x4000 | SerialNumberCounter.count(serialNumber, formula);\n     }\n@@ -1694,8 +1812,9 @@ public class GXDLMSClient {\n      *            Server physical address.\n      * @return Server address.\n      */\n-    public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress) {\n+\n+\n+    public static int getServerAddress(final int logicalAddress, final int physicalAddress) {\n         return getServerAddress(logicalAddress, physicalAddress, 0);\n     }\n \n@@ -1710,16 +1829,18 @@ public class GXDLMSClient {\n      *            Address size in bytes.\n      * @return Server address.\n      */\n-    public static int getServerAddress(final int logicalAddress,\n-            final int physicalAddress, final int addressSize) {\n-        if (addressSize < 4 && physicalAddress < 0x80\n+\n+\n+    public static int getServerAddress(final int logicalAddress, final int physicalAddress, final int addressSize) {\n+        if (addressSize < 4\n+                && physicalAddress < 0x80\n                 && logicalAddress < 0x80) {\n             return logicalAddress << 7 | physicalAddress;\n         }\n-        if (physicalAddress < 0x4000 && logicalAddress < 0x4000) {\n+        if (physicalAddress < 0x4000\n+                && logicalAddress < 0x4000) {\n             return logicalAddress << 14 | physicalAddress;\n         }\n-        throw new IllegalArgumentException(\n-                \"Invalid logical or physical address.\");\n+        throw new IllegalArgumentException(\"Invalid logical or physical address.\");\n     }\n }\n\\ No newline at end of file\n",
            "diff_size": 310
        },
        {
            "tool": "styler_random",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "532",
                    "severity": "warning",
                    "message": "Line is longer than 80 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}