{
    "error_id": "628",
    "information": {
        "errors": [
            {
                "line": "312",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                // Oracle date add\n                return new DateTimeFunction(\n                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n                                left),\n                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n            }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "312",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/628/BinaryOperation.java\nindex dd351ddc39..5ec97f9fe1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/628/BinaryOperation.java\n@@ -308,104 +308,104 @@ public class BinaryOperation extends Operation2 {\n             case Value.REAL:\n             case Value.DOUBLE:\n                 // Oracle date add\n-                return new DateTimeFunction(\n-                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n-                                left),\n-                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-            }\n-            break;\n-        }\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INTEGER: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n-                            DateTimeFunction.DAY).optimize(session);\n-                }\n-                case Value.NUMERIC:\n-                case Value.REAL:\n-                case Value.DOUBLE: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(\n-                            new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n-                                    right),\n-                            left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-                }\n-                case Value.TIME:\n-                case Value.TIME_TZ:\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n-                }\n-                break;\n-            case Value.TIME:\n-            case Value.TIME_TZ:\n-                if (DataType.isDateTimeType(r)) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                return new DateTimeFunction(new\n+                        BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n+                         left),\n+                 right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+     }\n+     break;\n+ }\n+ case MINUS:\n+     switch (l) {\n+     case Value.DATE:\n+     case Value.TIMESTAMP:\n+     case Value.TIMESTAMP_TZ:\n+         switch (r) {\n+         case Value.INTEGER: {\n+             if (forcedType != null) {\n+                 throw getUnexpectedForcedTypeException();\n+             }\n+             // Oracle date subtract\n+             return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n+                     DateTimeFunction.DAY).optimize(session);\n+         }\n+         case Value.NUMERIC:\n+         case Value.REAL:\n+         case Value.DOUBLE: {\n+             if (forcedType != null) {\n+                 throw getUnexpectedForcedTypeException();\n+             }\n+             // Oracle date subtract\n+             return new DateTimeFunction(\n+                     new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n+                             right),\n+                     left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+         }\n+         case Value.TIME:\n+         case Value.TIME_TZ:\n+         case Value.DATE:\n+         case Value.TIMESTAMP:\n+         case Value.TIMESTAMP_TZ:\n+             return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+         }\n+         break;\n+     case Value.TIME:\n+     case Value.TIME_TZ:\n+         if (DataType.isDateTimeType(r)) {\n+             return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+         }\n+         break;\n+     }\n+     break;\n+ case MULTIPLY:\n+     if (l == Value.TIME) {\n+         type = TypeInfo.TYPE_TIME;\n+         convertRight = false;\n+         return this;\n+     } else if (r == Value.TIME) {\n+         swap();\n+         type = TypeInfo.TYPE_TIME;\n+         convertRight = false;\n+         return this;\n+     }\n+     break;\n+ case DIVIDE:\n+     if (l == Value.TIME) {\n+         type = TypeInfo.TYPE_TIME;\n+         convertRight = false;\n+         return this;\n+     }\n+     break;\n+ default:\n+ }\n+ throw getUnsupported(l, r);\n+}\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+private DbException getUnsupported(int l, int r) {\n+    return DbException.getUnsupportedException(\n+            DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+}\n \n-    private DbException getUnexpectedForcedTypeException() {\n-        StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n-        int index = builder.length();\n-        return DbException.getSyntaxError(\n-                IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n-    }\n+private DbException getUnexpectedForcedTypeException() {\n+    StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n+    int index = builder.length();\n+    return DbException.getSyntaxError(\n+            IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n+}\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+private void swap() {\n+    Expression temp = left;\n+    left = right;\n+    right = temp;\n+}\n \n-    /**\n+/**\n      * Returns the type of this binary operation.\n      *\n      * @return the type of this binary operation\n      */\n-    public OpType getOperationType() {\n-        return opType;\n-    }\n+public OpType getOperationType() {\n+    return opType;\n+}\n \n }\n",
            "diff_size": 91
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "334",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/628/BinaryOperation.java\nindex dd351ddc39..2242db4f21 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/628/BinaryOperation.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.expression;\n \n import org.h2.engine.Session;\n@@ -21,391 +22,422 @@ import org.h2.value.ValueNumeric;\n  */\n public class BinaryOperation extends Operation2 {\n \n-    public enum OpType {\n-        /**\n-         * This operation represents an addition as in 1 + 2.\n-         */\n-        PLUS,\n+  public enum OpType {\n+    /**\n+     * This operation represents an addition as in 1 + 2.\n+     */\n+    PLUS,\n \n-        /**\n-         * This operation represents a subtraction as in 2 - 1.\n-         */\n-        MINUS,\n+    /**\n+     * This operation represents a subtraction as in 2 - 1.\n+     */\n+    MINUS,\n \n-        /**\n-         * This operation represents a multiplication as in 2 * 3.\n-         */\n-        MULTIPLY,\n+    /**\n+     * This operation represents a multiplication as in 2 * 3.\n+     */\n+    MULTIPLY,\n \n-        /**\n-         * This operation represents a division as in 4 * 2.\n-         */\n-        DIVIDE\n-    }\n+    /**\n+     * This operation represents a division as in 4 * 2.\n+     */\n+    DIVIDE\n+  }\n \n-    private OpType opType;\n-    private TypeInfo forcedType;\n-    private boolean convertRight = true;\n+  private OpType opType;\n+  private TypeInfo forcedType;\n+  private boolean convertRight = true;\n \n-    public BinaryOperation(OpType opType, Expression left, Expression right) {\n-        super(left, right);\n-        this.opType = opType;\n-    }\n+  public BinaryOperation(OpType opType, Expression left, Expression right) {\n+    super(left, right);\n+    this.opType = opType;\n+  }\n \n-    /**\n-     * Sets a forced data type of a datetime minus datetime operation.\n-     *\n-     * @param forcedType the forced data type\n-     */\n-    public void setForcedType(TypeInfo forcedType) {\n-        if (opType != OpType.MINUS) {\n-            throw getUnexpectedForcedTypeException();\n-        }\n-        this.forcedType = forcedType;\n+  /**\n+   * Sets a forced data type of a datetime minus datetime operation.\n+   *\n+   * @param forcedType the forced data type\n+   */\n+  public void setForcedType(TypeInfo forcedType) {\n+    if (opType != OpType.MINUS) {\n+      throw getUnexpectedForcedTypeException();\n     }\n+    this.forcedType = forcedType;\n+  }\n \n-    @Override\n-    public StringBuilder getSQL(StringBuilder builder, int sqlFlags) {\n-        // don't remove the space, otherwise it might end up some thing like\n-        // --1 which is a line remark\n-        builder.append('(');\n-        left.getSQL(builder, sqlFlags).append(' ').append(getOperationToken()).append(' ');\n-        return right.getSQL(builder, sqlFlags).append(')');\n-    }\n+  @Override\n+  public StringBuilder getSQL(StringBuilder builder, int sqlFlags) {\n+    // don't remove the space, otherwise it might end up some thing like\n+    // --1 which is a line remark\n+    builder.append('(');\n+    left.getSQL(builder, sqlFlags).append(' ').append(getOperationToken())\n+        .append(' ');\n+    return right.getSQL(builder, sqlFlags).append(')');\n+  }\n \n-    private String getOperationToken() {\n-        switch (opType) {\n-        case PLUS:\n-            return \"+\";\n-        case MINUS:\n-            return \"-\";\n-        case MULTIPLY:\n-            return \"*\";\n-        case DIVIDE:\n-            return \"/\";\n-        default:\n-            throw DbException.throwInternalError(\"opType=\" + opType);\n-        }\n+  private String getOperationToken() {\n+    switch (opType) {\n+      case PLUS:\n+        return \"+\";\n+      case MINUS:\n+        return \"-\";\n+      case MULTIPLY:\n+        return \"*\";\n+      case DIVIDE:\n+        return \"/\";\n+      default:\n+        throw DbException.throwInternalError(\"opType=\" + opType);\n     }\n+  }\n \n-    @Override\n-    public Value getValue(Session session) {\n-        Value l = left.getValue(session).convertTo(type, session);\n-        Value r = right.getValue(session);\n-        if (convertRight) {\n-            r = r.convertTo(type, session);\n+  @Override\n+  public Value getValue(Session session) {\n+    Value l = left.getValue(session).convertTo(type, session);\n+    Value r = right.getValue(session);\n+    if (convertRight) {\n+      r = r.convertTo(type, session);\n+    }\n+    switch (opType) {\n+      case PLUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        switch (opType) {\n-        case PLUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.add(r);\n-        case MINUS:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.subtract(r);\n-        case MULTIPLY:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.multiply(r);\n-        case DIVIDE:\n-            if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n-                return ValueNull.INSTANCE;\n-            }\n-            return l.divide(r, right.getType().getPrecision());\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + opType);\n+        return l.add(r);\n+      case MINUS:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-    }\n-\n-    @Override\n-    public Expression optimize(Session session) {\n-        left = left.optimize(session);\n-        right = right.optimize(session);\n-        TypeInfo leftType = left.getType(), rightType = right.getType();\n-        int l = leftType.getValueType(), r = rightType.getValueType();\n-        if ((l == Value.NULL && r == Value.NULL) || (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n-            // (? + ?) - use decimal by default (the most safe data type) or\n-            // string when text concatenation with + is enabled\n-            if (opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n-                return new ConcatenationOperation(left, right).optimize(session);\n-            } else {\n-                type = TypeInfo.TYPE_NUMERIC_FLOATING_POINT;\n-            }\n-        } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n-            if (forcedType != null) {\n-                throw getUnexpectedForcedTypeException();\n-            }\n-            return optimizeInterval(session, l, r);\n-        } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n-            return optimizeDateTime(session, l, r);\n-        } else if (forcedType != null) {\n-            throw getUnexpectedForcedTypeException();\n-        } else {\n-            int dataType = Value.getHigherOrder(l, r);\n-            if (dataType == Value.NUMERIC) {\n-                optimizeNumeric(leftType, rightType);\n-            } else if (dataType == Value.ENUM) {\n-                type = TypeInfo.TYPE_INTEGER;\n-            } else if (DataType.isCharacterStringType(dataType)\n-                    && opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n-                return new ConcatenationOperation(left, right).optimize(session);\n-            } else {\n-                type = TypeInfo.getTypeInfo(dataType);\n-            }\n+        return l.subtract(r);\n+      case MULTIPLY:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        if (left.isConstant() && right.isConstant()) {\n-            return ValueExpression.get(getValue(session));\n+        return l.multiply(r);\n+      case DIVIDE:\n+        if (l == ValueNull.INSTANCE || r == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n         }\n-        return this;\n+        return l.divide(r, right.getType().getPrecision());\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + opType);\n     }\n+  }\n \n-    private void optimizeNumeric(TypeInfo leftType, TypeInfo rightType) {\n-        leftType = leftType.toNumericType();\n-        rightType = rightType.toNumericType();\n-        long leftPrecision = leftType.getPrecision(), rightPrecision = rightType.getPrecision();\n-        int leftScale = leftType.getScale(), rightScale = rightType.getScale();\n-        long precision;\n-        int scale;\n-        switch (opType) {\n-        case PLUS:\n-        case MINUS:\n-            // Precision is implementation-defined.\n-            // Scale must be max(leftScale, rightScale).\n-            // Choose the largest scale and adjust the precision of other\n-            // argument.\n-            if (leftScale < rightScale) {\n-                leftPrecision += rightScale - leftScale;\n-                scale = rightScale;\n-            } else {\n-                rightPrecision += leftScale - rightScale;\n-                scale = leftScale;\n-            }\n-            // Add one extra digit to the largest precision.\n-            precision = Math.max(leftPrecision, rightPrecision) + 1;\n-            break;\n-        case MULTIPLY:\n-            // Precision is implementation-defined.\n-            // Scale must be leftScale + rightScale.\n-            // Use sum of precisions.\n-            precision = leftPrecision + rightPrecision;\n-            scale = leftScale + rightScale;\n-            break;\n-        case DIVIDE:\n-            // Precision and scale are implementation-defined.\n-            scale = ValueNumeric.getQuotientScale(leftScale, rightPrecision, rightScale);\n-            // Divider can be effectively multiplied by no more than\n-            // 10^rightScale, so add rightScale to its precision and adjust the\n-            // result to the changes in scale.\n-            precision = leftPrecision + rightScale - leftScale + scale;\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + opType);\n-        }\n-        type = TypeInfo.getTypeInfo(Value.NUMERIC, precision, scale, null);\n+  @Override\n+  public Expression optimize(Session session) {\n+    left = left.optimize(session);\n+    right = right.optimize(session);\n+    TypeInfo leftType = left.getType(), rightType = right.getType();\n+    int l = leftType.getValueType(), r = rightType.getValueType();\n+    if ((l == Value.NULL && r == Value.NULL) ||\n+        (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n+      // (? + ?) - use decimal by default (the most safe data type) or\n+      // string when text concatenation with + is enabled\n+      if (opType == OpType.PLUS &&\n+          session.getDatabase().getMode().allowPlusForStringConcat) {\n+        return new ConcatenationOperation(left, right).optimize(session);\n+      } else {\n+        type = TypeInfo.TYPE_NUMERIC_FLOATING_POINT;\n+      }\n+    } else if (DataType.isIntervalType(l) || DataType.isIntervalType(r)) {\n+      if (forcedType != null) {\n+        throw getUnexpectedForcedTypeException();\n+      }\n+      return optimizeInterval(session, l, r);\n+    } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n+      return optimizeDateTime(session, l, r);\n+    } else if (forcedType != null) {\n+      throw getUnexpectedForcedTypeException();\n+    } else {\n+      int dataType = Value.getHigherOrder(l, r);\n+      if (dataType == Value.NUMERIC) {\n+        optimizeNumeric(leftType, rightType);\n+      } else if (dataType == Value.ENUM) {\n+        type = TypeInfo.TYPE_INTEGER;\n+      } else if (DataType.isCharacterStringType(dataType)\n+          && opType == OpType.PLUS &&\n+          session.getDatabase().getMode().allowPlusForStringConcat) {\n+        return new ConcatenationOperation(left, right).optimize(session);\n+      } else {\n+        type = TypeInfo.getTypeInfo(dataType);\n+      }\n     }\n+    if (left.isConstant() && right.isConstant()) {\n+      return ValueExpression.get(getValue(session));\n+    }\n+    return this;\n+  }\n \n-    private Expression optimizeInterval(Session session, int l, int r) {\n-        boolean lInterval = false, lNumeric = false, lDateTime = false;\n-        if (DataType.isIntervalType(l)) {\n-            lInterval = true;\n-        } else if (DataType.isNumericType(l)) {\n-            lNumeric = true;\n-        } else if (DataType.isDateTimeType(l)) {\n-            lDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n-        boolean rInterval = false, rNumeric = false, rDateTime = false;\n-        if (DataType.isIntervalType(r)) {\n-            rInterval = true;\n-        } else if (DataType.isNumericType(r)) {\n-            rNumeric = true;\n-        } else if (DataType.isDateTimeType(r)) {\n-            rDateTime = true;\n+  private void optimizeNumeric(TypeInfo leftType, TypeInfo rightType) {\n+    leftType = leftType.toNumericType();\n+    rightType = rightType.toNumericType();\n+    long leftPrecision = leftType.getPrecision(), rightPrecision =\n+        rightType.getPrecision();\n+    int leftScale = leftType.getScale(), rightScale = rightType.getScale();\n+    long precision;\n+    int scale;\n+    switch (opType) {\n+      case PLUS:\n+      case MINUS:\n+        // Precision is implementation-defined.\n+        // Scale must be max(leftScale, rightScale).\n+        // Choose the largest scale and adjust the precision of other\n+        // argument.\n+        if (leftScale < rightScale) {\n+          leftPrecision += rightScale - leftScale;\n+          scale = rightScale;\n         } else {\n-            throw getUnsupported(l, r);\n+          rightPrecision += leftScale - rightScale;\n+          scale = leftScale;\n         }\n-        switch (opType) {\n-        case PLUS:\n-            if (lInterval && rInterval) {\n-                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL, left, right);\n-                }\n-            } else if (lInterval && rDateTime) {\n-                if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);\n-            } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n-            }\n-            break;\n-        case MINUS:\n-            if (lInterval && rInterval) {\n-                if (DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL, left, right);\n-                }\n-            } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL, left, right);\n-            }\n+        // Add one extra digit to the largest precision.\n+        precision = Math.max(leftPrecision, rightPrecision) + 1;\n+        break;\n+      case MULTIPLY:\n+        // Precision is implementation-defined.\n+        // Scale must be leftScale + rightScale.\n+        // Use sum of precisions.\n+        precision = leftPrecision + rightPrecision;\n+        scale = leftScale + rightScale;\n+        break;\n+      case DIVIDE:\n+        // Precision and scale are implementation-defined.\n+        scale = ValueNumeric\n+            .getQuotientScale(leftScale, rightPrecision, rightScale);\n+        // Divider can be effectively multiplied by no more than\n+        // 10^rightScale, so add rightScale to its precision and adjust the\n+        // result to the changes in scale.\n+        precision = leftPrecision + rightScale - leftScale + scale;\n+        break;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + opType);\n+    }\n+    type = TypeInfo.getTypeInfo(Value.NUMERIC, precision, scale, null);\n+  }\n+\n+  private Expression optimizeInterval(Session session, int l, int r) {\n+    boolean lInterval = false, lNumeric = false, lDateTime = false;\n+    if (DataType.isIntervalType(l)) {\n+      lInterval = true;\n+    } else if (DataType.isNumericType(l)) {\n+      lNumeric = true;\n+    } else if (DataType.isDateTimeType(l)) {\n+      lDateTime = true;\n+    } else {\n+      throw getUnsupported(l, r);\n+    }\n+    boolean rInterval = false, rNumeric = false, rDateTime = false;\n+    if (DataType.isIntervalType(r)) {\n+      rInterval = true;\n+    } else if (DataType.isNumericType(r)) {\n+      rNumeric = true;\n+    } else if (DataType.isDateTimeType(r)) {\n+      rDateTime = true;\n+    } else {\n+      throw getUnsupported(l, r);\n+    }\n+    switch (opType) {\n+      case PLUS:\n+        if (lInterval && rInterval) {\n+          if (DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_PLUS_INTERVAL,\n+                left, right);\n+          }\n+        } else if (lInterval && rDateTime) {\n+          if (r == Value.TIME && DataType.isYearMonthIntervalType(l)) {\n             break;\n-        case MULTIPLY:\n-            if (lInterval && rNumeric) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, left, right);\n-            } else if (lNumeric && rInterval) {\n-                return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC, right, left);\n-            }\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL,\n+              right, left);\n+        } else if (lDateTime && rInterval) {\n+          if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n             break;\n-        case DIVIDE:\n-            if (lInterval) {\n-                if (rNumeric) {\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC, left, right);\n-                } else if (rInterval && DataType.isYearMonthIntervalType(l) == DataType.isYearMonthIntervalType(r)) {\n-                    // Non-standard\n-                    return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_INTERVAL, left, right);\n-                }\n-            }\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL,\n+              left, right);\n+        }\n+        break;\n+      case MINUS:\n+        if (lInterval && rInterval) {\n+          if (DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_MINUS_INTERVAL,\n+                left, right);\n+          }\n+        } else if (lDateTime && rInterval) {\n+          if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n             break;\n-        default:\n+          }\n+          return new IntervalOperation(IntervalOpType.DATETIME_MINUS_INTERVAL,\n+              left, right);\n+        }\n+        break;\n+      case MULTIPLY:\n+        if (lInterval && rNumeric) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC,\n+              left, right);\n+        } else if (lNumeric && rInterval) {\n+          return new IntervalOperation(IntervalOpType.INTERVAL_MULTIPLY_NUMERIC,\n+              right, left);\n         }\n-        throw getUnsupported(l, r);\n+        break;\n+      case DIVIDE:\n+        if (lInterval) {\n+          if (rNumeric) {\n+            return new IntervalOperation(IntervalOpType.INTERVAL_DIVIDE_NUMERIC,\n+                left, right);\n+          } else if (rInterval && DataType.isYearMonthIntervalType(l) ==\n+              DataType.isYearMonthIntervalType(r)) {\n+            // Non-standard\n+            return new IntervalOperation(\n+                IntervalOpType.INTERVAL_DIVIDE_INTERVAL, left, right);\n+          }\n+        }\n+        break;\n+      default:\n     }\n+    throw getUnsupported(l, r);\n+  }\n \n-    private Expression optimizeDateTime(Session session, int l, int r) {\n-        switch (opType) {\n-        case PLUS: {\n-            if (DataType.isDateTimeType(l)) {\n-                if (DataType.isDateTimeType(r)) {\n-                    if (l > r) {\n-                        swap();\n-                        int t = l;\n-                        l = r;\n-                        r = t;\n-                    }\n-                    return new CompatibilityDatePlusTimeOperation(right, left).optimize(session);\n-                }\n-                swap();\n-                int t = l;\n-                l = r;\n-                r = t;\n+  private Expression optimizeDateTime(Session session, int l, int r) {\n+    switch (opType) {\n+      case PLUS: {\n+        if (DataType.isDateTimeType(l)) {\n+          if (DataType.isDateTimeType(r)) {\n+            if (l > r) {\n+              swap();\n+              int t = l;\n+              l = r;\n+              r = t;\n             }\n-            switch (l) {\n-            case Value.INTEGER:\n-                // Oracle date add\n-                return new DateTimeFunction(left, right, DateTimeFunction.DATEADD, DateTimeFunction.DAY)\n-                        .optimize(session);\n-            case Value.NUMERIC:\n-            case Value.REAL:\n-            case Value.DOUBLE:\n-                // Oracle date add\n-                return new DateTimeFunction(\n-                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n-                                left),\n-                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-            }\n-            break;\n+            return new CompatibilityDatePlusTimeOperation(right, left)\n+                .optimize(session);\n+          }\n+          swap();\n+          int t = l;\n+          l = r;\n+          r = t;\n         }\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INTEGER: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n-                            DateTimeFunction.DAY).optimize(session);\n-                }\n-                case Value.NUMERIC:\n-                case Value.REAL:\n-                case Value.DOUBLE: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(\n-                            new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n-                                    right),\n-                            left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-                }\n-                case Value.TIME:\n-                case Value.TIME_TZ:\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+        switch (l) {\n+          case Value.INTEGER:\n+            // Oracle date add\n+            return new DateTimeFunction(left, right, DateTimeFunction.DATEADD,\n+                DateTimeFunction.DAY)\n+                .optimize(session);\n+          case Value.NUMERIC:\n+          case Value.REAL:\n+          case Value.DOUBLE:\n+            // Oracle date add\n+            return new DateTimeFunction(\n+                new BinaryOperation(OpType.MULTIPLY,\n+                    ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n+                    left),\n+                right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND)\n+                .optimize(session);\n+        }\n+        break;\n+      }\n+      case MINUS:\n+        switch (l) {\n+          case Value.DATE:\n+          case Value.TIMESTAMP:\n+          case Value.TIMESTAMP_TZ:\n+            switch (r) {\n+              case Value.INTEGER: {\n+                if (forcedType != null) {\n+                  throw getUnexpectedForcedTypeException();\n                 }\n-                break;\n-            case Value.TIME:\n-            case Value.TIME_TZ:\n-                if (DataType.isDateTimeType(r)) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+                // Oracle date subtract\n+                return new DateTimeFunction(new UnaryOperation(right), left,\n+                    DateTimeFunction.DATEADD,\n+                    DateTimeFunction.DAY).optimize(session);\n+              }\n+              case Value.NUMERIC:\n+              case Value.REAL:\n+              case Value.DOUBLE: {\n+                if (forcedType != null) {\n+                  throw getUnexpectedForcedTypeException();\n                 }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n+                // Oracle date subtract\n+                return new DateTimeFunction(\n+                    new BinaryOperation(OpType.MULTIPLY,\n+                        ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n+                        right),\n+                    left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND)\n+                    .optimize(session);\n+              }\n+              case Value.TIME:\n+              case Value.TIME_TZ:\n+              case Value.DATE:\n+              case Value.TIMESTAMP:\n+              case Value.TIMESTAMP_TZ:\n+                return new IntervalOperation(\n+                    IntervalOpType.DATETIME_MINUS_DATETIME, left, right,\n+                    forcedType);\n             }\n             break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n+          case Value.TIME:\n+          case Value.TIME_TZ:\n+            if (DataType.isDateTimeType(r)) {\n+              return new IntervalOperation(\n+                  IntervalOpType.DATETIME_MINUS_DATETIME, left, right,\n+                  forcedType);\n             }\n             break;\n-        default:\n         }\n-        throw getUnsupported(l, r);\n+        break;\n+      case MULTIPLY:\n+        if (l == Value.TIME) {\n+          type = TypeInfo.TYPE_TIME;\n+          convertRight = false;\n+          return this;\n+        } else if (r == Value.TIME) {\n+          swap();\n+          type = TypeInfo.TYPE_TIME;\n+          convertRight = false;\n+          return this;\n+        }\n+        break;\n+      case DIVIDE:\n+        if (l == Value.TIME) {\n+          type = TypeInfo.TYPE_TIME;\n+          convertRight = false;\n+          return this;\n+        }\n+        break;\n+      default:\n     }\n+    throw getUnsupported(l, r);\n+  }\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+  private DbException getUnsupported(int l, int r) {\n+    return DbException.getUnsupportedException(\n+        DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' +\n+            DataType.getDataType(r).name);\n+  }\n \n-    private DbException getUnexpectedForcedTypeException() {\n-        StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n-        int index = builder.length();\n-        return DbException.getSyntaxError(\n-                IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n-    }\n+  private DbException getUnexpectedForcedTypeException() {\n+    StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n+    int index = builder.length();\n+    return DbException.getSyntaxError(\n+        IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType)\n+            .toString(), index, \"\");\n+  }\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+  private void swap() {\n+    Expression temp = left;\n+    left = right;\n+    right = temp;\n+  }\n \n-    /**\n-     * Returns the type of this binary operation.\n-     *\n-     * @return the type of this binary operation\n-     */\n-    public OpType getOperationType() {\n-        return opType;\n-    }\n+  /**\n+   * Returns the type of this binary operation.\n+   *\n+   * @return the type of this binary operation\n+   */\n+  public OpType getOperationType() {\n+    return opType;\n+  }\n \n }\n",
            "diff_size": 458
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/628/BinaryOperation.java\nindex dd351ddc39..0a02eec2dc 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/628/BinaryOperation.java\n@@ -22,7 +22,8 @@ import org.h2.value.ValueNumeric;\n public class BinaryOperation extends Operation2 {\n \n     public enum OpType {\n-        /**\n+\n+    /**\n          * This operation represents an addition as in 1 + 2.\n          */\n         PLUS,\n@@ -309,9 +310,9 @@ public class BinaryOperation extends Operation2 {\n             case Value.DOUBLE:\n                 // Oracle date add\n                 return new DateTimeFunction(\n-                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n-                                left),\n-                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)),\n+//\n+                                left), right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n             }\n             break;\n         }\n@@ -338,8 +339,7 @@ public class BinaryOperation extends Operation2 {\n                     // Oracle date subtract\n                     return new DateTimeFunction(\n                             new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n-                                    right),\n-                            left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+                                    right), left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n                 }\n                 case Value.TIME:\n                 case Value.TIME_TZ:\n@@ -408,4 +408,4 @@ public class BinaryOperation extends Operation2 {\n         return opType;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "315",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/628/BinaryOperation.java\nindex dd351ddc39..e96c731231 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/628/BinaryOperation.java\n@@ -19,8 +19,11 @@ import org.h2.value.ValueNumeric;\n /**\n  * A mathematical expression, or string concatenation.\n  */\n+\n+\n public class BinaryOperation extends Operation2 {\n \n+\n     public enum OpType {\n         /**\n          * This operation represents an addition as in 1 + 2.\n@@ -29,20 +32,15 @@ public class BinaryOperation extends Operation2 {\n \n         /**\n          * This operation represents a subtraction as in 2 - 1.\n-         */\n-        MINUS,\n+         */ MINUS,\n \n         /**\n          * This operation represents a multiplication as in 2 * 3.\n-         */\n-        MULTIPLY,\n+         */ MULTIPLY,\n \n         /**\n          * This operation represents a division as in 4 * 2.\n-         */\n-        DIVIDE\n-    }\n-\n+         */ DIVIDE }\n     private OpType opType;\n     private TypeInfo forcedType;\n     private boolean convertRight = true;\n@@ -57,6 +55,8 @@ public class BinaryOperation extends Operation2 {\n      *\n      * @param forcedType the forced data type\n      */\n+\n+\n     public void setForcedType(TypeInfo forcedType) {\n         if (opType != OpType.MINUS) {\n             throw getUnexpectedForcedTypeException();\n@@ -127,7 +127,8 @@ public class BinaryOperation extends Operation2 {\n         right = right.optimize(session);\n         TypeInfo leftType = left.getType(), rightType = right.getType();\n         int l = leftType.getValueType(), r = rightType.getValueType();\n-        if ((l == Value.NULL && r == Value.NULL) || (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n+        if ((l == Value.NULL && r == Value.NULL) ||\n+                (l == Value.UNKNOWN && r == Value.UNKNOWN)) {\n             // (? + ?) - use decimal by default (the most safe data type) or\n             // string when text concatenation with + is enabled\n             if (opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n@@ -141,22 +142,21 @@ public class BinaryOperation extends Operation2 {\n             }\n             return optimizeInterval(session, l, r);\n         } else if (DataType.isDateTimeType(l) || DataType.isDateTimeType(r)) {\n-            return optimizeDateTime(session, l, r);\n-        } else if (forcedType != null) {\n-            throw getUnexpectedForcedTypeException();\n-        } else {\n-            int dataType = Value.getHigherOrder(l, r);\n-            if (dataType == Value.NUMERIC) {\n-                optimizeNumeric(leftType, rightType);\n-            } else if (dataType == Value.ENUM) {\n-                type = TypeInfo.TYPE_INTEGER;\n-            } else if (DataType.isCharacterStringType(dataType)\n-                    && opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n-                return new ConcatenationOperation(left, right).optimize(session);\n-            } else {\n-                type = TypeInfo.getTypeInfo(dataType);\n-            }\n-        }\n+                                                    return optimizeDateTime(session, l, r);\n+               } else if (forcedType != null) {\n+                   throw getUnexpectedForcedTypeException();\n+               } else {\n+                   int dataType = Value.getHigherOrder(l, r);\n+                   if (dataType == Value.NUMERIC) {\n+                       optimizeNumeric(leftType, rightType);\n+                   } else if (dataType == Value.ENUM) {\n+                       type = TypeInfo.TYPE_INTEGER;\n+                   } else if (DataType.isCharacterStringType(dataType) && opType == OpType.PLUS && session.getDatabase().getMode().allowPlusForStringConcat) {\n+                          return new ConcatenationOperation(left, right).optimize(session);\n+                          } else {\n+                              type = TypeInfo.getTypeInfo(dataType);\n+                          }\n+               }\n         if (left.isConstant() && right.isConstant()) {\n             return ValueExpression.get(getValue(session));\n         }\n@@ -215,20 +215,20 @@ public class BinaryOperation extends Operation2 {\n         } else if (DataType.isNumericType(l)) {\n             lNumeric = true;\n         } else if (DataType.isDateTimeType(l)) {\n-            lDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n+                   lDateTime = true;\n+               } else {\n+                   throw getUnsupported(l, r);\n+               }\n         boolean rInterval = false, rNumeric = false, rDateTime = false;\n         if (DataType.isIntervalType(r)) {\n             rInterval = true;\n         } else if (DataType.isNumericType(r)) {\n             rNumeric = true;\n         } else if (DataType.isDateTimeType(r)) {\n-            rDateTime = true;\n-        } else {\n-            throw getUnsupported(l, r);\n-        }\n+                   rDateTime = true;\n+               } else {\n+                   throw getUnsupported(l, r);\n+               }\n         switch (opType) {\n         case PLUS:\n             if (lInterval && rInterval) {\n@@ -241,11 +241,11 @@ public class BinaryOperation extends Operation2 {\n                 }\n                 return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, right, left);\n             } else if (lDateTime && rInterval) {\n-                if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n-                    break;\n-                }\n-                return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n-            }\n+                       if (l == Value.TIME && DataType.isYearMonthIntervalType(r)) {\n+                           break;\n+                       }\n+                       return new IntervalOperation(IntervalOpType.DATETIME_PLUS_INTERVAL, left, right);\n+                   }\n             break;\n         case MINUS:\n             if (lInterval && rInterval) {\n@@ -302,16 +302,18 @@ public class BinaryOperation extends Operation2 {\n             switch (l) {\n             case Value.INTEGER:\n                 // Oracle date add\n-                return new DateTimeFunction(left, right, DateTimeFunction.DATEADD, DateTimeFunction.DAY)\n-                        .optimize(session);\n+                return new DateTimeFunction(left,\n+                    right,\n+                        DateTimeFunction.DATEADD,\n+                            DateTimeFunction.DAY).optimize(session);\n             case Value.NUMERIC:\n             case Value.REAL:\n             case Value.DOUBLE:\n                 // Oracle date add\n                 return new DateTimeFunction(\n-                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n-                                left),\n-                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+                    new BinaryOperation(OpType.MULTIPLY,\n+                        ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n+                            left), right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n             }\n             break;\n         }\n@@ -326,8 +328,10 @@ public class BinaryOperation extends Operation2 {\n                         throw getUnexpectedForcedTypeException();\n                     }\n                     // Oracle date subtract\n-                    return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n-                            DateTimeFunction.DAY).optimize(session);\n+                    return new DateTimeFunction(new UnaryOperation(right),\n+                        left,\n+                            DateTimeFunction.DATEADD,\n+                                DateTimeFunction.DAY).optimize(session);\n                 }\n                 case Value.NUMERIC:\n                 case Value.REAL:\n@@ -337,22 +341,28 @@ public class BinaryOperation extends Operation2 {\n                     }\n                     // Oracle date subtract\n                     return new DateTimeFunction(\n-                            new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n-                                    right),\n-                            left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+                        new BinaryOperation(OpType.MULTIPLY,\n+                            ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n+                                right), left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n                 }\n                 case Value.TIME:\n                 case Value.TIME_TZ:\n                 case Value.DATE:\n                 case Value.TIMESTAMP:\n                 case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME,\n+                        left,\n+                            right,\n+                                forcedType);\n                 }\n                 break;\n             case Value.TIME:\n             case Value.TIME_TZ:\n                 if (DataType.isDateTimeType(r)) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME,\n+                        left,\n+                            right,\n+                                forcedType);\n                 }\n                 break;\n             }\n@@ -382,15 +392,13 @@ public class BinaryOperation extends Operation2 {\n     }\n \n     private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+        return DbException.getUnsupportedException(DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n     }\n \n     private DbException getUnexpectedForcedTypeException() {\n         StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n         int index = builder.length();\n-        return DbException.getSyntaxError(\n-                IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n+        return DbException.getSyntaxError(IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n     }\n \n     private void swap() {\n@@ -404,8 +412,10 @@ public class BinaryOperation extends Operation2 {\n      *\n      * @return the type of this binary operation\n      */\n+\n+\n     public OpType getOperationType() {\n         return opType;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 73
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "311",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/628/BinaryOperation.java\nindex dd351ddc39..202c34b17c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/628/BinaryOperation.java\n@@ -308,104 +308,103 @@ public class BinaryOperation extends Operation2 {\n             case Value.REAL:\n             case Value.DOUBLE:\n                 // Oracle date add\n-                return new DateTimeFunction(\n-                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n-                                left),\n-                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+                return new DateTimeFunction(newBinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n+                        left),\n+                right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+    }\n+    break;\n+}\n+case MINUS:\n+    switch (l) {\n+    case Value.DATE:\n+    case Value.TIMESTAMP:\n+    case Value.TIMESTAMP_TZ:\n+        switch (r) {\n+        case Value.INTEGER: {\n+            if (forcedType != null) {\n+                throw getUnexpectedForcedTypeException();\n             }\n-            break;\n+            // Oracle date subtract\n+            return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n+                    DateTimeFunction.DAY).optimize(session);\n         }\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INTEGER: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n-                            DateTimeFunction.DAY).optimize(session);\n-                }\n-                case Value.NUMERIC:\n-                case Value.REAL:\n-                case Value.DOUBLE: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(\n-                            new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n-                                    right),\n-                            left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-                }\n-                case Value.TIME:\n-                case Value.TIME_TZ:\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n-                }\n-                break;\n-            case Value.TIME:\n-            case Value.TIME_TZ:\n-                if (DataType.isDateTimeType(r)) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n+        case Value.NUMERIC:\n+        case Value.REAL:\n+        case Value.DOUBLE: {\n+            if (forcedType != null) {\n+                throw getUnexpectedForcedTypeException();\n             }\n-            break;\n-        default:\n+            // Oracle date subtract\n+            return new DateTimeFunction(\n+                    new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n+                            right),\n+                    left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n         }\n-        throw getUnsupported(l, r);\n+        case Value.TIME:\n+        case Value.TIME_TZ:\n+        case Value.DATE:\n+        case Value.TIMESTAMP:\n+        case Value.TIMESTAMP_TZ:\n+            return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+        }\n+        break;\n+    case Value.TIME:\n+    case Value.TIME_TZ:\n+        if (DataType.isDateTimeType(r)) {\n+            return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+        }\n+        break;\n     }\n-\n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+    break;\n+case MULTIPLY:\n+    if (l == Value.TIME) {\n+        type = TypeInfo.TYPE_TIME;\n+        convertRight = false;\n+        return this;\n+    } else if (r == Value.TIME) {\n+        swap();\n+        type = TypeInfo.TYPE_TIME;\n+        convertRight = false;\n+        return this;\n     }\n-\n-    private DbException getUnexpectedForcedTypeException() {\n-        StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n-        int index = builder.length();\n-        return DbException.getSyntaxError(\n-                IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n+    break;\n+case DIVIDE:\n+    if (l == Value.TIME) {\n+        type = TypeInfo.TYPE_TIME;\n+        convertRight = false;\n+        return this;\n     }\n+    break;\n+default:\n+}\n+throw getUnsupported(l, r);\n+}\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+private DbException getUnsupported(int l, int r) {\n+    return DbException.getUnsupportedException(\n+            DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+}\n \n-    /**\n+private DbException getUnexpectedForcedTypeException() {\n+    StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n+    int index = builder.length();\n+    return DbException.getSyntaxError(\n+            IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n+}\n+\n+private void swap() {\n+    Expression temp = left;\n+    left = right;\n+    right = temp;\n+}\n+\n+/**\n      * Returns the type of this binary operation.\n      *\n      * @return the type of this binary operation\n      */\n-    public OpType getOperationType() {\n-        return opType;\n-    }\n+public OpType getOperationType() {\n+    return opType;\n+}\n \n }\n",
            "diff_size": 140
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "312",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/628/BinaryOperation.java\nindex dd351ddc39..5ec97f9fe1 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/628/BinaryOperation.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/628/BinaryOperation.java\n@@ -308,104 +308,104 @@ public class BinaryOperation extends Operation2 {\n             case Value.REAL:\n             case Value.DOUBLE:\n                 // Oracle date add\n-                return new DateTimeFunction(\n-                        new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n-                                left),\n-                        right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-            }\n-            break;\n-        }\n-        case MINUS:\n-            switch (l) {\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-            case Value.TIMESTAMP_TZ:\n-                switch (r) {\n-                case Value.INTEGER: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n-                            DateTimeFunction.DAY).optimize(session);\n-                }\n-                case Value.NUMERIC:\n-                case Value.REAL:\n-                case Value.DOUBLE: {\n-                    if (forcedType != null) {\n-                        throw getUnexpectedForcedTypeException();\n-                    }\n-                    // Oracle date subtract\n-                    return new DateTimeFunction(\n-                            new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n-                                    right),\n-                            left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n-                }\n-                case Value.TIME:\n-                case Value.TIME_TZ:\n-                case Value.DATE:\n-                case Value.TIMESTAMP:\n-                case Value.TIMESTAMP_TZ:\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n-                }\n-                break;\n-            case Value.TIME:\n-            case Value.TIME_TZ:\n-                if (DataType.isDateTimeType(r)) {\n-                    return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n-                }\n-                break;\n-            }\n-            break;\n-        case MULTIPLY:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            } else if (r == Value.TIME) {\n-                swap();\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        case DIVIDE:\n-            if (l == Value.TIME) {\n-                type = TypeInfo.TYPE_TIME;\n-                convertRight = false;\n-                return this;\n-            }\n-            break;\n-        default:\n-        }\n-        throw getUnsupported(l, r);\n-    }\n+                return new DateTimeFunction(new\n+                        BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(60 * 60 * 24)), //\n+                         left),\n+                 right, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+     }\n+     break;\n+ }\n+ case MINUS:\n+     switch (l) {\n+     case Value.DATE:\n+     case Value.TIMESTAMP:\n+     case Value.TIMESTAMP_TZ:\n+         switch (r) {\n+         case Value.INTEGER: {\n+             if (forcedType != null) {\n+                 throw getUnexpectedForcedTypeException();\n+             }\n+             // Oracle date subtract\n+             return new DateTimeFunction(new UnaryOperation(right), left, DateTimeFunction.DATEADD,\n+                     DateTimeFunction.DAY).optimize(session);\n+         }\n+         case Value.NUMERIC:\n+         case Value.REAL:\n+         case Value.DOUBLE: {\n+             if (forcedType != null) {\n+                 throw getUnexpectedForcedTypeException();\n+             }\n+             // Oracle date subtract\n+             return new DateTimeFunction(\n+                     new BinaryOperation(OpType.MULTIPLY, ValueExpression.get(ValueInteger.get(-60 * 60 * 24)),\n+                             right),\n+                     left, DateTimeFunction.DATEADD, DateTimeFunction.SECOND).optimize(session);\n+         }\n+         case Value.TIME:\n+         case Value.TIME_TZ:\n+         case Value.DATE:\n+         case Value.TIMESTAMP:\n+         case Value.TIMESTAMP_TZ:\n+             return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+         }\n+         break;\n+     case Value.TIME:\n+     case Value.TIME_TZ:\n+         if (DataType.isDateTimeType(r)) {\n+             return new IntervalOperation(IntervalOpType.DATETIME_MINUS_DATETIME, left, right, forcedType);\n+         }\n+         break;\n+     }\n+     break;\n+ case MULTIPLY:\n+     if (l == Value.TIME) {\n+         type = TypeInfo.TYPE_TIME;\n+         convertRight = false;\n+         return this;\n+     } else if (r == Value.TIME) {\n+         swap();\n+         type = TypeInfo.TYPE_TIME;\n+         convertRight = false;\n+         return this;\n+     }\n+     break;\n+ case DIVIDE:\n+     if (l == Value.TIME) {\n+         type = TypeInfo.TYPE_TIME;\n+         convertRight = false;\n+         return this;\n+     }\n+     break;\n+ default:\n+ }\n+ throw getUnsupported(l, r);\n+}\n \n-    private DbException getUnsupported(int l, int r) {\n-        return DbException.getUnsupportedException(\n-                DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n-    }\n+private DbException getUnsupported(int l, int r) {\n+    return DbException.getUnsupportedException(\n+            DataType.getDataType(l).name + ' ' + getOperationToken() + ' ' + DataType.getDataType(r).name);\n+}\n \n-    private DbException getUnexpectedForcedTypeException() {\n-        StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n-        int index = builder.length();\n-        return DbException.getSyntaxError(\n-                IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n-    }\n+private DbException getUnexpectedForcedTypeException() {\n+    StringBuilder builder = getSQL(new StringBuilder(), TRACE_SQL_FLAGS);\n+    int index = builder.length();\n+    return DbException.getSyntaxError(\n+            IntervalOperation.getForcedTypeSQL(builder.append(' '), forcedType).toString(), index, \"\");\n+}\n \n-    private void swap() {\n-        Expression temp = left;\n-        left = right;\n-        right = temp;\n-    }\n+private void swap() {\n+    Expression temp = left;\n+    left = right;\n+    right = temp;\n+}\n \n-    /**\n+/**\n      * Returns the type of this binary operation.\n      *\n      * @return the type of this binary operation\n      */\n-    public OpType getOperationType() {\n-        return opType;\n-    }\n+public OpType getOperationType() {\n+    return opType;\n+}\n \n }\n",
            "diff_size": 91
        }
    ]
}