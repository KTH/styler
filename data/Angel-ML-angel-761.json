{
    "error_id": "761",
    "information": {
        "errors": [
            {
                "line": "11",
                "severity": "error",
                "message": "Line is longer than 100 characters (found 103).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": " * https://opensource.org/licenses/BSD-3-Clause\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language governing permissions and\n * limitations under the License.",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "206",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/761/ModelParse.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/761/ModelParse.java\nindex 56d79ac385..d2b730b201 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/761/ModelParse.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/intellij/761/ModelParse.java\n@@ -32,311 +32,327 @@ import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n public class ModelParse {\n-  private static final Log LOG = LogFactory.getLog(ModelParse.class);\n-  private ExecutorService convertTaskPool;\n-  private static FileSystem infs;\n-  private static FileStatus[] fileStatus = null;\n-  private int[] indics;\n-  private AtomicBoolean isConverting = new AtomicBoolean(false);\n-  private String inputStr;\n-  private String modelName;\n-  private String outputStr;\n-  private Path outputPath;\n-  private int convertThreadCount;\n-  private Boolean type;// true-dense;false-sparse;\n+    private static final Log LOG = LogFactory.getLog(ModelParse.class);\n+    private ExecutorService convertTaskPool;\n+    private static FileSystem infs;\n+    private static FileStatus[] fileStatus = null;\n+    private int[] indics;\n+    private AtomicBoolean isConverting = new AtomicBoolean(false);\n+    private String inputStr;\n+    private String modelName;\n+    private String outputStr;\n+    private Path outputPath;\n+    private int convertThreadCount;\n+    private Boolean type;// true-dense;false-sparse;\n \n \n-  public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n-    this.inputStr = inputStr;\n-    this.outputStr = outputStr;\n-    this.modelName = modelName;\n-    this.convertThreadCount = convertThreadCount;\n-  }\n+    public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n+        this.inputStr = inputStr;\n+        this.outputStr = outputStr;\n+        this.modelName = modelName;\n+        this.convertThreadCount = convertThreadCount;\n+    }\n \n-  public class ConvertTask implements Runnable {\n+    public class ConvertTask implements Runnable {\n \n-    private FileStatus status;\n-    private AtomicBoolean isSuccess = new AtomicBoolean(false);\n-    private AtomicBoolean finishFlag = new AtomicBoolean(false);\n-    private String errorLog;\n-    private FSDataOutputStream out;\n+        private FileStatus status;\n+        private AtomicBoolean isSuccess = new AtomicBoolean(false);\n+        private AtomicBoolean finishFlag = new AtomicBoolean(false);\n+        private String errorLog;\n+        private FSDataOutputStream out;\n \n-    public ConvertTask(FileStatus status, FSDataOutputStream out) {\n-      this.status = status;\n-      this.out = out;\n-    }\n+        public ConvertTask(FileStatus status, FSDataOutputStream out) {\n+            this.status = status;\n+            this.out = out;\n+        }\n \n-    @Override\n-    public void run() {\n-      long startTime = Time.monotonicNow();\n-      LOG.info(\"open file \" + status.getPath());\n-      try {\n-        FSDataInputStream fin;\n-        fin = infs.open(status.getPath());\n-        int matrixId = fin.readInt();\n-        out.writeBytes(\"matrixId:\" + matrixId + \"\\n\");\n-        int partSize = fin.readInt();\n-        out.writeBytes(\"partSize:\" + partSize + \"\\n\");\n+        @Override\n+        public void run() {\n+            long startTime = Time.monotonicNow();\n+            LOG.info(\"open file \" + status.getPath());\n+            try {\n+                FSDataInputStream fin;\n+                fin = infs.open(status.getPath());\n+                int matrixId = fin.readInt();\n+                out.writeBytes(\"matrixId:\" + matrixId + \"\\n\");\n+                int partSize = fin.readInt();\n+                out.writeBytes(\"partSize:\" + partSize + \"\\n\");\n \n-        // read partition header\n-        int startRow = fin.readInt();\n-        int startCol = fin.readInt();\n-        int endRow = fin.readInt();\n-        int endCol = fin.readInt();\n-        String rowType = fin.readUTF();\n-        String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \"\n-                + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n-        out.writeBytes(patInfo + \"\\n\");\n-        LOG.info(patInfo);\n+                // read partition header\n+                int startRow = fin.readInt();\n+                int startCol = fin.readInt();\n+                int endRow = fin.readInt();\n+                int endCol = fin.readInt();\n+                String rowType = fin.readUTF();\n+                String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \"\n+                        + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n+                out.writeBytes(patInfo + \"\\n\");\n+                LOG.info(patInfo);\n \n-        int rowNum = fin.readInt();\n-        LOG.info(\"rowNum=\" + rowNum);\n-        out.writeBytes(\"rowNum:\" + rowNum + \"\\n\");\n-        int rowIndex;\n-        int rowLen;\n-        int startPos;\n-        int clock;\n+                int rowNum = fin.readInt();\n+                LOG.info(\"rowNum=\" + rowNum);\n+                out.writeBytes(\"rowNum:\" + rowNum + \"\\n\");\n+                int rowIndex;\n+                int rowLen;\n+                int startPos;\n+                int clock;\n \n-        switch (rowType) {\n-          case \"T_DOUBLE_SPARSE\": {\n-            type = false;\n-            int key;\n-            double value;\n-            for (int j = 0; j < rowNum; j++) {\n-              rowIndex = fin.readInt();\n-              clock = fin.readInt();\n-              rowLen = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n-              for (int k = 0; k < rowLen; k++) {\n-                key = fin.readInt();\n-                value = fin.readDouble();\n-                out.writeBytes(key + \":\" + value + \" \");\n-              }\n-              out.writeBytes(\"\\n\");\n-            }\n-            break;\n-          }\n+                switch (rowType) {\n+                    case \"T_DOUBLE_SPARSE\": {\n+                        type = false;\n+                        int key;\n+                        double value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            rowIndex = fin.readInt();\n+                            clock = fin.readInt();\n+                            rowLen = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen +\n+                                            \"\\n\");\n+                            for (int k = 0; k < rowLen; k++) {\n+                                key = fin.readInt();\n+                                value = fin.readDouble();\n+                                out.writeBytes(key + \":\" + value + \" \");\n+                            }\n+                            out.writeBytes(\"\\n\");\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_DOUBLE_DENSE\": {\n-            byte[] data = new byte[8 * (endCol - startCol)];\n-            rowLen = endCol - startCol;\n-            double value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              DoubleBuffer dBuffer = ByteBuffer.wrap(data, 0, data.length).asDoubleBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = dBuffer.get();\n-                out.writeBytes(value + \" \");\n-                // if (k < 10) {\n-                // LOG.info(\"resultArray: \" + vectorArray[startPos + k]);\n-                // }\n-              }\n-              out.writeBytes(\"\\n\");\n-            }\n-            break;\n-          }\n+                    case \"T_DOUBLE_DENSE\": {\n+                        byte[] data = new byte[8 * (endCol - startCol)];\n+                        rowLen = endCol - startCol;\n+                        double value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                            \"\\n\");\n+                            fin.read(data, 0, data.length);\n+                            DoubleBuffer dBuffer =\n+                                    ByteBuffer.wrap(data, 0, data.length).asDoubleBuffer();\n+                            for (int k = 0; k < rowLen; k++) {\n+                                value = dBuffer.get();\n+                                out.writeBytes(value + \" \");\n+                                // if (k < 10) {\n+                                // LOG.info(\"resultArray: \" + vectorArray[startPos + k]);\n+                                // }\n+                            }\n+                            out.writeBytes(\"\\n\");\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_FLOAT_DENSE\": {\n-            byte[] data = new byte[4 * (endCol - startCol)];\n-            rowLen = endCol - startCol;\n-            float value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              FloatBuffer fBuffer = ByteBuffer.wrap(data, 0, data.length).asFloatBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = fBuffer.get();\n-                out.writeBytes(value + \" \");\n-              }\n-              out.writeBytes(\"\\n\");\n-            }\n-            break;\n-          }\n+                    case \"T_FLOAT_DENSE\": {\n+                        byte[] data = new byte[4 * (endCol - startCol)];\n+                        rowLen = endCol - startCol;\n+                        float value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                            \"\\n\");\n+                            fin.read(data, 0, data.length);\n+                            FloatBuffer fBuffer =\n+                                    ByteBuffer.wrap(data, 0, data.length).asFloatBuffer();\n+                            for (int k = 0; k < rowLen; k++) {\n+                                value = fBuffer.get();\n+                                out.writeBytes(value + \" \");\n+                            }\n+                            out.writeBytes(\"\\n\");\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_INT_SPARSE\": {\n-            int key;\n-            int value;\n-            for (int j = 0; j < rowNum; j++) {\n-              rowIndex = fin.readInt();\n-              clock = fin.readInt();\n-              rowLen = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n-              for (int k = 0; k < rowLen; k++) {\n-                key = fin.readInt();\n-                value = fin.readInt();\n-                out.writeBytes(key + \":\" + value + \" \");\n-              }\n-            }\n-            break;\n-          }\n+                    case \"T_INT_SPARSE\": {\n+                        int key;\n+                        int value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            rowIndex = fin.readInt();\n+                            clock = fin.readInt();\n+                            rowLen = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen +\n+                                            \"\\n\");\n+                            for (int k = 0; k < rowLen; k++) {\n+                                key = fin.readInt();\n+                                value = fin.readInt();\n+                                out.writeBytes(key + \":\" + value + \" \");\n+                            }\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_INT_DENSE\": {\n-            byte[] data = new byte[4 * (endCol - startCol)];\n-            rowLen = endCol - startCol;\n-            int value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length)\n-                      .order(ByteOrder.nativeOrder()).asIntBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = iBuffer.get();\n-                out.writeBytes(value + \" \");\n-              }\n-              // for (int k = 0; k < rowLen; k++) {\n-              // LOG.info(\"Array[\" + String.valueOf(k) + \": \" + String.valueOf(vectorArray));\n-              // }\n-            }\n-            break;\n-          }\n+                    case \"T_INT_DENSE\": {\n+                        byte[] data = new byte[4 * (endCol - startCol)];\n+                        rowLen = endCol - startCol;\n+                        int value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            out.writeBytes(\n+                                    \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                            \"\\n\");\n+                            fin.read(data, 0, data.length);\n+                            IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length)\n+                                    .order(ByteOrder.nativeOrder()).asIntBuffer();\n+                            for (int k = 0; k < rowLen; k++) {\n+                                value = iBuffer.get();\n+                                out.writeBytes(value + \" \");\n+                            }\n+                            // for (int k = 0; k < rowLen; k++) {\n+                            // LOG.info(\"Array[\" + String.valueOf(k) + \": \" + String.valueOf(vectorArray));\n+                            // }\n+                        }\n+                        break;\n+                    }\n \n-          case \"T_INT_ARBITRARY\": {\n-            byte[] data = new byte[4 * (endCol - startCol)];\n-            String denseOrSparse;\n-            int nnz;\n-            int key;\n-            int value;\n-            for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              denseOrSparse = fin.readUTF();\n-              if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n-                rowLen = endCol - startCol;\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \" type:\"\n-                        + denseOrSparse + \"\\n\");\n-                fin.read(data, 0, data.length);\n-                IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length).asIntBuffer();\n-                for (int k = 0; k < rowLen; k++) {\n-                  value = iBuffer.get();\n-                  out.writeBytes(value + \" \");\n-                }\n-              } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n-                nnz = fin.readInt();\n-                rowLen = fin.readInt();\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen\n-                        + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n-                for (int k = 0; k < rowLen; k++) {\n-                  key = fin.readInt();\n-                  value = fin.readInt();\n-                  out.writeBytes(key + \":\" + value + \" \");\n+                    case \"T_INT_ARBITRARY\": {\n+                        byte[] data = new byte[4 * (endCol - startCol)];\n+                        String denseOrSparse;\n+                        int nnz;\n+                        int key;\n+                        int value;\n+                        for (int j = 0; j < rowNum; j++) {\n+                            clock = fin.readInt();\n+                            rowIndex = fin.readInt();\n+                            denseOrSparse = fin.readUTF();\n+                            if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n+                                rowLen = endCol - startCol;\n+                                out.writeBytes(\n+                                        \"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen +\n+                                                \" type:\"\n+                                                + denseOrSparse + \"\\n\");\n+                                fin.read(data, 0, data.length);\n+                                IntBuffer iBuffer =\n+                                        ByteBuffer.wrap(data, 0, data.length).asIntBuffer();\n+                                for (int k = 0; k < rowLen; k++) {\n+                                    value = iBuffer.get();\n+                                    out.writeBytes(value + \" \");\n+                                }\n+                            } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n+                                nnz = fin.readInt();\n+                                rowLen = fin.readInt();\n+                                out.writeBytes(\n+                                        \"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen\n+                                                + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n+                                for (int k = 0; k < rowLen; k++) {\n+                                    key = fin.readInt();\n+                                    value = fin.readInt();\n+                                    out.writeBytes(key + \":\" + value + \" \");\n+                                }\n+                            } else {\n+                                LOG.error(denseOrSparse + \" type error,need T_INT_ARBITRARY\");\n+                            }\n+                        }\n+                        break;\n+                    }\n                 }\n-              } else {\n-                LOG.error(denseOrSparse+\" type error,need T_INT_ARBITRARY\");\n-              }\n+\n+                fin.close();\n+                out.close();\n+                isSuccess.set(true);\n+                finishFlag.set(true);\n+            } catch (IOException e) {\n+                errorLog = \"convert partFile \" + status.toString() + \" error\";\n+                LOG.error(errorLog, e);\n+                isSuccess.set(false);\n+            } finally {\n+                LOG.info(\"convert partFile \" + status.toString() + \" cost time: \"\n+                        + (Time.monotonicNow() - startTime) + \"ms!\");\n+                finishFlag.set(true);\n             }\n-            break;\n-          }\n         }\n \n-        fin.close();\n-        out.close();\n-        isSuccess.set(true);\n-        finishFlag.set(true);\n-      } catch (IOException e) {\n-        errorLog = \"convert partFile \" + status.toString() + \" error\";\n-        LOG.error(errorLog, e);\n-        isSuccess.set(false);\n-      } finally {\n-        LOG.info(\"convert partFile \" + status.toString() + \" cost time: \"\n-                + (Time.monotonicNow() - startTime) + \"ms!\");\n-        finishFlag.set(true);\n-      }\n-    }\n+        /**\n+         * Is success.\n+         *\n+         * @return true if success, else false\n+         */\n+        public boolean isSuccess() {\n+            return isSuccess.get();\n+        }\n \n-    /**\n-     * Is success.\n-     *\n-     * @return true if success, else false\n-     */\n-    public boolean isSuccess() {\n-      return isSuccess.get();\n+        /**\n+         * Gets error log\n+         *\n+         * @return the error log if exists\n+         */\n+        public String getErrorLog() {\n+            return errorLog;\n+        }\n     }\n \n-    /**\n-     * Gets error log\n-     *\n-     * @return the error log if exists\n-     */\n-    public String getErrorLog() {\n-      return errorLog;\n-    }\n-  }\n+    public void convertInit() throws IOException {\n+        fileStatus = null;\n+        LOG.info(\"read model from \" + inputStr);\n+        if (inputStr == null) {\n+            throw new IOException(\"inputStr is null\");\n+        }\n+        Path inputPath = new Path(inputStr);\n+        Configuration conf = new Configuration();\n+        infs = inputPath.getFileSystem(conf);\n+        fileStatus = infs.listStatus(inputPath);\n \n-  public void convertInit() throws IOException {\n-    fileStatus = null;\n-    LOG.info(\"read model from \" + inputStr);\n-    if (inputStr == null) {\n-      throw new IOException(\"inputStr is null\");\n-    }\n-    Path inputPath = new Path(inputStr);\n-    Configuration conf = new Configuration();\n-    infs = inputPath.getFileSystem(conf);\n-    fileStatus = infs.listStatus(inputPath);\n+        if (outputStr == null) {\n+            throw new IOException(\"outputStr is null\");\n+        }\n \n-    if (outputStr == null) {\n-      throw new IOException(\"outputStr is null\");\n+        outputPath = new Path(new Path(outputStr, \"model\"), modelName);\n+        LOG.info(\"outputPath:\" + outputPath.toString());\n+        infs.mkdirs(outputPath);\n     }\n \n-    outputPath = new Path(new Path(outputStr, \"model\"), modelName);\n-    LOG.info(\"outputPath:\" + outputPath.toString());\n-    infs.mkdirs(outputPath);\n-  }\n-\n-  public void convertModel() throws IOException, InterruptedException {\n-    if (isConverting.get() == true) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"model is converting......\");\n-      }\n-      return;\n-    }\n-    LOG.info(\"to start convert tasks!\");\n-    isConverting.set(true);\n-    long startTime = Time.monotonicNow();\n+    public void convertModel() throws IOException, InterruptedException {\n+        if (isConverting.get() == true) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"model is converting......\");\n+            }\n+            return;\n+        }\n+        LOG.info(\"to start convert tasks!\");\n+        isConverting.set(true);\n+        long startTime = Time.monotonicNow();\n \n-    convertInit();\n-    ThreadFactory convertThreadFacotry =\n-            new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n-    convertTaskPool = Executors.newFixedThreadPool(convertThreadCount, convertThreadFacotry);\n-    List<ConvertTask> allConvertTasks = new ArrayList<>();\n-    Configuration conf;\n-    FileSystem outfs;\n-    for (int i = 0; i < fileStatus.length; i++) {\n-      FileStatus status = fileStatus[i];\n-      conf = new Configuration();\n-      outfs = outputPath.getFileSystem(conf);\n-      FSDataOutputStream out = outfs.create(new Path(outputPath, modelName + i));\n-      ConvertTask ConvertTask = new ConvertTask(status, out);\n-      allConvertTasks.add(ConvertTask);\n-      convertTaskPool.execute(ConvertTask);\n-    }\n-    boolean convertSuccess = true;\n-    String errorLog = null;\n-    for (ConvertTask task : allConvertTasks) {\n-      while (task.finishFlag.get() != true) {\n-        try {\n-          Thread.sleep(1000);\n-        } catch (InterruptedException e) {\n-          e.printStackTrace();\n+        convertInit();\n+        ThreadFactory convertThreadFacotry =\n+                new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n+        convertTaskPool = Executors.newFixedThreadPool(convertThreadCount, convertThreadFacotry);\n+        List<ConvertTask> allConvertTasks = new ArrayList<>();\n+        Configuration conf;\n+        FileSystem outfs;\n+        for (int i = 0; i < fileStatus.length; i++) {\n+            FileStatus status = fileStatus[i];\n+            conf = new Configuration();\n+            outfs = outputPath.getFileSystem(conf);\n+            FSDataOutputStream out = outfs.create(new Path(outputPath, modelName + i));\n+            ConvertTask ConvertTask = new ConvertTask(status, out);\n+            allConvertTasks.add(ConvertTask);\n+            convertTaskPool.execute(ConvertTask);\n+        }\n+        boolean convertSuccess = true;\n+        String errorLog = null;\n+        for (ConvertTask task : allConvertTasks) {\n+            while (task.finishFlag.get() != true) {\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+                continue;\n+            }\n+            if (task.isSuccess() == false) {\n+                convertSuccess = false;\n+                errorLog = task.getErrorLog();\n+            }\n+        }\n+        LOG.info(\"model convert cost time: \" + (Time.monotonicNow() - startTime) + \"ms\");\n+        convertTaskPool.shutdownNow();\n+        if (!convertSuccess) {\n+            LOG.error(\"convert failed for \" + errorLog);\n         }\n-        continue;\n-      }\n-      if (task.isSuccess() == false) {\n-        convertSuccess = false;\n-        errorLog = task.getErrorLog();\n-      }\n-    }\n-    LOG.info(\"model convert cost time: \" + (Time.monotonicNow() - startTime) + \"ms\");\n-    convertTaskPool.shutdownNow();\n-    if (!convertSuccess) {\n-      LOG.error(\"convert failed for \" + errorLog);\n     }\n-  }\n \n }\n",
            "diff_size": 326
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "88",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "110",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "128",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "130",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "136",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 16, expected is 49, indentation should be the same level as line 133.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "150",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "152",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 114).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "169",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "187",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 118).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "189",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "196",
                    "severity": "error",
                    "message": "Comment has incorrect indentation level 14, expected is 36, indentation should be the same level as line 190.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.indentation.CommentsIndentationCheck"
                },
                {
                    "line": "213",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "217",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 107).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "218",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "223",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 175).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "225",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 113).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "226",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 115).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "227",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "230",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 104).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "245",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "301",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 105).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/761/ModelParse.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/761/ModelParse.java\nindex 56d79ac385..4cfc52a87c 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/errored/1/761/ModelParse.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/Angel-ML-angel/codebuff/761/ModelParse.java\n@@ -32,29 +32,27 @@ import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n public class ModelParse {\n-  private static final Log LOG = LogFactory.getLog(ModelParse.class);\n-  private ExecutorService convertTaskPool;\n-  private static FileSystem infs;\n-  private static FileStatus[] fileStatus = null;\n-  private int[] indics;\n-  private AtomicBoolean isConverting = new AtomicBoolean(false);\n-  private String inputStr;\n-  private String modelName;\n-  private String outputStr;\n-  private Path outputPath;\n-  private int convertThreadCount;\n-  private Boolean type;// true-dense;false-sparse;\n+    private static final Log LOG = LogFactory.getLog(ModelParse.class);\n+    private ExecutorService convertTaskPool;\n+    private static FileSystem infs;\n+    private static FileStatus[] fileStatus = null;\n+    private int[] indics;\n+    private AtomicBoolean isConverting = new AtomicBoolean(false);\n+    private String inputStr;\n+    private String modelName;\n+    private String outputStr;\n+    private Path outputPath;\n+    private int convertThreadCount;\n+    private Boolean type;// true-dense;false-sparse;\n \n-\n-  public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n+    public ModelParse(String inputStr, String outputStr, String modelName, int convertThreadCount) {\n     this.inputStr = inputStr;\n     this.outputStr = outputStr;\n     this.modelName = modelName;\n     this.convertThreadCount = convertThreadCount;\n-  }\n-\n-  public class ConvertTask implements Runnable {\n+    }\n \n+    public class ConvertTask implements Runnable {\n     private FileStatus status;\n     private AtomicBoolean isSuccess = new AtomicBoolean(false);\n     private AtomicBoolean finishFlag = new AtomicBoolean(false);\n@@ -62,192 +60,191 @@ public class ModelParse {\n     private FSDataOutputStream out;\n \n     public ConvertTask(FileStatus status, FSDataOutputStream out) {\n-      this.status = status;\n-      this.out = out;\n+        this.status = status;\n+        this.out = out;\n     }\n \n     @Override\n     public void run() {\n-      long startTime = Time.monotonicNow();\n-      LOG.info(\"open file \" + status.getPath());\n-      try {\n+        long startTime = Time.monotonicNow();\n+        LOG.info(\"open file \" + status.getPath());\n+        try {\n         FSDataInputStream fin;\n         fin = infs.open(status.getPath());\n+\n         int matrixId = fin.readInt();\n         out.writeBytes(\"matrixId:\" + matrixId + \"\\n\");\n+\n         int partSize = fin.readInt();\n         out.writeBytes(\"partSize:\" + partSize + \"\\n\");\n \n         // read partition header\n+\n         int startRow = fin.readInt();\n         int startCol = fin.readInt();\n         int endRow = fin.readInt();\n         int endCol = fin.readInt();\n         String rowType = fin.readUTF();\n-        String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \"\n-                + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n+        String patInfo = \"rowType \" + rowType + \", partition range is [\" + startRow + \", \" + startCol + \"] to [\" + endRow + \", \" + endCol + \"]\";\n         out.writeBytes(patInfo + \"\\n\");\n         LOG.info(patInfo);\n \n         int rowNum = fin.readInt();\n         LOG.info(\"rowNum=\" + rowNum);\n         out.writeBytes(\"rowNum:\" + rowNum + \"\\n\");\n+\n         int rowIndex;\n         int rowLen;\n         int startPos;\n         int clock;\n-\n         switch (rowType) {\n-          case \"T_DOUBLE_SPARSE\": {\n+            case \"T_DOUBLE_SPARSE\": {\n             type = false;\n+\n             int key;\n             double value;\n             for (int j = 0; j < rowNum; j++) {\n-              rowIndex = fin.readInt();\n-              clock = fin.readInt();\n-              rowLen = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n-              for (int k = 0; k < rowLen; k++) {\n-                key = fin.readInt();\n-                value = fin.readDouble();\n-                out.writeBytes(key + \":\" + value + \" \");\n-              }\n-              out.writeBytes(\"\\n\");\n+                                        rowIndex = fin.readInt();\n+                                        clock = fin.readInt();\n+                                        rowLen = fin.readInt();\n+                                        out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n+                                        for (int k = 0; k < rowLen; k++) {\n+                                                 key = fin.readInt();\n+                                                 value = fin.readDouble();\n+                                                 out.writeBytes(key + \":\" + value + \" \");\n+                                        }\n+                                        out.writeBytes(\"\\n\");\n             }\n             break;\n-          }\n+            }\n \n-          case \"T_DOUBLE_DENSE\": {\n+            case \"T_DOUBLE_DENSE\": {\n             byte[] data = new byte[8 * (endCol - startCol)];\n             rowLen = endCol - startCol;\n             double value;\n             for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              DoubleBuffer dBuffer = ByteBuffer.wrap(data, 0, data.length).asDoubleBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = dBuffer.get();\n-                out.writeBytes(value + \" \");\n+                                       clock = fin.readInt();\n+                                       rowIndex = fin.readInt();\n+                                       out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n+                                       fin.read(data, 0, data.length);\n+                                       DoubleBuffer dBuffer = ByteBuffer.wrap(data, 0, data.length).asDoubleBuffer();\n+                                       for (int k = 0; k < rowLen; k++) {\n+                                                 value = dBuffer.get();\n+                                                 out.writeBytes(value + \" \");\n                 // if (k < 10) {\n                 // LOG.info(\"resultArray: \" + vectorArray[startPos + k]);\n                 // }\n-              }\n-              out.writeBytes(\"\\n\");\n+                                       }\n+                                       out.writeBytes(\"\\n\");\n             }\n             break;\n-          }\n+            }\n \n-          case \"T_FLOAT_DENSE\": {\n+            case \"T_FLOAT_DENSE\": {\n             byte[] data = new byte[4 * (endCol - startCol)];\n             rowLen = endCol - startCol;\n             float value;\n             for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              FloatBuffer fBuffer = ByteBuffer.wrap(data, 0, data.length).asFloatBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = fBuffer.get();\n-                out.writeBytes(value + \" \");\n-              }\n-              out.writeBytes(\"\\n\");\n+                                      clock = fin.readInt();\n+                                      rowIndex = fin.readInt();\n+                                      out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n+                                      fin.read(data, 0, data.length);\n+                                      FloatBuffer fBuffer = ByteBuffer.wrap(data, 0, data.length).asFloatBuffer();\n+                                      for (int k = 0; k < rowLen; k++) {\n+                                                 value = fBuffer.get();\n+                                                 out.writeBytes(value + \" \");\n+                                      }\n+                                      out.writeBytes(\"\\n\");\n             }\n             break;\n-          }\n+            }\n \n-          case \"T_INT_SPARSE\": {\n+            case \"T_INT_SPARSE\": {\n             int key;\n             int value;\n             for (int j = 0; j < rowNum; j++) {\n-              rowIndex = fin.readInt();\n-              clock = fin.readInt();\n-              rowLen = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n-              for (int k = 0; k < rowLen; k++) {\n-                key = fin.readInt();\n-                value = fin.readInt();\n-                out.writeBytes(key + \":\" + value + \" \");\n-              }\n+                                     rowIndex = fin.readInt();\n+                                     clock = fin.readInt();\n+                                     rowLen = fin.readInt();\n+                                     out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \"\\n\");\n+                                     for (int k = 0; k < rowLen; k++) {\n+                                                 key = fin.readInt();\n+                                                 value = fin.readInt();\n+                                                 out.writeBytes(key + \":\" + value + \" \");\n+                                     }\n             }\n             break;\n-          }\n+            }\n \n-          case \"T_INT_DENSE\": {\n+            case \"T_INT_DENSE\": {\n             byte[] data = new byte[4 * (endCol - startCol)];\n             rowLen = endCol - startCol;\n+\n             int value;\n             for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n-              fin.read(data, 0, data.length);\n-              IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length)\n-                      .order(ByteOrder.nativeOrder()).asIntBuffer();\n-              for (int k = 0; k < rowLen; k++) {\n-                value = iBuffer.get();\n-                out.writeBytes(value + \" \");\n-              }\n+                                    clock = fin.readInt();\n+                                    rowIndex = fin.readInt();\n+                                    out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \"\\n\");\n+                                    fin.read(data, 0, data.length);\n+                                    IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length).order(ByteOrder.nativeOrder()).asIntBuffer();\n+                                    for (int k = 0; k < rowLen; k++) {\n+                                                 value = iBuffer.get();\n+                                                 out.writeBytes(value + \" \");\n+                                    }\n               // for (int k = 0; k < rowLen; k++) {\n               // LOG.info(\"Array[\" + String.valueOf(k) + \": \" + String.valueOf(vectorArray));\n               // }\n             }\n             break;\n-          }\n+            }\n \n-          case \"T_INT_ARBITRARY\": {\n+            case \"T_INT_ARBITRARY\": {\n             byte[] data = new byte[4 * (endCol - startCol)];\n             String denseOrSparse;\n             int nnz;\n             int key;\n             int value;\n             for (int j = 0; j < rowNum; j++) {\n-              clock = fin.readInt();\n-              rowIndex = fin.readInt();\n-              denseOrSparse = fin.readUTF();\n-              if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n+                                        clock = fin.readInt();\n+                                        rowIndex = fin.readInt();\n+                                        denseOrSparse = fin.readUTF();\n+                                        if (denseOrSparse.equals(\"T_INT_DENSE\")) {\n                 rowLen = endCol - startCol;\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \" type:\"\n-                        + denseOrSparse + \"\\n\");\n+                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" len:\" + rowLen + \" type:\" + denseOrSparse + \"\\n\");\n                 fin.read(data, 0, data.length);\n                 IntBuffer iBuffer = ByteBuffer.wrap(data, 0, data.length).asIntBuffer();\n                 for (int k = 0; k < rowLen; k++) {\n-                  value = iBuffer.get();\n-                  out.writeBytes(value + \" \");\n-                }\n-              } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n-                nnz = fin.readInt();\n-                rowLen = fin.readInt();\n-                out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen\n-                        + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n-                for (int k = 0; k < rowLen; k++) {\n-                  key = fin.readInt();\n-                  value = fin.readInt();\n-                  out.writeBytes(key + \":\" + value + \" \");\n+                                                                                     value = iBuffer.get();\n+                                                                                     out.writeBytes(value + \" \");\n                 }\n-              } else {\n-                LOG.error(denseOrSparse+\" type error,need T_INT_ARBITRARY\");\n-              }\n+                                        } else if (denseOrSparse.equals(\"T_INT_SPARSE\")) {\n+                                                 nnz = fin.readInt();\n+                                                 rowLen = fin.readInt();\n+                                                 out.writeBytes(\"rowId:\" + rowIndex + \" clock:\" + clock + \" size:\" + rowLen + \" type:\" + denseOrSparse + \" nnz:\" + nnz + \"\\n\");\n+                                                 for (int k = 0; k < rowLen; k++) {\n+                                                                                             key = fin.readInt();\n+                                                                                             value = fin.readInt();\n+                                                                                             out.writeBytes(key + \":\" + value + \" \");\n+                                                 }\n+                                        } else {\n+                                          LOG.error(denseOrSparse + \" type error,need T_INT_ARBITRARY\");\n+                                        }\n             }\n             break;\n-          }\n+            }\n         }\n-\n         fin.close();\n         out.close();\n         isSuccess.set(true);\n         finishFlag.set(true);\n-      } catch (IOException e) {\n-        errorLog = \"convert partFile \" + status.toString() + \" error\";\n-        LOG.error(errorLog, e);\n-        isSuccess.set(false);\n-      } finally {\n-        LOG.info(\"convert partFile \" + status.toString() + \" cost time: \"\n-                + (Time.monotonicNow() - startTime) + \"ms!\");\n-        finishFlag.set(true);\n-      }\n+        } catch (IOException e) {\n+          errorLog = \"convert partFile \" + status.toString() + \" error\";\n+          LOG.error(errorLog, e);\n+          isSuccess.set(false);\n+        } finally {\n+          LOG.info(\"convert partFile \" + status.toString() + \" cost time: \" + (Time.monotonicNow() - startTime) + \"ms!\");\n+          finishFlag.set(true);\n+        }\n     }\n \n     /**\n@@ -255,8 +252,9 @@ public class ModelParse {\n      *\n      * @return true if success, else false\n      */\n+\n     public boolean isSuccess() {\n-      return isSuccess.get();\n+        return isSuccess.get();\n     }\n \n     /**\n@@ -264,79 +262,79 @@ public class ModelParse {\n      *\n      * @return the error log if exists\n      */\n+\n     public String getErrorLog() {\n-      return errorLog;\n+        return errorLog;\n+    }\n     }\n-  }\n \n-  public void convertInit() throws IOException {\n+    public void convertInit() throws IOException {\n     fileStatus = null;\n     LOG.info(\"read model from \" + inputStr);\n     if (inputStr == null) {\n-      throw new IOException(\"inputStr is null\");\n+        throw new IOException(\"inputStr is null\");\n     }\n+\n     Path inputPath = new Path(inputStr);\n     Configuration conf = new Configuration();\n     infs = inputPath.getFileSystem(conf);\n     fileStatus = infs.listStatus(inputPath);\n-\n     if (outputStr == null) {\n-      throw new IOException(\"outputStr is null\");\n+        throw new IOException(\"outputStr is null\");\n     }\n-\n     outputPath = new Path(new Path(outputStr, \"model\"), modelName);\n     LOG.info(\"outputPath:\" + outputPath.toString());\n     infs.mkdirs(outputPath);\n-  }\n+    }\n \n-  public void convertModel() throws IOException, InterruptedException {\n+    public void convertModel() throws IOException, InterruptedException {\n     if (isConverting.get() == true) {\n-      if (LOG.isDebugEnabled()) {\n+        if (LOG.isDebugEnabled()) {\n         LOG.debug(\"model is converting......\");\n-      }\n-      return;\n+        }\n+        return;\n     }\n     LOG.info(\"to start convert tasks!\");\n     isConverting.set(true);\n     long startTime = Time.monotonicNow();\n-\n     convertInit();\n-    ThreadFactory convertThreadFacotry =\n-            new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n+    ThreadFactory convertThreadFacotry = new ThreadFactoryBuilder().setNameFormat(\"ConvertTask\").build();\n     convertTaskPool = Executors.newFixedThreadPool(convertThreadCount, convertThreadFacotry);\n     List<ConvertTask> allConvertTasks = new ArrayList<>();\n     Configuration conf;\n     FileSystem outfs;\n     for (int i = 0; i < fileStatus.length; i++) {\n-      FileStatus status = fileStatus[i];\n-      conf = new Configuration();\n-      outfs = outputPath.getFileSystem(conf);\n-      FSDataOutputStream out = outfs.create(new Path(outputPath, modelName + i));\n-      ConvertTask ConvertTask = new ConvertTask(status, out);\n-      allConvertTasks.add(ConvertTask);\n-      convertTaskPool.execute(ConvertTask);\n+        FileStatus status = fileStatus[i];\n+        conf = new Configuration();\n+        outfs = outputPath.getFileSystem(conf);\n+        FSDataOutputStream out = outfs.create(new Path(outputPath, modelName + i));\n+        ConvertTask ConvertTask = new ConvertTask(status, out);\n+        allConvertTasks.add(ConvertTask);\n+        convertTaskPool.execute(ConvertTask);\n     }\n+\n     boolean convertSuccess = true;\n     String errorLog = null;\n     for (ConvertTask task : allConvertTasks) {\n-      while (task.finishFlag.get() != true) {\n-        try {\n-          Thread.sleep(1000);\n-        } catch (InterruptedException e) {\n-          e.printStackTrace();\n+        while (task.finishFlag.get() != true) {\n+                                                 try {\n+                                                  Thread.sleep(1000);\n+                                                 } catch (InterruptedException e) {\n+                                                   e.printStackTrace();\n+                                                 }\n+                                                 continue;\n         }\n-        continue;\n-      }\n-      if (task.isSuccess() == false) {\n+\n+        if (task.isSuccess() == false) {\n         convertSuccess = false;\n         errorLog = task.getErrorLog();\n-      }\n+        }\n     }\n     LOG.info(\"model convert cost time: \" + (Time.monotonicNow() - startTime) + \"ms\");\n     convertTaskPool.shutdownNow();\n     if (!convertSuccess) {\n-      LOG.error(\"convert failed for \" + errorLog);\n+        LOG.error(\"convert failed for \" + errorLog);\n+    }\n     }\n-  }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 176
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "11",
                    "severity": "error",
                    "message": "Line is longer than 100 characters (found 103).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ]
}