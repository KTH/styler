{
    "error_id": "240",
    "information": {
        "errors": [
            {
                "line": "282",
                "column": "76",
                "severity": "warning",
                "message": "',' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "        addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n        addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n        addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n        addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n        addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/240/Function.java\nindex ff01f50943..f9fc85c9ba 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler/240/Function.java\n@@ -279,7 +279,7 @@ public class Function extends Expression implements FunctionCall {\n         addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n         addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n         addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n-        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n+        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true, true);\n         addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n         addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n         addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/240/Function.java\nindex ff01f50943..2396d9e727 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/intellij/240/Function.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.expression;\n \n import java.io.FileOutputStream;\n@@ -75,2746 +76,2761 @@ import org.h2.value.ValueUuid;\n  * This class implements most built-in functions of this database.\n  */\n public class Function extends Expression implements FunctionCall {\n-    public static final int ABS = 0, ACOS = 1, ASIN = 2, ATAN = 3, ATAN2 = 4,\n-            BITAND = 5, BITOR = 6, BITXOR = 7, CEILING = 8, COS = 9, COT = 10,\n-            DEGREES = 11, EXP = 12, FLOOR = 13, LOG = 14, LOG10 = 15, MOD = 16,\n-            PI = 17, POWER = 18, RADIANS = 19, RAND = 20, ROUND = 21,\n-            ROUNDMAGIC = 22, SIGN = 23, SIN = 24, SQRT = 25, TAN = 26,\n-            TRUNCATE = 27, SECURE_RAND = 28, HASH = 29, ENCRYPT = 30,\n-            DECRYPT = 31, COMPRESS = 32, EXPAND = 33, ZERO = 34,\n-            RANDOM_UUID = 35, COSH = 36, SINH = 37, TANH = 38, LN = 39,\n-            BITGET = 40;\n-\n-    public static final int ASCII = 50, BIT_LENGTH = 51, CHAR = 52,\n-            CHAR_LENGTH = 53, CONCAT = 54, DIFFERENCE = 55, HEXTORAW = 56,\n-            INSERT = 57, INSTR = 58, LCASE = 59, LEFT = 60, LENGTH = 61,\n-            LOCATE = 62, LTRIM = 63, OCTET_LENGTH = 64, RAWTOHEX = 65,\n-            REPEAT = 66, REPLACE = 67, RIGHT = 68, RTRIM = 69, SOUNDEX = 70,\n-            SPACE = 71, SUBSTR = 72, SUBSTRING = 73, UCASE = 74, LOWER = 75,\n-            UPPER = 76, POSITION = 77, TRIM = 78, STRINGENCODE = 79,\n-            STRINGDECODE = 80, STRINGTOUTF8 = 81, UTF8TOSTRING = 82,\n-            XMLATTR = 83, XMLNODE = 84, XMLCOMMENT = 85, XMLCDATA = 86,\n-            XMLSTARTDOC = 87, XMLTEXT = 88, REGEXP_REPLACE = 89, RPAD = 90,\n-            LPAD = 91, CONCAT_WS = 92, TO_CHAR = 93, TRANSLATE = 94, ORA_HASH = 95,\n-            TO_DATE = 96, TO_TIMESTAMP = 97, ADD_MONTHS = 98;\n-\n-    public static final int CURDATE = 100, CURTIME = 101, DATE_ADD = 102,\n-            DATE_DIFF = 103, DAY_NAME = 104, DAY_OF_MONTH = 105,\n-            DAY_OF_WEEK = 106, DAY_OF_YEAR = 107, HOUR = 108, MINUTE = 109,\n-            MONTH = 110, MONTH_NAME = 111, NOW = 112, QUARTER = 113,\n-            SECOND = 114, WEEK = 115, YEAR = 116, CURRENT_DATE = 117,\n-            CURRENT_TIME = 118, CURRENT_TIMESTAMP = 119, EXTRACT = 120,\n-            FORMATDATETIME = 121, PARSEDATETIME = 122, ISO_YEAR = 123,\n-            ISO_WEEK = 124, ISO_DAY_OF_WEEK = 125;\n-\n-    public static final int DATABASE = 150, USER = 151, CURRENT_USER = 152,\n-            IDENTITY = 153, SCOPE_IDENTITY = 154, AUTOCOMMIT = 155,\n-            READONLY = 156, DATABASE_PATH = 157, LOCK_TIMEOUT = 158,\n-            DISK_SPACE_USED = 159;\n-\n-    public static final int IFNULL = 200, CASEWHEN = 201, CONVERT = 202,\n-            CAST = 203, COALESCE = 204, NULLIF = 205, CASE = 206,\n-            NEXTVAL = 207, CURRVAL = 208, ARRAY_GET = 209, CSVREAD = 210,\n-            CSVWRITE = 211, MEMORY_FREE = 212, MEMORY_USED = 213,\n-            LOCK_MODE = 214, SCHEMA = 215, SESSION_ID = 216,\n-            ARRAY_LENGTH = 217, LINK_SCHEMA = 218, GREATEST = 219, LEAST = 220,\n-            CANCEL_SESSION = 221, SET = 222, TABLE = 223, TABLE_DISTINCT = 224,\n-            FILE_READ = 225, TRANSACTION_ID = 226, TRUNCATE_VALUE = 227,\n-            NVL2 = 228, DECODE = 229, ARRAY_CONTAINS = 230, FILE_WRITE = 232;\n-\n-    public static final int REGEXP_LIKE = 240;\n-\n-    /**\n-     * Used in MySQL-style INSERT ... ON DUPLICATE KEY UPDATE ... VALUES\n-     */\n-    public static final int VALUES = 250;\n-\n-    /**\n-     * This is called H2VERSION() and not VERSION(), because we return a fake\n-     * value for VERSION() when running under the PostgreSQL ODBC driver.\n-     */\n-    public static final int H2VERSION = 231;\n-\n-    public static final int ROW_NUMBER = 300;\n-\n-    private static final int VAR_ARGS = -1;\n-    private static final long PRECISION_UNKNOWN = -1;\n-\n-    private static final HashMap<String, FunctionInfo> FUNCTIONS = New.hashMap();\n-    private static final HashMap<String, Integer> DATE_PART = New.hashMap();\n-    private static final char[] SOUNDEX_INDEX = new char[128];\n-\n-    protected Expression[] args;\n-\n-    private final FunctionInfo info;\n-    private ArrayList<Expression> varArgs;\n-    private int dataType, scale;\n-    private long precision = PRECISION_UNKNOWN;\n-    private int displaySize;\n-    private final Database database;\n-\n-    static {\n-        // DATE_PART\n-        DATE_PART.put(\"SQL_TSI_YEAR\", Calendar.YEAR);\n-        DATE_PART.put(\"YEAR\", Calendar.YEAR);\n-        DATE_PART.put(\"YYYY\", Calendar.YEAR);\n-        DATE_PART.put(\"YY\", Calendar.YEAR);\n-        DATE_PART.put(\"SQL_TSI_MONTH\", Calendar.MONTH);\n-        DATE_PART.put(\"MONTH\", Calendar.MONTH);\n-        DATE_PART.put(\"MM\", Calendar.MONTH);\n-        DATE_PART.put(\"M\", Calendar.MONTH);\n-        DATE_PART.put(\"SQL_TSI_WEEK\", Calendar.WEEK_OF_YEAR);\n-        DATE_PART.put(\"WW\", Calendar.WEEK_OF_YEAR);\n-        DATE_PART.put(\"WK\", Calendar.WEEK_OF_YEAR);\n-        DATE_PART.put(\"WEEK\", Calendar.WEEK_OF_YEAR);\n-        DATE_PART.put(\"DAY\", Calendar.DAY_OF_MONTH);\n-        DATE_PART.put(\"DD\", Calendar.DAY_OF_MONTH);\n-        DATE_PART.put(\"D\", Calendar.DAY_OF_MONTH);\n-        DATE_PART.put(\"SQL_TSI_DAY\", Calendar.DAY_OF_MONTH);\n-        DATE_PART.put(\"DAYOFYEAR\", Calendar.DAY_OF_YEAR);\n-        DATE_PART.put(\"DAY_OF_YEAR\", Calendar.DAY_OF_YEAR);\n-        DATE_PART.put(\"DY\", Calendar.DAY_OF_YEAR);\n-        DATE_PART.put(\"DOY\", Calendar.DAY_OF_YEAR);\n-        DATE_PART.put(\"SQL_TSI_HOUR\", Calendar.HOUR_OF_DAY);\n-        DATE_PART.put(\"HOUR\", Calendar.HOUR_OF_DAY);\n-        DATE_PART.put(\"HH\", Calendar.HOUR_OF_DAY);\n-        DATE_PART.put(\"SQL_TSI_MINUTE\", Calendar.MINUTE);\n-        DATE_PART.put(\"MINUTE\", Calendar.MINUTE);\n-        DATE_PART.put(\"MI\", Calendar.MINUTE);\n-        DATE_PART.put(\"N\", Calendar.MINUTE);\n-        DATE_PART.put(\"SQL_TSI_SECOND\", Calendar.SECOND);\n-        DATE_PART.put(\"SECOND\", Calendar.SECOND);\n-        DATE_PART.put(\"SS\", Calendar.SECOND);\n-        DATE_PART.put(\"S\", Calendar.SECOND);\n-        DATE_PART.put(\"MILLISECOND\", Calendar.MILLISECOND);\n-        DATE_PART.put(\"MS\", Calendar.MILLISECOND);\n-\n-        // SOUNDEX_INDEX\n-        String index = \"7AEIOUY8HW1BFPV2CGJKQSXZ3DT4L5MN6R\";\n-        char number = 0;\n-        for (int i = 0, length = index.length(); i < length; i++) {\n-            char c = index.charAt(i);\n-            if (c < '9') {\n-                number = c;\n-            } else {\n-                SOUNDEX_INDEX[c] = number;\n-                SOUNDEX_INDEX[Character.toLowerCase(c)] = number;\n-            }\n-        }\n-\n-        // FUNCTIONS\n-        addFunction(\"ABS\", ABS, 1, Value.NULL);\n-        addFunction(\"ACOS\", ACOS, 1, Value.DOUBLE);\n-        addFunction(\"ASIN\", ASIN, 1, Value.DOUBLE);\n-        addFunction(\"ATAN\", ATAN, 1, Value.DOUBLE);\n-        addFunction(\"ATAN2\", ATAN2, 2, Value.DOUBLE);\n-        addFunction(\"BITAND\", BITAND, 2, Value.LONG);\n-        addFunction(\"BITGET\", BITGET, 2, Value.BOOLEAN);\n-        addFunction(\"BITOR\", BITOR, 2, Value.LONG);\n-        addFunction(\"BITXOR\", BITXOR, 2, Value.LONG);\n-        addFunction(\"CEILING\", CEILING, 1, Value.DOUBLE);\n-        addFunction(\"CEIL\", CEILING, 1, Value.DOUBLE);\n-        addFunction(\"COS\", COS, 1, Value.DOUBLE);\n-        addFunction(\"COSH\", COSH, 1, Value.DOUBLE);\n-        addFunction(\"COT\", COT, 1, Value.DOUBLE);\n-        addFunction(\"DEGREES\", DEGREES, 1, Value.DOUBLE);\n-        addFunction(\"EXP\", EXP, 1, Value.DOUBLE);\n-        addFunction(\"FLOOR\", FLOOR, 1, Value.DOUBLE);\n-        addFunction(\"LOG\", LOG, 1, Value.DOUBLE);\n-        addFunction(\"LN\", LN, 1, Value.DOUBLE);\n-        addFunction(\"LOG10\", LOG10, 1, Value.DOUBLE);\n-        addFunction(\"MOD\", MOD, 2, Value.LONG);\n-        addFunction(\"PI\", PI, 0, Value.DOUBLE);\n-        addFunction(\"POWER\", POWER, 2, Value.DOUBLE);\n-        addFunction(\"RADIANS\", RADIANS, 1, Value.DOUBLE);\n-        // RAND without argument: get the next value\n-        // RAND with one argument: seed the random generator\n-        addFunctionNotDeterministic(\"RAND\", RAND, VAR_ARGS, Value.DOUBLE);\n-        addFunctionNotDeterministic(\"RANDOM\", RAND, VAR_ARGS, Value.DOUBLE);\n-        addFunction(\"ROUND\", ROUND, VAR_ARGS, Value.DOUBLE);\n-        addFunction(\"ROUNDMAGIC\", ROUNDMAGIC, 1, Value.DOUBLE);\n-        addFunction(\"SIGN\", SIGN, 1, Value.INT);\n-        addFunction(\"SIN\", SIN, 1, Value.DOUBLE);\n-        addFunction(\"SINH\", SINH, 1, Value.DOUBLE);\n-        addFunction(\"SQRT\", SQRT, 1, Value.DOUBLE);\n-        addFunction(\"TAN\", TAN, 1, Value.DOUBLE);\n-        addFunction(\"TANH\", TANH, 1, Value.DOUBLE);\n-        addFunction(\"TRUNCATE\", TRUNCATE, VAR_ARGS, Value.NULL);\n-        // same as TRUNCATE\n-        addFunction(\"TRUNC\", TRUNCATE, VAR_ARGS, Value.NULL);\n-        addFunction(\"HASH\", HASH, 3, Value.BYTES);\n-        addFunction(\"ENCRYPT\", ENCRYPT, 3, Value.BYTES);\n-        addFunction(\"DECRYPT\", DECRYPT, 3, Value.BYTES);\n-        addFunctionNotDeterministic(\"SECURE_RAND\", SECURE_RAND, 1, Value.BYTES);\n-        addFunction(\"COMPRESS\", COMPRESS, VAR_ARGS, Value.BYTES);\n-        addFunction(\"EXPAND\", EXPAND, 1, Value.BYTES);\n-        addFunction(\"ZERO\", ZERO, 0, Value.INT);\n-        addFunctionNotDeterministic(\"RANDOM_UUID\", RANDOM_UUID, 0, Value.UUID);\n-        addFunctionNotDeterministic(\"SYS_GUID\", RANDOM_UUID, 0, Value.UUID);\n-        addFunctionNotDeterministic(\"UUID\", RANDOM_UUID, 0, Value.UUID);\n-        // string\n-        addFunction(\"ASCII\", ASCII, 1, Value.INT);\n-        addFunction(\"BIT_LENGTH\", BIT_LENGTH, 1, Value.LONG);\n-        addFunction(\"CHAR\", CHAR, 1, Value.STRING);\n-        addFunction(\"CHR\", CHAR, 1, Value.STRING);\n-        addFunction(\"CHAR_LENGTH\", CHAR_LENGTH, 1, Value.INT);\n-        // same as CHAR_LENGTH\n-        addFunction(\"CHARACTER_LENGTH\", CHAR_LENGTH, 1, Value.INT);\n-        addFunctionWithNull(\"CONCAT\", CONCAT, VAR_ARGS, Value.STRING);\n-        addFunctionWithNull(\"CONCAT_WS\", CONCAT_WS, VAR_ARGS, Value.STRING);\n-        addFunction(\"DIFFERENCE\", DIFFERENCE, 2, Value.INT);\n-        addFunction(\"HEXTORAW\", HEXTORAW, 1, Value.STRING);\n-        addFunctionWithNull(\"INSERT\", INSERT, 4, Value.STRING);\n-        addFunction(\"LCASE\", LCASE, 1, Value.STRING);\n-        addFunction(\"LEFT\", LEFT, 2, Value.STRING);\n-        addFunction(\"LENGTH\", LENGTH, 1, Value.LONG);\n-        // 2 or 3 arguments\n-        addFunction(\"LOCATE\", LOCATE, VAR_ARGS, Value.INT);\n-        // alias for MSSQLServer\n-        addFunction(\"CHARINDEX\", LOCATE, VAR_ARGS, Value.INT);\n-        // same as LOCATE with 2 arguments\n-        addFunction(\"POSITION\", LOCATE, 2, Value.INT);\n-        addFunction(\"INSTR\", INSTR, VAR_ARGS, Value.INT);\n-        addFunction(\"LTRIM\", LTRIM, VAR_ARGS, Value.STRING);\n-        addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n-        addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n-        addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n-        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n-        addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n-        addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n-        addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n-        addFunction(\"SPACE\", SPACE, 1, Value.STRING);\n-        addFunction(\"SUBSTR\", SUBSTR, VAR_ARGS, Value.STRING);\n-        addFunction(\"SUBSTRING\", SUBSTRING, VAR_ARGS, Value.STRING);\n-        addFunction(\"UCASE\", UCASE, 1, Value.STRING);\n-        addFunction(\"LOWER\", LOWER, 1, Value.STRING);\n-        addFunction(\"UPPER\", UPPER, 1, Value.STRING);\n-        addFunction(\"POSITION\", POSITION, 2, Value.INT);\n-        addFunction(\"TRIM\", TRIM, VAR_ARGS, Value.STRING);\n-        addFunction(\"STRINGENCODE\", STRINGENCODE, 1, Value.STRING);\n-        addFunction(\"STRINGDECODE\", STRINGDECODE, 1, Value.STRING);\n-        addFunction(\"STRINGTOUTF8\", STRINGTOUTF8, 1, Value.BYTES);\n-        addFunction(\"UTF8TOSTRING\", UTF8TOSTRING, 1, Value.STRING);\n-        addFunction(\"XMLATTR\", XMLATTR, 2, Value.STRING);\n-        addFunctionWithNull(\"XMLNODE\", XMLNODE, VAR_ARGS, Value.STRING);\n-        addFunction(\"XMLCOMMENT\", XMLCOMMENT, 1, Value.STRING);\n-        addFunction(\"XMLCDATA\", XMLCDATA, 1, Value.STRING);\n-        addFunction(\"XMLSTARTDOC\", XMLSTARTDOC, 0, Value.STRING);\n-        addFunction(\"XMLTEXT\", XMLTEXT, VAR_ARGS, Value.STRING);\n-        addFunction(\"REGEXP_REPLACE\", REGEXP_REPLACE, VAR_ARGS, Value.STRING);\n-        addFunction(\"RPAD\", RPAD, VAR_ARGS, Value.STRING);\n-        addFunction(\"LPAD\", LPAD, VAR_ARGS, Value.STRING);\n-        addFunction(\"TO_CHAR\", TO_CHAR, VAR_ARGS, Value.STRING);\n-        addFunction(\"ORA_HASH\", ORA_HASH, VAR_ARGS, Value.INT);\n-        addFunction(\"TRANSLATE\", TRANSLATE, 3, Value.STRING);\n-        addFunction(\"REGEXP_LIKE\", REGEXP_LIKE, VAR_ARGS, Value.BOOLEAN);\n-\n-        // date\n-        addFunctionNotDeterministic(\"CURRENT_DATE\", CURRENT_DATE,\n-                0, Value.DATE);\n-        addFunctionNotDeterministic(\"CURDATE\", CURDATE,\n-                0, Value.DATE);\n-        addFunctionNotDeterministic(\"TODAY\", CURRENT_DATE,\n-                0, Value.DATE);\n-        addFunction(\"TO_DATE\", TO_DATE, VAR_ARGS, Value.TIMESTAMP);\n-        addFunction(\"TO_TIMESTAMP\", TO_TIMESTAMP, VAR_ARGS, Value.TIMESTAMP);\n-        addFunction(\"ADD_MONTHS\", ADD_MONTHS, 2, Value.TIMESTAMP);\n-        // alias for MSSQLServer\n-        addFunctionNotDeterministic(\"GETDATE\", CURDATE,\n-                0, Value.DATE);\n-        addFunctionNotDeterministic(\"CURRENT_TIME\", CURRENT_TIME,\n-                0, Value.TIME);\n-        addFunctionNotDeterministic(\"SYSTIME\", CURRENT_TIME,\n-                0, Value.TIME);\n-        addFunctionNotDeterministic(\"CURTIME\", CURTIME,\n-                0, Value.TIME);\n-        addFunctionNotDeterministic(\"CURRENT_TIMESTAMP\", CURRENT_TIMESTAMP,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunctionNotDeterministic(\"SYSDATE\", CURRENT_TIMESTAMP,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunctionNotDeterministic(\"SYSTIMESTAMP\", CURRENT_TIMESTAMP,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunctionNotDeterministic(\"NOW\", NOW,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunction(\"DATEADD\", DATE_ADD,\n-                3, Value.TIMESTAMP);\n-        addFunction(\"TIMESTAMPADD\", DATE_ADD,\n-                3, Value.LONG);\n-        addFunction(\"DATEDIFF\", DATE_DIFF,\n-                3, Value.LONG);\n-        addFunction(\"TIMESTAMPDIFF\", DATE_DIFF,\n-                3, Value.LONG);\n-        addFunction(\"DAYNAME\", DAY_NAME,\n-                1, Value.STRING);\n-        addFunction(\"DAYNAME\", DAY_NAME,\n-                1, Value.STRING);\n-        addFunction(\"DAY\", DAY_OF_MONTH,\n-                1, Value.INT);\n-        addFunction(\"DAY_OF_MONTH\", DAY_OF_MONTH,\n-                1, Value.INT);\n-        addFunction(\"DAY_OF_WEEK\", DAY_OF_WEEK,\n-                1, Value.INT);\n-        addFunction(\"DAY_OF_YEAR\", DAY_OF_YEAR,\n-                1, Value.INT);\n-        addFunction(\"DAYOFMONTH\", DAY_OF_MONTH,\n-                1, Value.INT);\n-        addFunction(\"DAYOFWEEK\", DAY_OF_WEEK,\n-                1, Value.INT);\n-        addFunction(\"DAYOFYEAR\", DAY_OF_YEAR,\n-                1, Value.INT);\n-        addFunction(\"HOUR\", HOUR,\n-                1, Value.INT);\n-        addFunction(\"MINUTE\", MINUTE,\n-                1, Value.INT);\n-        addFunction(\"MONTH\", MONTH,\n-                1, Value.INT);\n-        addFunction(\"MONTHNAME\", MONTH_NAME,\n-                1, Value.STRING);\n-        addFunction(\"QUARTER\", QUARTER,\n-                1, Value.INT);\n-        addFunction(\"SECOND\", SECOND,\n-                1, Value.INT);\n-        addFunction(\"WEEK\", WEEK,\n-                1, Value.INT);\n-        addFunction(\"YEAR\", YEAR,\n-                1, Value.INT);\n-        addFunction(\"EXTRACT\", EXTRACT,\n-                2, Value.INT);\n-        addFunctionWithNull(\"FORMATDATETIME\", FORMATDATETIME,\n-                VAR_ARGS, Value.STRING);\n-        addFunctionWithNull(\"PARSEDATETIME\", PARSEDATETIME,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunction(\"ISO_YEAR\", ISO_YEAR,\n-                1, Value.INT);\n-        addFunction(\"ISO_WEEK\", ISO_WEEK,\n-                1, Value.INT);\n-        addFunction(\"ISO_DAY_OF_WEEK\", ISO_DAY_OF_WEEK,\n-                1, Value.INT);\n-        // system\n-        addFunctionNotDeterministic(\"DATABASE\", DATABASE,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"USER\", USER,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"CURRENT_USER\", CURRENT_USER,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"IDENTITY\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"SCOPE_IDENTITY\", SCOPE_IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"IDENTITY_VAL_LOCAL\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"LAST_INSERT_ID\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"LASTVAL\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"AUTOCOMMIT\", AUTOCOMMIT,\n-                0, Value.BOOLEAN);\n-        addFunctionNotDeterministic(\"READONLY\", READONLY,\n-                0, Value.BOOLEAN);\n-        addFunction(\"DATABASE_PATH\", DATABASE_PATH,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"LOCK_TIMEOUT\", LOCK_TIMEOUT,\n-                0, Value.INT);\n-        addFunctionWithNull(\"IFNULL\", IFNULL,\n-                2, Value.NULL);\n-        addFunctionWithNull(\"ISNULL\", IFNULL,\n-                2, Value.NULL);\n-        addFunctionWithNull(\"CASEWHEN\", CASEWHEN,\n-                3, Value.NULL);\n-        addFunctionWithNull(\"CONVERT\", CONVERT,\n-                1, Value.NULL);\n-        addFunctionWithNull(\"CAST\", CAST,\n-                1, Value.NULL);\n-        addFunctionWithNull(\"TRUNCATE_VALUE\", TRUNCATE_VALUE,\n-                3, Value.NULL);\n-        addFunctionWithNull(\"COALESCE\", COALESCE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionWithNull(\"NVL\", COALESCE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionWithNull(\"NVL2\", NVL2,\n-                3, Value.NULL);\n-        addFunctionWithNull(\"NULLIF\", NULLIF,\n-                2, Value.NULL);\n-        addFunctionWithNull(\"CASE\", CASE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionNotDeterministic(\"NEXTVAL\", NEXTVAL,\n-                VAR_ARGS, Value.LONG);\n-        addFunctionNotDeterministic(\"CURRVAL\", CURRVAL,\n-                VAR_ARGS, Value.LONG);\n-        addFunction(\"ARRAY_GET\", ARRAY_GET,\n-                2, Value.STRING);\n-        addFunction(\"ARRAY_CONTAINS\", ARRAY_CONTAINS,\n-                2, Value.BOOLEAN, false, true, true);\n-        addFunction(\"CSVREAD\", CSVREAD,\n-                VAR_ARGS, Value.RESULT_SET, false, false, false);\n-        addFunction(\"CSVWRITE\", CSVWRITE,\n-                VAR_ARGS, Value.INT, false, false, true);\n-        addFunctionNotDeterministic(\"MEMORY_FREE\", MEMORY_FREE,\n-                0, Value.INT);\n-        addFunctionNotDeterministic(\"MEMORY_USED\", MEMORY_USED,\n-                0, Value.INT);\n-        addFunctionNotDeterministic(\"LOCK_MODE\", LOCK_MODE,\n-                0, Value.INT);\n-        addFunctionNotDeterministic(\"SCHEMA\", SCHEMA,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"SESSION_ID\", SESSION_ID,\n-                0, Value.INT);\n-        addFunction(\"ARRAY_LENGTH\", ARRAY_LENGTH,\n-                1, Value.INT);\n-        addFunctionNotDeterministic(\"LINK_SCHEMA\", LINK_SCHEMA,\n-                6, Value.RESULT_SET);\n-        addFunctionWithNull(\"LEAST\", LEAST,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionWithNull(\"GREATEST\", GREATEST,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionNotDeterministic(\"CANCEL_SESSION\", CANCEL_SESSION,\n-                1, Value.BOOLEAN);\n-        addFunction(\"SET\", SET,\n-                2, Value.NULL, false, false, true);\n-        addFunction(\"FILE_READ\", FILE_READ,\n-                VAR_ARGS, Value.NULL, false, false, true);\n-        addFunction(\"FILE_WRITE\", FILE_WRITE,\n-                2, Value.LONG, false, false, true);\n-        addFunctionNotDeterministic(\"TRANSACTION_ID\", TRANSACTION_ID,\n-                0, Value.STRING);\n-        addFunctionWithNull(\"DECODE\", DECODE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionNotDeterministic(\"DISK_SPACE_USED\", DISK_SPACE_USED,\n-                1, Value.LONG);\n-        addFunction(\"H2VERSION\", H2VERSION, 0, Value.STRING);\n-\n-        // TableFunction\n-        addFunctionWithNull(\"TABLE\", TABLE,\n-                VAR_ARGS, Value.RESULT_SET);\n-        addFunctionWithNull(\"TABLE_DISTINCT\", TABLE_DISTINCT,\n-                VAR_ARGS, Value.RESULT_SET);\n-\n-        // pseudo function\n-        addFunctionWithNull(\"ROW_NUMBER\", ROW_NUMBER, 0, Value.LONG);\n-\n-        // ON DUPLICATE KEY VALUES function\n-        addFunction(\"VALUES\", VALUES, 1, Value.NULL, false, true, false);\n-    }\n-\n-    protected Function(Database database, FunctionInfo info) {\n-        this.database = database;\n-        this.info = info;\n-        if (info.parameterCount == VAR_ARGS) {\n-            varArgs = New.arrayList();\n+  public static final int ABS = 0, ACOS = 1, ASIN = 2, ATAN = 3, ATAN2 = 4,\n+      BITAND = 5, BITOR = 6, BITXOR = 7, CEILING = 8, COS = 9, COT = 10,\n+      DEGREES = 11, EXP = 12, FLOOR = 13, LOG = 14, LOG10 = 15, MOD = 16,\n+      PI = 17, POWER = 18, RADIANS = 19, RAND = 20, ROUND = 21,\n+      ROUNDMAGIC = 22, SIGN = 23, SIN = 24, SQRT = 25, TAN = 26,\n+      TRUNCATE = 27, SECURE_RAND = 28, HASH = 29, ENCRYPT = 30,\n+      DECRYPT = 31, COMPRESS = 32, EXPAND = 33, ZERO = 34,\n+      RANDOM_UUID = 35, COSH = 36, SINH = 37, TANH = 38, LN = 39,\n+      BITGET = 40;\n+\n+  public static final int ASCII = 50, BIT_LENGTH = 51, CHAR = 52,\n+      CHAR_LENGTH = 53, CONCAT = 54, DIFFERENCE = 55, HEXTORAW = 56,\n+      INSERT = 57, INSTR = 58, LCASE = 59, LEFT = 60, LENGTH = 61,\n+      LOCATE = 62, LTRIM = 63, OCTET_LENGTH = 64, RAWTOHEX = 65,\n+      REPEAT = 66, REPLACE = 67, RIGHT = 68, RTRIM = 69, SOUNDEX = 70,\n+      SPACE = 71, SUBSTR = 72, SUBSTRING = 73, UCASE = 74, LOWER = 75,\n+      UPPER = 76, POSITION = 77, TRIM = 78, STRINGENCODE = 79,\n+      STRINGDECODE = 80, STRINGTOUTF8 = 81, UTF8TOSTRING = 82,\n+      XMLATTR = 83, XMLNODE = 84, XMLCOMMENT = 85, XMLCDATA = 86,\n+      XMLSTARTDOC = 87, XMLTEXT = 88, REGEXP_REPLACE = 89, RPAD = 90,\n+      LPAD = 91, CONCAT_WS = 92, TO_CHAR = 93, TRANSLATE = 94, ORA_HASH = 95,\n+      TO_DATE = 96, TO_TIMESTAMP = 97, ADD_MONTHS = 98;\n+\n+  public static final int CURDATE = 100, CURTIME = 101, DATE_ADD = 102,\n+      DATE_DIFF = 103, DAY_NAME = 104, DAY_OF_MONTH = 105,\n+      DAY_OF_WEEK = 106, DAY_OF_YEAR = 107, HOUR = 108, MINUTE = 109,\n+      MONTH = 110, MONTH_NAME = 111, NOW = 112, QUARTER = 113,\n+      SECOND = 114, WEEK = 115, YEAR = 116, CURRENT_DATE = 117,\n+      CURRENT_TIME = 118, CURRENT_TIMESTAMP = 119, EXTRACT = 120,\n+      FORMATDATETIME = 121, PARSEDATETIME = 122, ISO_YEAR = 123,\n+      ISO_WEEK = 124, ISO_DAY_OF_WEEK = 125;\n+\n+  public static final int DATABASE = 150, USER = 151, CURRENT_USER = 152,\n+      IDENTITY = 153, SCOPE_IDENTITY = 154, AUTOCOMMIT = 155,\n+      READONLY = 156, DATABASE_PATH = 157, LOCK_TIMEOUT = 158,\n+      DISK_SPACE_USED = 159;\n+\n+  public static final int IFNULL = 200, CASEWHEN = 201, CONVERT = 202,\n+      CAST = 203, COALESCE = 204, NULLIF = 205, CASE = 206,\n+      NEXTVAL = 207, CURRVAL = 208, ARRAY_GET = 209, CSVREAD = 210,\n+      CSVWRITE = 211, MEMORY_FREE = 212, MEMORY_USED = 213,\n+      LOCK_MODE = 214, SCHEMA = 215, SESSION_ID = 216,\n+      ARRAY_LENGTH = 217, LINK_SCHEMA = 218, GREATEST = 219, LEAST = 220,\n+      CANCEL_SESSION = 221, SET = 222, TABLE = 223, TABLE_DISTINCT = 224,\n+      FILE_READ = 225, TRANSACTION_ID = 226, TRUNCATE_VALUE = 227,\n+      NVL2 = 228, DECODE = 229, ARRAY_CONTAINS = 230, FILE_WRITE = 232;\n+\n+  public static final int REGEXP_LIKE = 240;\n+\n+  /**\n+   * Used in MySQL-style INSERT ... ON DUPLICATE KEY UPDATE ... VALUES\n+   */\n+  public static final int VALUES = 250;\n+\n+  /**\n+   * This is called H2VERSION() and not VERSION(), because we return a fake\n+   * value for VERSION() when running under the PostgreSQL ODBC driver.\n+   */\n+  public static final int H2VERSION = 231;\n+\n+  public static final int ROW_NUMBER = 300;\n+\n+  private static final int VAR_ARGS = -1;\n+  private static final long PRECISION_UNKNOWN = -1;\n+\n+  private static final HashMap<String, FunctionInfo> FUNCTIONS = New.hashMap();\n+  private static final HashMap<String, Integer> DATE_PART = New.hashMap();\n+  private static final char[] SOUNDEX_INDEX = new char[128];\n+\n+  protected Expression[] args;\n+\n+  private final FunctionInfo info;\n+  private ArrayList<Expression> varArgs;\n+  private int dataType, scale;\n+  private long precision = PRECISION_UNKNOWN;\n+  private int displaySize;\n+  private final Database database;\n+\n+  static {\n+    // DATE_PART\n+    DATE_PART.put(\"SQL_TSI_YEAR\", Calendar.YEAR);\n+    DATE_PART.put(\"YEAR\", Calendar.YEAR);\n+    DATE_PART.put(\"YYYY\", Calendar.YEAR);\n+    DATE_PART.put(\"YY\", Calendar.YEAR);\n+    DATE_PART.put(\"SQL_TSI_MONTH\", Calendar.MONTH);\n+    DATE_PART.put(\"MONTH\", Calendar.MONTH);\n+    DATE_PART.put(\"MM\", Calendar.MONTH);\n+    DATE_PART.put(\"M\", Calendar.MONTH);\n+    DATE_PART.put(\"SQL_TSI_WEEK\", Calendar.WEEK_OF_YEAR);\n+    DATE_PART.put(\"WW\", Calendar.WEEK_OF_YEAR);\n+    DATE_PART.put(\"WK\", Calendar.WEEK_OF_YEAR);\n+    DATE_PART.put(\"WEEK\", Calendar.WEEK_OF_YEAR);\n+    DATE_PART.put(\"DAY\", Calendar.DAY_OF_MONTH);\n+    DATE_PART.put(\"DD\", Calendar.DAY_OF_MONTH);\n+    DATE_PART.put(\"D\", Calendar.DAY_OF_MONTH);\n+    DATE_PART.put(\"SQL_TSI_DAY\", Calendar.DAY_OF_MONTH);\n+    DATE_PART.put(\"DAYOFYEAR\", Calendar.DAY_OF_YEAR);\n+    DATE_PART.put(\"DAY_OF_YEAR\", Calendar.DAY_OF_YEAR);\n+    DATE_PART.put(\"DY\", Calendar.DAY_OF_YEAR);\n+    DATE_PART.put(\"DOY\", Calendar.DAY_OF_YEAR);\n+    DATE_PART.put(\"SQL_TSI_HOUR\", Calendar.HOUR_OF_DAY);\n+    DATE_PART.put(\"HOUR\", Calendar.HOUR_OF_DAY);\n+    DATE_PART.put(\"HH\", Calendar.HOUR_OF_DAY);\n+    DATE_PART.put(\"SQL_TSI_MINUTE\", Calendar.MINUTE);\n+    DATE_PART.put(\"MINUTE\", Calendar.MINUTE);\n+    DATE_PART.put(\"MI\", Calendar.MINUTE);\n+    DATE_PART.put(\"N\", Calendar.MINUTE);\n+    DATE_PART.put(\"SQL_TSI_SECOND\", Calendar.SECOND);\n+    DATE_PART.put(\"SECOND\", Calendar.SECOND);\n+    DATE_PART.put(\"SS\", Calendar.SECOND);\n+    DATE_PART.put(\"S\", Calendar.SECOND);\n+    DATE_PART.put(\"MILLISECOND\", Calendar.MILLISECOND);\n+    DATE_PART.put(\"MS\", Calendar.MILLISECOND);\n+\n+    // SOUNDEX_INDEX\n+    String index = \"7AEIOUY8HW1BFPV2CGJKQSXZ3DT4L5MN6R\";\n+    char number = 0;\n+    for (int i = 0, length = index.length(); i < length; i++) {\n+      char c = index.charAt(i);\n+      if (c < '9') {\n+        number = c;\n+      } else {\n+        SOUNDEX_INDEX[c] = number;\n+        SOUNDEX_INDEX[Character.toLowerCase(c)] = number;\n+      }\n+    }\n+\n+    // FUNCTIONS\n+    addFunction(\"ABS\", ABS, 1, Value.NULL);\n+    addFunction(\"ACOS\", ACOS, 1, Value.DOUBLE);\n+    addFunction(\"ASIN\", ASIN, 1, Value.DOUBLE);\n+    addFunction(\"ATAN\", ATAN, 1, Value.DOUBLE);\n+    addFunction(\"ATAN2\", ATAN2, 2, Value.DOUBLE);\n+    addFunction(\"BITAND\", BITAND, 2, Value.LONG);\n+    addFunction(\"BITGET\", BITGET, 2, Value.BOOLEAN);\n+    addFunction(\"BITOR\", BITOR, 2, Value.LONG);\n+    addFunction(\"BITXOR\", BITXOR, 2, Value.LONG);\n+    addFunction(\"CEILING\", CEILING, 1, Value.DOUBLE);\n+    addFunction(\"CEIL\", CEILING, 1, Value.DOUBLE);\n+    addFunction(\"COS\", COS, 1, Value.DOUBLE);\n+    addFunction(\"COSH\", COSH, 1, Value.DOUBLE);\n+    addFunction(\"COT\", COT, 1, Value.DOUBLE);\n+    addFunction(\"DEGREES\", DEGREES, 1, Value.DOUBLE);\n+    addFunction(\"EXP\", EXP, 1, Value.DOUBLE);\n+    addFunction(\"FLOOR\", FLOOR, 1, Value.DOUBLE);\n+    addFunction(\"LOG\", LOG, 1, Value.DOUBLE);\n+    addFunction(\"LN\", LN, 1, Value.DOUBLE);\n+    addFunction(\"LOG10\", LOG10, 1, Value.DOUBLE);\n+    addFunction(\"MOD\", MOD, 2, Value.LONG);\n+    addFunction(\"PI\", PI, 0, Value.DOUBLE);\n+    addFunction(\"POWER\", POWER, 2, Value.DOUBLE);\n+    addFunction(\"RADIANS\", RADIANS, 1, Value.DOUBLE);\n+    // RAND without argument: get the next value\n+    // RAND with one argument: seed the random generator\n+    addFunctionNotDeterministic(\"RAND\", RAND, VAR_ARGS, Value.DOUBLE);\n+    addFunctionNotDeterministic(\"RANDOM\", RAND, VAR_ARGS, Value.DOUBLE);\n+    addFunction(\"ROUND\", ROUND, VAR_ARGS, Value.DOUBLE);\n+    addFunction(\"ROUNDMAGIC\", ROUNDMAGIC, 1, Value.DOUBLE);\n+    addFunction(\"SIGN\", SIGN, 1, Value.INT);\n+    addFunction(\"SIN\", SIN, 1, Value.DOUBLE);\n+    addFunction(\"SINH\", SINH, 1, Value.DOUBLE);\n+    addFunction(\"SQRT\", SQRT, 1, Value.DOUBLE);\n+    addFunction(\"TAN\", TAN, 1, Value.DOUBLE);\n+    addFunction(\"TANH\", TANH, 1, Value.DOUBLE);\n+    addFunction(\"TRUNCATE\", TRUNCATE, VAR_ARGS, Value.NULL);\n+    // same as TRUNCATE\n+    addFunction(\"TRUNC\", TRUNCATE, VAR_ARGS, Value.NULL);\n+    addFunction(\"HASH\", HASH, 3, Value.BYTES);\n+    addFunction(\"ENCRYPT\", ENCRYPT, 3, Value.BYTES);\n+    addFunction(\"DECRYPT\", DECRYPT, 3, Value.BYTES);\n+    addFunctionNotDeterministic(\"SECURE_RAND\", SECURE_RAND, 1, Value.BYTES);\n+    addFunction(\"COMPRESS\", COMPRESS, VAR_ARGS, Value.BYTES);\n+    addFunction(\"EXPAND\", EXPAND, 1, Value.BYTES);\n+    addFunction(\"ZERO\", ZERO, 0, Value.INT);\n+    addFunctionNotDeterministic(\"RANDOM_UUID\", RANDOM_UUID, 0, Value.UUID);\n+    addFunctionNotDeterministic(\"SYS_GUID\", RANDOM_UUID, 0, Value.UUID);\n+    addFunctionNotDeterministic(\"UUID\", RANDOM_UUID, 0, Value.UUID);\n+    // string\n+    addFunction(\"ASCII\", ASCII, 1, Value.INT);\n+    addFunction(\"BIT_LENGTH\", BIT_LENGTH, 1, Value.LONG);\n+    addFunction(\"CHAR\", CHAR, 1, Value.STRING);\n+    addFunction(\"CHR\", CHAR, 1, Value.STRING);\n+    addFunction(\"CHAR_LENGTH\", CHAR_LENGTH, 1, Value.INT);\n+    // same as CHAR_LENGTH\n+    addFunction(\"CHARACTER_LENGTH\", CHAR_LENGTH, 1, Value.INT);\n+    addFunctionWithNull(\"CONCAT\", CONCAT, VAR_ARGS, Value.STRING);\n+    addFunctionWithNull(\"CONCAT_WS\", CONCAT_WS, VAR_ARGS, Value.STRING);\n+    addFunction(\"DIFFERENCE\", DIFFERENCE, 2, Value.INT);\n+    addFunction(\"HEXTORAW\", HEXTORAW, 1, Value.STRING);\n+    addFunctionWithNull(\"INSERT\", INSERT, 4, Value.STRING);\n+    addFunction(\"LCASE\", LCASE, 1, Value.STRING);\n+    addFunction(\"LEFT\", LEFT, 2, Value.STRING);\n+    addFunction(\"LENGTH\", LENGTH, 1, Value.LONG);\n+    // 2 or 3 arguments\n+    addFunction(\"LOCATE\", LOCATE, VAR_ARGS, Value.INT);\n+    // alias for MSSQLServer\n+    addFunction(\"CHARINDEX\", LOCATE, VAR_ARGS, Value.INT);\n+    // same as LOCATE with 2 arguments\n+    addFunction(\"POSITION\", LOCATE, 2, Value.INT);\n+    addFunction(\"INSTR\", INSTR, VAR_ARGS, Value.INT);\n+    addFunction(\"LTRIM\", LTRIM, VAR_ARGS, Value.STRING);\n+    addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n+    addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n+    addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n+    addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true, true);\n+    addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n+    addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n+    addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n+    addFunction(\"SPACE\", SPACE, 1, Value.STRING);\n+    addFunction(\"SUBSTR\", SUBSTR, VAR_ARGS, Value.STRING);\n+    addFunction(\"SUBSTRING\", SUBSTRING, VAR_ARGS, Value.STRING);\n+    addFunction(\"UCASE\", UCASE, 1, Value.STRING);\n+    addFunction(\"LOWER\", LOWER, 1, Value.STRING);\n+    addFunction(\"UPPER\", UPPER, 1, Value.STRING);\n+    addFunction(\"POSITION\", POSITION, 2, Value.INT);\n+    addFunction(\"TRIM\", TRIM, VAR_ARGS, Value.STRING);\n+    addFunction(\"STRINGENCODE\", STRINGENCODE, 1, Value.STRING);\n+    addFunction(\"STRINGDECODE\", STRINGDECODE, 1, Value.STRING);\n+    addFunction(\"STRINGTOUTF8\", STRINGTOUTF8, 1, Value.BYTES);\n+    addFunction(\"UTF8TOSTRING\", UTF8TOSTRING, 1, Value.STRING);\n+    addFunction(\"XMLATTR\", XMLATTR, 2, Value.STRING);\n+    addFunctionWithNull(\"XMLNODE\", XMLNODE, VAR_ARGS, Value.STRING);\n+    addFunction(\"XMLCOMMENT\", XMLCOMMENT, 1, Value.STRING);\n+    addFunction(\"XMLCDATA\", XMLCDATA, 1, Value.STRING);\n+    addFunction(\"XMLSTARTDOC\", XMLSTARTDOC, 0, Value.STRING);\n+    addFunction(\"XMLTEXT\", XMLTEXT, VAR_ARGS, Value.STRING);\n+    addFunction(\"REGEXP_REPLACE\", REGEXP_REPLACE, VAR_ARGS, Value.STRING);\n+    addFunction(\"RPAD\", RPAD, VAR_ARGS, Value.STRING);\n+    addFunction(\"LPAD\", LPAD, VAR_ARGS, Value.STRING);\n+    addFunction(\"TO_CHAR\", TO_CHAR, VAR_ARGS, Value.STRING);\n+    addFunction(\"ORA_HASH\", ORA_HASH, VAR_ARGS, Value.INT);\n+    addFunction(\"TRANSLATE\", TRANSLATE, 3, Value.STRING);\n+    addFunction(\"REGEXP_LIKE\", REGEXP_LIKE, VAR_ARGS, Value.BOOLEAN);\n+\n+    // date\n+    addFunctionNotDeterministic(\"CURRENT_DATE\", CURRENT_DATE,\n+        0, Value.DATE);\n+    addFunctionNotDeterministic(\"CURDATE\", CURDATE,\n+        0, Value.DATE);\n+    addFunctionNotDeterministic(\"TODAY\", CURRENT_DATE,\n+        0, Value.DATE);\n+    addFunction(\"TO_DATE\", TO_DATE, VAR_ARGS, Value.TIMESTAMP);\n+    addFunction(\"TO_TIMESTAMP\", TO_TIMESTAMP, VAR_ARGS, Value.TIMESTAMP);\n+    addFunction(\"ADD_MONTHS\", ADD_MONTHS, 2, Value.TIMESTAMP);\n+    // alias for MSSQLServer\n+    addFunctionNotDeterministic(\"GETDATE\", CURDATE,\n+        0, Value.DATE);\n+    addFunctionNotDeterministic(\"CURRENT_TIME\", CURRENT_TIME,\n+        0, Value.TIME);\n+    addFunctionNotDeterministic(\"SYSTIME\", CURRENT_TIME,\n+        0, Value.TIME);\n+    addFunctionNotDeterministic(\"CURTIME\", CURTIME,\n+        0, Value.TIME);\n+    addFunctionNotDeterministic(\"CURRENT_TIMESTAMP\", CURRENT_TIMESTAMP,\n+        VAR_ARGS, Value.TIMESTAMP);\n+    addFunctionNotDeterministic(\"SYSDATE\", CURRENT_TIMESTAMP,\n+        VAR_ARGS, Value.TIMESTAMP);\n+    addFunctionNotDeterministic(\"SYSTIMESTAMP\", CURRENT_TIMESTAMP,\n+        VAR_ARGS, Value.TIMESTAMP);\n+    addFunctionNotDeterministic(\"NOW\", NOW,\n+        VAR_ARGS, Value.TIMESTAMP);\n+    addFunction(\"DATEADD\", DATE_ADD,\n+        3, Value.TIMESTAMP);\n+    addFunction(\"TIMESTAMPADD\", DATE_ADD,\n+        3, Value.LONG);\n+    addFunction(\"DATEDIFF\", DATE_DIFF,\n+        3, Value.LONG);\n+    addFunction(\"TIMESTAMPDIFF\", DATE_DIFF,\n+        3, Value.LONG);\n+    addFunction(\"DAYNAME\", DAY_NAME,\n+        1, Value.STRING);\n+    addFunction(\"DAYNAME\", DAY_NAME,\n+        1, Value.STRING);\n+    addFunction(\"DAY\", DAY_OF_MONTH,\n+        1, Value.INT);\n+    addFunction(\"DAY_OF_MONTH\", DAY_OF_MONTH,\n+        1, Value.INT);\n+    addFunction(\"DAY_OF_WEEK\", DAY_OF_WEEK,\n+        1, Value.INT);\n+    addFunction(\"DAY_OF_YEAR\", DAY_OF_YEAR,\n+        1, Value.INT);\n+    addFunction(\"DAYOFMONTH\", DAY_OF_MONTH,\n+        1, Value.INT);\n+    addFunction(\"DAYOFWEEK\", DAY_OF_WEEK,\n+        1, Value.INT);\n+    addFunction(\"DAYOFYEAR\", DAY_OF_YEAR,\n+        1, Value.INT);\n+    addFunction(\"HOUR\", HOUR,\n+        1, Value.INT);\n+    addFunction(\"MINUTE\", MINUTE,\n+        1, Value.INT);\n+    addFunction(\"MONTH\", MONTH,\n+        1, Value.INT);\n+    addFunction(\"MONTHNAME\", MONTH_NAME,\n+        1, Value.STRING);\n+    addFunction(\"QUARTER\", QUARTER,\n+        1, Value.INT);\n+    addFunction(\"SECOND\", SECOND,\n+        1, Value.INT);\n+    addFunction(\"WEEK\", WEEK,\n+        1, Value.INT);\n+    addFunction(\"YEAR\", YEAR,\n+        1, Value.INT);\n+    addFunction(\"EXTRACT\", EXTRACT,\n+        2, Value.INT);\n+    addFunctionWithNull(\"FORMATDATETIME\", FORMATDATETIME,\n+        VAR_ARGS, Value.STRING);\n+    addFunctionWithNull(\"PARSEDATETIME\", PARSEDATETIME,\n+        VAR_ARGS, Value.TIMESTAMP);\n+    addFunction(\"ISO_YEAR\", ISO_YEAR,\n+        1, Value.INT);\n+    addFunction(\"ISO_WEEK\", ISO_WEEK,\n+        1, Value.INT);\n+    addFunction(\"ISO_DAY_OF_WEEK\", ISO_DAY_OF_WEEK,\n+        1, Value.INT);\n+    // system\n+    addFunctionNotDeterministic(\"DATABASE\", DATABASE,\n+        0, Value.STRING);\n+    addFunctionNotDeterministic(\"USER\", USER,\n+        0, Value.STRING);\n+    addFunctionNotDeterministic(\"CURRENT_USER\", CURRENT_USER,\n+        0, Value.STRING);\n+    addFunctionNotDeterministic(\"IDENTITY\", IDENTITY,\n+        0, Value.LONG);\n+    addFunctionNotDeterministic(\"SCOPE_IDENTITY\", SCOPE_IDENTITY,\n+        0, Value.LONG);\n+    addFunctionNotDeterministic(\"IDENTITY_VAL_LOCAL\", IDENTITY,\n+        0, Value.LONG);\n+    addFunctionNotDeterministic(\"LAST_INSERT_ID\", IDENTITY,\n+        0, Value.LONG);\n+    addFunctionNotDeterministic(\"LASTVAL\", IDENTITY,\n+        0, Value.LONG);\n+    addFunctionNotDeterministic(\"AUTOCOMMIT\", AUTOCOMMIT,\n+        0, Value.BOOLEAN);\n+    addFunctionNotDeterministic(\"READONLY\", READONLY,\n+        0, Value.BOOLEAN);\n+    addFunction(\"DATABASE_PATH\", DATABASE_PATH,\n+        0, Value.STRING);\n+    addFunctionNotDeterministic(\"LOCK_TIMEOUT\", LOCK_TIMEOUT,\n+        0, Value.INT);\n+    addFunctionWithNull(\"IFNULL\", IFNULL,\n+        2, Value.NULL);\n+    addFunctionWithNull(\"ISNULL\", IFNULL,\n+        2, Value.NULL);\n+    addFunctionWithNull(\"CASEWHEN\", CASEWHEN,\n+        3, Value.NULL);\n+    addFunctionWithNull(\"CONVERT\", CONVERT,\n+        1, Value.NULL);\n+    addFunctionWithNull(\"CAST\", CAST,\n+        1, Value.NULL);\n+    addFunctionWithNull(\"TRUNCATE_VALUE\", TRUNCATE_VALUE,\n+        3, Value.NULL);\n+    addFunctionWithNull(\"COALESCE\", COALESCE,\n+        VAR_ARGS, Value.NULL);\n+    addFunctionWithNull(\"NVL\", COALESCE,\n+        VAR_ARGS, Value.NULL);\n+    addFunctionWithNull(\"NVL2\", NVL2,\n+        3, Value.NULL);\n+    addFunctionWithNull(\"NULLIF\", NULLIF,\n+        2, Value.NULL);\n+    addFunctionWithNull(\"CASE\", CASE,\n+        VAR_ARGS, Value.NULL);\n+    addFunctionNotDeterministic(\"NEXTVAL\", NEXTVAL,\n+        VAR_ARGS, Value.LONG);\n+    addFunctionNotDeterministic(\"CURRVAL\", CURRVAL,\n+        VAR_ARGS, Value.LONG);\n+    addFunction(\"ARRAY_GET\", ARRAY_GET,\n+        2, Value.STRING);\n+    addFunction(\"ARRAY_CONTAINS\", ARRAY_CONTAINS,\n+        2, Value.BOOLEAN, false, true, true);\n+    addFunction(\"CSVREAD\", CSVREAD,\n+        VAR_ARGS, Value.RESULT_SET, false, false, false);\n+    addFunction(\"CSVWRITE\", CSVWRITE,\n+        VAR_ARGS, Value.INT, false, false, true);\n+    addFunctionNotDeterministic(\"MEMORY_FREE\", MEMORY_FREE,\n+        0, Value.INT);\n+    addFunctionNotDeterministic(\"MEMORY_USED\", MEMORY_USED,\n+        0, Value.INT);\n+    addFunctionNotDeterministic(\"LOCK_MODE\", LOCK_MODE,\n+        0, Value.INT);\n+    addFunctionNotDeterministic(\"SCHEMA\", SCHEMA,\n+        0, Value.STRING);\n+    addFunctionNotDeterministic(\"SESSION_ID\", SESSION_ID,\n+        0, Value.INT);\n+    addFunction(\"ARRAY_LENGTH\", ARRAY_LENGTH,\n+        1, Value.INT);\n+    addFunctionNotDeterministic(\"LINK_SCHEMA\", LINK_SCHEMA,\n+        6, Value.RESULT_SET);\n+    addFunctionWithNull(\"LEAST\", LEAST,\n+        VAR_ARGS, Value.NULL);\n+    addFunctionWithNull(\"GREATEST\", GREATEST,\n+        VAR_ARGS, Value.NULL);\n+    addFunctionNotDeterministic(\"CANCEL_SESSION\", CANCEL_SESSION,\n+        1, Value.BOOLEAN);\n+    addFunction(\"SET\", SET,\n+        2, Value.NULL, false, false, true);\n+    addFunction(\"FILE_READ\", FILE_READ,\n+        VAR_ARGS, Value.NULL, false, false, true);\n+    addFunction(\"FILE_WRITE\", FILE_WRITE,\n+        2, Value.LONG, false, false, true);\n+    addFunctionNotDeterministic(\"TRANSACTION_ID\", TRANSACTION_ID,\n+        0, Value.STRING);\n+    addFunctionWithNull(\"DECODE\", DECODE,\n+        VAR_ARGS, Value.NULL);\n+    addFunctionNotDeterministic(\"DISK_SPACE_USED\", DISK_SPACE_USED,\n+        1, Value.LONG);\n+    addFunction(\"H2VERSION\", H2VERSION, 0, Value.STRING);\n+\n+    // TableFunction\n+    addFunctionWithNull(\"TABLE\", TABLE,\n+        VAR_ARGS, Value.RESULT_SET);\n+    addFunctionWithNull(\"TABLE_DISTINCT\", TABLE_DISTINCT,\n+        VAR_ARGS, Value.RESULT_SET);\n+\n+    // pseudo function\n+    addFunctionWithNull(\"ROW_NUMBER\", ROW_NUMBER, 0, Value.LONG);\n+\n+    // ON DUPLICATE KEY VALUES function\n+    addFunction(\"VALUES\", VALUES, 1, Value.NULL, false, true, false);\n+  }\n+\n+  protected Function(Database database, FunctionInfo info) {\n+    this.database = database;\n+    this.info = info;\n+    if (info.parameterCount == VAR_ARGS) {\n+      varArgs = New.arrayList();\n+    } else {\n+      args = new Expression[info.parameterCount];\n+    }\n+  }\n+\n+  private static void addFunction(String name, int type, int parameterCount,\n+                                  int returnDataType,\n+                                  boolean nullIfParameterIsNull,\n+                                  boolean deterministic,\n+                                  boolean bufferResultSetToLocalTemp) {\n+    FunctionInfo info = new FunctionInfo();\n+    info.name = name;\n+    info.type = type;\n+    info.parameterCount = parameterCount;\n+    info.returnDataType = returnDataType;\n+    info.nullIfParameterIsNull = nullIfParameterIsNull;\n+    info.deterministic = deterministic;\n+    info.bufferResultSetToLocalTemp = bufferResultSetToLocalTemp;\n+    FUNCTIONS.put(name, info);\n+  }\n+\n+  private static void addFunctionNotDeterministic(String name, int type,\n+                                                  int parameterCount,\n+                                                  int returnDataType) {\n+    addFunction(name, type, parameterCount, returnDataType, true, false, true);\n+  }\n+\n+  private static void addFunction(String name, int type, int parameterCount,\n+                                  int returnDataType) {\n+    addFunction(name, type, parameterCount, returnDataType, true, true, true);\n+  }\n+\n+  private static void addFunctionWithNull(String name, int type,\n+                                          int parameterCount,\n+                                          int returnDataType) {\n+    addFunction(name, type, parameterCount, returnDataType, false, true, true);\n+  }\n+\n+  /**\n+   * Get the function info object for this function, or null if there is no\n+   * such function.\n+   *\n+   * @param name the function name\n+   * @return the function info\n+   */\n+  private static FunctionInfo getFunctionInfo(String name) {\n+    return FUNCTIONS.get(name);\n+  }\n+\n+  /**\n+   * Get an instance of the given function for this database.\n+   * If no function with this name is found, null is returned.\n+   *\n+   * @param database the database\n+   * @param name     the function name\n+   * @return the function object or null\n+   */\n+  public static Function getFunction(Database database, String name) {\n+    if (!database.getSettings().databaseToUpper) {\n+      // if not yet converted to uppercase, do it now\n+      name = StringUtils.toUpperEnglish(name);\n+    }\n+    FunctionInfo info = getFunctionInfo(name);\n+    if (info == null) {\n+      return null;\n+    }\n+    switch (info.type) {\n+      case TABLE:\n+      case TABLE_DISTINCT:\n+        return new TableFunction(database, info, Long.MAX_VALUE);\n+      default:\n+        return new Function(database, info);\n+    }\n+  }\n+\n+  /**\n+   * Set the parameter expression at the given index.\n+   *\n+   * @param index the index (0, 1,...)\n+   * @param param the expression\n+   */\n+  public void setParameter(int index, Expression param) {\n+    if (varArgs != null) {\n+      varArgs.add(param);\n+    } else {\n+      if (index >= args.length) {\n+        throw DbException.get(ErrorCode.INVALID_PARAMETER_COUNT_2,\n+            info.name, \"\" + args.length);\n+      }\n+      args[index] = param;\n+    }\n+  }\n+\n+  private static strictfp double log10(double value) {\n+    return roundMagic(StrictMath.log(value) / StrictMath.log(10));\n+  }\n+\n+  @Override\n+  public Value getValue(Session session) {\n+    return getValueWithArgs(session, args);\n+  }\n+\n+  private Value getSimpleValue(Session session, Value v0, Expression[] args,\n+                               Value[] values) {\n+    Value result;\n+    switch (info.type) {\n+      case ABS:\n+        result = v0.getSignum() >= 0 ? v0 : v0.negate();\n+        break;\n+      case ACOS:\n+        result = ValueDouble.get(Math.acos(v0.getDouble()));\n+        break;\n+      case ASIN:\n+        result = ValueDouble.get(Math.asin(v0.getDouble()));\n+        break;\n+      case ATAN:\n+        result = ValueDouble.get(Math.atan(v0.getDouble()));\n+        break;\n+      case CEILING:\n+        result = ValueDouble.get(Math.ceil(v0.getDouble()));\n+        break;\n+      case COS:\n+        result = ValueDouble.get(Math.cos(v0.getDouble()));\n+        break;\n+      case COSH:\n+        result = ValueDouble.get(Math.cosh(v0.getDouble()));\n+        break;\n+      case COT: {\n+        double d = Math.tan(v0.getDouble());\n+        if (d == 0.0) {\n+          throw DbException.get(ErrorCode.DIVISION_BY_ZERO_1, getSQL());\n+        }\n+        result = ValueDouble.get(1. / d);\n+        break;\n+      }\n+      case DEGREES:\n+        result = ValueDouble.get(Math.toDegrees(v0.getDouble()));\n+        break;\n+      case EXP:\n+        result = ValueDouble.get(Math.exp(v0.getDouble()));\n+        break;\n+      case FLOOR:\n+        result = ValueDouble.get(Math.floor(v0.getDouble()));\n+        break;\n+      case LN:\n+        result = ValueDouble.get(Math.log(v0.getDouble()));\n+        break;\n+      case LOG:\n+        if (database.getMode().logIsLogBase10) {\n+          result = ValueDouble.get(Math.log10(v0.getDouble()));\n         } else {\n-            args = new Expression[info.parameterCount];\n-        }\n-    }\n-\n-    private static void addFunction(String name, int type, int parameterCount,\n-            int returnDataType, boolean nullIfParameterIsNull, boolean deterministic,\n-            boolean bufferResultSetToLocalTemp) {\n-        FunctionInfo info = new FunctionInfo();\n-        info.name = name;\n-        info.type = type;\n-        info.parameterCount = parameterCount;\n-        info.returnDataType = returnDataType;\n-        info.nullIfParameterIsNull = nullIfParameterIsNull;\n-        info.deterministic = deterministic;\n-        info.bufferResultSetToLocalTemp = bufferResultSetToLocalTemp;\n-        FUNCTIONS.put(name, info);\n-    }\n-\n-    private static void addFunctionNotDeterministic(String name, int type,\n-            int parameterCount, int returnDataType) {\n-        addFunction(name, type, parameterCount, returnDataType, true, false, true);\n-    }\n-\n-    private static void addFunction(String name, int type, int parameterCount,\n-            int returnDataType) {\n-        addFunction(name, type, parameterCount, returnDataType, true, true, true);\n-    }\n-\n-    private static void addFunctionWithNull(String name, int type,\n-            int parameterCount, int returnDataType) {\n-        addFunction(name, type, parameterCount, returnDataType, false, true, true);\n-    }\n-\n-    /**\n-     * Get the function info object for this function, or null if there is no\n-     * such function.\n-     *\n-     * @param name the function name\n-     * @return the function info\n-     */\n-    private static FunctionInfo getFunctionInfo(String name) {\n-        return FUNCTIONS.get(name);\n-    }\n-\n-    /**\n-     * Get an instance of the given function for this database.\n-     * If no function with this name is found, null is returned.\n-     *\n-     * @param database the database\n-     * @param name the function name\n-     * @return the function object or null\n-     */\n-    public static Function getFunction(Database database, String name) {\n-        if (!database.getSettings().databaseToUpper) {\n-            // if not yet converted to uppercase, do it now\n-            name = StringUtils.toUpperEnglish(name);\n-        }\n-        FunctionInfo info = getFunctionInfo(name);\n-        if (info == null) {\n-            return null;\n-        }\n-        switch (info.type) {\n-        case TABLE:\n-        case TABLE_DISTINCT:\n-            return new TableFunction(database, info, Long.MAX_VALUE);\n-        default:\n-            return new Function(database, info);\n-        }\n-    }\n-\n-    /**\n-     * Set the parameter expression at the given index.\n-     *\n-     * @param index the index (0, 1,...)\n-     * @param param the expression\n-     */\n-    public void setParameter(int index, Expression param) {\n-        if (varArgs != null) {\n-            varArgs.add(param);\n+          result = ValueDouble.get(Math.log(v0.getDouble()));\n+        }\n+        break;\n+      case LOG10:\n+        result = ValueDouble.get(log10(v0.getDouble()));\n+        break;\n+      case PI:\n+        result = ValueDouble.get(Math.PI);\n+        break;\n+      case RADIANS:\n+        result = ValueDouble.get(Math.toRadians(v0.getDouble()));\n+        break;\n+      case RAND: {\n+        if (v0 != null) {\n+          session.getRandom().setSeed(v0.getInt());\n+        }\n+        result = ValueDouble.get(session.getRandom().nextDouble());\n+        break;\n+      }\n+      case ROUNDMAGIC:\n+        result = ValueDouble.get(roundMagic(v0.getDouble()));\n+        break;\n+      case SIGN:\n+        result = ValueInt.get(v0.getSignum());\n+        break;\n+      case SIN:\n+        result = ValueDouble.get(Math.sin(v0.getDouble()));\n+        break;\n+      case SINH:\n+        result = ValueDouble.get(Math.sinh(v0.getDouble()));\n+        break;\n+      case SQRT:\n+        result = ValueDouble.get(Math.sqrt(v0.getDouble()));\n+        break;\n+      case TAN:\n+        result = ValueDouble.get(Math.tan(v0.getDouble()));\n+        break;\n+      case TANH:\n+        result = ValueDouble.get(Math.tanh(v0.getDouble()));\n+        break;\n+      case SECURE_RAND:\n+        result = ValueBytes.getNoCopy(\n+            MathUtils.secureRandomBytes(v0.getInt()));\n+        break;\n+      case EXPAND:\n+        result = ValueBytes.getNoCopy(\n+            CompressTool.getInstance().expand(v0.getBytesNoCopy()));\n+        break;\n+      case ZERO:\n+        result = ValueInt.get(0);\n+        break;\n+      case RANDOM_UUID:\n+        result = ValueUuid.getNewRandom();\n+        break;\n+      // string\n+      case ASCII: {\n+        String s = v0.getString();\n+        if (s.length() == 0) {\n+          result = ValueNull.INSTANCE;\n         } else {\n-            if (index >= args.length) {\n-                throw DbException.get(ErrorCode.INVALID_PARAMETER_COUNT_2,\n-                        info.name, \"\" + args.length);\n-            }\n-            args[index] = param;\n-        }\n-    }\n-\n-    private static strictfp double log10(double value) {\n-        return roundMagic(StrictMath.log(value) / StrictMath.log(10));\n-    }\n-\n-    @Override\n-    public Value getValue(Session session) {\n-        return getValueWithArgs(session, args);\n-    }\n-\n-    private Value getSimpleValue(Session session, Value v0, Expression[] args,\n-            Value[] values) {\n-        Value result;\n-        switch (info.type) {\n-        case ABS:\n-            result = v0.getSignum() >= 0 ? v0 : v0.negate();\n-            break;\n-        case ACOS:\n-            result = ValueDouble.get(Math.acos(v0.getDouble()));\n-            break;\n-        case ASIN:\n-            result = ValueDouble.get(Math.asin(v0.getDouble()));\n-            break;\n-        case ATAN:\n-            result = ValueDouble.get(Math.atan(v0.getDouble()));\n-            break;\n-        case CEILING:\n-            result = ValueDouble.get(Math.ceil(v0.getDouble()));\n-            break;\n-        case COS:\n-            result = ValueDouble.get(Math.cos(v0.getDouble()));\n-            break;\n-        case COSH:\n-            result = ValueDouble.get(Math.cosh(v0.getDouble()));\n-            break;\n-        case COT: {\n-            double d = Math.tan(v0.getDouble());\n-            if (d == 0.0) {\n-                throw DbException.get(ErrorCode.DIVISION_BY_ZERO_1, getSQL());\n-            }\n-            result = ValueDouble.get(1. / d);\n-            break;\n-        }\n-        case DEGREES:\n-            result = ValueDouble.get(Math.toDegrees(v0.getDouble()));\n-            break;\n-        case EXP:\n-            result = ValueDouble.get(Math.exp(v0.getDouble()));\n-            break;\n-        case FLOOR:\n-            result = ValueDouble.get(Math.floor(v0.getDouble()));\n-            break;\n-        case LN:\n-            result = ValueDouble.get(Math.log(v0.getDouble()));\n-            break;\n-        case LOG:\n-            if (database.getMode().logIsLogBase10) {\n-                result = ValueDouble.get(Math.log10(v0.getDouble()));\n-            } else {\n-                result = ValueDouble.get(Math.log(v0.getDouble()));\n-            }\n-            break;\n-        case LOG10:\n-            result = ValueDouble.get(log10(v0.getDouble()));\n-            break;\n-        case PI:\n-            result = ValueDouble.get(Math.PI);\n-            break;\n-        case RADIANS:\n-            result = ValueDouble.get(Math.toRadians(v0.getDouble()));\n-            break;\n-        case RAND: {\n-            if (v0 != null) {\n-                session.getRandom().setSeed(v0.getInt());\n-            }\n-            result = ValueDouble.get(session.getRandom().nextDouble());\n-            break;\n-        }\n-        case ROUNDMAGIC:\n-            result = ValueDouble.get(roundMagic(v0.getDouble()));\n-            break;\n-        case SIGN:\n-            result = ValueInt.get(v0.getSignum());\n-            break;\n-        case SIN:\n-            result = ValueDouble.get(Math.sin(v0.getDouble()));\n-            break;\n-        case SINH:\n-            result = ValueDouble.get(Math.sinh(v0.getDouble()));\n-            break;\n-        case SQRT:\n-            result = ValueDouble.get(Math.sqrt(v0.getDouble()));\n-            break;\n-        case TAN:\n-            result = ValueDouble.get(Math.tan(v0.getDouble()));\n-            break;\n-        case TANH:\n-            result = ValueDouble.get(Math.tanh(v0.getDouble()));\n-            break;\n-        case SECURE_RAND:\n-            result = ValueBytes.getNoCopy(\n-                    MathUtils.secureRandomBytes(v0.getInt()));\n-            break;\n-        case EXPAND:\n-            result = ValueBytes.getNoCopy(\n-                    CompressTool.getInstance().expand(v0.getBytesNoCopy()));\n-            break;\n-        case ZERO:\n-            result = ValueInt.get(0);\n-            break;\n-        case RANDOM_UUID:\n-            result = ValueUuid.getNewRandom();\n-            break;\n-            // string\n-        case ASCII: {\n-            String s = v0.getString();\n-            if (s.length() == 0) {\n-                result = ValueNull.INSTANCE;\n-            } else {\n-                result = ValueInt.get(s.charAt(0));\n-            }\n-            break;\n-        }\n-        case BIT_LENGTH:\n-            result = ValueLong.get(16 * length(v0));\n-            break;\n-        case CHAR:\n-            result = ValueString.get(String.valueOf((char) v0.getInt()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case CHAR_LENGTH:\n-        case LENGTH:\n-            result = ValueLong.get(length(v0));\n-            break;\n-        case OCTET_LENGTH:\n-            result = ValueLong.get(2 * length(v0));\n-            break;\n-        case CONCAT_WS:\n-        case CONCAT: {\n-            result = ValueNull.INSTANCE;\n-            int start = 0;\n-            String separator = \"\";\n-            if (info.type == CONCAT_WS) {\n-                start = 1;\n-                separator = getNullOrValue(session, args, values, 0).getString();\n-            }\n-            for (int i = start; i < args.length; i++) {\n-                Value v = getNullOrValue(session, args, values, i);\n-                if (v == ValueNull.INSTANCE) {\n-                    continue;\n-                }\n-                if (result == ValueNull.INSTANCE) {\n-                    result = v;\n-                } else {\n-                    String tmp = v.getString();\n-                    if (!StringUtils.isNullOrEmpty(separator)\n-                            && !StringUtils.isNullOrEmpty(tmp)) {\n-                        tmp = separator.concat(tmp);\n-                    }\n-                    result = ValueString.get(result.getString().concat(tmp),\n-                            database.getMode().treatEmptyStringsAsNull);\n-                }\n-            }\n-            if (info.type == CONCAT_WS) {\n-                if (separator != null && result == ValueNull.INSTANCE) {\n-                    result = ValueString.get(\"\",\n-                            database.getMode().treatEmptyStringsAsNull);\n-                }\n-            }\n-            break;\n-        }\n-        case HEXTORAW:\n-            result = ValueString.get(hexToRaw(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case LOWER:\n-        case LCASE:\n-            // TODO this is locale specific, need to document or provide a way\n-            // to set the locale\n-            result = ValueString.get(v0.getString().toLowerCase(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case RAWTOHEX:\n-            result = ValueString.get(rawToHex(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case SOUNDEX:\n-            result = ValueString.get(getSoundex(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case SPACE: {\n-            int len = Math.max(0, v0.getInt());\n-            char[] chars = new char[len];\n-            for (int i = len - 1; i >= 0; i--) {\n-                chars[i] = ' ';\n-            }\n-            result = ValueString.get(new String(chars),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case UPPER:\n-        case UCASE:\n-            // TODO this is locale specific, need to document or provide a way\n-            // to set the locale\n-            result = ValueString.get(v0.getString().toUpperCase(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case STRINGENCODE:\n-            result = ValueString.get(StringUtils.javaEncode(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case STRINGDECODE:\n-            result = ValueString.get(StringUtils.javaDecode(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case STRINGTOUTF8:\n-            result = ValueBytes.getNoCopy(v0.getString().\n-                    getBytes(Constants.UTF8));\n-            break;\n-        case UTF8TOSTRING:\n-            result = ValueString.get(new String(v0.getBytesNoCopy(),\n-                    Constants.UTF8),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case XMLCOMMENT:\n-            result = ValueString.get(StringUtils.xmlComment(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case XMLCDATA:\n-            result = ValueString.get(StringUtils.xmlCData(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case XMLSTARTDOC:\n-            result = ValueString.get(StringUtils.xmlStartDoc(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case DAY_NAME: {\n-            SimpleDateFormat dayName = new SimpleDateFormat(\n-                    \"EEEE\", Locale.ENGLISH);\n-            result = ValueString.get(dayName.format(v0.getDate()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case DAY_OF_MONTH:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.DAY_OF_MONTH));\n-            break;\n-        case DAY_OF_WEEK:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.DAY_OF_WEEK));\n-            break;\n-        case DAY_OF_YEAR:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.DAY_OF_YEAR));\n-            break;\n-        case HOUR:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n-                    Calendar.HOUR_OF_DAY));\n-            break;\n-        case MINUTE:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n-                    Calendar.MINUTE));\n-            break;\n-        case MONTH:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.MONTH));\n-            break;\n-        case MONTH_NAME: {\n-            SimpleDateFormat monthName = new SimpleDateFormat(\"MMMM\",\n-                    Locale.ENGLISH);\n-            result = ValueString.get(monthName.format(v0.getDate()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case QUARTER:\n-            result = ValueInt.get((DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.MONTH) - 1) / 3 + 1);\n-            break;\n-        case SECOND:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n-                    Calendar.SECOND));\n-            break;\n-        case WEEK:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.WEEK_OF_YEAR));\n-            break;\n-        case YEAR:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.YEAR));\n-            break;\n-        case ISO_YEAR:\n-            result = ValueInt.get(DateTimeUtils.getIsoYear(v0.getDate()));\n-            break;\n-        case ISO_WEEK:\n-            result = ValueInt.get(DateTimeUtils.getIsoWeek(v0.getDate()));\n-            break;\n-        case ISO_DAY_OF_WEEK:\n-            result = ValueInt.get(DateTimeUtils.getIsoDayOfWeek(v0.getDate()));\n-            break;\n-        case CURDATE:\n-        case CURRENT_DATE: {\n-            long now = session.getTransactionStart();\n-            // need to normalize\n-            result = ValueDate.fromMillis(now);\n-            break;\n-        }\n-        case CURTIME:\n-        case CURRENT_TIME: {\n-            long now = session.getTransactionStart();\n-            // need to normalize\n-            result = ValueTime.fromMillis(now);\n-            break;\n-        }\n-        case NOW:\n-        case CURRENT_TIMESTAMP: {\n-            long now = session.getTransactionStart();\n-            ValueTimestamp vt = ValueTimestamp.fromMillis(now);\n-            if (v0 != null) {\n-                Mode mode = database.getMode();\n-                vt = (ValueTimestamp) vt.convertScale(\n-                        mode.convertOnlyToSmallerScale, v0.getInt());\n-            }\n-            result = vt;\n-            break;\n-        }\n-        case DATABASE:\n-            result = ValueString.get(database.getShortName(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case USER:\n-        case CURRENT_USER:\n-            result = ValueString.get(session.getUser().getName(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case IDENTITY:\n-            result = session.getLastIdentity();\n-            break;\n-        case SCOPE_IDENTITY:\n-            result = session.getLastScopeIdentity();\n-            break;\n-        case AUTOCOMMIT:\n-            result = ValueBoolean.get(session.getAutoCommit());\n-            break;\n-        case READONLY:\n-            result = ValueBoolean.get(database.isReadOnly());\n-            break;\n-        case DATABASE_PATH: {\n-            String path = database.getDatabasePath();\n-            result = path == null ?\n-                    (Value) ValueNull.INSTANCE : ValueString.get(path,\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case LOCK_TIMEOUT:\n-            result = ValueInt.get(session.getLockTimeout());\n-            break;\n-        case DISK_SPACE_USED:\n-            result = ValueLong.get(getDiskSpaceUsed(session, v0));\n-            break;\n-        case CAST:\n-        case CONVERT: {\n-            v0 = v0.convertTo(dataType);\n-            Mode mode = database.getMode();\n-            v0 = v0.convertScale(mode.convertOnlyToSmallerScale, scale);\n-            v0 = v0.convertPrecision(getPrecision(), false);\n-            result = v0;\n-            break;\n-        }\n-        case MEMORY_FREE:\n-            session.getUser().checkAdmin();\n-            result = ValueInt.get(Utils.getMemoryFree());\n-            break;\n-        case MEMORY_USED:\n-            session.getUser().checkAdmin();\n-            result = ValueInt.get(Utils.getMemoryUsed());\n-            break;\n-        case LOCK_MODE:\n-            result = ValueInt.get(database.getLockMode());\n-            break;\n-        case SCHEMA:\n-            result = ValueString.get(session.getCurrentSchemaName(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case SESSION_ID:\n-            result = ValueInt.get(session.getId());\n-            break;\n-        case IFNULL: {\n-            result = v0;\n-            if (v0 == ValueNull.INSTANCE) {\n-                result = getNullOrValue(session, args, values, 1);\n-            }\n-            result = convertResult(result);\n-            break;\n-        }\n-        case CASEWHEN: {\n-            Value v;\n-            if (v0 == ValueNull.INSTANCE ||\n-                    !v0.getBoolean().booleanValue()) {\n-                v = getNullOrValue(session, args, values, 2);\n-            } else {\n-                v = getNullOrValue(session, args, values, 1);\n-            }\n-            result = v.convertTo(dataType);\n-            break;\n+          result = ValueInt.get(s.charAt(0));\n+        }\n+        break;\n+      }\n+      case BIT_LENGTH:\n+        result = ValueLong.get(16 * length(v0));\n+        break;\n+      case CHAR:\n+        result = ValueString.get(String.valueOf((char) v0.getInt()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case CHAR_LENGTH:\n+      case LENGTH:\n+        result = ValueLong.get(length(v0));\n+        break;\n+      case OCTET_LENGTH:\n+        result = ValueLong.get(2 * length(v0));\n+        break;\n+      case CONCAT_WS:\n+      case CONCAT: {\n+        result = ValueNull.INSTANCE;\n+        int start = 0;\n+        String separator = \"\";\n+        if (info.type == CONCAT_WS) {\n+          start = 1;\n+          separator = getNullOrValue(session, args, values, 0).getString();\n+        }\n+        for (int i = start; i < args.length; i++) {\n+          Value v = getNullOrValue(session, args, values, i);\n+          if (v == ValueNull.INSTANCE) {\n+            continue;\n+          }\n+          if (result == ValueNull.INSTANCE) {\n+            result = v;\n+          } else {\n+            String tmp = v.getString();\n+            if (!StringUtils.isNullOrEmpty(separator)\n+                && !StringUtils.isNullOrEmpty(tmp)) {\n+              tmp = separator.concat(tmp);\n+            }\n+            result = ValueString.get(result.getString().concat(tmp),\n+                database.getMode().treatEmptyStringsAsNull);\n+          }\n+        }\n+        if (info.type == CONCAT_WS) {\n+          if (separator != null && result == ValueNull.INSTANCE) {\n+            result = ValueString.get(\"\",\n+                database.getMode().treatEmptyStringsAsNull);\n+          }\n+        }\n+        break;\n+      }\n+      case HEXTORAW:\n+        result = ValueString.get(hexToRaw(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case LOWER:\n+      case LCASE:\n+        // TODO this is locale specific, need to document or provide a way\n+        // to set the locale\n+        result = ValueString.get(v0.getString().toLowerCase(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case RAWTOHEX:\n+        result = ValueString.get(rawToHex(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case SOUNDEX:\n+        result = ValueString.get(getSoundex(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case SPACE: {\n+        int len = Math.max(0, v0.getInt());\n+        char[] chars = new char[len];\n+        for (int i = len - 1; i >= 0; i--) {\n+          chars[i] = ' ';\n+        }\n+        result = ValueString.get(new String(chars),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case UPPER:\n+      case UCASE:\n+        // TODO this is locale specific, need to document or provide a way\n+        // to set the locale\n+        result = ValueString.get(v0.getString().toUpperCase(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case STRINGENCODE:\n+        result = ValueString.get(StringUtils.javaEncode(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case STRINGDECODE:\n+        result = ValueString.get(StringUtils.javaDecode(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case STRINGTOUTF8:\n+        result = ValueBytes.getNoCopy(v0.getString().\n+            getBytes(Constants.UTF8));\n+        break;\n+      case UTF8TOSTRING:\n+        result = ValueString.get(new String(v0.getBytesNoCopy(),\n+                Constants.UTF8),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case XMLCOMMENT:\n+        result = ValueString.get(StringUtils.xmlComment(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case XMLCDATA:\n+        result = ValueString.get(StringUtils.xmlCData(v0.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case XMLSTARTDOC:\n+        result = ValueString.get(StringUtils.xmlStartDoc(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case DAY_NAME: {\n+        SimpleDateFormat dayName = new SimpleDateFormat(\n+            \"EEEE\", Locale.ENGLISH);\n+        result = ValueString.get(dayName.format(v0.getDate()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case DAY_OF_MONTH:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.DAY_OF_MONTH));\n+        break;\n+      case DAY_OF_WEEK:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.DAY_OF_WEEK));\n+        break;\n+      case DAY_OF_YEAR:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.DAY_OF_YEAR));\n+        break;\n+      case HOUR:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n+            Calendar.HOUR_OF_DAY));\n+        break;\n+      case MINUTE:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n+            Calendar.MINUTE));\n+        break;\n+      case MONTH:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.MONTH));\n+        break;\n+      case MONTH_NAME: {\n+        SimpleDateFormat monthName = new SimpleDateFormat(\"MMMM\",\n+            Locale.ENGLISH);\n+        result = ValueString.get(monthName.format(v0.getDate()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case QUARTER:\n+        result = ValueInt.get((DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.MONTH) - 1) / 3 + 1);\n+        break;\n+      case SECOND:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n+            Calendar.SECOND));\n+        break;\n+      case WEEK:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.WEEK_OF_YEAR));\n+        break;\n+      case YEAR:\n+        result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n+            Calendar.YEAR));\n+        break;\n+      case ISO_YEAR:\n+        result = ValueInt.get(DateTimeUtils.getIsoYear(v0.getDate()));\n+        break;\n+      case ISO_WEEK:\n+        result = ValueInt.get(DateTimeUtils.getIsoWeek(v0.getDate()));\n+        break;\n+      case ISO_DAY_OF_WEEK:\n+        result = ValueInt.get(DateTimeUtils.getIsoDayOfWeek(v0.getDate()));\n+        break;\n+      case CURDATE:\n+      case CURRENT_DATE: {\n+        long now = session.getTransactionStart();\n+        // need to normalize\n+        result = ValueDate.fromMillis(now);\n+        break;\n+      }\n+      case CURTIME:\n+      case CURRENT_TIME: {\n+        long now = session.getTransactionStart();\n+        // need to normalize\n+        result = ValueTime.fromMillis(now);\n+        break;\n+      }\n+      case NOW:\n+      case CURRENT_TIMESTAMP: {\n+        long now = session.getTransactionStart();\n+        ValueTimestamp vt = ValueTimestamp.fromMillis(now);\n+        if (v0 != null) {\n+          Mode mode = database.getMode();\n+          vt = (ValueTimestamp) vt.convertScale(\n+              mode.convertOnlyToSmallerScale, v0.getInt());\n+        }\n+        result = vt;\n+        break;\n+      }\n+      case DATABASE:\n+        result = ValueString.get(database.getShortName(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case USER:\n+      case CURRENT_USER:\n+        result = ValueString.get(session.getUser().getName(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case IDENTITY:\n+        result = session.getLastIdentity();\n+        break;\n+      case SCOPE_IDENTITY:\n+        result = session.getLastScopeIdentity();\n+        break;\n+      case AUTOCOMMIT:\n+        result = ValueBoolean.get(session.getAutoCommit());\n+        break;\n+      case READONLY:\n+        result = ValueBoolean.get(database.isReadOnly());\n+        break;\n+      case DATABASE_PATH: {\n+        String path = database.getDatabasePath();\n+        result = path == null ?\n+            (Value) ValueNull.INSTANCE : ValueString.get(path,\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case LOCK_TIMEOUT:\n+        result = ValueInt.get(session.getLockTimeout());\n+        break;\n+      case DISK_SPACE_USED:\n+        result = ValueLong.get(getDiskSpaceUsed(session, v0));\n+        break;\n+      case CAST:\n+      case CONVERT: {\n+        v0 = v0.convertTo(dataType);\n+        Mode mode = database.getMode();\n+        v0 = v0.convertScale(mode.convertOnlyToSmallerScale, scale);\n+        v0 = v0.convertPrecision(getPrecision(), false);\n+        result = v0;\n+        break;\n+      }\n+      case MEMORY_FREE:\n+        session.getUser().checkAdmin();\n+        result = ValueInt.get(Utils.getMemoryFree());\n+        break;\n+      case MEMORY_USED:\n+        session.getUser().checkAdmin();\n+        result = ValueInt.get(Utils.getMemoryUsed());\n+        break;\n+      case LOCK_MODE:\n+        result = ValueInt.get(database.getLockMode());\n+        break;\n+      case SCHEMA:\n+        result = ValueString.get(session.getCurrentSchemaName(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case SESSION_ID:\n+        result = ValueInt.get(session.getId());\n+        break;\n+      case IFNULL: {\n+        result = v0;\n+        if (v0 == ValueNull.INSTANCE) {\n+          result = getNullOrValue(session, args, values, 1);\n+        }\n+        result = convertResult(result);\n+        break;\n+      }\n+      case CASEWHEN: {\n+        Value v;\n+        if (v0 == ValueNull.INSTANCE ||\n+            !v0.getBoolean().booleanValue()) {\n+          v = getNullOrValue(session, args, values, 2);\n+        } else {\n+          v = getNullOrValue(session, args, values, 1);\n+        }\n+        result = v.convertTo(dataType);\n+        break;\n+      }\n+      case DECODE: {\n+        int index = -1;\n+        for (int i = 1, len = args.length - 1; i < len; i += 2) {\n+          if (database.areEqual(v0,\n+              getNullOrValue(session, args, values, i))) {\n+            index = i + 1;\n+            break;\n+          }\n+        }\n+        if (index < 0 && args.length % 2 == 0) {\n+          index = args.length - 1;\n+        }\n+        Value v = index < 0 ? ValueNull.INSTANCE :\n+            getNullOrValue(session, args, values, index);\n+        result = v.convertTo(dataType);\n+        break;\n+      }\n+      case NVL2: {\n+        Value v;\n+        if (v0 == ValueNull.INSTANCE) {\n+          v = getNullOrValue(session, args, values, 2);\n+        } else {\n+          v = getNullOrValue(session, args, values, 1);\n         }\n-        case DECODE: {\n-            int index = -1;\n-            for (int i = 1, len = args.length - 1; i < len; i += 2) {\n-                if (database.areEqual(v0,\n-                        getNullOrValue(session, args, values, i))) {\n-                    index = i + 1;\n-                    break;\n-                }\n-            }\n-            if (index < 0 && args.length % 2 == 0) {\n-                index = args.length - 1;\n-            }\n-            Value v = index < 0 ? ValueNull.INSTANCE :\n-                    getNullOrValue(session, args, values, index);\n+        result = v.convertTo(dataType);\n+        break;\n+      }\n+      case COALESCE: {\n+        result = v0;\n+        for (int i = 0; i < args.length; i++) {\n+          Value v = getNullOrValue(session, args, values, i);\n+          if (!(v == ValueNull.INSTANCE)) {\n             result = v.convertTo(dataType);\n             break;\n+          }\n         }\n-        case NVL2: {\n-            Value v;\n-            if (v0 == ValueNull.INSTANCE) {\n-                v = getNullOrValue(session, args, values, 2);\n+        break;\n+      }\n+      case GREATEST:\n+      case LEAST: {\n+        result = ValueNull.INSTANCE;\n+        for (int i = 0; i < args.length; i++) {\n+          Value v = getNullOrValue(session, args, values, i);\n+          if (!(v == ValueNull.INSTANCE)) {\n+            v = v.convertTo(dataType);\n+            if (result == ValueNull.INSTANCE) {\n+              result = v;\n             } else {\n-                v = getNullOrValue(session, args, values, 1);\n-            }\n-            result = v.convertTo(dataType);\n-            break;\n-        }\n-        case COALESCE: {\n-            result = v0;\n-            for (int i = 0; i < args.length; i++) {\n-                Value v = getNullOrValue(session, args, values, i);\n-                if (!(v == ValueNull.INSTANCE)) {\n-                    result = v.convertTo(dataType);\n-                    break;\n-                }\n-            }\n-            break;\n-        }\n-        case GREATEST:\n-        case LEAST: {\n+              int comp = database.compareTypeSafe(result, v);\n+              if (info.type == GREATEST && comp < 0) {\n+                result = v;\n+              } else if (info.type == LEAST && comp > 0) {\n+                result = v;\n+              }\n+            }\n+          }\n+        }\n+        break;\n+      }\n+      case CASE: {\n+        Expression then = null;\n+        if (v0 == null) {\n+          // Searched CASE expression\n+          // (null, when, then)\n+          // (null, when, then, else)\n+          // (null, when, then, when, then)\n+          // (null, when, then, when, then, else)\n+          for (int i = 1, len = args.length - 1; i < len; i += 2) {\n+            Value when = args[i].getValue(session);\n+            if (!(when == ValueNull.INSTANCE) &&\n+                when.getBoolean().booleanValue()) {\n+              then = args[i + 1];\n+              break;\n+            }\n+          }\n+        } else {\n+          // Simple CASE expression\n+          // (expr, when, then)\n+          // (expr, when, then, else)\n+          // (expr, when, then, when, then)\n+          // (expr, when, then, when, then, else)\n+          if (!(v0 == ValueNull.INSTANCE)) {\n+            for (int i = 1, len = args.length - 1; i < len; i += 2) {\n+              Value when = args[i].getValue(session);\n+              if (database.areEqual(v0, when)) {\n+                then = args[i + 1];\n+                break;\n+              }\n+            }\n+          }\n+        }\n+        if (then == null && args.length % 2 == 0) {\n+          // then = elsePart\n+          then = args[args.length - 1];\n+        }\n+        Value v = then == null ? ValueNull.INSTANCE : then.getValue(session);\n+        result = v.convertTo(dataType);\n+        break;\n+      }\n+      case ARRAY_GET: {\n+        if (v0.getType() == Value.ARRAY) {\n+          Value v1 = getNullOrValue(session, args, values, 1);\n+          int element = v1.getInt();\n+          Value[] list = ((ValueArray) v0).getList();\n+          if (element < 1 || element > list.length) {\n             result = ValueNull.INSTANCE;\n-            for (int i = 0; i < args.length; i++) {\n-                Value v = getNullOrValue(session, args, values, i);\n-                if (!(v == ValueNull.INSTANCE)) {\n-                    v = v.convertTo(dataType);\n-                    if (result == ValueNull.INSTANCE) {\n-                        result = v;\n-                    } else {\n-                        int comp = database.compareTypeSafe(result, v);\n-                        if (info.type == GREATEST && comp < 0) {\n-                            result = v;\n-                        } else if (info.type == LEAST && comp > 0) {\n-                            result = v;\n-                        }\n-                    }\n-                }\n-            }\n-            break;\n-        }\n-        case CASE: {\n-            Expression then = null;\n-            if (v0 == null) {\n-                // Searched CASE expression\n-                // (null, when, then)\n-                // (null, when, then, else)\n-                // (null, when, then, when, then)\n-                // (null, when, then, when, then, else)\n-                for (int i = 1, len = args.length - 1; i < len; i += 2) {\n-                    Value when = args[i].getValue(session);\n-                    if (!(when == ValueNull.INSTANCE) &&\n-                            when.getBoolean().booleanValue()) {\n-                        then = args[i + 1];\n-                        break;\n-                    }\n-                }\n-            } else {\n-                // Simple CASE expression\n-                // (expr, when, then)\n-                // (expr, when, then, else)\n-                // (expr, when, then, when, then)\n-                // (expr, when, then, when, then, else)\n-                if (!(v0 == ValueNull.INSTANCE)) {\n-                    for (int i = 1, len = args.length - 1; i < len; i += 2) {\n-                        Value when = args[i].getValue(session);\n-                        if (database.areEqual(v0, when)) {\n-                            then = args[i + 1];\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            if (then == null && args.length % 2 == 0) {\n-                // then = elsePart\n-                then = args[args.length - 1];\n-            }\n-            Value v = then == null ? ValueNull.INSTANCE : then.getValue(session);\n-            result = v.convertTo(dataType);\n-            break;\n-        }\n-        case ARRAY_GET: {\n-            if (v0.getType() == Value.ARRAY) {\n-                Value v1 = getNullOrValue(session, args, values, 1);\n-                int element = v1.getInt();\n-                Value[] list = ((ValueArray) v0).getList();\n-                if (element < 1 || element > list.length) {\n-                    result = ValueNull.INSTANCE;\n-                } else {\n-                    result = list[element - 1];\n-                }\n-            } else {\n-                result = ValueNull.INSTANCE;\n-            }\n-            break;\n-        }\n-        case ARRAY_LENGTH: {\n-            if (v0.getType() == Value.ARRAY) {\n-                Value[] list = ((ValueArray) v0).getList();\n-                result = ValueInt.get(list.length);\n+          } else {\n+            result = list[element - 1];\n+          }\n+        } else {\n+          result = ValueNull.INSTANCE;\n+        }\n+        break;\n+      }\n+      case ARRAY_LENGTH: {\n+        if (v0.getType() == Value.ARRAY) {\n+          Value[] list = ((ValueArray) v0).getList();\n+          result = ValueInt.get(list.length);\n+        } else {\n+          result = ValueNull.INSTANCE;\n+        }\n+        break;\n+      }\n+      case ARRAY_CONTAINS: {\n+        result = ValueBoolean.get(false);\n+        if (v0.getType() == Value.ARRAY) {\n+          Value v1 = getNullOrValue(session, args, values, 1);\n+          Value[] list = ((ValueArray) v0).getList();\n+          for (Value v : list) {\n+            if (v.equals(v1)) {\n+              result = ValueBoolean.get(true);\n+              break;\n+            }\n+          }\n+        }\n+        break;\n+      }\n+      case CANCEL_SESSION: {\n+        result = ValueBoolean.get(cancelStatement(session, v0.getInt()));\n+        break;\n+      }\n+      case TRANSACTION_ID: {\n+        result = session.getTransactionId();\n+        break;\n+      }\n+      default:\n+        result = null;\n+    }\n+    return result;\n+  }\n+\n+  private Value convertResult(Value v) {\n+    return v.convertTo(dataType);\n+  }\n+\n+  private static boolean cancelStatement(Session session, int targetSessionId) {\n+    session.getUser().checkAdmin();\n+    Session[] sessions = session.getDatabase().getSessions(false);\n+    for (Session s : sessions) {\n+      if (s.getId() == targetSessionId) {\n+        Command c = s.getCurrentCommand();\n+        if (c == null) {\n+          return false;\n+        }\n+        c.cancel();\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static long getDiskSpaceUsed(Session session, Value v0) {\n+    Parser p = new Parser(session);\n+    String sql = v0.getString();\n+    Table table = p.parseTableName(sql);\n+    return table.getDiskSpaceUsed();\n+  }\n+\n+  private static Value getNullOrValue(Session session, Expression[] args,\n+                                      Value[] values, int i) {\n+    if (i >= args.length) {\n+      return null;\n+    }\n+    Value v = values[i];\n+    if (v == null) {\n+      Expression e = args[i];\n+      if (e == null) {\n+        return null;\n+      }\n+      v = values[i] = e.getValue(session);\n+    }\n+    return v;\n+  }\n+\n+  private Value getValueWithArgs(Session session, Expression[] args) {\n+    Value[] values = new Value[args.length];\n+    if (info.nullIfParameterIsNull) {\n+      for (int i = 0; i < args.length; i++) {\n+        Expression e = args[i];\n+        Value v = e.getValue(session);\n+        if (v == ValueNull.INSTANCE) {\n+          return ValueNull.INSTANCE;\n+        }\n+        values[i] = v;\n+      }\n+    }\n+    Value v0 = getNullOrValue(session, args, values, 0);\n+    Value resultSimple = getSimpleValue(session, v0, args, values);\n+    if (resultSimple != null) {\n+      return resultSimple;\n+    }\n+    Value v1 = getNullOrValue(session, args, values, 1);\n+    Value v2 = getNullOrValue(session, args, values, 2);\n+    Value v3 = getNullOrValue(session, args, values, 3);\n+    Value v4 = getNullOrValue(session, args, values, 4);\n+    Value v5 = getNullOrValue(session, args, values, 5);\n+    Value result;\n+    switch (info.type) {\n+      case ATAN2:\n+        result = ValueDouble.get(\n+            Math.atan2(v0.getDouble(), v1.getDouble()));\n+        break;\n+      case BITAND:\n+        result = ValueLong.get(v0.getLong() & v1.getLong());\n+        break;\n+      case BITGET:\n+        result = ValueBoolean.get((v0.getLong() & (1L << v1.getInt())) != 0);\n+        break;\n+      case BITOR:\n+        result = ValueLong.get(v0.getLong() | v1.getLong());\n+        break;\n+      case BITXOR:\n+        result = ValueLong.get(v0.getLong() ^ v1.getLong());\n+        break;\n+      case MOD: {\n+        long x = v1.getLong();\n+        if (x == 0) {\n+          throw DbException.get(ErrorCode.DIVISION_BY_ZERO_1, getSQL());\n+        }\n+        result = ValueLong.get(v0.getLong() % x);\n+        break;\n+      }\n+      case POWER:\n+        result = ValueDouble.get(Math.pow(\n+            v0.getDouble(), v1.getDouble()));\n+        break;\n+      case ROUND: {\n+        double f = v1 == null ? 1. : Math.pow(10., v1.getDouble());\n+\n+        double middleResult = v0.getDouble() * f;\n+\n+        int oneWithSymbol = middleResult > 0 ? 1 : -1;\n+        result = ValueDouble\n+            .get(Math.round(Math.abs(middleResult)) / f * oneWithSymbol);\n+        break;\n+      }\n+      case TRUNCATE: {\n+        if (v0.getType() == Value.TIMESTAMP) {\n+          java.sql.Timestamp d = v0.getTimestamp();\n+          Calendar c = DateTimeUtils.createGregorianCalendar();\n+          c.setTime(d);\n+          c.set(Calendar.HOUR_OF_DAY, 0);\n+          c.set(Calendar.MINUTE, 0);\n+          c.set(Calendar.SECOND, 0);\n+          c.set(Calendar.MILLISECOND, 0);\n+          result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n+        } else if (v0.getType() == Value.DATE) {\n+          ValueDate vd = (ValueDate) v0;\n+          Calendar c = DateTimeUtils.createGregorianCalendar();\n+          c.setTime(vd.getDate());\n+          c.set(Calendar.HOUR_OF_DAY, 0);\n+          c.set(Calendar.MINUTE, 0);\n+          c.set(Calendar.SECOND, 0);\n+          c.set(Calendar.MILLISECOND, 0);\n+          result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n+        } else if (v0.getType() == Value.STRING) {\n+          ValueString vd = (ValueString) v0;\n+          Calendar c = DateTimeUtils.createGregorianCalendar();\n+          c.setTime(ValueTimestamp\n+              .parse(vd.getString(), session.getDatabase().getMode())\n+              .getDate());\n+          c.set(Calendar.HOUR_OF_DAY, 0);\n+          c.set(Calendar.MINUTE, 0);\n+          c.set(Calendar.SECOND, 0);\n+          c.set(Calendar.MILLISECOND, 0);\n+          result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n+        } else {\n+          double d = v0.getDouble();\n+          int p = v1 == null ? 0 : v1.getInt();\n+          double f = Math.pow(10., p);\n+          double g = d * f;\n+          result =\n+              ValueDouble.get(((d < 0) ? Math.ceil(g) : Math.floor(g)) / f);\n+        }\n+        break;\n+      }\n+      case HASH:\n+        result = ValueBytes.getNoCopy(getHash(v0.getString(),\n+            v1.getBytesNoCopy(), v2.getInt()));\n+        break;\n+      case ENCRYPT:\n+        result = ValueBytes.getNoCopy(encrypt(v0.getString(),\n+            v1.getBytesNoCopy(), v2.getBytesNoCopy()));\n+        break;\n+      case DECRYPT:\n+        result = ValueBytes.getNoCopy(decrypt(v0.getString(),\n+            v1.getBytesNoCopy(), v2.getBytesNoCopy()));\n+        break;\n+      case COMPRESS: {\n+        String algorithm = null;\n+        if (v1 != null) {\n+          algorithm = v1.getString();\n+        }\n+        result = ValueBytes.getNoCopy(CompressTool.getInstance().\n+            compress(v0.getBytesNoCopy(), algorithm));\n+        break;\n+      }\n+      case DIFFERENCE:\n+        result = ValueInt.get(getDifference(\n+            v0.getString(), v1.getString()));\n+        break;\n+      case INSERT: {\n+        if (v1 == ValueNull.INSTANCE || v2 == ValueNull.INSTANCE) {\n+          result = v1;\n+        } else {\n+          result = ValueString.get(insert(v0.getString(),\n+              v1.getInt(), v2.getInt(), v3.getString()),\n+              database.getMode().treatEmptyStringsAsNull);\n+        }\n+        break;\n+      }\n+      case LEFT:\n+        result = ValueString.get(left(v0.getString(), v1.getInt()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case LOCATE: {\n+        int start = v2 == null ? 0 : v2.getInt();\n+        result = ValueInt.get(locate(v0.getString(), v1.getString(), start));\n+        break;\n+      }\n+      case INSTR: {\n+        int start = v2 == null ? 0 : v2.getInt();\n+        result = ValueInt.get(locate(v1.getString(), v0.getString(), start));\n+        break;\n+      }\n+      case REPEAT: {\n+        int count = Math.max(0, v1.getInt());\n+        result = ValueString.get(repeat(v0.getString(), count),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case REPLACE: {\n+        if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE\n+            || v2 == ValueNull.INSTANCE &&\n+            database.getMode() != Mode.getOracle()) {\n+          result = ValueNull.INSTANCE;\n+        } else {\n+          String s0 = v0.getString();\n+          String s1 = v1.getString();\n+          String s2 = (v2 == null) ? \"\" : v2.getString();\n+          if (s2 == null) {\n+            s2 = \"\";\n+          }\n+          result = ValueString.get(replace(s0, s1, s2),\n+              database.getMode().treatEmptyStringsAsNull);\n+        }\n+        break;\n+      }\n+      case RIGHT:\n+        result = ValueString.get(right(v0.getString(), v1.getInt()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case LTRIM:\n+        result = ValueString.get(StringUtils.trim(v0.getString(),\n+            true, false, v1 == null ? \" \" : v1.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case TRIM:\n+        result = ValueString.get(StringUtils.trim(v0.getString(),\n+            true, true, v1 == null ? \" \" : v1.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case RTRIM:\n+        result = ValueString.get(StringUtils.trim(v0.getString(),\n+            false, true, v1 == null ? \" \" : v1.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case SUBSTR:\n+      case SUBSTRING: {\n+        String s = v0.getString();\n+        int offset = v1.getInt();\n+        if (offset < 0) {\n+          offset = s.length() + offset + 1;\n+        }\n+        int length = v2 == null ? s.length() : v2.getInt();\n+        result = ValueString.get(substring(s, offset, length),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case POSITION:\n+        result = ValueInt.get(locate(v0.getString(), v1.getString(), 0));\n+        break;\n+      case XMLATTR:\n+        result = ValueString.get(\n+            StringUtils.xmlAttr(v0.getString(), v1.getString()),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case XMLNODE: {\n+        String attr = v1 == null ?\n+            null : v1 == ValueNull.INSTANCE ? null : v1.getString();\n+        String content = v2 == null ?\n+            null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n+        boolean indent = v3 == null ?\n+            true : v3.getBoolean();\n+        result = ValueString.get(StringUtils.xmlNode(\n+            v0.getString(), attr, content, indent),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case REGEXP_REPLACE: {\n+        String regexp = v1.getString();\n+        String replacement = v2.getString();\n+        String regexpMode = v3 == null || v3.getString() == null ? \"\" :\n+            v3.getString();\n+        int flags = makeRegexpFlags(regexpMode);\n+        try {\n+          result = ValueString.get(\n+              Pattern.compile(regexp, flags).matcher(v0.getString())\n+                  .replaceAll(replacement),\n+              database.getMode().treatEmptyStringsAsNull);\n+        } catch (StringIndexOutOfBoundsException e) {\n+          throw DbException.get(\n+              ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n+        } catch (PatternSyntaxException e) {\n+          throw DbException.get(\n+              ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n+        } catch (IllegalArgumentException e) {\n+          throw DbException.get(\n+              ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n+        }\n+        break;\n+      }\n+      case RPAD:\n+        result = ValueString.get(StringUtils.pad(v0.getString(),\n+            v1.getInt(), v2 == null ? null : v2.getString(), true),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case LPAD:\n+        result = ValueString.get(StringUtils.pad(v0.getString(),\n+            v1.getInt(), v2 == null ? null : v2.getString(), false),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case ORA_HASH:\n+        result = ValueLong.get(oraHash(v0.getString(),\n+            v1 == null ? null : v1.getInt(),\n+            v2 == null ? null : v2.getInt()));\n+        break;\n+      case TO_CHAR:\n+        switch (v0.getType()) {\n+          case Value.TIME:\n+          case Value.DATE:\n+          case Value.TIMESTAMP:\n+            result = ValueString.get(ToChar.toChar(v0.getTimestamp(),\n+                v1 == null ? null : v1.getString(),\n+                v2 == null ? null : v2.getString()),\n+                database.getMode().treatEmptyStringsAsNull);\n+            break;\n+          case Value.SHORT:\n+          case Value.INT:\n+          case Value.LONG:\n+          case Value.DECIMAL:\n+          case Value.DOUBLE:\n+          case Value.FLOAT:\n+            result = ValueString.get(ToChar.toChar(v0.getBigDecimal(),\n+                v1 == null ? null : v1.getString(),\n+                v2 == null ? null : v2.getString()),\n+                database.getMode().treatEmptyStringsAsNull);\n+            break;\n+          default:\n+            result = ValueString.get(v0.getString(),\n+                database.getMode().treatEmptyStringsAsNull);\n+        }\n+        break;\n+      case TO_DATE:\n+        result = ValueTimestamp.get(ToDateParser.toDate(v0.getString(),\n+            v1 == null ? null : v1.getString()));\n+        break;\n+      case TO_TIMESTAMP:\n+        result = ValueTimestamp.get(ToDateParser.toTimestamp(v0.getString(),\n+            v1 == null ? null : v1.getString()));\n+        break;\n+      case ADD_MONTHS:\n+        result = ValueTimestamp\n+            .get(DateTimeUtils.addMonths(v0.getTimestamp(), v1.getInt()));\n+        break;\n+      case TRANSLATE: {\n+        String matching = v1.getString();\n+        String replacement = v2.getString();\n+        result = ValueString.get(\n+            translate(v0.getString(), matching, replacement),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      }\n+      case H2VERSION:\n+        result = ValueString.get(Constants.getVersion(),\n+            database.getMode().treatEmptyStringsAsNull);\n+        break;\n+      case DATE_ADD:\n+        result = ValueTimestamp.get(dateadd(\n+            v0.getString(), v1.getLong(), v2.getTimestamp()));\n+        break;\n+      case DATE_DIFF:\n+        result = ValueLong.get(datediff(\n+            v0.getString(), v1.getTimestamp(), v2.getTimestamp()));\n+        break;\n+      case EXTRACT: {\n+        int field = getDatePart(v0.getString());\n+        result = ValueInt.get(DateTimeUtils.getDatePart(\n+            v1.getTimestamp(), field));\n+        break;\n+      }\n+      case FORMATDATETIME: {\n+        if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE) {\n+          result = ValueNull.INSTANCE;\n+        } else {\n+          String locale = v2 == null ?\n+              null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n+          String tz = v3 == null ?\n+              null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n+          result = ValueString.get(DateTimeUtils.formatDateTime(\n+              v0.getTimestamp(), v1.getString(), locale, tz),\n+              database.getMode().treatEmptyStringsAsNull);\n+        }\n+        break;\n+      }\n+      case PARSEDATETIME: {\n+        if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE) {\n+          result = ValueNull.INSTANCE;\n+        } else {\n+          String locale = v2 == null ?\n+              null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n+          String tz = v3 == null ?\n+              null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n+          java.util.Date d = DateTimeUtils.parseDateTime(\n+              v0.getString(), v1.getString(), locale, tz);\n+          result = ValueTimestamp.fromMillis(d.getTime());\n+        }\n+        break;\n+      }\n+      case NULLIF:\n+        result = database.areEqual(v0, v1) ? ValueNull.INSTANCE : v0;\n+        break;\n+      // system\n+      case NEXTVAL: {\n+        Sequence sequence = getSequence(session, v0, v1);\n+        SequenceValue value = new SequenceValue(sequence);\n+        result = value.getValue(session);\n+        break;\n+      }\n+      case CURRVAL: {\n+        Sequence sequence = getSequence(session, v0, v1);\n+        result = ValueLong.get(sequence.getCurrentValue());\n+        break;\n+      }\n+      case CSVREAD: {\n+        String fileName = v0.getString();\n+        String columnList = v1 == null ? null : v1.getString();\n+        Csv csv = new Csv();\n+        String options = v2 == null ? null : v2.getString();\n+        String charset = null;\n+        if (options != null && options.indexOf('=') >= 0) {\n+          charset = csv.setOptions(options);\n+        } else {\n+          charset = options;\n+          String fieldSeparatorRead = v3 == null ? null : v3.getString();\n+          String fieldDelimiter = v4 == null ? null : v4.getString();\n+          String escapeCharacter = v5 == null ? null : v5.getString();\n+          Value v6 = getNullOrValue(session, args, values, 6);\n+          String nullString = v6 == null ? null : v6.getString();\n+          setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter,\n+              escapeCharacter);\n+          csv.setNullString(nullString);\n+        }\n+        char fieldSeparator = csv.getFieldSeparatorRead();\n+        String[] columns = StringUtils.arraySplit(columnList,\n+            fieldSeparator, true);\n+        try {\n+          ValueResultSet vr = ValueResultSet.get(csv.read(fileName,\n+              columns, charset));\n+          result = vr;\n+        } catch (SQLException e) {\n+          throw DbException.convert(e);\n+        }\n+        break;\n+      }\n+      case LINK_SCHEMA: {\n+        session.getUser().checkAdmin();\n+        Connection conn = session.createConnection(false);\n+        ResultSet rs = LinkSchema.linkSchema(conn, v0.getString(),\n+            v1.getString(), v2.getString(), v3.getString(),\n+            v4.getString(), v5.getString());\n+        result = ValueResultSet.get(rs);\n+        break;\n+      }\n+      case CSVWRITE: {\n+        session.getUser().checkAdmin();\n+        Connection conn = session.createConnection(false);\n+        Csv csv = new Csv();\n+        String options = v2 == null ? null : v2.getString();\n+        String charset = null;\n+        if (options != null && options.indexOf('=') >= 0) {\n+          charset = csv.setOptions(options);\n+        } else {\n+          charset = options;\n+          String fieldSeparatorWrite = v3 == null ? null : v3.getString();\n+          String fieldDelimiter = v4 == null ? null : v4.getString();\n+          String escapeCharacter = v5 == null ? null : v5.getString();\n+          Value v6 = getNullOrValue(session, args, values, 6);\n+          String nullString = v6 == null ? null : v6.getString();\n+          Value v7 = getNullOrValue(session, args, values, 7);\n+          String lineSeparator = v7 == null ? null : v7.getString();\n+          setCsvDelimiterEscape(csv, fieldSeparatorWrite, fieldDelimiter,\n+              escapeCharacter);\n+          csv.setNullString(nullString);\n+          if (lineSeparator != null) {\n+            csv.setLineSeparator(lineSeparator);\n+          }\n+        }\n+        try {\n+          int rows = csv.write(conn, v0.getString(), v1.getString(),\n+              charset);\n+          result = ValueInt.get(rows);\n+        } catch (SQLException e) {\n+          throw DbException.convert(e);\n+        }\n+        break;\n+      }\n+      case SET: {\n+        Variable var = (Variable) args[0];\n+        session.setVariable(var.getName(), v1);\n+        result = v1;\n+        break;\n+      }\n+      case FILE_READ: {\n+        session.getUser().checkAdmin();\n+        String fileName = v0.getString();\n+        boolean blob = args.length == 1;\n+        try {\n+          long fileLength = FileUtils.size(fileName);\n+          InputStream in = new AutoCloseInputStream(\n+              FileUtils.newInputStream(fileName));\n+          if (blob) {\n+            result = database.getLobStorage().createBlob(in, fileLength);\n+          } else {\n+            Reader reader;\n+            if (v1 == ValueNull.INSTANCE) {\n+              reader = new InputStreamReader(in);\n             } else {\n-                result = ValueNull.INSTANCE;\n-            }\n-            break;\n-        }\n-        case ARRAY_CONTAINS: {\n-            result = ValueBoolean.get(false);\n-            if (v0.getType() == Value.ARRAY) {\n-                Value v1 = getNullOrValue(session, args, values, 1);\n-                Value[] list = ((ValueArray) v0).getList();\n-                for (Value v : list) {\n-                    if (v.equals(v1)) {\n-                        result = ValueBoolean.get(true);\n-                        break;\n-                    }\n-                }\n+              reader = new InputStreamReader(in, v1.getString());\n             }\n-            break;\n-        }\n-        case CANCEL_SESSION: {\n-            result = ValueBoolean.get(cancelStatement(session, v0.getInt()));\n-            break;\n-        }\n-        case TRANSACTION_ID: {\n-            result = session.getTransactionId();\n-            break;\n-        }\n-        default:\n-            result = null;\n+            result = database.getLobStorage().createClob(reader, fileLength);\n+          }\n+          session.addTemporaryLob(result);\n+        } catch (IOException e) {\n+          throw DbException.convertIOException(e, fileName);\n         }\n-        return result;\n-    }\n-\n-    private Value convertResult(Value v) {\n-        return v.convertTo(dataType);\n-    }\n-\n-    private static boolean cancelStatement(Session session, int targetSessionId) {\n+        break;\n+      }\n+      case FILE_WRITE: {\n         session.getUser().checkAdmin();\n-        Session[] sessions = session.getDatabase().getSessions(false);\n-        for (Session s : sessions) {\n-            if (s.getId() == targetSessionId) {\n-                Command c = s.getCurrentCommand();\n-                if (c == null) {\n-                    return false;\n-                }\n-                c.cancel();\n-                return true;\n-            }\n+        result = ValueNull.INSTANCE;\n+        String fileName = v1.getString();\n+        try {\n+          FileOutputStream fileOutputStream = new FileOutputStream(fileName);\n+          try (InputStream in = v0.getInputStream()) {\n+            result = ValueLong.get(IOUtils.copyAndClose(in,\n+                fileOutputStream));\n+          }\n+        } catch (IOException e) {\n+          throw DbException.convertIOException(e, fileName);\n+        }\n+        break;\n+      }\n+      case TRUNCATE_VALUE: {\n+        result = v0.convertPrecision(v1.getLong(), v2.getBoolean());\n+        break;\n+      }\n+      case XMLTEXT:\n+        if (v1 == null) {\n+          result = ValueString.get(StringUtils.xmlText(\n+              v0.getString()),\n+              database.getMode().treatEmptyStringsAsNull);\n+        } else {\n+          result = ValueString.get(StringUtils.xmlText(\n+              v0.getString(), v1.getBoolean()),\n+              database.getMode().treatEmptyStringsAsNull);\n+        }\n+        break;\n+      case REGEXP_LIKE: {\n+        String regexp = v1.getString();\n+        String regexpMode = v2 == null || v2.getString() == null ? \"\" :\n+            v2.getString();\n+        int flags = makeRegexpFlags(regexpMode);\n+        try {\n+          result = ValueBoolean.get(Pattern.compile(regexp, flags)\n+              .matcher(v0.getString()).find());\n+        } catch (PatternSyntaxException e) {\n+          throw DbException.get(ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n+        }\n+        break;\n+      }\n+      case VALUES:\n+        result = session.getVariable(args[0].getSchemaName() + \".\" +\n+            args[0].getTableName() + \".\" + args[0].getColumnName());\n+        break;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + info.type);\n+    }\n+    return result;\n+  }\n+\n+  private Sequence getSequence(Session session, Value v0, Value v1) {\n+    String schemaName, sequenceName;\n+    if (v1 == null) {\n+      Parser p = new Parser(session);\n+      String sql = v0.getString();\n+      Expression expr = p.parseExpression(sql);\n+      if (expr instanceof ExpressionColumn) {\n+        ExpressionColumn seq = (ExpressionColumn) expr;\n+        schemaName = seq.getOriginalTableAliasName();\n+        if (schemaName == null) {\n+          schemaName = session.getCurrentSchemaName();\n+          sequenceName = sql;\n+        } else {\n+          sequenceName = seq.getColumnName();\n+        }\n+      } else {\n+        throw DbException.getSyntaxError(sql, 1);\n+      }\n+    } else {\n+      schemaName = v0.getString();\n+      sequenceName = v1.getString();\n+    }\n+    Schema s = database.findSchema(schemaName);\n+    if (s == null) {\n+      schemaName = StringUtils.toUpperEnglish(schemaName);\n+      s = database.getSchema(schemaName);\n+    }\n+    Sequence seq = s.findSequence(sequenceName);\n+    if (seq == null) {\n+      sequenceName = StringUtils.toUpperEnglish(sequenceName);\n+      seq = s.getSequence(sequenceName);\n+    }\n+    return seq;\n+  }\n+\n+  private static long length(Value v) {\n+    switch (v.getType()) {\n+      case Value.BLOB:\n+      case Value.CLOB:\n+      case Value.BYTES:\n+      case Value.JAVA_OBJECT:\n+        return v.getPrecision();\n+      default:\n+        return v.getString().length();\n+    }\n+  }\n+\n+  private static byte[] getPaddedArrayCopy(byte[] data, int blockSize) {\n+    int size = MathUtils.roundUpInt(data.length, blockSize);\n+    byte[] newData = DataUtils.newBytes(size);\n+    System.arraycopy(data, 0, newData, 0, data.length);\n+    return newData;\n+  }\n+\n+  private static byte[] decrypt(String algorithm, byte[] key, byte[] data) {\n+    BlockCipher cipher = CipherFactory.getBlockCipher(algorithm);\n+    byte[] newKey = getPaddedArrayCopy(key, cipher.getKeyLength());\n+    cipher.setKey(newKey);\n+    byte[] newData = getPaddedArrayCopy(data, BlockCipher.ALIGN);\n+    cipher.decrypt(newData, 0, newData.length);\n+    return newData;\n+  }\n+\n+  private static byte[] encrypt(String algorithm, byte[] key, byte[] data) {\n+    BlockCipher cipher = CipherFactory.getBlockCipher(algorithm);\n+    byte[] newKey = getPaddedArrayCopy(key, cipher.getKeyLength());\n+    cipher.setKey(newKey);\n+    byte[] newData = getPaddedArrayCopy(data, BlockCipher.ALIGN);\n+    cipher.encrypt(newData, 0, newData.length);\n+    return newData;\n+  }\n+\n+  private static byte[] getHash(String algorithm, byte[] bytes,\n+                                int iterations) {\n+    if (!\"SHA256\".equalsIgnoreCase(algorithm)) {\n+      throw DbException.getInvalidValueException(\"algorithm\", algorithm);\n+    }\n+    for (int i = 0; i < iterations; i++) {\n+      bytes = SHA256.getHash(bytes, false);\n+    }\n+    return bytes;\n+  }\n+\n+  /**\n+   * Check if a given string is a valid date part string.\n+   *\n+   * @param part the string\n+   * @return true if it is\n+   */\n+  public static boolean isDatePart(String part) {\n+    Integer p = DATE_PART.get(StringUtils.toUpperEnglish(part));\n+    return p != null;\n+  }\n+\n+  private static int getDatePart(String part) {\n+    Integer p = DATE_PART.get(StringUtils.toUpperEnglish(part));\n+    if (p == null) {\n+      throw DbException.getInvalidValueException(\"date part\", part);\n+    }\n+    return p.intValue();\n+  }\n+\n+  private static Timestamp dateadd(String part, long count, Timestamp d) {\n+    int field = getDatePart(part);\n+    if (field == Calendar.MILLISECOND) {\n+      Timestamp ts = new Timestamp(d.getTime() + count);\n+      ts.setNanos(ts.getNanos() + (d.getNanos() % 1000000));\n+      return ts;\n+    }\n+    // We allow long for manipulating the millisecond component,\n+    // for the rest we only allow int.\n+    if (count > Integer.MAX_VALUE) {\n+      throw DbException.getInvalidValueException(\"DATEADD count\", count);\n+    }\n+    Calendar calendar = DateTimeUtils.createGregorianCalendar();\n+    int nanos = d.getNanos() % 1000000;\n+    calendar.setTime(d);\n+    calendar.add(field, (int) count);\n+    long t = calendar.getTime().getTime();\n+    Timestamp ts = new Timestamp(t);\n+    ts.setNanos(ts.getNanos() + nanos);\n+    return ts;\n+  }\n+\n+  /**\n+   * Calculate the number of crossed unit boundaries between two timestamps.\n+   * This method is supported for MS SQL Server compatibility.\n+   * <pre>\n+   * DATEDIFF(YEAR, '2004-12-31', '2005-01-01') = 1\n+   * </pre>\n+   *\n+   * @param part the part\n+   * @param d1   the first date\n+   * @param d2   the second date\n+   * @return the number of crossed boundaries\n+   */\n+  private static long datediff(String part, Timestamp d1, Timestamp d2) {\n+    int field = getDatePart(part);\n+    Calendar calendar = DateTimeUtils.createGregorianCalendar();\n+    long t1 = d1.getTime(), t2 = d2.getTime();\n+    // need to convert to UTC, otherwise we get inconsistent results with\n+    // certain time zones (those that are 30 minutes off)\n+    TimeZone zone = calendar.getTimeZone();\n+    calendar.setTime(d1);\n+    t1 += zone.getOffset(calendar.get(Calendar.ERA),\n+        calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.DAY_OF_WEEK),\n+        calendar.get(Calendar.MILLISECOND));\n+    calendar.setTime(d2);\n+    t2 += zone.getOffset(calendar.get(Calendar.ERA),\n+        calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.DAY_OF_WEEK),\n+        calendar.get(Calendar.MILLISECOND));\n+    switch (field) {\n+      case Calendar.MILLISECOND:\n+        return t2 - t1;\n+      case Calendar.SECOND:\n+      case Calendar.MINUTE:\n+      case Calendar.HOUR_OF_DAY:\n+      case Calendar.DAY_OF_YEAR:\n+      case Calendar.WEEK_OF_YEAR: {\n+        // first 'normalize' the numbers so both are not negative\n+        long hour = 60 * 60 * 1000;\n+        long add = Math.min(t1 / hour * hour, t2 / hour * hour);\n+        t1 -= add;\n+        t2 -= add;\n+        switch (field) {\n+          case Calendar.SECOND:\n+            return t2 / 1000 - t1 / 1000;\n+          case Calendar.MINUTE:\n+            return t2 / (60 * 1000) - t1 / (60 * 1000);\n+          case Calendar.HOUR_OF_DAY:\n+            return t2 / hour - t1 / hour;\n+          case Calendar.DAY_OF_YEAR:\n+            return t2 / (hour * 24) - t1 / (hour * 24);\n+          case Calendar.WEEK_OF_YEAR:\n+            return t2 / (hour * 24 * 7) - t1 / (hour * 24 * 7);\n+          default:\n+            throw DbException.throwInternalError(\"field:\" + field);\n+        }\n+      }\n+      case Calendar.DATE:\n+        return t2 / (24 * 60 * 60 * 1000) - t1 / (24 * 60 * 60 * 1000);\n+      default:\n+        break;\n+    }\n+    calendar =\n+        DateTimeUtils.createGregorianCalendar(TimeZone.getTimeZone(\"UTC\"));\n+    calendar.setTimeInMillis(t1);\n+    int year1 = calendar.get(Calendar.YEAR);\n+    int month1 = calendar.get(Calendar.MONTH);\n+    calendar.setTimeInMillis(t2);\n+    int year2 = calendar.get(Calendar.YEAR);\n+    int month2 = calendar.get(Calendar.MONTH);\n+    int result = year2 - year1;\n+    if (field == Calendar.MONTH) {\n+      return 12 * result + (month2 - month1);\n+    } else if (field == Calendar.YEAR) {\n+      return result;\n+    } else {\n+      throw DbException.getUnsupportedException(\"DATEDIFF \" + part);\n+    }\n+  }\n+\n+  private static String substring(String s, int start, int length) {\n+    int len = s.length();\n+    start--;\n+    if (start < 0) {\n+      start = 0;\n+    }\n+    if (length < 0) {\n+      length = 0;\n+    }\n+    start = (start > len) ? len : start;\n+    if (start + length > len) {\n+      length = len - start;\n+    }\n+    return s.substring(start, start + length);\n+  }\n+\n+  private static String replace(String s, String replace, String with) {\n+    if (s == null || replace == null || with == null) {\n+      return null;\n+    }\n+    if (replace.length() == 0) {\n+      // avoid out of memory\n+      return s;\n+    }\n+    StringBuilder buff = new StringBuilder(s.length());\n+    int start = 0;\n+    int len = replace.length();\n+    while (true) {\n+      int i = s.indexOf(replace, start);\n+      if (i == -1) {\n+        break;\n+      }\n+      buff.append(s.substring(start, i)).append(with);\n+      start = i + len;\n+    }\n+    buff.append(s.substring(start));\n+    return buff.toString();\n+  }\n+\n+  private static String repeat(String s, int count) {\n+    StringBuilder buff = new StringBuilder(s.length() * count);\n+    while (count-- > 0) {\n+      buff.append(s);\n+    }\n+    return buff.toString();\n+  }\n+\n+  private static String rawToHex(String s) {\n+    int length = s.length();\n+    StringBuilder buff = new StringBuilder(4 * length);\n+    for (int i = 0; i < length; i++) {\n+      String hex = Integer.toHexString(s.charAt(i) & 0xffff);\n+      for (int j = hex.length(); j < 4; j++) {\n+        buff.append('0');\n+      }\n+      buff.append(hex);\n+    }\n+    return buff.toString();\n+  }\n+\n+  private static int locate(String search, String s, int start) {\n+    if (start < 0) {\n+      int i = s.length() + start;\n+      return s.lastIndexOf(search, i) + 1;\n+    }\n+    int i = (start == 0) ? 0 : start - 1;\n+    return s.indexOf(search, i) + 1;\n+  }\n+\n+  private static String right(String s, int count) {\n+    if (count < 0) {\n+      count = 0;\n+    } else if (count > s.length()) {\n+      count = s.length();\n+    }\n+    return s.substring(s.length() - count);\n+  }\n+\n+  private static String left(String s, int count) {\n+    if (count < 0) {\n+      count = 0;\n+    } else if (count > s.length()) {\n+      count = s.length();\n+    }\n+    return s.substring(0, count);\n+  }\n+\n+  private static String insert(String s1, int start, int length, String s2) {\n+    if (s1 == null) {\n+      return s2;\n+    }\n+    if (s2 == null) {\n+      return s1;\n+    }\n+    int len1 = s1.length();\n+    int len2 = s2.length();\n+    start--;\n+    if (start < 0 || length <= 0 || len2 == 0 || start > len1) {\n+      return s1;\n+    }\n+    if (start + length > len1) {\n+      length = len1 - start;\n+    }\n+    return s1.substring(0, start) + s2 + s1.substring(start + length);\n+  }\n+\n+  private static String hexToRaw(String s) {\n+    // TODO function hextoraw compatibility with oracle\n+    int len = s.length();\n+    if (len % 4 != 0) {\n+      throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1, s);\n+    }\n+    StringBuilder buff = new StringBuilder(len / 4);\n+    for (int i = 0; i < len; i += 4) {\n+      try {\n+        char raw = (char) Integer.parseInt(s.substring(i, i + 4), 16);\n+        buff.append(raw);\n+      } catch (NumberFormatException e) {\n+        throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1, s);\n+      }\n+    }\n+    return buff.toString();\n+  }\n+\n+  private static int getDifference(String s1, String s2) {\n+    // TODO function difference: compatibility with SQL Server and HSQLDB\n+    s1 = getSoundex(s1);\n+    s2 = getSoundex(s2);\n+    int e = 0;\n+    for (int i = 0; i < 4; i++) {\n+      if (s1.charAt(i) == s2.charAt(i)) {\n+        e++;\n+      }\n+    }\n+    return e;\n+  }\n+\n+  private static String translate(String original, String findChars,\n+                                  String replaceChars) {\n+    if (StringUtils.isNullOrEmpty(original) ||\n+        StringUtils.isNullOrEmpty(findChars)) {\n+      return original;\n+    }\n+    // if it stays null, then no replacements have been made\n+    StringBuilder buff = null;\n+    // if shorter than findChars, then characters are removed\n+    // (if null, we don't access replaceChars at all)\n+    int replaceSize = replaceChars == null ? 0 : replaceChars.length();\n+    for (int i = 0, size = original.length(); i < size; i++) {\n+      char ch = original.charAt(i);\n+      int index = findChars.indexOf(ch);\n+      if (index >= 0) {\n+        if (buff == null) {\n+          buff = new StringBuilder(size);\n+          if (i > 0) {\n+            buff.append(original.substring(0, i));\n+          }\n+        }\n+        if (index < replaceSize) {\n+          ch = replaceChars.charAt(index);\n+        }\n+      }\n+      if (buff != null) {\n+        buff.append(ch);\n+      }\n+    }\n+    return buff == null ? original : buff.toString();\n+  }\n+\n+  private static double roundMagic(double d) {\n+    if ((d < 0.0000000000001) && (d > -0.0000000000001)) {\n+      return 0.0;\n+    }\n+    if ((d > 1000000000000.) || (d < -1000000000000.)) {\n+      return d;\n+    }\n+    StringBuilder s = new StringBuilder();\n+    s.append(d);\n+    if (s.toString().indexOf('E') >= 0) {\n+      return d;\n+    }\n+    int len = s.length();\n+    if (len < 16) {\n+      return d;\n+    }\n+    if (s.toString().indexOf('.') > len - 3) {\n+      return d;\n+    }\n+    s.delete(len - 2, len);\n+    len -= 2;\n+    char c1 = s.charAt(len - 2);\n+    char c2 = s.charAt(len - 3);\n+    char c3 = s.charAt(len - 4);\n+    if ((c1 == '0') && (c2 == '0') && (c3 == '0')) {\n+      s.setCharAt(len - 1, '0');\n+    } else if ((c1 == '9') && (c2 == '9') && (c3 == '9')) {\n+      s.setCharAt(len - 1, '9');\n+      s.append('9');\n+      s.append('9');\n+      s.append('9');\n+    }\n+    return Double.parseDouble(s.toString());\n+  }\n+\n+  private static String getSoundex(String s) {\n+    int len = s.length();\n+    char[] chars = {'0', '0', '0', '0'};\n+    char lastDigit = '0';\n+    for (int i = 0, j = 0; i < len && j < 4; i++) {\n+      char c = s.charAt(i);\n+      char newDigit = c > SOUNDEX_INDEX.length ?\n+          0 : SOUNDEX_INDEX[c];\n+      if (newDigit != 0) {\n+        if (j == 0) {\n+          chars[j++] = c;\n+          lastDigit = newDigit;\n+        } else if (newDigit <= '6') {\n+          if (newDigit != lastDigit) {\n+            chars[j++] = newDigit;\n+            lastDigit = newDigit;\n+          }\n+        } else if (newDigit == '7') {\n+          lastDigit = newDigit;\n+        }\n+      }\n+    }\n+    return new String(chars);\n+  }\n+\n+  private static Integer oraHash(String s, Integer bucket, Integer seed) {\n+    int hc = s.hashCode();\n+    if (seed != null && seed.intValue() != 0) {\n+      hc *= seed.intValue() * 17;\n+    }\n+    if (bucket == null || bucket.intValue() <= 0) {\n+      // do nothing\n+    } else {\n+      hc %= bucket.intValue();\n+    }\n+    return hc;\n+  }\n+\n+  private static int makeRegexpFlags(String stringFlags) {\n+    int flags = Pattern.UNICODE_CASE;\n+    if (stringFlags != null) {\n+      for (int i = 0; i < stringFlags.length(); ++i) {\n+        switch (stringFlags.charAt(i)) {\n+          case 'i':\n+            flags |= Pattern.CASE_INSENSITIVE;\n+            break;\n+          case 'c':\n+            flags &= ~Pattern.CASE_INSENSITIVE;\n+            break;\n+          case 'n':\n+            flags |= Pattern.DOTALL;\n+            break;\n+          case 'm':\n+            flags |= Pattern.MULTILINE;\n+            break;\n+          default:\n+            throw DbException.get(ErrorCode.INVALID_VALUE_2, stringFlags);\n+        }\n+      }\n+    }\n+    return flags;\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return dataType;\n+  }\n+\n+  @Override\n+  public void mapColumns(ColumnResolver resolver, int level) {\n+    for (Expression e : args) {\n+      if (e != null) {\n+        e.mapColumns(resolver, level);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Check if the parameter count is correct.\n+   *\n+   * @param len the number of parameters set\n+   * @throws DbException if the parameter count is incorrect\n+   */\n+  protected void checkParameterCount(int len) {\n+    int min = 0, max = Integer.MAX_VALUE;\n+    switch (info.type) {\n+      case COALESCE:\n+      case CSVREAD:\n+      case LEAST:\n+      case GREATEST:\n+        min = 1;\n+        break;\n+      case NOW:\n+      case CURRENT_TIMESTAMP:\n+      case RAND:\n+        max = 1;\n+        break;\n+      case COMPRESS:\n+      case LTRIM:\n+      case RTRIM:\n+      case TRIM:\n+      case FILE_READ:\n+      case ROUND:\n+      case XMLTEXT:\n+      case TRUNCATE:\n+      case TO_TIMESTAMP:\n+        min = 1;\n+        max = 2;\n+        break;\n+      case TO_CHAR:\n+      case TO_DATE:\n+        min = 1;\n+        max = 3;\n+        break;\n+      case ORA_HASH:\n+        min = 1;\n+        max = 3;\n+        break;\n+      case REPLACE:\n+      case LOCATE:\n+      case INSTR:\n+      case SUBSTR:\n+      case SUBSTRING:\n+      case LPAD:\n+      case RPAD:\n+        min = 2;\n+        max = 3;\n+        break;\n+      case CONCAT:\n+      case CONCAT_WS:\n+      case CSVWRITE:\n+        min = 2;\n+        break;\n+      case XMLNODE:\n+        min = 1;\n+        max = 4;\n+        break;\n+      case FORMATDATETIME:\n+      case PARSEDATETIME:\n+        min = 2;\n+        max = 4;\n+        break;\n+      case CURRVAL:\n+      case NEXTVAL:\n+        min = 1;\n+        max = 2;\n+        break;\n+      case DECODE:\n+      case CASE:\n+        min = 3;\n+        break;\n+      case REGEXP_REPLACE:\n+        min = 3;\n+        max = 4;\n+        break;\n+      case REGEXP_LIKE:\n+        min = 2;\n+        max = 3;\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + info.type);\n+    }\n+    boolean ok = (len >= min) && (len <= max);\n+    if (!ok) {\n+      throw DbException.get(\n+          ErrorCode.INVALID_PARAMETER_COUNT_2,\n+          info.name, min + \"..\" + max);\n+    }\n+  }\n+\n+  /**\n+   * This method is called after all the parameters have been set.\n+   * It checks if the parameter count is correct.\n+   *\n+   * @throws DbException if the parameter count is incorrect.\n+   */\n+  public void doneWithParameters() {\n+    if (info.parameterCount == VAR_ARGS) {\n+      int len = varArgs.size();\n+      checkParameterCount(len);\n+      args = new Expression[len];\n+      varArgs.toArray(args);\n+      varArgs = null;\n+    } else {\n+      int len = args.length;\n+      if (len > 0 && args[len - 1] == null) {\n+        throw DbException.get(\n+            ErrorCode.INVALID_PARAMETER_COUNT_2,\n+            info.name, \"\" + len);\n+      }\n+    }\n+  }\n+\n+  public void setDataType(Column col) {\n+    dataType = col.getType();\n+    precision = col.getPrecision();\n+    displaySize = col.getDisplaySize();\n+    scale = col.getScale();\n+  }\n+\n+  @Override\n+  public Expression optimize(Session session) {\n+    boolean allConst = info.deterministic;\n+    for (int i = 0; i < args.length; i++) {\n+      Expression e = args[i];\n+      if (e == null) {\n+        continue;\n+      }\n+      e = e.optimize(session);\n+      args[i] = e;\n+      if (!e.isConstant()) {\n+        allConst = false;\n+      }\n+    }\n+    int t, s, d;\n+    long p;\n+    Expression p0 = args.length < 1 ? null : args[0];\n+    switch (info.type) {\n+      case IFNULL:\n+      case NULLIF:\n+      case COALESCE:\n+      case LEAST:\n+      case GREATEST: {\n+        t = Value.UNKNOWN;\n+        s = 0;\n+        p = 0;\n+        d = 0;\n+        for (Expression e : args) {\n+          if (e != ValueExpression.getNull()) {\n+            int type = e.getType();\n+            if (type != Value.UNKNOWN && type != Value.NULL) {\n+              t = Value.getHigherOrder(t, type);\n+              s = Math.max(s, e.getScale());\n+              p = Math.max(p, e.getPrecision());\n+              d = Math.max(d, e.getDisplaySize());\n+            }\n+          }\n+        }\n+        if (t == Value.UNKNOWN) {\n+          t = Value.STRING;\n+          s = 0;\n+          p = Integer.MAX_VALUE;\n+          d = Integer.MAX_VALUE;\n+        }\n+        break;\n+      }\n+      case CASE:\n+      case DECODE: {\n+        t = Value.UNKNOWN;\n+        s = 0;\n+        p = 0;\n+        d = 0;\n+        // (expr, when, then)\n+        // (expr, when, then, else)\n+        // (expr, when, then, when, then)\n+        // (expr, when, then, when, then, else)\n+        for (int i = 2, len = args.length; i < len; i += 2) {\n+          Expression then = args[i];\n+          if (then != ValueExpression.getNull()) {\n+            int type = then.getType();\n+            if (type != Value.UNKNOWN && type != Value.NULL) {\n+              t = Value.getHigherOrder(t, type);\n+              s = Math.max(s, then.getScale());\n+              p = Math.max(p, then.getPrecision());\n+              d = Math.max(d, then.getDisplaySize());\n+            }\n+          }\n+        }\n+        if (args.length % 2 == 0) {\n+          Expression elsePart = args[args.length - 1];\n+          if (elsePart != ValueExpression.getNull()) {\n+            int type = elsePart.getType();\n+            if (type != Value.UNKNOWN && type != Value.NULL) {\n+              t = Value.getHigherOrder(t, type);\n+              s = Math.max(s, elsePart.getScale());\n+              p = Math.max(p, elsePart.getPrecision());\n+              d = Math.max(d, elsePart.getDisplaySize());\n+            }\n+          }\n+        }\n+        if (t == Value.UNKNOWN) {\n+          t = Value.STRING;\n+          s = 0;\n+          p = Integer.MAX_VALUE;\n+          d = Integer.MAX_VALUE;\n+        }\n+        break;\n+      }\n+      case CASEWHEN:\n+        t = Value.getHigherOrder(args[1].getType(), args[2].getType());\n+        p = Math.max(args[1].getPrecision(), args[2].getPrecision());\n+        d = Math.max(args[1].getDisplaySize(), args[2].getDisplaySize());\n+        s = Math.max(args[1].getScale(), args[2].getScale());\n+        break;\n+      case NVL2:\n+        switch (args[1].getType()) {\n+          case Value.STRING:\n+          case Value.CLOB:\n+          case Value.STRING_FIXED:\n+          case Value.STRING_IGNORECASE:\n+            t = args[1].getType();\n+            break;\n+          default:\n+            t = Value.getHigherOrder(args[1].getType(), args[2].getType());\n+            break;\n         }\n+        p = Math.max(args[1].getPrecision(), args[2].getPrecision());\n+        d = Math.max(args[1].getDisplaySize(), args[2].getDisplaySize());\n+        s = Math.max(args[1].getScale(), args[2].getScale());\n+        break;\n+      case CAST:\n+      case CONVERT:\n+      case TRUNCATE_VALUE:\n+        // data type, precision and scale is already set\n+        t = dataType;\n+        p = precision;\n+        s = scale;\n+        d = displaySize;\n+        break;\n+      case TRUNCATE:\n+        t = p0.getType();\n+        s = p0.getScale();\n+        p = p0.getPrecision();\n+        d = p0.getDisplaySize();\n+        if (t == Value.NULL) {\n+          t = Value.INT;\n+          p = ValueInt.PRECISION;\n+          d = ValueInt.DISPLAY_SIZE;\n+          s = 0;\n+        } else if (t == Value.TIMESTAMP) {\n+          t = Value.DATE;\n+          p = ValueDate.PRECISION;\n+          s = 0;\n+          d = ValueDate.DISPLAY_SIZE;\n+        }\n+        break;\n+      case ABS:\n+      case FLOOR:\n+      case ROUND:\n+        t = p0.getType();\n+        s = p0.getScale();\n+        p = p0.getPrecision();\n+        d = p0.getDisplaySize();\n+        if (t == Value.NULL) {\n+          t = Value.INT;\n+          p = ValueInt.PRECISION;\n+          d = ValueInt.DISPLAY_SIZE;\n+          s = 0;\n+        }\n+        break;\n+      case SET: {\n+        Expression p1 = args[1];\n+        t = p1.getType();\n+        p = p1.getPrecision();\n+        s = p1.getScale();\n+        d = p1.getDisplaySize();\n+        if (!(p0 instanceof Variable)) {\n+          throw DbException.get(\n+              ErrorCode.CAN_ONLY_ASSIGN_TO_VARIABLE_1, p0.getSQL());\n+        }\n+        break;\n+      }\n+      case FILE_READ: {\n+        if (args.length == 1) {\n+          t = Value.BLOB;\n+        } else {\n+          t = Value.CLOB;\n+        }\n+        p = Integer.MAX_VALUE;\n+        s = 0;\n+        d = Integer.MAX_VALUE;\n+        break;\n+      }\n+      case SUBSTRING:\n+      case SUBSTR: {\n+        t = info.returnDataType;\n+        p = args[0].getPrecision();\n+        s = 0;\n+        if (args[1].isConstant()) {\n+          // if only two arguments are used,\n+          // subtract offset from first argument length\n+          p -= args[1].getValue(session).getLong() - 1;\n+        }\n+        if (args.length == 3 && args[2].isConstant()) {\n+          // if the third argument is constant it is at most this value\n+          p = Math.min(p, args[2].getValue(session).getLong());\n+        }\n+        p = Math.max(0, p);\n+        d = MathUtils.convertLongToInt(p);\n+        break;\n+      }\n+      default:\n+        t = info.returnDataType;\n+        DataType type = DataType.getDataType(t);\n+        p = PRECISION_UNKNOWN;\n+        d = 0;\n+        s = type.defaultScale;\n+    }\n+    dataType = t;\n+    precision = p;\n+    scale = s;\n+    displaySize = d;\n+    if (allConst) {\n+      Value v = getValue(session);\n+      if (v == ValueNull.INSTANCE) {\n+        if (info.type == CAST || info.type == CONVERT) {\n+          return this;\n+        }\n+      }\n+      return ValueExpression.get(v);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+    for (Expression e : args) {\n+      if (e != null) {\n+        e.setEvaluatable(tableFilter, b);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public int getScale() {\n+    return scale;\n+  }\n+\n+  @Override\n+  public long getPrecision() {\n+    if (precision == PRECISION_UNKNOWN) {\n+      calculatePrecisionAndDisplaySize();\n+    }\n+    return precision;\n+  }\n+\n+  @Override\n+  public int getDisplaySize() {\n+    if (precision == PRECISION_UNKNOWN) {\n+      calculatePrecisionAndDisplaySize();\n+    }\n+    return displaySize;\n+  }\n+\n+  private void calculatePrecisionAndDisplaySize() {\n+    switch (info.type) {\n+      case ENCRYPT:\n+      case DECRYPT:\n+        precision = args[2].getPrecision();\n+        displaySize = args[2].getDisplaySize();\n+        break;\n+      case COMPRESS:\n+        precision = args[0].getPrecision();\n+        displaySize = args[0].getDisplaySize();\n+        break;\n+      case CHAR:\n+        precision = 1;\n+        displaySize = 1;\n+        break;\n+      case CONCAT:\n+        precision = 0;\n+        displaySize = 0;\n+        for (Expression e : args) {\n+          precision += e.getPrecision();\n+          displaySize = MathUtils.convertLongToInt(\n+              (long) displaySize + e.getDisplaySize());\n+          if (precision < 0) {\n+            precision = Long.MAX_VALUE;\n+          }\n+        }\n+        break;\n+      case HEXTORAW:\n+        precision = (args[0].getPrecision() + 3) / 4;\n+        displaySize = MathUtils.convertLongToInt(precision);\n+        break;\n+      case LCASE:\n+      case LTRIM:\n+      case RIGHT:\n+      case RTRIM:\n+      case UCASE:\n+      case LOWER:\n+      case UPPER:\n+      case TRIM:\n+      case STRINGDECODE:\n+      case UTF8TOSTRING:\n+      case TRUNCATE:\n+        precision = args[0].getPrecision();\n+        displaySize = args[0].getDisplaySize();\n+        break;\n+      case RAWTOHEX:\n+        precision = args[0].getPrecision() * 4;\n+        displaySize = MathUtils.convertLongToInt(precision);\n+        break;\n+      case SOUNDEX:\n+        precision = 4;\n+        displaySize = (int) precision;\n+        break;\n+      case DAY_NAME:\n+      case MONTH_NAME:\n+        // day and month names may be long in some languages\n+        precision = 20;\n+        displaySize = (int) precision;\n+        break;\n+      default:\n+        DataType type = DataType.getDataType(dataType);\n+        precision = type.defaultPrecision;\n+        displaySize = type.defaultDisplaySize;\n+    }\n+  }\n+\n+  @Override\n+  public String getSQL() {\n+    StatementBuilder buff = new StatementBuilder(info.name);\n+    if (info.type == CASE) {\n+      if (args[0] != null) {\n+        buff.append(\" \").append(args[0].getSQL());\n+      }\n+      for (int i = 1, len = args.length - 1; i < len; i += 2) {\n+        buff.append(\" WHEN \").append(args[i].getSQL());\n+        buff.append(\" THEN \").append(args[i + 1].getSQL());\n+      }\n+      if (args.length % 2 == 0) {\n+        buff.append(\" ELSE \").append(args[args.length - 1].getSQL());\n+      }\n+      return buff.append(\" END\").toString();\n+    }\n+    buff.append('(');\n+    switch (info.type) {\n+      case CAST: {\n+        buff.append(args[0].getSQL()).append(\" AS \").\n+            append(new Column(null, dataType, precision,\n+                scale, displaySize).getCreateSQL());\n+        break;\n+      }\n+      case CONVERT: {\n+        if (database.getMode().swapConvertFunctionParameters) {\n+          buff.append(new Column(null, dataType, precision,\n+              scale, displaySize).getCreateSQL()).\n+              append(',').append(args[0].getSQL());\n+        } else {\n+          buff.append(args[0].getSQL()).append(',').\n+              append(new Column(null, dataType, precision,\n+                  scale, displaySize).getCreateSQL());\n+        }\n+        break;\n+      }\n+      case EXTRACT: {\n+        ValueString v =\n+            (ValueString) ((ValueExpression) args[0]).getValue(null);\n+        buff.append(v.getString()).append(\" FROM \").append(args[1].getSQL());\n+        break;\n+      }\n+      default: {\n+        for (Expression e : args) {\n+          buff.appendExceptFirst(\", \");\n+          buff.append(e.getSQL());\n+        }\n+      }\n+    }\n+    return buff.append(')').toString();\n+  }\n+\n+  @Override\n+  public void updateAggregate(Session session) {\n+    for (Expression e : args) {\n+      if (e != null) {\n+        e.updateAggregate(session);\n+      }\n+    }\n+  }\n+\n+  public int getFunctionType() {\n+    return info.type;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return info.name;\n+  }\n+\n+  @Override\n+  public ValueResultSet getValueForColumnList(Session session,\n+                                              Expression[] argList) {\n+    switch (info.type) {\n+      case CSVREAD: {\n+        String fileName = argList[0].getValue(session).getString();\n+        if (fileName == null) {\n+          throw DbException.get(ErrorCode.PARAMETER_NOT_SET_1, \"fileName\");\n+        }\n+        String columnList = argList.length < 2 ?\n+            null : argList[1].getValue(session).getString();\n+        Csv csv = new Csv();\n+        String options = argList.length < 3 ?\n+            null : argList[2].getValue(session).getString();\n+        String charset = null;\n+        if (options != null && options.indexOf('=') >= 0) {\n+          charset = csv.setOptions(options);\n+        } else {\n+          charset = options;\n+          String fieldSeparatorRead = argList.length < 4 ?\n+              null : argList[3].getValue(session).getString();\n+          String fieldDelimiter = argList.length < 5 ?\n+              null : argList[4].getValue(session).getString();\n+          String escapeCharacter = argList.length < 6 ?\n+              null : argList[5].getValue(session).getString();\n+          setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter,\n+              escapeCharacter);\n+        }\n+        char fieldSeparator = csv.getFieldSeparatorRead();\n+        String[] columns =\n+            StringUtils.arraySplit(columnList, fieldSeparator, true);\n+        ResultSet rs = null;\n+        ValueResultSet x;\n+        try {\n+          rs = csv.read(fileName, columns, charset);\n+          x = ValueResultSet.getCopy(rs, 0);\n+        } catch (SQLException e) {\n+          throw DbException.convert(e);\n+        } finally {\n+          csv.close();\n+          JdbcUtils.closeSilently(rs);\n+        }\n+        return x;\n+      }\n+      default:\n+        break;\n+    }\n+    return (ValueResultSet) getValueWithArgs(session, argList);\n+  }\n+\n+  private static void setCsvDelimiterEscape(Csv csv, String fieldSeparator,\n+                                            String fieldDelimiter,\n+                                            String escapeCharacter) {\n+    if (fieldSeparator != null) {\n+      csv.setFieldSeparatorWrite(fieldSeparator);\n+      if (fieldSeparator.length() > 0) {\n+        char fs = fieldSeparator.charAt(0);\n+        csv.setFieldSeparatorRead(fs);\n+      }\n+    }\n+    if (fieldDelimiter != null) {\n+      char fd = fieldDelimiter.length() == 0 ?\n+          0 : fieldDelimiter.charAt(0);\n+      csv.setFieldDelimiter(fd);\n+    }\n+    if (escapeCharacter != null) {\n+      char ec = escapeCharacter.length() == 0 ?\n+          0 : escapeCharacter.charAt(0);\n+      csv.setEscapeCharacter(ec);\n+    }\n+  }\n+\n+  @Override\n+  public Expression[] getArgs() {\n+    return args;\n+  }\n+\n+  @Override\n+  public boolean isEverything(ExpressionVisitor visitor) {\n+    for (Expression e : args) {\n+      if (e != null && !e.isEverything(visitor)) {\n         return false;\n+      }\n     }\n-\n-    private static long getDiskSpaceUsed(Session session, Value v0) {\n-        Parser p = new Parser(session);\n-        String sql = v0.getString();\n-        Table table = p.parseTableName(sql);\n-        return table.getDiskSpaceUsed();\n-    }\n-\n-    private static Value getNullOrValue(Session session, Expression[] args,\n-            Value[] values, int i) {\n-        if (i >= args.length) {\n-            return null;\n-        }\n-        Value v = values[i];\n-        if (v == null) {\n-            Expression e = args[i];\n-            if (e == null) {\n-                return null;\n-            }\n-            v = values[i] = e.getValue(session);\n-        }\n-        return v;\n-    }\n-\n-    private Value getValueWithArgs(Session session, Expression[] args) {\n-        Value[] values = new Value[args.length];\n-        if (info.nullIfParameterIsNull) {\n-            for (int i = 0; i < args.length; i++) {\n-                Expression e = args[i];\n-                Value v = e.getValue(session);\n-                if (v == ValueNull.INSTANCE) {\n-                    return ValueNull.INSTANCE;\n-                }\n-                values[i] = v;\n-            }\n-        }\n-        Value v0 = getNullOrValue(session, args, values, 0);\n-        Value resultSimple = getSimpleValue(session, v0, args, values);\n-        if (resultSimple != null) {\n-            return resultSimple;\n-        }\n-        Value v1 = getNullOrValue(session, args, values, 1);\n-        Value v2 = getNullOrValue(session, args, values, 2);\n-        Value v3 = getNullOrValue(session, args, values, 3);\n-        Value v4 = getNullOrValue(session, args, values, 4);\n-        Value v5 = getNullOrValue(session, args, values, 5);\n-        Value result;\n-        switch (info.type) {\n-        case ATAN2:\n-            result = ValueDouble.get(\n-                    Math.atan2(v0.getDouble(), v1.getDouble()));\n-            break;\n-        case BITAND:\n-            result = ValueLong.get(v0.getLong() & v1.getLong());\n-            break;\n-        case BITGET:\n-            result = ValueBoolean.get((v0.getLong() & (1L << v1.getInt())) != 0);\n-            break;\n-        case BITOR:\n-            result = ValueLong.get(v0.getLong() | v1.getLong());\n-            break;\n-        case BITXOR:\n-            result = ValueLong.get(v0.getLong() ^ v1.getLong());\n-            break;\n-        case MOD: {\n-            long x = v1.getLong();\n-            if (x == 0) {\n-                throw DbException.get(ErrorCode.DIVISION_BY_ZERO_1, getSQL());\n-            }\n-            result = ValueLong.get(v0.getLong() % x);\n-            break;\n-        }\n-        case POWER:\n-            result = ValueDouble.get(Math.pow(\n-                    v0.getDouble(), v1.getDouble()));\n-            break;\n-        case ROUND: {\n-            double f = v1 == null ? 1. : Math.pow(10., v1.getDouble());\n-\n-            double middleResult = v0.getDouble() * f;\n-\n-            int oneWithSymbol = middleResult > 0 ? 1 : -1;\n-            result = ValueDouble.get(Math.round(Math.abs(middleResult)) / f * oneWithSymbol);\n-            break;\n-        }\n-        case TRUNCATE: {\n-            if (v0.getType() == Value.TIMESTAMP) {\n-                java.sql.Timestamp d = v0.getTimestamp();\n-                Calendar c = DateTimeUtils.createGregorianCalendar();\n-                c.setTime(d);\n-                c.set(Calendar.HOUR_OF_DAY, 0);\n-                c.set(Calendar.MINUTE, 0);\n-                c.set(Calendar.SECOND, 0);\n-                c.set(Calendar.MILLISECOND, 0);\n-                result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n-            } else if (v0.getType() == Value.DATE) {\n-                ValueDate vd = (ValueDate) v0;\n-                Calendar c = DateTimeUtils.createGregorianCalendar();\n-                c.setTime(vd.getDate());\n-                c.set(Calendar.HOUR_OF_DAY, 0);\n-                c.set(Calendar.MINUTE, 0);\n-                c.set(Calendar.SECOND, 0);\n-                c.set(Calendar.MILLISECOND, 0);\n-                result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n-            } else if (v0.getType() == Value.STRING) {\n-                ValueString vd = (ValueString) v0;\n-                Calendar c = DateTimeUtils.createGregorianCalendar();\n-                c.setTime(ValueTimestamp.parse(vd.getString(), session.getDatabase().getMode()).getDate());\n-                c.set(Calendar.HOUR_OF_DAY, 0);\n-                c.set(Calendar.MINUTE, 0);\n-                c.set(Calendar.SECOND, 0);\n-                c.set(Calendar.MILLISECOND, 0);\n-                result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n-            } else {\n-                double d = v0.getDouble();\n-                int p = v1 == null ? 0 : v1.getInt();\n-                double f = Math.pow(10., p);\n-                double g = d * f;\n-                result = ValueDouble.get(((d < 0) ? Math.ceil(g) : Math.floor(g)) / f);\n-            }\n-            break;\n-        }\n-        case HASH:\n-            result = ValueBytes.getNoCopy(getHash(v0.getString(),\n-                    v1.getBytesNoCopy(), v2.getInt()));\n-            break;\n-        case ENCRYPT:\n-            result = ValueBytes.getNoCopy(encrypt(v0.getString(),\n-                    v1.getBytesNoCopy(), v2.getBytesNoCopy()));\n-            break;\n-        case DECRYPT:\n-            result = ValueBytes.getNoCopy(decrypt(v0.getString(),\n-                    v1.getBytesNoCopy(), v2.getBytesNoCopy()));\n-            break;\n-        case COMPRESS: {\n-            String algorithm = null;\n-            if (v1 != null) {\n-                algorithm = v1.getString();\n-            }\n-            result = ValueBytes.getNoCopy(CompressTool.getInstance().\n-                    compress(v0.getBytesNoCopy(), algorithm));\n-            break;\n-        }\n-        case DIFFERENCE:\n-            result = ValueInt.get(getDifference(\n-                    v0.getString(), v1.getString()));\n-            break;\n-        case INSERT: {\n-            if (v1 == ValueNull.INSTANCE || v2 == ValueNull.INSTANCE) {\n-                result = v1;\n-            } else {\n-                result = ValueString.get(insert(v0.getString(),\n-                        v1.getInt(), v2.getInt(), v3.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            }\n-            break;\n-        }\n-        case LEFT:\n-            result = ValueString.get(left(v0.getString(), v1.getInt()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case LOCATE: {\n-            int start = v2 == null ? 0 : v2.getInt();\n-            result = ValueInt.get(locate(v0.getString(), v1.getString(), start));\n-            break;\n-        }\n-        case INSTR: {\n-            int start = v2 == null ? 0 : v2.getInt();\n-            result = ValueInt.get(locate(v1.getString(), v0.getString(), start));\n-            break;\n-        }\n-        case REPEAT: {\n-            int count = Math.max(0, v1.getInt());\n-            result = ValueString.get(repeat(v0.getString(), count),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case REPLACE: {\n-            if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE\n-                    || v2 == ValueNull.INSTANCE && database.getMode() != Mode.getOracle()) {\n-                result = ValueNull.INSTANCE;\n-            } else {\n-                String s0 = v0.getString();\n-                String s1 = v1.getString();\n-                String s2 = (v2 == null) ? \"\" : v2.getString();\n-                if (s2 == null) {\n-                    s2 = \"\";\n-                }\n-                result = ValueString.get(replace(s0, s1, s2),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            }\n-            break;\n-        }\n-        case RIGHT:\n-            result = ValueString.get(right(v0.getString(), v1.getInt()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case LTRIM:\n-            result = ValueString.get(StringUtils.trim(v0.getString(),\n-                    true, false, v1 == null ? \" \" : v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case TRIM:\n-            result = ValueString.get(StringUtils.trim(v0.getString(),\n-                    true, true, v1 == null ? \" \" : v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case RTRIM:\n-            result = ValueString.get(StringUtils.trim(v0.getString(),\n-                    false, true, v1 == null ? \" \" : v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case SUBSTR:\n-        case SUBSTRING: {\n-            String s = v0.getString();\n-            int offset = v1.getInt();\n-            if (offset < 0) {\n-                offset = s.length() + offset + 1;\n-            }\n-            int length = v2 == null ? s.length() : v2.getInt();\n-            result = ValueString.get(substring(s, offset, length),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case POSITION:\n-            result = ValueInt.get(locate(v0.getString(), v1.getString(), 0));\n-            break;\n-        case XMLATTR:\n-            result = ValueString.get(\n-                    StringUtils.xmlAttr(v0.getString(), v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case XMLNODE: {\n-            String attr = v1 == null ?\n-                    null : v1 == ValueNull.INSTANCE ? null : v1.getString();\n-            String content = v2 == null ?\n-                    null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n-            boolean indent = v3 == null ?\n-                    true : v3.getBoolean();\n-            result = ValueString.get(StringUtils.xmlNode(\n-                    v0.getString(), attr, content, indent),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case REGEXP_REPLACE: {\n-            String regexp = v1.getString();\n-            String replacement = v2.getString();\n-            String regexpMode = v3 == null || v3.getString() == null ? \"\" :\n-                    v3.getString();\n-            int flags = makeRegexpFlags(regexpMode);\n-            try {\n-                result = ValueString.get(\n-                        Pattern.compile(regexp, flags).matcher(v0.getString())\n-                                .replaceAll(replacement),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            } catch (StringIndexOutOfBoundsException e) {\n-                throw DbException.get(\n-                        ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n-            } catch (PatternSyntaxException e) {\n-                throw DbException.get(\n-                        ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n-            } catch (IllegalArgumentException e) {\n-                throw DbException.get(\n-                        ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n-            }\n-            break;\n-        }\n-        case RPAD:\n-            result = ValueString.get(StringUtils.pad(v0.getString(),\n-                    v1.getInt(), v2 == null ? null : v2.getString(), true),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case LPAD:\n-            result = ValueString.get(StringUtils.pad(v0.getString(),\n-                    v1.getInt(), v2 == null ? null : v2.getString(), false),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case ORA_HASH:\n-            result = ValueLong.get(oraHash(v0.getString(),\n-                    v1 == null ? null : v1.getInt(),\n-                    v2 == null ? null : v2.getInt()));\n-            break;\n-        case TO_CHAR:\n-            switch (v0.getType()){\n-            case Value.TIME:\n-            case Value.DATE:\n-            case Value.TIMESTAMP:\n-                result = ValueString.get(ToChar.toChar(v0.getTimestamp(),\n-                        v1 == null ? null : v1.getString(),\n-                        v2 == null ? null : v2.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n-                break;\n-            case Value.SHORT:\n-            case Value.INT:\n-            case Value.LONG:\n-            case Value.DECIMAL:\n-            case Value.DOUBLE:\n-            case Value.FLOAT:\n-                result = ValueString.get(ToChar.toChar(v0.getBigDecimal(),\n-                        v1 == null ? null : v1.getString(),\n-                        v2 == null ? null : v2.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n-                break;\n-            default:\n-                result = ValueString.get(v0.getString(),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            }\n-            break;\n-        case TO_DATE:\n-            result = ValueTimestamp.get(ToDateParser.toDate(v0.getString(),\n-                    v1 == null ? null : v1.getString()));\n-            break;\n-        case TO_TIMESTAMP:\n-            result = ValueTimestamp.get(ToDateParser.toTimestamp(v0.getString(),\n-                    v1 == null ? null : v1.getString()));\n-            break;\n-        case ADD_MONTHS:\n-            result = ValueTimestamp.get(DateTimeUtils.addMonths(v0.getTimestamp(), v1.getInt()));\n-            break;\n-        case TRANSLATE: {\n-            String matching = v1.getString();\n-            String replacement = v2.getString();\n-            result = ValueString.get(\n-                    translate(v0.getString(), matching, replacement),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        }\n-        case H2VERSION:\n-            result = ValueString.get(Constants.getVersion(),\n-                    database.getMode().treatEmptyStringsAsNull);\n-            break;\n-        case DATE_ADD:\n-            result = ValueTimestamp.get(dateadd(\n-                    v0.getString(), v1.getLong(), v2.getTimestamp()));\n-            break;\n-        case DATE_DIFF:\n-            result = ValueLong.get(datediff(\n-                    v0.getString(), v1.getTimestamp(), v2.getTimestamp()));\n-            break;\n-        case EXTRACT: {\n-            int field = getDatePart(v0.getString());\n-            result = ValueInt.get(DateTimeUtils.getDatePart(\n-                    v1.getTimestamp(), field));\n-            break;\n-        }\n-        case FORMATDATETIME: {\n-            if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE) {\n-                result = ValueNull.INSTANCE;\n-            } else {\n-                String locale = v2 == null ?\n-                        null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n-                String tz = v3 == null ?\n-                        null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n-                result = ValueString.get(DateTimeUtils.formatDateTime(\n-                        v0.getTimestamp(), v1.getString(), locale, tz),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            }\n-            break;\n-        }\n-        case PARSEDATETIME: {\n-            if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE) {\n-                result = ValueNull.INSTANCE;\n-            } else {\n-                String locale = v2 == null ?\n-                        null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n-                String tz = v3 == null ?\n-                        null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n-                java.util.Date d = DateTimeUtils.parseDateTime(\n-                        v0.getString(), v1.getString(), locale, tz);\n-                result = ValueTimestamp.fromMillis(d.getTime());\n-            }\n-            break;\n-        }\n-        case NULLIF:\n-            result = database.areEqual(v0, v1) ? ValueNull.INSTANCE : v0;\n-            break;\n-            // system\n-        case NEXTVAL: {\n-            Sequence sequence = getSequence(session, v0, v1);\n-            SequenceValue value = new SequenceValue(sequence);\n-            result = value.getValue(session);\n-            break;\n-        }\n-        case CURRVAL: {\n-            Sequence sequence = getSequence(session, v0, v1);\n-            result = ValueLong.get(sequence.getCurrentValue());\n-            break;\n-        }\n-        case CSVREAD: {\n-            String fileName = v0.getString();\n-            String columnList = v1 == null ? null : v1.getString();\n-            Csv csv = new Csv();\n-            String options = v2 == null ? null : v2.getString();\n-            String charset = null;\n-            if (options != null && options.indexOf('=') >= 0) {\n-                charset = csv.setOptions(options);\n-            } else {\n-                charset = options;\n-                String fieldSeparatorRead = v3 == null ? null : v3.getString();\n-                String fieldDelimiter = v4 == null ? null : v4.getString();\n-                String escapeCharacter = v5 == null ? null : v5.getString();\n-                Value v6 = getNullOrValue(session, args, values, 6);\n-                String nullString = v6 == null ? null : v6.getString();\n-                setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter,\n-                        escapeCharacter);\n-                csv.setNullString(nullString);\n-            }\n-            char fieldSeparator = csv.getFieldSeparatorRead();\n-            String[] columns = StringUtils.arraySplit(columnList,\n-                    fieldSeparator, true);\n-            try {\n-                ValueResultSet vr = ValueResultSet.get(csv.read(fileName,\n-                        columns, charset));\n-                result = vr;\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-            break;\n-        }\n-        case LINK_SCHEMA: {\n-            session.getUser().checkAdmin();\n-            Connection conn = session.createConnection(false);\n-            ResultSet rs = LinkSchema.linkSchema(conn, v0.getString(),\n-                    v1.getString(), v2.getString(), v3.getString(),\n-                    v4.getString(), v5.getString());\n-            result = ValueResultSet.get(rs);\n-            break;\n-        }\n-        case CSVWRITE: {\n-            session.getUser().checkAdmin();\n-            Connection conn = session.createConnection(false);\n-            Csv csv = new Csv();\n-            String options = v2 == null ? null : v2.getString();\n-            String charset = null;\n-            if (options != null && options.indexOf('=') >= 0) {\n-                charset = csv.setOptions(options);\n-            } else {\n-                charset = options;\n-                String fieldSeparatorWrite = v3 == null ? null : v3.getString();\n-                String fieldDelimiter = v4 == null ? null : v4.getString();\n-                String escapeCharacter = v5 == null ? null : v5.getString();\n-                Value v6 = getNullOrValue(session, args, values, 6);\n-                String nullString = v6 == null ? null : v6.getString();\n-                Value v7 = getNullOrValue(session, args, values, 7);\n-                String lineSeparator = v7 == null ? null : v7.getString();\n-                setCsvDelimiterEscape(csv, fieldSeparatorWrite, fieldDelimiter,\n-                        escapeCharacter);\n-                csv.setNullString(nullString);\n-                if (lineSeparator != null) {\n-                    csv.setLineSeparator(lineSeparator);\n-                }\n-            }\n-            try {\n-                int rows = csv.write(conn, v0.getString(), v1.getString(),\n-                        charset);\n-                result = ValueInt.get(rows);\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-            break;\n-        }\n-        case SET: {\n-            Variable var = (Variable) args[0];\n-            session.setVariable(var.getName(), v1);\n-            result = v1;\n-            break;\n-        }\n-        case FILE_READ: {\n-            session.getUser().checkAdmin();\n-            String fileName = v0.getString();\n-            boolean blob = args.length == 1;\n-            try {\n-                long fileLength = FileUtils.size(fileName);\n-                InputStream in = new AutoCloseInputStream(\n-                        FileUtils.newInputStream(fileName));\n-                if (blob) {\n-                    result = database.getLobStorage().createBlob(in, fileLength);\n-                } else {\n-                    Reader reader;\n-                    if (v1 == ValueNull.INSTANCE) {\n-                        reader = new InputStreamReader(in);\n-                    } else {\n-                        reader = new InputStreamReader(in, v1.getString());\n-                    }\n-                    result = database.getLobStorage().createClob(reader, fileLength);\n-                }\n-                session.addTemporaryLob(result);\n-            } catch (IOException e) {\n-                throw DbException.convertIOException(e, fileName);\n-            }\n-            break;\n-        }\n-        case FILE_WRITE: {\n-            session.getUser().checkAdmin();\n-            result = ValueNull.INSTANCE;\n-            String fileName = v1.getString();\n-            try {\n-                FileOutputStream fileOutputStream = new FileOutputStream(fileName);\n-                try (InputStream in = v0.getInputStream()) {\n-                    result = ValueLong.get(IOUtils.copyAndClose(in,\n-                            fileOutputStream));\n-                }\n-            } catch (IOException e) {\n-                throw DbException.convertIOException(e, fileName);\n-            }\n-            break;\n-        }\n-        case TRUNCATE_VALUE: {\n-            result = v0.convertPrecision(v1.getLong(), v2.getBoolean());\n-            break;\n-        }\n-        case XMLTEXT:\n-            if (v1 == null) {\n-                result = ValueString.get(StringUtils.xmlText(\n-                        v0.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            } else {\n-                result = ValueString.get(StringUtils.xmlText(\n-                        v0.getString(), v1.getBoolean()),\n-                        database.getMode().treatEmptyStringsAsNull);\n-            }\n-            break;\n-        case REGEXP_LIKE: {\n-            String regexp = v1.getString();\n-            String regexpMode = v2 == null || v2.getString() == null ? \"\" :\n-                    v2.getString();\n-            int flags = makeRegexpFlags(regexpMode);\n-            try {\n-                result = ValueBoolean.get(Pattern.compile(regexp, flags)\n-                        .matcher(v0.getString()).find());\n-            } catch (PatternSyntaxException e) {\n-                throw DbException.get(ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n-            }\n-            break;\n-        }\n-        case VALUES:\n-            result = session.getVariable(args[0].getSchemaName() + \".\" +\n-                    args[0].getTableName() + \".\" + args[0].getColumnName());\n-            break;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + info.type);\n-        }\n-        return result;\n-    }\n-\n-    private Sequence getSequence(Session session, Value v0, Value v1) {\n-        String schemaName, sequenceName;\n-        if (v1 == null) {\n-            Parser p = new Parser(session);\n-            String sql = v0.getString();\n-            Expression expr = p.parseExpression(sql);\n-            if (expr instanceof ExpressionColumn) {\n-                ExpressionColumn seq = (ExpressionColumn) expr;\n-                schemaName = seq.getOriginalTableAliasName();\n-                if (schemaName == null) {\n-                    schemaName = session.getCurrentSchemaName();\n-                    sequenceName = sql;\n-                } else {\n-                    sequenceName = seq.getColumnName();\n-                }\n-            } else {\n-                throw DbException.getSyntaxError(sql, 1);\n-            }\n-        } else {\n-            schemaName = v0.getString();\n-            sequenceName = v1.getString();\n-        }\n-        Schema s = database.findSchema(schemaName);\n-        if (s == null) {\n-            schemaName = StringUtils.toUpperEnglish(schemaName);\n-            s = database.getSchema(schemaName);\n-        }\n-        Sequence seq = s.findSequence(sequenceName);\n-        if (seq == null) {\n-            sequenceName = StringUtils.toUpperEnglish(sequenceName);\n-            seq = s.getSequence(sequenceName);\n-        }\n-        return seq;\n-    }\n-\n-    private static long length(Value v) {\n-        switch (v.getType()) {\n-        case Value.BLOB:\n-        case Value.CLOB:\n-        case Value.BYTES:\n-        case Value.JAVA_OBJECT:\n-            return v.getPrecision();\n-        default:\n-            return v.getString().length();\n-        }\n-    }\n-\n-    private static byte[] getPaddedArrayCopy(byte[] data, int blockSize) {\n-        int size = MathUtils.roundUpInt(data.length, blockSize);\n-        byte[] newData = DataUtils.newBytes(size);\n-        System.arraycopy(data, 0, newData, 0, data.length);\n-        return newData;\n-    }\n-\n-    private static byte[] decrypt(String algorithm, byte[] key, byte[] data) {\n-        BlockCipher cipher = CipherFactory.getBlockCipher(algorithm);\n-        byte[] newKey = getPaddedArrayCopy(key, cipher.getKeyLength());\n-        cipher.setKey(newKey);\n-        byte[] newData = getPaddedArrayCopy(data, BlockCipher.ALIGN);\n-        cipher.decrypt(newData, 0, newData.length);\n-        return newData;\n-    }\n-\n-    private static byte[] encrypt(String algorithm, byte[] key, byte[] data) {\n-        BlockCipher cipher = CipherFactory.getBlockCipher(algorithm);\n-        byte[] newKey = getPaddedArrayCopy(key, cipher.getKeyLength());\n-        cipher.setKey(newKey);\n-        byte[] newData = getPaddedArrayCopy(data, BlockCipher.ALIGN);\n-        cipher.encrypt(newData, 0, newData.length);\n-        return newData;\n-    }\n-\n-    private static byte[] getHash(String algorithm, byte[] bytes, int iterations) {\n-        if (!\"SHA256\".equalsIgnoreCase(algorithm)) {\n-            throw DbException.getInvalidValueException(\"algorithm\", algorithm);\n-        }\n-        for (int i = 0; i < iterations; i++) {\n-            bytes = SHA256.getHash(bytes, false);\n-        }\n-        return bytes;\n-    }\n-\n-    /**\n-     * Check if a given string is a valid date part string.\n-     *\n-     * @param part the string\n-     * @return true if it is\n-     */\n-    public static boolean isDatePart(String part) {\n-        Integer p = DATE_PART.get(StringUtils.toUpperEnglish(part));\n-        return p != null;\n-    }\n-\n-    private static int getDatePart(String part) {\n-        Integer p = DATE_PART.get(StringUtils.toUpperEnglish(part));\n-        if (p == null) {\n-            throw DbException.getInvalidValueException(\"date part\", part);\n-        }\n-        return p.intValue();\n-    }\n-\n-    private static Timestamp dateadd(String part, long count, Timestamp d) {\n-        int field = getDatePart(part);\n-        if (field == Calendar.MILLISECOND) {\n-            Timestamp ts = new Timestamp(d.getTime() + count);\n-            ts.setNanos(ts.getNanos() + (d.getNanos() % 1000000));\n-            return ts;\n-        }\n-        // We allow long for manipulating the millisecond component,\n-        // for the rest we only allow int.\n-        if (count > Integer.MAX_VALUE) {\n-            throw DbException.getInvalidValueException(\"DATEADD count\", count);\n-        }\n-        Calendar calendar = DateTimeUtils.createGregorianCalendar();\n-        int nanos = d.getNanos() % 1000000;\n-        calendar.setTime(d);\n-        calendar.add(field, (int) count);\n-        long t = calendar.getTime().getTime();\n-        Timestamp ts = new Timestamp(t);\n-        ts.setNanos(ts.getNanos() + nanos);\n-        return ts;\n-    }\n-\n-    /**\n-     * Calculate the number of crossed unit boundaries between two timestamps.\n-     * This method is supported for MS SQL Server compatibility.\n-     * <pre>\n-     * DATEDIFF(YEAR, '2004-12-31', '2005-01-01') = 1\n-     * </pre>\n-     *\n-     * @param part the part\n-     * @param d1 the first date\n-     * @param d2 the second date\n-     * @return the number of crossed boundaries\n-     */\n-    private static long datediff(String part, Timestamp d1, Timestamp d2) {\n-        int field = getDatePart(part);\n-        Calendar calendar = DateTimeUtils.createGregorianCalendar();\n-        long t1 = d1.getTime(), t2 = d2.getTime();\n-        // need to convert to UTC, otherwise we get inconsistent results with\n-        // certain time zones (those that are 30 minutes off)\n-        TimeZone zone = calendar.getTimeZone();\n-        calendar.setTime(d1);\n-        t1 += zone.getOffset(calendar.get(Calendar.ERA),\n-                calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n-                calendar.get(Calendar.DAY_OF_MONTH),\n-                calendar.get(Calendar.DAY_OF_WEEK),\n-                calendar.get(Calendar.MILLISECOND));\n-        calendar.setTime(d2);\n-        t2 += zone.getOffset(calendar.get(Calendar.ERA),\n-                calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n-                calendar.get(Calendar.DAY_OF_MONTH),\n-                calendar.get(Calendar.DAY_OF_WEEK),\n-                calendar.get(Calendar.MILLISECOND));\n-        switch (field) {\n-        case Calendar.MILLISECOND:\n-            return t2 - t1;\n-        case Calendar.SECOND:\n-        case Calendar.MINUTE:\n-        case Calendar.HOUR_OF_DAY:\n-        case Calendar.DAY_OF_YEAR:\n-        case Calendar.WEEK_OF_YEAR: {\n-            // first 'normalize' the numbers so both are not negative\n-            long hour = 60 * 60 * 1000;\n-            long add = Math.min(t1 / hour * hour, t2 / hour * hour);\n-            t1 -= add;\n-            t2 -= add;\n-            switch (field) {\n-            case Calendar.SECOND:\n-                return t2 / 1000 - t1 / 1000;\n-            case Calendar.MINUTE:\n-                return t2 / (60 * 1000) - t1 / (60 * 1000);\n-            case Calendar.HOUR_OF_DAY:\n-                return t2 / hour - t1 / hour;\n-            case Calendar.DAY_OF_YEAR:\n-                return t2 / (hour * 24) - t1 / (hour * 24);\n-            case Calendar.WEEK_OF_YEAR:\n-                return t2 / (hour * 24 * 7) - t1 / (hour * 24 * 7);\n-            default:\n-                throw DbException.throwInternalError(\"field:\" + field);\n-            }\n-        }\n-        case Calendar.DATE:\n-            return t2 / (24 * 60 * 60 * 1000) - t1 / (24 * 60 * 60 * 1000);\n-        default:\n-            break;\n-        }\n-        calendar = DateTimeUtils.createGregorianCalendar(TimeZone.getTimeZone(\"UTC\"));\n-        calendar.setTimeInMillis(t1);\n-        int year1 = calendar.get(Calendar.YEAR);\n-        int month1 = calendar.get(Calendar.MONTH);\n-        calendar.setTimeInMillis(t2);\n-        int year2 = calendar.get(Calendar.YEAR);\n-        int month2 = calendar.get(Calendar.MONTH);\n-        int result = year2 - year1;\n-        if (field == Calendar.MONTH) {\n-            return 12 * result + (month2 - month1);\n-        } else if (field == Calendar.YEAR) {\n-            return result;\n-        } else {\n-            throw DbException.getUnsupportedException(\"DATEDIFF \" + part);\n-        }\n-    }\n-\n-    private static String substring(String s, int start, int length) {\n-        int len = s.length();\n-        start--;\n-        if (start < 0) {\n-            start = 0;\n-        }\n-        if (length < 0) {\n-            length = 0;\n-        }\n-        start = (start > len) ? len : start;\n-        if (start + length > len) {\n-            length = len - start;\n-        }\n-        return s.substring(start, start + length);\n-    }\n-\n-    private static String replace(String s, String replace, String with) {\n-        if (s == null || replace == null || with == null) {\n-            return null;\n-        }\n-        if (replace.length() == 0) {\n-            // avoid out of memory\n-            return s;\n-        }\n-        StringBuilder buff = new StringBuilder(s.length());\n-        int start = 0;\n-        int len = replace.length();\n-        while (true) {\n-            int i = s.indexOf(replace, start);\n-            if (i == -1) {\n-                break;\n-            }\n-            buff.append(s.substring(start, i)).append(with);\n-            start = i + len;\n-        }\n-        buff.append(s.substring(start));\n-        return buff.toString();\n-    }\n-\n-    private static String repeat(String s, int count) {\n-        StringBuilder buff = new StringBuilder(s.length() * count);\n-        while (count-- > 0) {\n-            buff.append(s);\n-        }\n-        return buff.toString();\n-    }\n-\n-    private static String rawToHex(String s) {\n-        int length = s.length();\n-        StringBuilder buff = new StringBuilder(4 * length);\n-        for (int i = 0; i < length; i++) {\n-            String hex = Integer.toHexString(s.charAt(i) & 0xffff);\n-            for (int j = hex.length(); j < 4; j++) {\n-                buff.append('0');\n-            }\n-            buff.append(hex);\n-        }\n-        return buff.toString();\n-    }\n-\n-    private static int locate(String search, String s, int start) {\n-        if (start < 0) {\n-            int i = s.length() + start;\n-            return s.lastIndexOf(search, i) + 1;\n-        }\n-        int i = (start == 0) ? 0 : start - 1;\n-        return s.indexOf(search, i) + 1;\n-    }\n-\n-    private static String right(String s, int count) {\n-        if (count < 0) {\n-            count = 0;\n-        } else if (count > s.length()) {\n-            count = s.length();\n-        }\n-        return s.substring(s.length() - count);\n-    }\n-\n-    private static String left(String s, int count) {\n-        if (count < 0) {\n-            count = 0;\n-        } else if (count > s.length()) {\n-            count = s.length();\n-        }\n-        return s.substring(0, count);\n-    }\n-\n-    private static String insert(String s1, int start, int length, String s2) {\n-        if (s1 == null) {\n-            return s2;\n-        }\n-        if (s2 == null) {\n-            return s1;\n-        }\n-        int len1 = s1.length();\n-        int len2 = s2.length();\n-        start--;\n-        if (start < 0 || length <= 0 || len2 == 0 || start > len1) {\n-            return s1;\n-        }\n-        if (start + length > len1) {\n-            length = len1 - start;\n-        }\n-        return s1.substring(0, start) + s2 + s1.substring(start + length);\n-    }\n-\n-    private static String hexToRaw(String s) {\n-        // TODO function hextoraw compatibility with oracle\n-        int len = s.length();\n-        if (len % 4 != 0) {\n-            throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1, s);\n-        }\n-        StringBuilder buff = new StringBuilder(len / 4);\n-        for (int i = 0; i < len; i += 4) {\n-            try {\n-                char raw = (char) Integer.parseInt(s.substring(i, i + 4), 16);\n-                buff.append(raw);\n-            } catch (NumberFormatException e) {\n-                throw DbException.get(ErrorCode.DATA_CONVERSION_ERROR_1, s);\n-            }\n-        }\n-        return buff.toString();\n-    }\n-\n-    private static int getDifference(String s1, String s2) {\n-        // TODO function difference: compatibility with SQL Server and HSQLDB\n-        s1 = getSoundex(s1);\n-        s2 = getSoundex(s2);\n-        int e = 0;\n-        for (int i = 0; i < 4; i++) {\n-            if (s1.charAt(i) == s2.charAt(i)) {\n-                e++;\n-            }\n-        }\n-        return e;\n-    }\n-\n-    private static String translate(String original, String findChars,\n-            String replaceChars) {\n-        if (StringUtils.isNullOrEmpty(original) ||\n-                StringUtils.isNullOrEmpty(findChars)) {\n-            return original;\n-        }\n-        // if it stays null, then no replacements have been made\n-        StringBuilder buff = null;\n-        // if shorter than findChars, then characters are removed\n-        // (if null, we don't access replaceChars at all)\n-        int replaceSize = replaceChars == null ? 0 : replaceChars.length();\n-        for (int i = 0, size = original.length(); i < size; i++) {\n-            char ch = original.charAt(i);\n-            int index = findChars.indexOf(ch);\n-            if (index >= 0) {\n-                if (buff == null) {\n-                    buff = new StringBuilder(size);\n-                    if (i > 0) {\n-                        buff.append(original.substring(0, i));\n-                    }\n-                }\n-                if (index < replaceSize) {\n-                    ch = replaceChars.charAt(index);\n-                }\n-            }\n-            if (buff != null) {\n-                buff.append(ch);\n-            }\n-        }\n-        return buff == null ? original : buff.toString();\n-    }\n-\n-    private static double roundMagic(double d) {\n-        if ((d < 0.0000000000001) && (d > -0.0000000000001)) {\n-            return 0.0;\n-        }\n-        if ((d > 1000000000000.) || (d < -1000000000000.)) {\n-            return d;\n-        }\n-        StringBuilder s = new StringBuilder();\n-        s.append(d);\n-        if (s.toString().indexOf('E') >= 0) {\n-            return d;\n-        }\n-        int len = s.length();\n-        if (len < 16) {\n-            return d;\n-        }\n-        if (s.toString().indexOf('.') > len - 3) {\n-            return d;\n-        }\n-        s.delete(len - 2, len);\n-        len -= 2;\n-        char c1 = s.charAt(len - 2);\n-        char c2 = s.charAt(len - 3);\n-        char c3 = s.charAt(len - 4);\n-        if ((c1 == '0') && (c2 == '0') && (c3 == '0')) {\n-            s.setCharAt(len - 1, '0');\n-        } else if ((c1 == '9') && (c2 == '9') && (c3 == '9')) {\n-            s.setCharAt(len - 1, '9');\n-            s.append('9');\n-            s.append('9');\n-            s.append('9');\n-        }\n-        return Double.parseDouble(s.toString());\n-    }\n-\n-    private static String getSoundex(String s) {\n-        int len = s.length();\n-        char[] chars = { '0', '0', '0', '0' };\n-        char lastDigit = '0';\n-        for (int i = 0, j = 0; i < len && j < 4; i++) {\n-            char c = s.charAt(i);\n-            char newDigit = c > SOUNDEX_INDEX.length ?\n-                    0 : SOUNDEX_INDEX[c];\n-            if (newDigit != 0) {\n-                if (j == 0) {\n-                    chars[j++] = c;\n-                    lastDigit = newDigit;\n-                } else if (newDigit <= '6') {\n-                    if (newDigit != lastDigit) {\n-                        chars[j++] = newDigit;\n-                        lastDigit = newDigit;\n-                    }\n-                } else if (newDigit == '7') {\n-                    lastDigit = newDigit;\n-                }\n-            }\n-        }\n-        return new String(chars);\n-    }\n-\n-    private static Integer oraHash(String s, Integer bucket, Integer seed) {\n-        int hc = s.hashCode();\n-        if (seed != null && seed.intValue() != 0) {\n-            hc *= seed.intValue() * 17;\n-        }\n-        if (bucket == null  || bucket.intValue() <= 0) {\n-            // do nothing\n-        } else {\n-            hc %= bucket.intValue();\n-        }\n-        return hc;\n-    }\n-\n-    private static int makeRegexpFlags(String stringFlags) {\n-        int flags = Pattern.UNICODE_CASE;\n-        if (stringFlags != null) {\n-            for (int i = 0; i < stringFlags.length(); ++i) {\n-                switch (stringFlags.charAt(i)) {\n-                    case 'i':\n-                        flags |= Pattern.CASE_INSENSITIVE;\n-                        break;\n-                    case 'c':\n-                        flags &= ~Pattern.CASE_INSENSITIVE;\n-                        break;\n-                    case 'n':\n-                        flags |= Pattern.DOTALL;\n-                        break;\n-                    case 'm':\n-                        flags |= Pattern.MULTILINE;\n-                        break;\n-                    default:\n-                        throw DbException.get(ErrorCode.INVALID_VALUE_2, stringFlags);\n-                }\n-            }\n-        }\n-        return flags;\n-    }\n-\n-    @Override\n-    public int getType() {\n-        return dataType;\n-    }\n-\n-    @Override\n-    public void mapColumns(ColumnResolver resolver, int level) {\n-        for (Expression e : args) {\n-            if (e != null) {\n-                e.mapColumns(resolver, level);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if the parameter count is correct.\n-     *\n-     * @param len the number of parameters set\n-     * @throws DbException if the parameter count is incorrect\n-     */\n-    protected void checkParameterCount(int len) {\n-        int min = 0, max = Integer.MAX_VALUE;\n-        switch (info.type) {\n-        case COALESCE:\n-        case CSVREAD:\n-        case LEAST:\n-        case GREATEST:\n-            min = 1;\n-            break;\n-        case NOW:\n-        case CURRENT_TIMESTAMP:\n-        case RAND:\n-            max = 1;\n-            break;\n-        case COMPRESS:\n-        case LTRIM:\n-        case RTRIM:\n-        case TRIM:\n-        case FILE_READ:\n-        case ROUND:\n-        case XMLTEXT:\n-        case TRUNCATE:\n-        case TO_TIMESTAMP:\n-            min = 1;\n-            max = 2;\n-            break;\n-        case TO_CHAR:\n-        case TO_DATE:\n-            min = 1;\n-            max = 3;\n-            break;\n-        case ORA_HASH:\n-            min = 1;\n-            max = 3;\n-            break;\n-        case REPLACE:\n-        case LOCATE:\n-        case INSTR:\n-        case SUBSTR:\n-        case SUBSTRING:\n-        case LPAD:\n-        case RPAD:\n-            min = 2;\n-            max = 3;\n-            break;\n-        case CONCAT:\n-        case CONCAT_WS:\n-        case CSVWRITE:\n-            min = 2;\n-            break;\n-        case XMLNODE:\n-            min = 1;\n-            max = 4;\n-            break;\n-        case FORMATDATETIME:\n-        case PARSEDATETIME:\n-            min = 2;\n-            max = 4;\n-            break;\n-        case CURRVAL:\n-        case NEXTVAL:\n-            min = 1;\n-            max = 2;\n-            break;\n-        case DECODE:\n-        case CASE:\n-            min = 3;\n-            break;\n-        case REGEXP_REPLACE:\n-            min = 3;\n-            max = 4;\n-            break;\n-        case REGEXP_LIKE:\n-            min = 2;\n-            max = 3;\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + info.type);\n-        }\n-        boolean ok = (len >= min) && (len <= max);\n-        if (!ok) {\n-            throw DbException.get(\n-                    ErrorCode.INVALID_PARAMETER_COUNT_2,\n-                    info.name, min + \"..\" + max);\n-        }\n-    }\n-\n-    /**\n-     * This method is called after all the parameters have been set.\n-     * It checks if the parameter count is correct.\n-     *\n-     * @throws DbException if the parameter count is incorrect.\n-     */\n-    public void doneWithParameters() {\n-        if (info.parameterCount == VAR_ARGS) {\n-            int len = varArgs.size();\n-            checkParameterCount(len);\n-            args = new Expression[len];\n-            varArgs.toArray(args);\n-            varArgs = null;\n-        } else {\n-            int len = args.length;\n-            if (len > 0 && args[len - 1] == null) {\n-                throw DbException.get(\n-                        ErrorCode.INVALID_PARAMETER_COUNT_2,\n-                        info.name, \"\" + len);\n-            }\n-        }\n-    }\n-\n-    public void setDataType(Column col) {\n-        dataType = col.getType();\n-        precision = col.getPrecision();\n-        displaySize = col.getDisplaySize();\n-        scale = col.getScale();\n-    }\n-\n-    @Override\n-    public Expression optimize(Session session) {\n-        boolean allConst = info.deterministic;\n-        for (int i = 0; i < args.length; i++) {\n-            Expression e = args[i];\n-            if (e == null) {\n-                continue;\n-            }\n-            e = e.optimize(session);\n-            args[i] = e;\n-            if (!e.isConstant()) {\n-                allConst = false;\n-            }\n-        }\n-        int t, s, d;\n-        long p;\n-        Expression p0 = args.length < 1 ? null : args[0];\n-        switch (info.type) {\n-        case IFNULL:\n-        case NULLIF:\n-        case COALESCE:\n-        case LEAST:\n-        case GREATEST: {\n-            t = Value.UNKNOWN;\n-            s = 0;\n-            p = 0;\n-            d = 0;\n-            for (Expression e : args) {\n-                if (e != ValueExpression.getNull()) {\n-                    int type = e.getType();\n-                    if (type != Value.UNKNOWN && type != Value.NULL) {\n-                        t = Value.getHigherOrder(t, type);\n-                        s = Math.max(s, e.getScale());\n-                        p = Math.max(p, e.getPrecision());\n-                        d = Math.max(d, e.getDisplaySize());\n-                    }\n-                }\n-            }\n-            if (t == Value.UNKNOWN) {\n-                t = Value.STRING;\n-                s = 0;\n-                p = Integer.MAX_VALUE;\n-                d = Integer.MAX_VALUE;\n-            }\n-            break;\n-        }\n-        case CASE:\n-        case DECODE: {\n-            t = Value.UNKNOWN;\n-            s = 0;\n-            p = 0;\n-            d = 0;\n-            // (expr, when, then)\n-            // (expr, when, then, else)\n-            // (expr, when, then, when, then)\n-            // (expr, when, then, when, then, else)\n-            for (int i = 2, len = args.length; i < len; i += 2) {\n-                Expression then = args[i];\n-                if (then != ValueExpression.getNull()) {\n-                    int type = then.getType();\n-                    if (type != Value.UNKNOWN && type != Value.NULL) {\n-                        t = Value.getHigherOrder(t, type);\n-                        s = Math.max(s, then.getScale());\n-                        p = Math.max(p, then.getPrecision());\n-                        d = Math.max(d, then.getDisplaySize());\n-                    }\n-                }\n-            }\n-            if (args.length % 2 == 0) {\n-                Expression elsePart = args[args.length - 1];\n-                if (elsePart != ValueExpression.getNull()) {\n-                    int type = elsePart.getType();\n-                    if (type != Value.UNKNOWN && type != Value.NULL) {\n-                        t = Value.getHigherOrder(t, type);\n-                        s = Math.max(s, elsePart.getScale());\n-                        p = Math.max(p, elsePart.getPrecision());\n-                        d = Math.max(d, elsePart.getDisplaySize());\n-                    }\n-                }\n-            }\n-            if (t == Value.UNKNOWN) {\n-                t = Value.STRING;\n-                s = 0;\n-                p = Integer.MAX_VALUE;\n-                d = Integer.MAX_VALUE;\n-            }\n-            break;\n-        }\n-        case CASEWHEN:\n-            t = Value.getHigherOrder(args[1].getType(), args[2].getType());\n-            p = Math.max(args[1].getPrecision(), args[2].getPrecision());\n-            d = Math.max(args[1].getDisplaySize(), args[2].getDisplaySize());\n-            s = Math.max(args[1].getScale(), args[2].getScale());\n-            break;\n-        case NVL2:\n-            switch (args[1].getType()) {\n-            case Value.STRING:\n-            case Value.CLOB:\n-            case Value.STRING_FIXED:\n-            case Value.STRING_IGNORECASE:\n-                t = args[1].getType();\n-                break;\n-            default:\n-                t = Value.getHigherOrder(args[1].getType(), args[2].getType());\n-                break;\n-            }\n-            p = Math.max(args[1].getPrecision(), args[2].getPrecision());\n-            d = Math.max(args[1].getDisplaySize(), args[2].getDisplaySize());\n-            s = Math.max(args[1].getScale(), args[2].getScale());\n-            break;\n-        case CAST:\n-        case CONVERT:\n-        case TRUNCATE_VALUE:\n-            // data type, precision and scale is already set\n-            t = dataType;\n-            p = precision;\n-            s = scale;\n-            d = displaySize;\n-            break;\n-        case TRUNCATE:\n-            t = p0.getType();\n-            s = p0.getScale();\n-            p = p0.getPrecision();\n-            d = p0.getDisplaySize();\n-            if (t == Value.NULL) {\n-                t = Value.INT;\n-                p = ValueInt.PRECISION;\n-                d = ValueInt.DISPLAY_SIZE;\n-                s = 0;\n-            } else if (t == Value.TIMESTAMP) {\n-                t = Value.DATE;\n-                p = ValueDate.PRECISION;\n-                s = 0;\n-                d = ValueDate.DISPLAY_SIZE;\n-            }\n-            break;\n-        case ABS:\n-        case FLOOR:\n-        case ROUND:\n-            t = p0.getType();\n-            s = p0.getScale();\n-            p = p0.getPrecision();\n-            d = p0.getDisplaySize();\n-            if (t == Value.NULL) {\n-                t = Value.INT;\n-                p = ValueInt.PRECISION;\n-                d = ValueInt.DISPLAY_SIZE;\n-                s = 0;\n-            }\n-            break;\n-        case SET: {\n-            Expression p1 = args[1];\n-            t = p1.getType();\n-            p = p1.getPrecision();\n-            s = p1.getScale();\n-            d = p1.getDisplaySize();\n-            if (!(p0 instanceof Variable)) {\n-                throw DbException.get(\n-                        ErrorCode.CAN_ONLY_ASSIGN_TO_VARIABLE_1, p0.getSQL());\n-            }\n-            break;\n-        }\n-        case FILE_READ: {\n-            if (args.length == 1) {\n-                t = Value.BLOB;\n-            } else {\n-                t = Value.CLOB;\n-            }\n-            p = Integer.MAX_VALUE;\n-            s = 0;\n-            d = Integer.MAX_VALUE;\n-            break;\n-        }\n-        case SUBSTRING:\n-        case SUBSTR: {\n-            t = info.returnDataType;\n-            p = args[0].getPrecision();\n-            s = 0;\n-            if (args[1].isConstant()) {\n-                // if only two arguments are used,\n-                // subtract offset from first argument length\n-                p -= args[1].getValue(session).getLong() - 1;\n-            }\n-            if (args.length == 3 && args[2].isConstant()) {\n-                // if the third argument is constant it is at most this value\n-                p = Math.min(p, args[2].getValue(session).getLong());\n-            }\n-            p = Math.max(0, p);\n-            d = MathUtils.convertLongToInt(p);\n-            break;\n-        }\n-        default:\n-            t = info.returnDataType;\n-            DataType type = DataType.getDataType(t);\n-            p = PRECISION_UNKNOWN;\n-            d = 0;\n-            s = type.defaultScale;\n-        }\n-        dataType = t;\n-        precision = p;\n-        scale = s;\n-        displaySize = d;\n-        if (allConst) {\n-            Value v = getValue(session);\n-            if (v == ValueNull.INSTANCE) {\n-                if (info.type == CAST || info.type == CONVERT) {\n-                    return this;\n-                }\n-            }\n-            return ValueExpression.get(v);\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        for (Expression e : args) {\n-            if (e != null) {\n-                e.setEvaluatable(tableFilter, b);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int getScale() {\n-        return scale;\n-    }\n-\n-    @Override\n-    public long getPrecision() {\n-        if (precision == PRECISION_UNKNOWN) {\n-            calculatePrecisionAndDisplaySize();\n-        }\n-        return precision;\n-    }\n-\n-    @Override\n-    public int getDisplaySize() {\n-        if (precision == PRECISION_UNKNOWN) {\n-            calculatePrecisionAndDisplaySize();\n-        }\n-        return displaySize;\n-    }\n-\n-    private void calculatePrecisionAndDisplaySize() {\n-        switch (info.type) {\n-        case ENCRYPT:\n-        case DECRYPT:\n-            precision = args[2].getPrecision();\n-            displaySize = args[2].getDisplaySize();\n-            break;\n-        case COMPRESS:\n-            precision = args[0].getPrecision();\n-            displaySize = args[0].getDisplaySize();\n-            break;\n-        case CHAR:\n-            precision = 1;\n-            displaySize = 1;\n-            break;\n-        case CONCAT:\n-            precision = 0;\n-            displaySize = 0;\n-            for (Expression e : args) {\n-                precision += e.getPrecision();\n-                displaySize = MathUtils.convertLongToInt(\n-                        (long) displaySize + e.getDisplaySize());\n-                if (precision < 0) {\n-                    precision = Long.MAX_VALUE;\n-                }\n-            }\n-            break;\n-        case HEXTORAW:\n-            precision = (args[0].getPrecision() + 3) / 4;\n-            displaySize = MathUtils.convertLongToInt(precision);\n-            break;\n-        case LCASE:\n-        case LTRIM:\n-        case RIGHT:\n-        case RTRIM:\n-        case UCASE:\n-        case LOWER:\n-        case UPPER:\n-        case TRIM:\n-        case STRINGDECODE:\n-        case UTF8TOSTRING:\n-        case TRUNCATE:\n-            precision = args[0].getPrecision();\n-            displaySize = args[0].getDisplaySize();\n-            break;\n-        case RAWTOHEX:\n-            precision = args[0].getPrecision() * 4;\n-            displaySize = MathUtils.convertLongToInt(precision);\n-            break;\n-        case SOUNDEX:\n-            precision = 4;\n-            displaySize = (int) precision;\n-            break;\n-        case DAY_NAME:\n-        case MONTH_NAME:\n-            // day and month names may be long in some languages\n-            precision = 20;\n-            displaySize = (int) precision;\n-            break;\n-        default:\n-            DataType type = DataType.getDataType(dataType);\n-            precision = type.defaultPrecision;\n-            displaySize = type.defaultDisplaySize;\n-        }\n-    }\n-\n-    @Override\n-    public String getSQL() {\n-        StatementBuilder buff = new StatementBuilder(info.name);\n-        if (info.type == CASE) {\n-            if (args[0] != null) {\n-                buff.append(\" \").append(args[0].getSQL());\n-            }\n-            for (int i = 1, len = args.length - 1; i < len; i += 2) {\n-                buff.append(\" WHEN \").append(args[i].getSQL());\n-                buff.append(\" THEN \").append(args[i + 1].getSQL());\n-            }\n-            if (args.length % 2 == 0) {\n-                buff.append(\" ELSE \").append(args[args.length - 1].getSQL());\n-            }\n-            return buff.append(\" END\").toString();\n-        }\n-        buff.append('(');\n-        switch (info.type) {\n-        case CAST: {\n-            buff.append(args[0].getSQL()).append(\" AS \").\n-                append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL());\n-            break;\n-        }\n-        case CONVERT: {\n-            if (database.getMode().swapConvertFunctionParameters) {\n-                buff.append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL()).\n-                    append(',').append(args[0].getSQL());\n-            } else {\n-                buff.append(args[0].getSQL()).append(',').\n-                    append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL());\n-            }\n-            break;\n-        }\n-        case EXTRACT: {\n-            ValueString v = (ValueString) ((ValueExpression) args[0]).getValue(null);\n-            buff.append(v.getString()).append(\" FROM \").append(args[1].getSQL());\n-            break;\n-        }\n-        default: {\n-            for (Expression e : args) {\n-                buff.appendExceptFirst(\", \");\n-                buff.append(e.getSQL());\n-            }\n-        }\n-        }\n-        return buff.append(')').toString();\n-    }\n-\n-    @Override\n-    public void updateAggregate(Session session) {\n-        for (Expression e : args) {\n-            if (e != null) {\n-                e.updateAggregate(session);\n-            }\n-        }\n-    }\n-\n-    public int getFunctionType() {\n-        return info.type;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return info.name;\n-    }\n-\n-    @Override\n-    public ValueResultSet getValueForColumnList(Session session,\n-            Expression[] argList) {\n-        switch (info.type) {\n-        case CSVREAD: {\n-            String fileName = argList[0].getValue(session).getString();\n-            if (fileName == null) {\n-                throw DbException.get(ErrorCode.PARAMETER_NOT_SET_1, \"fileName\");\n-            }\n-            String columnList = argList.length < 2 ?\n-                    null : argList[1].getValue(session).getString();\n-            Csv csv = new Csv();\n-            String options = argList.length < 3 ?\n-                    null : argList[2].getValue(session).getString();\n-            String charset = null;\n-            if (options != null && options.indexOf('=') >= 0) {\n-                charset = csv.setOptions(options);\n-            } else {\n-                charset = options;\n-                String fieldSeparatorRead = argList.length < 4 ?\n-                        null : argList[3].getValue(session).getString();\n-                String fieldDelimiter = argList.length < 5 ?\n-                        null : argList[4].getValue(session).getString();\n-                String escapeCharacter = argList.length < 6 ?\n-                        null : argList[5].getValue(session).getString();\n-                setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter,\n-                        escapeCharacter);\n-            }\n-            char fieldSeparator = csv.getFieldSeparatorRead();\n-            String[] columns = StringUtils.arraySplit(columnList, fieldSeparator, true);\n-            ResultSet rs = null;\n-            ValueResultSet x;\n-            try {\n-                rs = csv.read(fileName, columns, charset);\n-                x = ValueResultSet.getCopy(rs, 0);\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            } finally {\n-                csv.close();\n-                JdbcUtils.closeSilently(rs);\n-            }\n-            return x;\n-        }\n-        default:\n-            break;\n-        }\n-        return (ValueResultSet) getValueWithArgs(session, argList);\n-    }\n-\n-    private static void setCsvDelimiterEscape(Csv csv, String fieldSeparator,\n-            String fieldDelimiter, String escapeCharacter) {\n-        if (fieldSeparator != null) {\n-            csv.setFieldSeparatorWrite(fieldSeparator);\n-            if (fieldSeparator.length() > 0) {\n-                char fs = fieldSeparator.charAt(0);\n-                csv.setFieldSeparatorRead(fs);\n-            }\n-        }\n-        if (fieldDelimiter != null) {\n-            char fd = fieldDelimiter.length() == 0 ?\n-                    0 : fieldDelimiter.charAt(0);\n-            csv.setFieldDelimiter(fd);\n-        }\n-        if (escapeCharacter != null) {\n-            char ec = escapeCharacter.length() == 0 ?\n-                    0 : escapeCharacter.charAt(0);\n-            csv.setEscapeCharacter(ec);\n-        }\n-    }\n-\n-    @Override\n-    public Expression[] getArgs() {\n-        return args;\n-    }\n-\n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        for (Expression e : args) {\n-            if (e != null && !e.isEverything(visitor)) {\n-                return false;\n-            }\n-        }\n-        switch (visitor.getType()) {\n-        case ExpressionVisitor.DETERMINISTIC:\n-        case ExpressionVisitor.QUERY_COMPARABLE:\n-        case ExpressionVisitor.READONLY:\n-            return info.deterministic;\n-        case ExpressionVisitor.EVALUATABLE:\n-        case ExpressionVisitor.GET_DEPENDENCIES:\n-        case ExpressionVisitor.INDEPENDENT:\n-        case ExpressionVisitor.NOT_FROM_RESOLVER:\n-        case ExpressionVisitor.OPTIMIZABLE_MIN_MAX_COUNT_ALL:\n-        case ExpressionVisitor.SET_MAX_DATA_MODIFICATION_ID:\n-        case ExpressionVisitor.GET_COLUMNS:\n-            return true;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + visitor.getType());\n-        }\n-    }\n-\n-    @Override\n-    public int getCost() {\n-        int cost = 3;\n-        for (Expression e : args) {\n-            if (e != null) {\n-                cost += e.getCost();\n-            }\n-        }\n-        return cost;\n-    }\n-\n-    @Override\n-    public boolean isDeterministic() {\n+    switch (visitor.getType()) {\n+      case ExpressionVisitor.DETERMINISTIC:\n+      case ExpressionVisitor.QUERY_COMPARABLE:\n+      case ExpressionVisitor.READONLY:\n         return info.deterministic;\n-    }\n-\n-    @Override\n-    public boolean isBufferResultSetToLocalTemp() {\n-        return info.bufferResultSetToLocalTemp;\n-    }\n+      case ExpressionVisitor.EVALUATABLE:\n+      case ExpressionVisitor.GET_DEPENDENCIES:\n+      case ExpressionVisitor.INDEPENDENT:\n+      case ExpressionVisitor.NOT_FROM_RESOLVER:\n+      case ExpressionVisitor.OPTIMIZABLE_MIN_MAX_COUNT_ALL:\n+      case ExpressionVisitor.SET_MAX_DATA_MODIFICATION_ID:\n+      case ExpressionVisitor.GET_COLUMNS:\n+        return true;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + visitor.getType());\n+    }\n+  }\n+\n+  @Override\n+  public int getCost() {\n+    int cost = 3;\n+    for (Expression e : args) {\n+      if (e != null) {\n+        cost += e.getCost();\n+      }\n+    }\n+    return cost;\n+  }\n+\n+  @Override\n+  public boolean isDeterministic() {\n+    return info.deterministic;\n+  }\n+\n+  @Override\n+  public boolean isBufferResultSetToLocalTemp() {\n+    return info.bufferResultSetToLocalTemp;\n+  }\n \n }\n",
            "diff_size": 4536
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/240/Function.java\nindex ff01f50943..6b76964a75 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/naturalize/240/Function.java\n@@ -279,7 +279,7 @@ public class Function extends Expression implements FunctionCall {\n         addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n         addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n         addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n-        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n+        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true, true);\n         addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n         addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n         addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n@@ -1411,8 +1411,7 @@ public class Function extends Expression implements FunctionCall {\n         case REGEXP_REPLACE: {\n             String regexp = v1.getString();\n             String replacement = v2.getString();\n-            String regexpMode = v3 == null || v3.getString() == null ? \"\" :\n-                    v3.getString();\n+            String regexpMode = v3 == null || v3.getString() == null ? \"\" : v3.getString();\n             int flags = makeRegexpFlags(regexpMode);\n             try {\n                 result = ValueString.get(\n@@ -1688,8 +1687,7 @@ public class Function extends Expression implements FunctionCall {\n             break;\n         case REGEXP_LIKE: {\n             String regexp = v1.getString();\n-            String regexpMode = v2 == null || v2.getString() == null ? \"\" :\n-                    v2.getString();\n+            String regexpMode = v2 == null || v2.getString() == null ? \"\" : v2.getString();\n             int flags = makeRegexpFlags(regexpMode);\n             try {\n                 result = ValueBoolean.get(Pattern.compile(regexp, flags)\n@@ -2654,12 +2652,10 @@ public class Function extends Expression implements FunctionCall {\n         case CONVERT: {\n             if (database.getMode().swapConvertFunctionParameters) {\n                 buff.append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL()).\n-                    append(',').append(args[0].getSQL());\n+                        scale, displaySize).getCreateSQL()).append(',').append(args[0].getSQL());\n             } else {\n                 buff.append(args[0].getSQL()).append(',').\n-                    append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL());\n+                    append(new Column(null, dataType, precision, scale, displaySize).getCreateSQL());\n             }\n             break;\n         }\n@@ -2817,4 +2813,4 @@ public class Function extends Expression implements FunctionCall {\n         return info.bufferResultSetToLocalTemp;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 10
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/240/Function.java\nindex ff01f50943..7980538e50 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/codebuff/240/Function.java\n@@ -74,78 +74,53 @@ import org.h2.value.ValueUuid;\n /**\n  * This class implements most built-in functions of this database.\n  */\n+\n+\n public class Function extends Expression implements FunctionCall {\n-    public static final int ABS = 0, ACOS = 1, ASIN = 2, ATAN = 3, ATAN2 = 4,\n-            BITAND = 5, BITOR = 6, BITXOR = 7, CEILING = 8, COS = 9, COT = 10,\n-            DEGREES = 11, EXP = 12, FLOOR = 13, LOG = 14, LOG10 = 15, MOD = 16,\n-            PI = 17, POWER = 18, RADIANS = 19, RAND = 20, ROUND = 21,\n-            ROUNDMAGIC = 22, SIGN = 23, SIN = 24, SQRT = 25, TAN = 26,\n-            TRUNCATE = 27, SECURE_RAND = 28, HASH = 29, ENCRYPT = 30,\n-            DECRYPT = 31, COMPRESS = 32, EXPAND = 33, ZERO = 34,\n-            RANDOM_UUID = 35, COSH = 36, SINH = 37, TANH = 38, LN = 39,\n-            BITGET = 40;\n-\n-    public static final int ASCII = 50, BIT_LENGTH = 51, CHAR = 52,\n-            CHAR_LENGTH = 53, CONCAT = 54, DIFFERENCE = 55, HEXTORAW = 56,\n-            INSERT = 57, INSTR = 58, LCASE = 59, LEFT = 60, LENGTH = 61,\n-            LOCATE = 62, LTRIM = 63, OCTET_LENGTH = 64, RAWTOHEX = 65,\n-            REPEAT = 66, REPLACE = 67, RIGHT = 68, RTRIM = 69, SOUNDEX = 70,\n-            SPACE = 71, SUBSTR = 72, SUBSTRING = 73, UCASE = 74, LOWER = 75,\n-            UPPER = 76, POSITION = 77, TRIM = 78, STRINGENCODE = 79,\n-            STRINGDECODE = 80, STRINGTOUTF8 = 81, UTF8TOSTRING = 82,\n-            XMLATTR = 83, XMLNODE = 84, XMLCOMMENT = 85, XMLCDATA = 86,\n-            XMLSTARTDOC = 87, XMLTEXT = 88, REGEXP_REPLACE = 89, RPAD = 90,\n-            LPAD = 91, CONCAT_WS = 92, TO_CHAR = 93, TRANSLATE = 94, ORA_HASH = 95,\n-            TO_DATE = 96, TO_TIMESTAMP = 97, ADD_MONTHS = 98;\n-\n-    public static final int CURDATE = 100, CURTIME = 101, DATE_ADD = 102,\n-            DATE_DIFF = 103, DAY_NAME = 104, DAY_OF_MONTH = 105,\n-            DAY_OF_WEEK = 106, DAY_OF_YEAR = 107, HOUR = 108, MINUTE = 109,\n-            MONTH = 110, MONTH_NAME = 111, NOW = 112, QUARTER = 113,\n-            SECOND = 114, WEEK = 115, YEAR = 116, CURRENT_DATE = 117,\n-            CURRENT_TIME = 118, CURRENT_TIMESTAMP = 119, EXTRACT = 120,\n-            FORMATDATETIME = 121, PARSEDATETIME = 122, ISO_YEAR = 123,\n-            ISO_WEEK = 124, ISO_DAY_OF_WEEK = 125;\n-\n-    public static final int DATABASE = 150, USER = 151, CURRENT_USER = 152,\n-            IDENTITY = 153, SCOPE_IDENTITY = 154, AUTOCOMMIT = 155,\n-            READONLY = 156, DATABASE_PATH = 157, LOCK_TIMEOUT = 158,\n-            DISK_SPACE_USED = 159;\n-\n-    public static final int IFNULL = 200, CASEWHEN = 201, CONVERT = 202,\n-            CAST = 203, COALESCE = 204, NULLIF = 205, CASE = 206,\n-            NEXTVAL = 207, CURRVAL = 208, ARRAY_GET = 209, CSVREAD = 210,\n-            CSVWRITE = 211, MEMORY_FREE = 212, MEMORY_USED = 213,\n-            LOCK_MODE = 214, SCHEMA = 215, SESSION_ID = 216,\n-            ARRAY_LENGTH = 217, LINK_SCHEMA = 218, GREATEST = 219, LEAST = 220,\n-            CANCEL_SESSION = 221, SET = 222, TABLE = 223, TABLE_DISTINCT = 224,\n-            FILE_READ = 225, TRANSACTION_ID = 226, TRUNCATE_VALUE = 227,\n-            NVL2 = 228, DECODE = 229, ARRAY_CONTAINS = 230, FILE_WRITE = 232;\n+\n+\n+    public static final int ABS = 0, ACOS = 1, ASIN = 2, ATAN = 3, ATAN2 = 4, BITAND = 5, BITOR = 6, BITXOR = 7, CEILING = 8, COS = 9, COT = 10, DEGREES = 11, EXP = 12, FLOOR = 13, LOG = 14, LOG10 = 15, MOD = 16, PI = 17, POWER = 18, RADIANS = 19, RAND = 20, ROUND = 21, ROUNDMAGIC = 22, SIGN = 23, SIN = 24, SQRT = 25, TAN = 26, TRUNCATE = 27, SECURE_RAND = 28, HASH = 29, ENCRYPT = 30, DECRYPT = 31, COMPRESS = 32, EXPAND = 33, ZERO = 34, RANDOM_UUID = 35, COSH = 36, SINH = 37, TANH = 38, LN = 39, BITGET = 40;\n+\n+\n+    public static final int ASCII = 50, BIT_LENGTH = 51, CHAR = 52, CHAR_LENGTH = 53, CONCAT = 54, DIFFERENCE = 55, HEXTORAW = 56, INSERT = 57, INSTR = 58, LCASE = 59, LEFT = 60, LENGTH = 61, LOCATE = 62, LTRIM = 63, OCTET_LENGTH = 64, RAWTOHEX = 65, REPEAT = 66, REPLACE = 67, RIGHT = 68, RTRIM = 69, SOUNDEX = 70, SPACE = 71, SUBSTR = 72, SUBSTRING = 73, UCASE = 74, LOWER = 75, UPPER = 76, POSITION = 77, TRIM = 78, STRINGENCODE = 79, STRINGDECODE = 80, STRINGTOUTF8 = 81, UTF8TOSTRING = 82, XMLATTR = 83, XMLNODE = 84, XMLCOMMENT = 85, XMLCDATA = 86, XMLSTARTDOC = 87, XMLTEXT = 88, REGEXP_REPLACE = 89, RPAD = 90, LPAD = 91, CONCAT_WS = 92, TO_CHAR = 93, TRANSLATE = 94, ORA_HASH = 95, TO_DATE = 96, TO_TIMESTAMP = 97, ADD_MONTHS = 98;\n+\n+\n+    public static final int CURDATE = 100, CURTIME = 101, DATE_ADD = 102, DATE_DIFF = 103, DAY_NAME = 104, DAY_OF_MONTH = 105, DAY_OF_WEEK = 106, DAY_OF_YEAR = 107, HOUR = 108, MINUTE = 109, MONTH = 110, MONTH_NAME = 111, NOW = 112, QUARTER = 113, SECOND = 114, WEEK = 115, YEAR = 116, CURRENT_DATE = 117, CURRENT_TIME = 118, CURRENT_TIMESTAMP = 119, EXTRACT = 120, FORMATDATETIME = 121, PARSEDATETIME = 122, ISO_YEAR = 123, ISO_WEEK = 124, ISO_DAY_OF_WEEK = 125;\n+\n+\n+    public static final int DATABASE = 150, USER = 151, CURRENT_USER = 152, IDENTITY = 153, SCOPE_IDENTITY = 154, AUTOCOMMIT = 155, READONLY = 156, DATABASE_PATH = 157, LOCK_TIMEOUT = 158, DISK_SPACE_USED = 159;\n+\n+\n+    public static final int IFNULL = 200, CASEWHEN = 201, CONVERT = 202, CAST = 203, COALESCE = 204, NULLIF = 205, CASE = 206, NEXTVAL = 207, CURRVAL = 208, ARRAY_GET = 209, CSVREAD = 210, CSVWRITE = 211, MEMORY_FREE = 212, MEMORY_USED = 213, LOCK_MODE = 214, SCHEMA = 215, SESSION_ID = 216, ARRAY_LENGTH = 217, LINK_SCHEMA = 218, GREATEST = 219, LEAST = 220, CANCEL_SESSION = 221, SET = 222, TABLE = 223, TABLE_DISTINCT = 224, FILE_READ = 225, TRANSACTION_ID = 226, TRUNCATE_VALUE = 227, NVL2 = 228, DECODE = 229, ARRAY_CONTAINS = 230, FILE_WRITE = 232;\n+\n \n     public static final int REGEXP_LIKE = 240;\n \n     /**\n      * Used in MySQL-style INSERT ... ON DUPLICATE KEY UPDATE ... VALUES\n      */\n+\n+\n     public static final int VALUES = 250;\n \n     /**\n      * This is called H2VERSION() and not VERSION(), because we return a fake\n      * value for VERSION() when running under the PostgreSQL ODBC driver.\n      */\n+\n+\n     public static final int H2VERSION = 231;\n \n-    public static final int ROW_NUMBER = 300;\n \n+    public static final int ROW_NUMBER = 300;\n     private static final int VAR_ARGS = -1;\n     private static final long PRECISION_UNKNOWN = -1;\n-\n     private static final HashMap<String, FunctionInfo> FUNCTIONS = New.hashMap();\n     private static final HashMap<String, Integer> DATE_PART = New.hashMap();\n     private static final char[] SOUNDEX_INDEX = new char[128];\n \n-    protected Expression[] args;\n \n+    protected Expression[] args;\n     private final FunctionInfo info;\n     private ArrayList<Expression> varArgs;\n     private int dataType, scale;\n@@ -279,7 +254,7 @@ public class Function extends Expression implements FunctionCall {\n         addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n         addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n         addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n-        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n+        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true, true);\n         addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n         addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n         addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n@@ -310,184 +285,116 @@ public class Function extends Expression implements FunctionCall {\n         addFunction(\"REGEXP_LIKE\", REGEXP_LIKE, VAR_ARGS, Value.BOOLEAN);\n \n         // date\n-        addFunctionNotDeterministic(\"CURRENT_DATE\", CURRENT_DATE,\n-                0, Value.DATE);\n-        addFunctionNotDeterministic(\"CURDATE\", CURDATE,\n-                0, Value.DATE);\n-        addFunctionNotDeterministic(\"TODAY\", CURRENT_DATE,\n-                0, Value.DATE);\n+        addFunctionNotDeterministic(\"CURRENT_DATE\", CURRENT_DATE, 0, Value.DATE);\n+        addFunctionNotDeterministic(\"CURDATE\", CURDATE, 0, Value.DATE);\n+        addFunctionNotDeterministic(\"TODAY\", CURRENT_DATE, 0, Value.DATE);\n         addFunction(\"TO_DATE\", TO_DATE, VAR_ARGS, Value.TIMESTAMP);\n         addFunction(\"TO_TIMESTAMP\", TO_TIMESTAMP, VAR_ARGS, Value.TIMESTAMP);\n         addFunction(\"ADD_MONTHS\", ADD_MONTHS, 2, Value.TIMESTAMP);\n         // alias for MSSQLServer\n-        addFunctionNotDeterministic(\"GETDATE\", CURDATE,\n-                0, Value.DATE);\n-        addFunctionNotDeterministic(\"CURRENT_TIME\", CURRENT_TIME,\n-                0, Value.TIME);\n-        addFunctionNotDeterministic(\"SYSTIME\", CURRENT_TIME,\n-                0, Value.TIME);\n-        addFunctionNotDeterministic(\"CURTIME\", CURTIME,\n-                0, Value.TIME);\n-        addFunctionNotDeterministic(\"CURRENT_TIMESTAMP\", CURRENT_TIMESTAMP,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunctionNotDeterministic(\"SYSDATE\", CURRENT_TIMESTAMP,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunctionNotDeterministic(\"SYSTIMESTAMP\", CURRENT_TIMESTAMP,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunctionNotDeterministic(\"NOW\", NOW,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunction(\"DATEADD\", DATE_ADD,\n-                3, Value.TIMESTAMP);\n-        addFunction(\"TIMESTAMPADD\", DATE_ADD,\n-                3, Value.LONG);\n-        addFunction(\"DATEDIFF\", DATE_DIFF,\n-                3, Value.LONG);\n-        addFunction(\"TIMESTAMPDIFF\", DATE_DIFF,\n-                3, Value.LONG);\n-        addFunction(\"DAYNAME\", DAY_NAME,\n-                1, Value.STRING);\n-        addFunction(\"DAYNAME\", DAY_NAME,\n-                1, Value.STRING);\n-        addFunction(\"DAY\", DAY_OF_MONTH,\n-                1, Value.INT);\n-        addFunction(\"DAY_OF_MONTH\", DAY_OF_MONTH,\n-                1, Value.INT);\n-        addFunction(\"DAY_OF_WEEK\", DAY_OF_WEEK,\n-                1, Value.INT);\n-        addFunction(\"DAY_OF_YEAR\", DAY_OF_YEAR,\n-                1, Value.INT);\n-        addFunction(\"DAYOFMONTH\", DAY_OF_MONTH,\n-                1, Value.INT);\n-        addFunction(\"DAYOFWEEK\", DAY_OF_WEEK,\n-                1, Value.INT);\n-        addFunction(\"DAYOFYEAR\", DAY_OF_YEAR,\n-                1, Value.INT);\n-        addFunction(\"HOUR\", HOUR,\n-                1, Value.INT);\n-        addFunction(\"MINUTE\", MINUTE,\n-                1, Value.INT);\n-        addFunction(\"MONTH\", MONTH,\n-                1, Value.INT);\n-        addFunction(\"MONTHNAME\", MONTH_NAME,\n-                1, Value.STRING);\n-        addFunction(\"QUARTER\", QUARTER,\n-                1, Value.INT);\n-        addFunction(\"SECOND\", SECOND,\n-                1, Value.INT);\n-        addFunction(\"WEEK\", WEEK,\n-                1, Value.INT);\n-        addFunction(\"YEAR\", YEAR,\n-                1, Value.INT);\n-        addFunction(\"EXTRACT\", EXTRACT,\n-                2, Value.INT);\n-        addFunctionWithNull(\"FORMATDATETIME\", FORMATDATETIME,\n-                VAR_ARGS, Value.STRING);\n-        addFunctionWithNull(\"PARSEDATETIME\", PARSEDATETIME,\n-                VAR_ARGS, Value.TIMESTAMP);\n-        addFunction(\"ISO_YEAR\", ISO_YEAR,\n-                1, Value.INT);\n-        addFunction(\"ISO_WEEK\", ISO_WEEK,\n-                1, Value.INT);\n-        addFunction(\"ISO_DAY_OF_WEEK\", ISO_DAY_OF_WEEK,\n-                1, Value.INT);\n+        addFunctionNotDeterministic(\"GETDATE\", CURDATE, 0, Value.DATE);\n+        addFunctionNotDeterministic(\"CURRENT_TIME\", CURRENT_TIME, 0, Value.TIME);\n+        addFunctionNotDeterministic(\"SYSTIME\", CURRENT_TIME, 0, Value.TIME);\n+        addFunctionNotDeterministic(\"CURTIME\", CURTIME, 0, Value.TIME);\n+        addFunctionNotDeterministic(\"CURRENT_TIMESTAMP\",\n+            CURRENT_TIMESTAMP,\n+                VAR_ARGS,\n+                    Value.TIMESTAMP);\n+        addFunctionNotDeterministic(\"SYSDATE\", CURRENT_TIMESTAMP, VAR_ARGS, Value.TIMESTAMP);\n+        addFunctionNotDeterministic(\"SYSTIMESTAMP\",\n+            CURRENT_TIMESTAMP,\n+                VAR_ARGS,\n+                    Value.TIMESTAMP);\n+        addFunctionNotDeterministic(\"NOW\", NOW, VAR_ARGS, Value.TIMESTAMP);\n+        addFunction(\"DATEADD\", DATE_ADD, 3, Value.TIMESTAMP);\n+        addFunction(\"TIMESTAMPADD\", DATE_ADD, 3, Value.LONG);\n+        addFunction(\"DATEDIFF\", DATE_DIFF, 3, Value.LONG);\n+        addFunction(\"TIMESTAMPDIFF\", DATE_DIFF, 3, Value.LONG);\n+        addFunction(\"DAYNAME\", DAY_NAME, 1, Value.STRING);\n+        addFunction(\"DAYNAME\", DAY_NAME, 1, Value.STRING);\n+        addFunction(\"DAY\", DAY_OF_MONTH, 1, Value.INT);\n+        addFunction(\"DAY_OF_MONTH\", DAY_OF_MONTH, 1, Value.INT);\n+        addFunction(\"DAY_OF_WEEK\", DAY_OF_WEEK, 1, Value.INT);\n+        addFunction(\"DAY_OF_YEAR\", DAY_OF_YEAR, 1, Value.INT);\n+        addFunction(\"DAYOFMONTH\", DAY_OF_MONTH, 1, Value.INT);\n+        addFunction(\"DAYOFWEEK\", DAY_OF_WEEK, 1, Value.INT);\n+        addFunction(\"DAYOFYEAR\", DAY_OF_YEAR, 1, Value.INT);\n+        addFunction(\"HOUR\", HOUR, 1, Value.INT);\n+        addFunction(\"MINUTE\", MINUTE, 1, Value.INT);\n+        addFunction(\"MONTH\", MONTH, 1, Value.INT);\n+        addFunction(\"MONTHNAME\", MONTH_NAME, 1, Value.STRING);\n+        addFunction(\"QUARTER\", QUARTER, 1, Value.INT);\n+        addFunction(\"SECOND\", SECOND, 1, Value.INT);\n+        addFunction(\"WEEK\", WEEK, 1, Value.INT);\n+        addFunction(\"YEAR\", YEAR, 1, Value.INT);\n+        addFunction(\"EXTRACT\", EXTRACT, 2, Value.INT);\n+        addFunctionWithNull(\"FORMATDATETIME\", FORMATDATETIME, VAR_ARGS, Value.STRING);\n+        addFunctionWithNull(\"PARSEDATETIME\", PARSEDATETIME, VAR_ARGS, Value.TIMESTAMP);\n+        addFunction(\"ISO_YEAR\", ISO_YEAR, 1, Value.INT);\n+        addFunction(\"ISO_WEEK\", ISO_WEEK, 1, Value.INT);\n+        addFunction(\"ISO_DAY_OF_WEEK\", ISO_DAY_OF_WEEK, 1, Value.INT);\n         // system\n-        addFunctionNotDeterministic(\"DATABASE\", DATABASE,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"USER\", USER,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"CURRENT_USER\", CURRENT_USER,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"IDENTITY\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"SCOPE_IDENTITY\", SCOPE_IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"IDENTITY_VAL_LOCAL\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"LAST_INSERT_ID\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"LASTVAL\", IDENTITY,\n-                0, Value.LONG);\n-        addFunctionNotDeterministic(\"AUTOCOMMIT\", AUTOCOMMIT,\n-                0, Value.BOOLEAN);\n-        addFunctionNotDeterministic(\"READONLY\", READONLY,\n-                0, Value.BOOLEAN);\n-        addFunction(\"DATABASE_PATH\", DATABASE_PATH,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"LOCK_TIMEOUT\", LOCK_TIMEOUT,\n-                0, Value.INT);\n-        addFunctionWithNull(\"IFNULL\", IFNULL,\n-                2, Value.NULL);\n-        addFunctionWithNull(\"ISNULL\", IFNULL,\n-                2, Value.NULL);\n-        addFunctionWithNull(\"CASEWHEN\", CASEWHEN,\n-                3, Value.NULL);\n-        addFunctionWithNull(\"CONVERT\", CONVERT,\n-                1, Value.NULL);\n-        addFunctionWithNull(\"CAST\", CAST,\n-                1, Value.NULL);\n-        addFunctionWithNull(\"TRUNCATE_VALUE\", TRUNCATE_VALUE,\n-                3, Value.NULL);\n-        addFunctionWithNull(\"COALESCE\", COALESCE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionWithNull(\"NVL\", COALESCE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionWithNull(\"NVL2\", NVL2,\n-                3, Value.NULL);\n-        addFunctionWithNull(\"NULLIF\", NULLIF,\n-                2, Value.NULL);\n-        addFunctionWithNull(\"CASE\", CASE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionNotDeterministic(\"NEXTVAL\", NEXTVAL,\n-                VAR_ARGS, Value.LONG);\n-        addFunctionNotDeterministic(\"CURRVAL\", CURRVAL,\n-                VAR_ARGS, Value.LONG);\n-        addFunction(\"ARRAY_GET\", ARRAY_GET,\n-                2, Value.STRING);\n-        addFunction(\"ARRAY_CONTAINS\", ARRAY_CONTAINS,\n-                2, Value.BOOLEAN, false, true, true);\n-        addFunction(\"CSVREAD\", CSVREAD,\n-                VAR_ARGS, Value.RESULT_SET, false, false, false);\n-        addFunction(\"CSVWRITE\", CSVWRITE,\n-                VAR_ARGS, Value.INT, false, false, true);\n-        addFunctionNotDeterministic(\"MEMORY_FREE\", MEMORY_FREE,\n-                0, Value.INT);\n-        addFunctionNotDeterministic(\"MEMORY_USED\", MEMORY_USED,\n-                0, Value.INT);\n-        addFunctionNotDeterministic(\"LOCK_MODE\", LOCK_MODE,\n-                0, Value.INT);\n-        addFunctionNotDeterministic(\"SCHEMA\", SCHEMA,\n-                0, Value.STRING);\n-        addFunctionNotDeterministic(\"SESSION_ID\", SESSION_ID,\n-                0, Value.INT);\n-        addFunction(\"ARRAY_LENGTH\", ARRAY_LENGTH,\n-                1, Value.INT);\n-        addFunctionNotDeterministic(\"LINK_SCHEMA\", LINK_SCHEMA,\n-                6, Value.RESULT_SET);\n-        addFunctionWithNull(\"LEAST\", LEAST,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionWithNull(\"GREATEST\", GREATEST,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionNotDeterministic(\"CANCEL_SESSION\", CANCEL_SESSION,\n-                1, Value.BOOLEAN);\n-        addFunction(\"SET\", SET,\n-                2, Value.NULL, false, false, true);\n-        addFunction(\"FILE_READ\", FILE_READ,\n-                VAR_ARGS, Value.NULL, false, false, true);\n-        addFunction(\"FILE_WRITE\", FILE_WRITE,\n-                2, Value.LONG, false, false, true);\n-        addFunctionNotDeterministic(\"TRANSACTION_ID\", TRANSACTION_ID,\n-                0, Value.STRING);\n-        addFunctionWithNull(\"DECODE\", DECODE,\n-                VAR_ARGS, Value.NULL);\n-        addFunctionNotDeterministic(\"DISK_SPACE_USED\", DISK_SPACE_USED,\n-                1, Value.LONG);\n+        addFunctionNotDeterministic(\"DATABASE\", DATABASE, 0, Value.STRING);\n+        addFunctionNotDeterministic(\"USER\", USER, 0, Value.STRING);\n+        addFunctionNotDeterministic(\"CURRENT_USER\", CURRENT_USER, 0, Value.STRING);\n+        addFunctionNotDeterministic(\"IDENTITY\", IDENTITY, 0, Value.LONG);\n+        addFunctionNotDeterministic(\"SCOPE_IDENTITY\", SCOPE_IDENTITY, 0, Value.LONG);\n+        addFunctionNotDeterministic(\"IDENTITY_VAL_LOCAL\", IDENTITY, 0, Value.LONG);\n+        addFunctionNotDeterministic(\"LAST_INSERT_ID\", IDENTITY, 0, Value.LONG);\n+        addFunctionNotDeterministic(\"LASTVAL\", IDENTITY, 0, Value.LONG);\n+        addFunctionNotDeterministic(\"AUTOCOMMIT\", AUTOCOMMIT, 0, Value.BOOLEAN);\n+        addFunctionNotDeterministic(\"READONLY\", READONLY, 0, Value.BOOLEAN);\n+        addFunction(\"DATABASE_PATH\", DATABASE_PATH, 0, Value.STRING);\n+        addFunctionNotDeterministic(\"LOCK_TIMEOUT\", LOCK_TIMEOUT, 0, Value.INT);\n+        addFunctionWithNull(\"IFNULL\", IFNULL, 2, Value.NULL);\n+        addFunctionWithNull(\"ISNULL\", IFNULL, 2, Value.NULL);\n+        addFunctionWithNull(\"CASEWHEN\", CASEWHEN, 3, Value.NULL);\n+        addFunctionWithNull(\"CONVERT\", CONVERT, 1, Value.NULL);\n+        addFunctionWithNull(\"CAST\", CAST, 1, Value.NULL);\n+        addFunctionWithNull(\"TRUNCATE_VALUE\", TRUNCATE_VALUE, 3, Value.NULL);\n+        addFunctionWithNull(\"COALESCE\", COALESCE, VAR_ARGS, Value.NULL);\n+        addFunctionWithNull(\"NVL\", COALESCE, VAR_ARGS, Value.NULL);\n+        addFunctionWithNull(\"NVL2\", NVL2, 3, Value.NULL);\n+        addFunctionWithNull(\"NULLIF\", NULLIF, 2, Value.NULL);\n+        addFunctionWithNull(\"CASE\", CASE, VAR_ARGS, Value.NULL);\n+        addFunctionNotDeterministic(\"NEXTVAL\", NEXTVAL, VAR_ARGS, Value.LONG);\n+        addFunctionNotDeterministic(\"CURRVAL\", CURRVAL, VAR_ARGS, Value.LONG);\n+        addFunction(\"ARRAY_GET\", ARRAY_GET, 2, Value.STRING);\n+        addFunction(\"ARRAY_CONTAINS\",\n+            ARRAY_CONTAINS, 2,\n+                Value.BOOLEAN, false, true, true);\n+        addFunction(\"CSVREAD\",\n+            CSVREAD,\n+                VAR_ARGS,\n+                    Value.RESULT_SET, false, false, false);\n+        addFunction(\"CSVWRITE\", CSVWRITE, VAR_ARGS, Value.INT, false, false, true);\n+        addFunctionNotDeterministic(\"MEMORY_FREE\", MEMORY_FREE, 0, Value.INT);\n+        addFunctionNotDeterministic(\"MEMORY_USED\", MEMORY_USED, 0, Value.INT);\n+        addFunctionNotDeterministic(\"LOCK_MODE\", LOCK_MODE, 0, Value.INT);\n+        addFunctionNotDeterministic(\"SCHEMA\", SCHEMA, 0, Value.STRING);\n+        addFunctionNotDeterministic(\"SESSION_ID\", SESSION_ID, 0, Value.INT);\n+        addFunction(\"ARRAY_LENGTH\", ARRAY_LENGTH, 1, Value.INT);\n+        addFunctionNotDeterministic(\"LINK_SCHEMA\", LINK_SCHEMA, 6, Value.RESULT_SET);\n+        addFunctionWithNull(\"LEAST\", LEAST, VAR_ARGS, Value.NULL);\n+        addFunctionWithNull(\"GREATEST\", GREATEST, VAR_ARGS, Value.NULL);\n+        addFunctionNotDeterministic(\"CANCEL_SESSION\", CANCEL_SESSION, 1, Value.BOOLEAN);\n+        addFunction(\"SET\", SET, 2, Value.NULL, false, false, true);\n+        addFunction(\"FILE_READ\",\n+            FILE_READ,\n+                VAR_ARGS,\n+                    Value.NULL, false, false, true);\n+        addFunction(\"FILE_WRITE\", FILE_WRITE, 2, Value.LONG, false, false, true);\n+        addFunctionNotDeterministic(\"TRANSACTION_ID\", TRANSACTION_ID, 0, Value.STRING);\n+        addFunctionWithNull(\"DECODE\", DECODE, VAR_ARGS, Value.NULL);\n+        addFunctionNotDeterministic(\"DISK_SPACE_USED\", DISK_SPACE_USED, 1, Value.LONG);\n         addFunction(\"H2VERSION\", H2VERSION, 0, Value.STRING);\n \n         // TableFunction\n-        addFunctionWithNull(\"TABLE\", TABLE,\n-                VAR_ARGS, Value.RESULT_SET);\n-        addFunctionWithNull(\"TABLE_DISTINCT\", TABLE_DISTINCT,\n-                VAR_ARGS, Value.RESULT_SET);\n+        addFunctionWithNull(\"TABLE\", TABLE, VAR_ARGS, Value.RESULT_SET);\n+        addFunctionWithNull(\"TABLE_DISTINCT\",\n+            TABLE_DISTINCT,\n+                VAR_ARGS,\n+                    Value.RESULT_SET);\n \n         // pseudo function\n         addFunctionWithNull(\"ROW_NUMBER\", ROW_NUMBER, 0, Value.LONG);\n@@ -506,9 +413,7 @@ public class Function extends Expression implements FunctionCall {\n         }\n     }\n \n-    private static void addFunction(String name, int type, int parameterCount,\n-            int returnDataType, boolean nullIfParameterIsNull, boolean deterministic,\n-            boolean bufferResultSetToLocalTemp) {\n+    private static void addFunction(String name, int type, int parameterCount, int returnDataType, boolean nullIfParameterIsNull, boolean deterministic, boolean bufferResultSetToLocalTemp) {\n         FunctionInfo info = new FunctionInfo();\n         info.name = name;\n         info.type = type;\n@@ -520,18 +425,15 @@ public class Function extends Expression implements FunctionCall {\n         FUNCTIONS.put(name, info);\n     }\n \n-    private static void addFunctionNotDeterministic(String name, int type,\n-            int parameterCount, int returnDataType) {\n+    private static void addFunctionNotDeterministic(String name, int type, int parameterCount, int returnDataType) {\n         addFunction(name, type, parameterCount, returnDataType, true, false, true);\n     }\n \n-    private static void addFunction(String name, int type, int parameterCount,\n-            int returnDataType) {\n+    private static void addFunction(String name, int type, int parameterCount, int returnDataType) {\n         addFunction(name, type, parameterCount, returnDataType, true, true, true);\n     }\n \n-    private static void addFunctionWithNull(String name, int type,\n-            int parameterCount, int returnDataType) {\n+    private static void addFunctionWithNull(String name, int type, int parameterCount, int returnDataType) {\n         addFunction(name, type, parameterCount, returnDataType, false, true, true);\n     }\n \n@@ -542,6 +444,7 @@ public class Function extends Expression implements FunctionCall {\n      * @param name the function name\n      * @return the function info\n      */\n+\n     private static FunctionInfo getFunctionInfo(String name) {\n         return FUNCTIONS.get(name);\n     }\n@@ -554,6 +457,8 @@ public class Function extends Expression implements FunctionCall {\n      * @param name the function name\n      * @return the function object or null\n      */\n+\n+\n     public static Function getFunction(Database database, String name) {\n         if (!database.getSettings().databaseToUpper) {\n             // if not yet converted to uppercase, do it now\n@@ -578,13 +483,16 @@ public class Function extends Expression implements FunctionCall {\n      * @param index the index (0, 1,...)\n      * @param param the expression\n      */\n+\n+\n     public void setParameter(int index, Expression param) {\n         if (varArgs != null) {\n             varArgs.add(param);\n         } else {\n             if (index >= args.length) {\n                 throw DbException.get(ErrorCode.INVALID_PARAMETER_COUNT_2,\n-                        info.name, \"\" + args.length);\n+                                      info.name,\n+                                          \"\" + args.length);\n             }\n             args[index] = param;\n         }\n@@ -599,8 +507,9 @@ public class Function extends Expression implements FunctionCall {\n         return getValueWithArgs(session, args);\n     }\n \n-    private Value getSimpleValue(Session session, Value v0, Expression[] args,\n-            Value[] values) {\n+    private Value getSimpleValue(Session session,\n+            Value v0,\n+            Expression[] args, Value[] values) {\n         Value result;\n         switch (info.type) {\n         case ABS:\n@@ -689,12 +598,10 @@ public class Function extends Expression implements FunctionCall {\n             result = ValueDouble.get(Math.tanh(v0.getDouble()));\n             break;\n         case SECURE_RAND:\n-            result = ValueBytes.getNoCopy(\n-                    MathUtils.secureRandomBytes(v0.getInt()));\n+            result = ValueBytes.getNoCopy(MathUtils.secureRandomBytes(v0.getInt()));\n             break;\n         case EXPAND:\n-            result = ValueBytes.getNoCopy(\n-                    CompressTool.getInstance().expand(v0.getBytesNoCopy()));\n+            result = ValueBytes.getNoCopy(CompressTool.getInstance().expand(v0.getBytesNoCopy()));\n             break;\n         case ZERO:\n             result = ValueInt.get(0);\n@@ -717,7 +624,7 @@ public class Function extends Expression implements FunctionCall {\n             break;\n         case CHAR:\n             result = ValueString.get(String.valueOf((char) v0.getInt()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case CHAR_LENGTH:\n         case LENGTH:\n@@ -744,40 +651,38 @@ public class Function extends Expression implements FunctionCall {\n                     result = v;\n                 } else {\n                     String tmp = v.getString();\n-                    if (!StringUtils.isNullOrEmpty(separator)\n-                            && !StringUtils.isNullOrEmpty(tmp)) {\n+                    if (!StringUtils.isNullOrEmpty(separator) && !StringUtils.isNullOrEmpty(tmp)) {\n                         tmp = separator.concat(tmp);\n                     }\n                     result = ValueString.get(result.getString().concat(tmp),\n-                            database.getMode().treatEmptyStringsAsNull);\n+                                             database.getMode().treatEmptyStringsAsNull);\n                 }\n             }\n             if (info.type == CONCAT_WS) {\n                 if (separator != null && result == ValueNull.INSTANCE) {\n-                    result = ValueString.get(\"\",\n-                            database.getMode().treatEmptyStringsAsNull);\n+                    result = ValueString.get(\"\", database.getMode().treatEmptyStringsAsNull);\n                 }\n             }\n             break;\n         }\n         case HEXTORAW:\n             result = ValueString.get(hexToRaw(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case LOWER:\n         case LCASE:\n             // TODO this is locale specific, need to document or provide a way\n             // to set the locale\n             result = ValueString.get(v0.getString().toLowerCase(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case RAWTOHEX:\n             result = ValueString.get(rawToHex(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case SOUNDEX:\n             result = ValueString.get(getSoundex(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case SPACE: {\n             int len = Math.max(0, v0.getInt());\n@@ -785,8 +690,9 @@ public class Function extends Expression implements FunctionCall {\n             for (int i = len - 1; i >= 0; i--) {\n                 chars[i] = ' ';\n             }\n-            result = ValueString.get(new String(chars),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(\n+                new String(chars),\n+                database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case UPPER:\n@@ -794,90 +700,71 @@ public class Function extends Expression implements FunctionCall {\n             // TODO this is locale specific, need to document or provide a way\n             // to set the locale\n             result = ValueString.get(v0.getString().toUpperCase(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case STRINGENCODE:\n-            result = ValueString.get(StringUtils.javaEncode(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.javaEncode(v0.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case STRINGDECODE:\n-            result = ValueString.get(StringUtils.javaDecode(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.javaDecode(v0.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case STRINGTOUTF8:\n-            result = ValueBytes.getNoCopy(v0.getString().\n-                    getBytes(Constants.UTF8));\n+            result = ValueBytes.getNoCopy(v0.getString().getBytes(Constants.UTF8));\n             break;\n         case UTF8TOSTRING:\n-            result = ValueString.get(new String(v0.getBytesNoCopy(),\n-                    Constants.UTF8),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(new String(v0.getBytesNoCopy(), Constants.UTF8), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case XMLCOMMENT:\n-            result = ValueString.get(StringUtils.xmlComment(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.xmlComment(v0.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case XMLCDATA:\n-            result = ValueString.get(StringUtils.xmlCData(v0.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.xmlCData(v0.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case XMLSTARTDOC:\n             result = ValueString.get(StringUtils.xmlStartDoc(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case DAY_NAME: {\n-            SimpleDateFormat dayName = new SimpleDateFormat(\n-                    \"EEEE\", Locale.ENGLISH);\n+            SimpleDateFormat dayName = new SimpleDateFormat(\"EEEE\", Locale.ENGLISH);\n             result = ValueString.get(dayName.format(v0.getDate()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case DAY_OF_MONTH:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.DAY_OF_MONTH));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(), Calendar.DAY_OF_MONTH));\n             break;\n         case DAY_OF_WEEK:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.DAY_OF_WEEK));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(), Calendar.DAY_OF_WEEK));\n             break;\n         case DAY_OF_YEAR:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.DAY_OF_YEAR));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(), Calendar.DAY_OF_YEAR));\n             break;\n         case HOUR:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n-                    Calendar.HOUR_OF_DAY));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(), Calendar.HOUR_OF_DAY));\n             break;\n         case MINUTE:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n-                    Calendar.MINUTE));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(), Calendar.MINUTE));\n             break;\n         case MONTH:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.MONTH));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(), Calendar.MONTH));\n             break;\n         case MONTH_NAME: {\n-            SimpleDateFormat monthName = new SimpleDateFormat(\"MMMM\",\n-                    Locale.ENGLISH);\n+            SimpleDateFormat monthName = new SimpleDateFormat(\"MMMM\", Locale.ENGLISH);\n             result = ValueString.get(monthName.format(v0.getDate()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case QUARTER:\n-            result = ValueInt.get((DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.MONTH) - 1) / 3 + 1);\n+            result = ValueInt.get((DateTimeUtils.getDatePart(v0.getDate(), Calendar.MONTH) - 1) / 3 + 1);\n             break;\n         case SECOND:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(),\n-                    Calendar.SECOND));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getTimestamp(), Calendar.SECOND));\n             break;\n         case WEEK:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.WEEK_OF_YEAR));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(), Calendar.WEEK_OF_YEAR));\n             break;\n         case YEAR:\n-            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(),\n-                    Calendar.YEAR));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v0.getDate(), Calendar.YEAR));\n             break;\n         case ISO_YEAR:\n             result = ValueInt.get(DateTimeUtils.getIsoYear(v0.getDate()));\n@@ -908,20 +795,19 @@ public class Function extends Expression implements FunctionCall {\n             ValueTimestamp vt = ValueTimestamp.fromMillis(now);\n             if (v0 != null) {\n                 Mode mode = database.getMode();\n-                vt = (ValueTimestamp) vt.convertScale(\n-                        mode.convertOnlyToSmallerScale, v0.getInt());\n+                vt = (ValueTimestamp) vt.convertScale(mode.convertOnlyToSmallerScale, v0.getInt());\n             }\n             result = vt;\n             break;\n         }\n         case DATABASE:\n             result = ValueString.get(database.getShortName(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case USER:\n         case CURRENT_USER:\n             result = ValueString.get(session.getUser().getName(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case IDENTITY:\n             result = session.getLastIdentity();\n@@ -937,9 +823,7 @@ public class Function extends Expression implements FunctionCall {\n             break;\n         case DATABASE_PATH: {\n             String path = database.getDatabasePath();\n-            result = path == null ?\n-                    (Value) ValueNull.INSTANCE : ValueString.get(path,\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = path == null ? (Value) ValueNull.INSTANCE : ValueString.get(path, database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case LOCK_TIMEOUT:\n@@ -970,7 +854,7 @@ public class Function extends Expression implements FunctionCall {\n             break;\n         case SCHEMA:\n             result = ValueString.get(session.getCurrentSchemaName(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case SESSION_ID:\n             result = ValueInt.get(session.getId());\n@@ -985,8 +869,7 @@ public class Function extends Expression implements FunctionCall {\n         }\n         case CASEWHEN: {\n             Value v;\n-            if (v0 == ValueNull.INSTANCE ||\n-                    !v0.getBoolean().booleanValue()) {\n+            if (v0 == ValueNull.INSTANCE || !v0.getBoolean().booleanValue()) {\n                 v = getNullOrValue(session, args, values, 2);\n             } else {\n                 v = getNullOrValue(session, args, values, 1);\n@@ -997,8 +880,7 @@ public class Function extends Expression implements FunctionCall {\n         case DECODE: {\n             int index = -1;\n             for (int i = 1, len = args.length - 1; i < len; i += 2) {\n-                if (database.areEqual(v0,\n-                        getNullOrValue(session, args, values, i))) {\n+                if (database.areEqual(v0, getNullOrValue(session, args, values, i))) {\n                     index = i + 1;\n                     break;\n                 }\n@@ -1006,8 +888,7 @@ public class Function extends Expression implements FunctionCall {\n             if (index < 0 && args.length % 2 == 0) {\n                 index = args.length - 1;\n             }\n-            Value v = index < 0 ? ValueNull.INSTANCE :\n-                    getNullOrValue(session, args, values, index);\n+            Value v = index < 0 ? ValueNull.INSTANCE : getNullOrValue(session, args, values, index);\n             result = v.convertTo(dataType);\n             break;\n         }\n@@ -1063,8 +944,7 @@ public class Function extends Expression implements FunctionCall {\n                 // (null, when, then, when, then, else)\n                 for (int i = 1, len = args.length - 1; i < len; i += 2) {\n                     Value when = args[i].getValue(session);\n-                    if (!(when == ValueNull.INSTANCE) &&\n-                            when.getBoolean().booleanValue()) {\n+                    if (!(when == ValueNull.INSTANCE) && when.getBoolean().booleanValue()) {\n                         then = args[i + 1];\n                         break;\n                     }\n@@ -1172,8 +1052,7 @@ public class Function extends Expression implements FunctionCall {\n         return table.getDiskSpaceUsed();\n     }\n \n-    private static Value getNullOrValue(Session session, Expression[] args,\n-            Value[] values, int i) {\n+    private static Value getNullOrValue(Session session, Expression[] args, Value[] values, int i) {\n         if (i >= args.length) {\n             return null;\n         }\n@@ -1213,8 +1092,7 @@ public class Function extends Expression implements FunctionCall {\n         Value result;\n         switch (info.type) {\n         case ATAN2:\n-            result = ValueDouble.get(\n-                    Math.atan2(v0.getDouble(), v1.getDouble()));\n+            result = ValueDouble.get(Math.atan2(v0.getDouble(), v1.getDouble()));\n             break;\n         case BITAND:\n             result = ValueLong.get(v0.getLong() & v1.getLong());\n@@ -1237,14 +1115,11 @@ public class Function extends Expression implements FunctionCall {\n             break;\n         }\n         case POWER:\n-            result = ValueDouble.get(Math.pow(\n-                    v0.getDouble(), v1.getDouble()));\n+            result = ValueDouble.get(Math.pow(v0.getDouble(), v1.getDouble()));\n             break;\n         case ROUND: {\n             double f = v1 == null ? 1. : Math.pow(10., v1.getDouble());\n-\n             double middleResult = v0.getDouble() * f;\n-\n             int oneWithSymbol = middleResult > 0 ? 1 : -1;\n             result = ValueDouble.get(Math.round(Math.abs(middleResult)) / f * oneWithSymbol);\n             break;\n@@ -1269,61 +1144,58 @@ public class Function extends Expression implements FunctionCall {\n                 c.set(Calendar.MILLISECOND, 0);\n                 result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n             } else if (v0.getType() == Value.STRING) {\n-                ValueString vd = (ValueString) v0;\n-                Calendar c = DateTimeUtils.createGregorianCalendar();\n-                c.setTime(ValueTimestamp.parse(vd.getString(), session.getDatabase().getMode()).getDate());\n-                c.set(Calendar.HOUR_OF_DAY, 0);\n-                c.set(Calendar.MINUTE, 0);\n-                c.set(Calendar.SECOND, 0);\n-                c.set(Calendar.MILLISECOND, 0);\n-                result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n-            } else {\n-                double d = v0.getDouble();\n-                int p = v1 == null ? 0 : v1.getInt();\n-                double f = Math.pow(10., p);\n-                double g = d * f;\n-                result = ValueDouble.get(((d < 0) ? Math.ceil(g) : Math.floor(g)) / f);\n-            }\n+                       ValueString vd = (ValueString) v0;\n+                       Calendar c = DateTimeUtils.createGregorianCalendar();\n+                       c.setTime(ValueTimestamp.parse(vd.getString(), session.getDatabase().getMode()).getDate());\n+                       c.set(Calendar.HOUR_OF_DAY, 0);\n+                       c.set(Calendar.MINUTE, 0);\n+                       c.set(Calendar.SECOND, 0);\n+                       c.set(Calendar.MILLISECOND, 0);\n+                       result = ValueTimestamp.fromMillis(c.getTimeInMillis());\n+                   } else {\n+                       double d = v0.getDouble();\n+                       int p = v1 == null ? 0 : v1.getInt();\n+                       double f = Math.pow(10., p);\n+                       double g = d * f;\n+                       result = ValueDouble.get(((d < 0) ? Math.ceil(g) : Math.floor(g)) / f);\n+                   }\n             break;\n         }\n         case HASH:\n-            result = ValueBytes.getNoCopy(getHash(v0.getString(),\n-                    v1.getBytesNoCopy(), v2.getInt()));\n+            result = ValueBytes.getNoCopy(getHash(v0.getString(), v1.getBytesNoCopy(), v2.getInt()));\n             break;\n         case ENCRYPT:\n             result = ValueBytes.getNoCopy(encrypt(v0.getString(),\n-                    v1.getBytesNoCopy(), v2.getBytesNoCopy()));\n+                v1.getBytesNoCopy(),\n+                    v2.getBytesNoCopy()));\n             break;\n         case DECRYPT:\n             result = ValueBytes.getNoCopy(decrypt(v0.getString(),\n-                    v1.getBytesNoCopy(), v2.getBytesNoCopy()));\n+                v1.getBytesNoCopy(),\n+                    v2.getBytesNoCopy()));\n             break;\n         case COMPRESS: {\n             String algorithm = null;\n             if (v1 != null) {\n                 algorithm = v1.getString();\n             }\n-            result = ValueBytes.getNoCopy(CompressTool.getInstance().\n-                    compress(v0.getBytesNoCopy(), algorithm));\n+            result = ValueBytes.getNoCopy(CompressTool.getInstance().compress(v0.getBytesNoCopy(), algorithm));\n             break;\n         }\n         case DIFFERENCE:\n-            result = ValueInt.get(getDifference(\n-                    v0.getString(), v1.getString()));\n+            result = ValueInt.get(getDifference(v0.getString(), v1.getString()));\n             break;\n         case INSERT: {\n             if (v1 == ValueNull.INSTANCE || v2 == ValueNull.INSTANCE) {\n                 result = v1;\n             } else {\n-                result = ValueString.get(insert(v0.getString(),\n-                        v1.getInt(), v2.getInt(), v3.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                result = ValueString.get(insert(v0.getString(), v1.getInt(), v2.getInt(), v3.getString()), database.getMode().treatEmptyStringsAsNull);\n             }\n             break;\n         }\n         case LEFT:\n             result = ValueString.get(left(v0.getString(), v1.getInt()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case LOCATE: {\n             int start = v2 == null ? 0 : v2.getInt();\n@@ -1338,12 +1210,11 @@ public class Function extends Expression implements FunctionCall {\n         case REPEAT: {\n             int count = Math.max(0, v1.getInt());\n             result = ValueString.get(repeat(v0.getString(), count),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case REPLACE: {\n-            if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE\n-                    || v2 == ValueNull.INSTANCE && database.getMode() != Mode.getOracle()) {\n+            if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE || v2 == ValueNull.INSTANCE && database.getMode() != Mode.getOracle()) {\n                 result = ValueNull.INSTANCE;\n             } else {\n                 String s0 = v0.getString();\n@@ -1353,28 +1224,22 @@ public class Function extends Expression implements FunctionCall {\n                     s2 = \"\";\n                 }\n                 result = ValueString.get(replace(s0, s1, s2),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                                         database.getMode().treatEmptyStringsAsNull);\n             }\n             break;\n         }\n         case RIGHT:\n             result = ValueString.get(right(v0.getString(), v1.getInt()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case LTRIM:\n-            result = ValueString.get(StringUtils.trim(v0.getString(),\n-                    true, false, v1 == null ? \" \" : v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.trim(v0.getString(), true, false, v1 == null ? \" \" : v1.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case TRIM:\n-            result = ValueString.get(StringUtils.trim(v0.getString(),\n-                    true, true, v1 == null ? \" \" : v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.trim(v0.getString(), true, true, v1 == null ? \" \" : v1.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case RTRIM:\n-            result = ValueString.get(StringUtils.trim(v0.getString(),\n-                    false, true, v1 == null ? \" \" : v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.trim(v0.getString(), false, true, v1 == null ? \" \" : v1.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case SUBSTR:\n         case SUBSTRING: {\n@@ -1385,76 +1250,61 @@ public class Function extends Expression implements FunctionCall {\n             }\n             int length = v2 == null ? s.length() : v2.getInt();\n             result = ValueString.get(substring(s, offset, length),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case POSITION:\n             result = ValueInt.get(locate(v0.getString(), v1.getString(), 0));\n             break;\n         case XMLATTR:\n-            result = ValueString.get(\n-                    StringUtils.xmlAttr(v0.getString(), v1.getString()),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(StringUtils.xmlAttr(v0.getString(), v1.getString()), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case XMLNODE: {\n-            String attr = v1 == null ?\n-                    null : v1 == ValueNull.INSTANCE ? null : v1.getString();\n-            String content = v2 == null ?\n-                    null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n-            boolean indent = v3 == null ?\n-                    true : v3.getBoolean();\n-            result = ValueString.get(StringUtils.xmlNode(\n-                    v0.getString(), attr, content, indent),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            String attr = v1 == null ? null : v1 == ValueNull.INSTANCE ? null : v1.getString();\n+            String content = v2 == null ? null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n+            boolean indent = v3 == null ? true : v3.getBoolean();\n+            result = ValueString.get(StringUtils.xmlNode(v0.getString(), attr, content, indent), database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case REGEXP_REPLACE: {\n             String regexp = v1.getString();\n             String replacement = v2.getString();\n-            String regexpMode = v3 == null || v3.getString() == null ? \"\" :\n-                    v3.getString();\n+            String regexpMode = v3 == null || v3.getString() == null ? \"\" : v3.getString();\n             int flags = makeRegexpFlags(regexpMode);\n             try {\n-                result = ValueString.get(\n-                        Pattern.compile(regexp, flags).matcher(v0.getString())\n-                                .replaceAll(replacement),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                result = ValueString.get(Pattern.compile(regexp, flags).matcher(v0.getString()).replaceAll(replacement), database.getMode().treatEmptyStringsAsNull);\n             } catch (StringIndexOutOfBoundsException e) {\n-                throw DbException.get(\n-                        ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n+                throw DbException.get(ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n             } catch (PatternSyntaxException e) {\n-                throw DbException.get(\n-                        ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n+                throw DbException.get(ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n             } catch (IllegalArgumentException e) {\n-                throw DbException.get(\n-                        ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n+                throw DbException.get(ErrorCode.LIKE_ESCAPE_ERROR_1, e, replacement);\n             }\n             break;\n         }\n         case RPAD:\n             result = ValueString.get(StringUtils.pad(v0.getString(),\n-                    v1.getInt(), v2 == null ? null : v2.getString(), true),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                                     v1.getInt(),\n+                                                     v2 == null ? null : v2.getString(), true), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case LPAD:\n             result = ValueString.get(StringUtils.pad(v0.getString(),\n-                    v1.getInt(), v2 == null ? null : v2.getString(), false),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                                     v1.getInt(),\n+                                                     v2 == null ? null : v2.getString(), false), database.getMode().treatEmptyStringsAsNull);\n             break;\n         case ORA_HASH:\n             result = ValueLong.get(oraHash(v0.getString(),\n-                    v1 == null ? null : v1.getInt(),\n+                v1 == null ? null : v1.getInt(),\n                     v2 == null ? null : v2.getInt()));\n             break;\n         case TO_CHAR:\n-            switch (v0.getType()){\n+            switch (v0.getType()) {\n             case Value.TIME:\n             case Value.DATE:\n             case Value.TIMESTAMP:\n                 result = ValueString.get(ToChar.toChar(v0.getTimestamp(),\n-                        v1 == null ? null : v1.getString(),\n-                        v2 == null ? null : v2.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                                                       v1 == null ? null : v1.getString(),\n+                                                       v2 == null ? null : v2.getString()), database.getMode().treatEmptyStringsAsNull);\n                 break;\n             case Value.SHORT:\n             case Value.INT:\n@@ -1463,22 +1313,19 @@ public class Function extends Expression implements FunctionCall {\n             case Value.DOUBLE:\n             case Value.FLOAT:\n                 result = ValueString.get(ToChar.toChar(v0.getBigDecimal(),\n-                        v1 == null ? null : v1.getString(),\n-                        v2 == null ? null : v2.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                                                       v1 == null ? null : v1.getString(),\n+                                                       v2 == null ? null : v2.getString()), database.getMode().treatEmptyStringsAsNull);\n                 break;\n             default:\n                 result = ValueString.get(v0.getString(),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                                         database.getMode().treatEmptyStringsAsNull);\n             }\n             break;\n         case TO_DATE:\n-            result = ValueTimestamp.get(ToDateParser.toDate(v0.getString(),\n-                    v1 == null ? null : v1.getString()));\n+            result = ValueTimestamp.get(ToDateParser.toDate(v0.getString(), v1 == null ? null : v1.getString()));\n             break;\n         case TO_TIMESTAMP:\n-            result = ValueTimestamp.get(ToDateParser.toTimestamp(v0.getString(),\n-                    v1 == null ? null : v1.getString()));\n+            result = ValueTimestamp.get(ToDateParser.toTimestamp(v0.getString(), v1 == null ? null : v1.getString()));\n             break;\n         case ADD_MONTHS:\n             result = ValueTimestamp.get(DateTimeUtils.addMonths(v0.getTimestamp(), v1.getInt()));\n@@ -1486,40 +1333,31 @@ public class Function extends Expression implements FunctionCall {\n         case TRANSLATE: {\n             String matching = v1.getString();\n             String replacement = v2.getString();\n-            result = ValueString.get(\n-                    translate(v0.getString(), matching, replacement),\n-                    database.getMode().treatEmptyStringsAsNull);\n+            result = ValueString.get(translate(v0.getString(), matching, replacement), database.getMode().treatEmptyStringsAsNull);\n             break;\n         }\n         case H2VERSION:\n             result = ValueString.get(Constants.getVersion(),\n-                    database.getMode().treatEmptyStringsAsNull);\n+                                     database.getMode().treatEmptyStringsAsNull);\n             break;\n         case DATE_ADD:\n-            result = ValueTimestamp.get(dateadd(\n-                    v0.getString(), v1.getLong(), v2.getTimestamp()));\n+            result = ValueTimestamp.get(dateadd(v0.getString(), v1.getLong(), v2.getTimestamp()));\n             break;\n         case DATE_DIFF:\n-            result = ValueLong.get(datediff(\n-                    v0.getString(), v1.getTimestamp(), v2.getTimestamp()));\n+            result = ValueLong.get(datediff(v0.getString(), v1.getTimestamp(), v2.getTimestamp()));\n             break;\n         case EXTRACT: {\n             int field = getDatePart(v0.getString());\n-            result = ValueInt.get(DateTimeUtils.getDatePart(\n-                    v1.getTimestamp(), field));\n+            result = ValueInt.get(DateTimeUtils.getDatePart(v1.getTimestamp(), field));\n             break;\n         }\n         case FORMATDATETIME: {\n             if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE) {\n                 result = ValueNull.INSTANCE;\n             } else {\n-                String locale = v2 == null ?\n-                        null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n-                String tz = v3 == null ?\n-                        null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n-                result = ValueString.get(DateTimeUtils.formatDateTime(\n-                        v0.getTimestamp(), v1.getString(), locale, tz),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                String locale = v2 == null ? null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n+                String tz = v3 == null ? null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n+                result = ValueString.get(DateTimeUtils.formatDateTime(v0.getTimestamp(), v1.getString(), locale, tz), database.getMode().treatEmptyStringsAsNull);\n             }\n             break;\n         }\n@@ -1527,12 +1365,9 @@ public class Function extends Expression implements FunctionCall {\n             if (v0 == ValueNull.INSTANCE || v1 == ValueNull.INSTANCE) {\n                 result = ValueNull.INSTANCE;\n             } else {\n-                String locale = v2 == null ?\n-                        null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n-                String tz = v3 == null ?\n-                        null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n-                java.util.Date d = DateTimeUtils.parseDateTime(\n-                        v0.getString(), v1.getString(), locale, tz);\n+                String locale = v2 == null ? null : v2 == ValueNull.INSTANCE ? null : v2.getString();\n+                String tz = v3 == null ? null : v3 == ValueNull.INSTANCE ? null : v3.getString();\n+                java.util.Date d = DateTimeUtils.parseDateTime(v0.getString(), v1.getString(), locale, tz);\n                 result = ValueTimestamp.fromMillis(d.getTime());\n             }\n             break;\n@@ -1567,16 +1402,13 @@ public class Function extends Expression implements FunctionCall {\n                 String escapeCharacter = v5 == null ? null : v5.getString();\n                 Value v6 = getNullOrValue(session, args, values, 6);\n                 String nullString = v6 == null ? null : v6.getString();\n-                setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter,\n-                        escapeCharacter);\n+                setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter, escapeCharacter);\n                 csv.setNullString(nullString);\n             }\n             char fieldSeparator = csv.getFieldSeparatorRead();\n-            String[] columns = StringUtils.arraySplit(columnList,\n-                    fieldSeparator, true);\n+            String[] columns = StringUtils.arraySplit(columnList, fieldSeparator, true);\n             try {\n-                ValueResultSet vr = ValueResultSet.get(csv.read(fileName,\n-                        columns, charset));\n+                ValueResultSet vr = ValueResultSet.get(csv.read(fileName, columns, charset));\n                 result = vr;\n             } catch (SQLException e) {\n                 throw DbException.convert(e);\n@@ -1586,9 +1418,7 @@ public class Function extends Expression implements FunctionCall {\n         case LINK_SCHEMA: {\n             session.getUser().checkAdmin();\n             Connection conn = session.createConnection(false);\n-            ResultSet rs = LinkSchema.linkSchema(conn, v0.getString(),\n-                    v1.getString(), v2.getString(), v3.getString(),\n-                    v4.getString(), v5.getString());\n+            ResultSet rs = LinkSchema.linkSchema(conn, v0.getString(), v1.getString(), v2.getString(), v3.getString(), v4.getString(), v5.getString());\n             result = ValueResultSet.get(rs);\n             break;\n         }\n@@ -1609,16 +1439,14 @@ public class Function extends Expression implements FunctionCall {\n                 String nullString = v6 == null ? null : v6.getString();\n                 Value v7 = getNullOrValue(session, args, values, 7);\n                 String lineSeparator = v7 == null ? null : v7.getString();\n-                setCsvDelimiterEscape(csv, fieldSeparatorWrite, fieldDelimiter,\n-                        escapeCharacter);\n+                setCsvDelimiterEscape(csv, fieldSeparatorWrite, fieldDelimiter, escapeCharacter);\n                 csv.setNullString(nullString);\n                 if (lineSeparator != null) {\n                     csv.setLineSeparator(lineSeparator);\n                 }\n             }\n             try {\n-                int rows = csv.write(conn, v0.getString(), v1.getString(),\n-                        charset);\n+                int rows = csv.write(conn, v0.getString(), v1.getString(), charset);\n                 result = ValueInt.get(rows);\n             } catch (SQLException e) {\n                 throw DbException.convert(e);\n@@ -1637,8 +1465,7 @@ public class Function extends Expression implements FunctionCall {\n             boolean blob = args.length == 1;\n             try {\n                 long fileLength = FileUtils.size(fileName);\n-                InputStream in = new AutoCloseInputStream(\n-                        FileUtils.newInputStream(fileName));\n+                InputStream in = new AutoCloseInputStream(FileUtils.newInputStream(fileName));\n                 if (blob) {\n                     result = database.getLobStorage().createBlob(in, fileLength);\n                 } else {\n@@ -1663,8 +1490,7 @@ public class Function extends Expression implements FunctionCall {\n             try {\n                 FileOutputStream fileOutputStream = new FileOutputStream(fileName);\n                 try (InputStream in = v0.getInputStream()) {\n-                    result = ValueLong.get(IOUtils.copyAndClose(in,\n-                            fileOutputStream));\n+                    result = ValueLong.get(IOUtils.copyAndClose(in, fileOutputStream));\n                 }\n             } catch (IOException e) {\n                 throw DbException.convertIOException(e, fileName);\n@@ -1677,31 +1503,25 @@ public class Function extends Expression implements FunctionCall {\n         }\n         case XMLTEXT:\n             if (v1 == null) {\n-                result = ValueString.get(StringUtils.xmlText(\n-                        v0.getString()),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                result = ValueString.get(StringUtils.xmlText(v0.getString()), database.getMode().treatEmptyStringsAsNull);\n             } else {\n-                result = ValueString.get(StringUtils.xmlText(\n-                        v0.getString(), v1.getBoolean()),\n-                        database.getMode().treatEmptyStringsAsNull);\n+                result = ValueString.get(StringUtils.xmlText(v0.getString(), v1.getBoolean()), database.getMode().treatEmptyStringsAsNull);\n             }\n             break;\n         case REGEXP_LIKE: {\n             String regexp = v1.getString();\n-            String regexpMode = v2 == null || v2.getString() == null ? \"\" :\n-                    v2.getString();\n+            String regexpMode = v2 == null || v2.getString() == null ? \"\" : v2.getString();\n             int flags = makeRegexpFlags(regexpMode);\n             try {\n-                result = ValueBoolean.get(Pattern.compile(regexp, flags)\n-                        .matcher(v0.getString()).find());\n+                result = ValueBoolean.get(Pattern.compile(regexp, flags).matcher(v0.getString()).find());\n             } catch (PatternSyntaxException e) {\n                 throw DbException.get(ErrorCode.LIKE_ESCAPE_ERROR_1, e, regexp);\n             }\n             break;\n         }\n         case VALUES:\n-            result = session.getVariable(args[0].getSchemaName() + \".\" +\n-                    args[0].getTableName() + \".\" + args[0].getColumnName());\n+            result = session.getVariable(args[0].getSchemaName() + \".\"\n+            + args[0].getTableName() + \".\" + args[0].getColumnName());\n             break;\n         default:\n             throw DbException.throwInternalError(\"type=\" + info.type);\n@@ -1797,6 +1617,8 @@ public class Function extends Expression implements FunctionCall {\n      * @param part the string\n      * @return true if it is\n      */\n+\n+\n     public static boolean isDatePart(String part) {\n         Integer p = DATE_PART.get(StringUtils.toUpperEnglish(part));\n         return p != null;\n@@ -1844,6 +1666,7 @@ public class Function extends Expression implements FunctionCall {\n      * @param d2 the second date\n      * @return the number of crossed boundaries\n      */\n+\n     private static long datediff(String part, Timestamp d1, Timestamp d2) {\n         int field = getDatePart(part);\n         Calendar calendar = DateTimeUtils.createGregorianCalendar();\n@@ -1852,17 +1675,9 @@ public class Function extends Expression implements FunctionCall {\n         // certain time zones (those that are 30 minutes off)\n         TimeZone zone = calendar.getTimeZone();\n         calendar.setTime(d1);\n-        t1 += zone.getOffset(calendar.get(Calendar.ERA),\n-                calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n-                calendar.get(Calendar.DAY_OF_MONTH),\n-                calendar.get(Calendar.DAY_OF_WEEK),\n-                calendar.get(Calendar.MILLISECOND));\n+        t1 += zone.getOffset(calendar.get(Calendar.ERA), calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.DAY_OF_WEEK), calendar.get(Calendar.MILLISECOND));\n         calendar.setTime(d2);\n-        t2 += zone.getOffset(calendar.get(Calendar.ERA),\n-                calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n-                calendar.get(Calendar.DAY_OF_MONTH),\n-                calendar.get(Calendar.DAY_OF_WEEK),\n-                calendar.get(Calendar.MILLISECOND));\n+        t2 += zone.getOffset(calendar.get(Calendar.ERA), calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.DAY_OF_WEEK), calendar.get(Calendar.MILLISECOND));\n         switch (field) {\n         case Calendar.MILLISECOND:\n             return t2 - t1;\n@@ -1907,7 +1722,7 @@ public class Function extends Expression implements FunctionCall {\n         if (field == Calendar.MONTH) {\n             return 12 * result + (month2 - month1);\n         } else if (field == Calendar.YEAR) {\n-            return result;\n+        return result;\n         } else {\n             throw DbException.getUnsupportedException(\"DATEDIFF \" + part);\n         }\n@@ -2050,10 +1865,8 @@ public class Function extends Expression implements FunctionCall {\n         return e;\n     }\n \n-    private static String translate(String original, String findChars,\n-            String replaceChars) {\n-        if (StringUtils.isNullOrEmpty(original) ||\n-                StringUtils.isNullOrEmpty(findChars)) {\n+    private static String translate(String original, String findChars, String replaceChars) {\n+        if (StringUtils.isNullOrEmpty(original) || StringUtils.isNullOrEmpty(findChars)) {\n             return original;\n         }\n         // if it stays null, then no replacements have been made\n@@ -2086,7 +1899,8 @@ public class Function extends Expression implements FunctionCall {\n         if ((d < 0.0000000000001) && (d > -0.0000000000001)) {\n             return 0.0;\n         }\n-        if ((d > 1000000000000.) || (d < -1000000000000.)) {\n+        if ((d > 1000000000000.) ||\n+                (d < -1000000000000.)) {\n             return d;\n         }\n         StringBuilder s = new StringBuilder();\n@@ -2123,8 +1937,7 @@ public class Function extends Expression implements FunctionCall {\n         char lastDigit = '0';\n         for (int i = 0, j = 0; i < len && j < 4; i++) {\n             char c = s.charAt(i);\n-            char newDigit = c > SOUNDEX_INDEX.length ?\n-                    0 : SOUNDEX_INDEX[c];\n+            char newDigit = c > SOUNDEX_INDEX.length ? 0 : SOUNDEX_INDEX[c];\n             if (newDigit != 0) {\n                 if (j == 0) {\n                     chars[j++] = c;\n@@ -2135,8 +1948,8 @@ public class Function extends Expression implements FunctionCall {\n                         lastDigit = newDigit;\n                     }\n                 } else if (newDigit == '7') {\n-                    lastDigit = newDigit;\n-                }\n+                           lastDigit = newDigit;\n+                       }\n             }\n         }\n         return new String(chars);\n@@ -2147,8 +1960,9 @@ public class Function extends Expression implements FunctionCall {\n         if (seed != null && seed.intValue() != 0) {\n             hc *= seed.intValue() * 17;\n         }\n-        if (bucket == null  || bucket.intValue() <= 0) {\n+        if (bucket == null || bucket.intValue() <= 0) {\n             // do nothing\n+\n         } else {\n             hc %= bucket.intValue();\n         }\n@@ -2160,20 +1974,20 @@ public class Function extends Expression implements FunctionCall {\n         if (stringFlags != null) {\n             for (int i = 0; i < stringFlags.length(); ++i) {\n                 switch (stringFlags.charAt(i)) {\n-                    case 'i':\n-                        flags |= Pattern.CASE_INSENSITIVE;\n-                        break;\n-                    case 'c':\n-                        flags &= ~Pattern.CASE_INSENSITIVE;\n-                        break;\n-                    case 'n':\n-                        flags |= Pattern.DOTALL;\n-                        break;\n-                    case 'm':\n-                        flags |= Pattern.MULTILINE;\n-                        break;\n-                    default:\n-                        throw DbException.get(ErrorCode.INVALID_VALUE_2, stringFlags);\n+                case 'i':\n+                    flags |= Pattern.CASE_INSENSITIVE;\n+                    break;\n+                case 'c':\n+                    flags &= ~Pattern.CASE_INSENSITIVE;\n+                    break;\n+                case 'n':\n+                    flags |= Pattern.DOTALL;\n+                    break;\n+                case 'm':\n+                    flags |= Pattern.MULTILINE;\n+                    break;\n+                default:\n+                    throw DbException.get(ErrorCode.INVALID_VALUE_2, stringFlags);\n                 }\n             }\n         }\n@@ -2200,6 +2014,8 @@ public class Function extends Expression implements FunctionCall {\n      * @param len the number of parameters set\n      * @throws DbException if the parameter count is incorrect\n      */\n+\n+\n     protected void checkParameterCount(int len) {\n         int min = 0, max = Integer.MAX_VALUE;\n         switch (info.type) {\n@@ -2281,9 +2097,9 @@ public class Function extends Expression implements FunctionCall {\n         }\n         boolean ok = (len >= min) && (len <= max);\n         if (!ok) {\n-            throw DbException.get(\n-                    ErrorCode.INVALID_PARAMETER_COUNT_2,\n-                    info.name, min + \"..\" + max);\n+            throw DbException.get(ErrorCode.INVALID_PARAMETER_COUNT_2,\n+                                  info.name,\n+                                  min + \"..\" + max);\n         }\n     }\n \n@@ -2293,6 +2109,8 @@ public class Function extends Expression implements FunctionCall {\n      *\n      * @throws DbException if the parameter count is incorrect.\n      */\n+\n+\n     public void doneWithParameters() {\n         if (info.parameterCount == VAR_ARGS) {\n             int len = varArgs.size();\n@@ -2303,13 +2121,12 @@ public class Function extends Expression implements FunctionCall {\n         } else {\n             int len = args.length;\n             if (len > 0 && args[len - 1] == null) {\n-                throw DbException.get(\n-                        ErrorCode.INVALID_PARAMETER_COUNT_2,\n-                        info.name, \"\" + len);\n+                throw DbException.get(ErrorCode.INVALID_PARAMETER_COUNT_2, info.name, \"\" + len);\n             }\n         }\n     }\n \n+\n     public void setDataType(Column col) {\n         dataType = col.getType();\n         precision = col.getPrecision();\n@@ -2474,8 +2291,7 @@ public class Function extends Expression implements FunctionCall {\n             s = p1.getScale();\n             d = p1.getDisplaySize();\n             if (!(p0 instanceof Variable)) {\n-                throw DbException.get(\n-                        ErrorCode.CAN_ONLY_ASSIGN_TO_VARIABLE_1, p0.getSQL());\n+                throw DbException.get(ErrorCode.CAN_ONLY_ASSIGN_TO_VARIABLE_1, p0.getSQL());\n             }\n             break;\n         }\n@@ -2581,8 +2397,7 @@ public class Function extends Expression implements FunctionCall {\n             displaySize = 0;\n             for (Expression e : args) {\n                 precision += e.getPrecision();\n-                displaySize = MathUtils.convertLongToInt(\n-                        (long) displaySize + e.getDisplaySize());\n+                displaySize = MathUtils.convertLongToInt((long) displaySize + e.getDisplaySize());\n                 if (precision < 0) {\n                     precision = Long.MAX_VALUE;\n                 }\n@@ -2646,20 +2461,14 @@ public class Function extends Expression implements FunctionCall {\n         buff.append('(');\n         switch (info.type) {\n         case CAST: {\n-            buff.append(args[0].getSQL()).append(\" AS \").\n-                append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL());\n+            buff.append(args[0].getSQL()).append(\" AS \").append(new Column(null, dataType, precision, scale, displaySize).getCreateSQL());\n             break;\n         }\n         case CONVERT: {\n             if (database.getMode().swapConvertFunctionParameters) {\n-                buff.append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL()).\n-                    append(',').append(args[0].getSQL());\n+                buff.append(new Column(null, dataType, precision, scale, displaySize).getCreateSQL()).append(',').append(args[0].getSQL());\n             } else {\n-                buff.append(args[0].getSQL()).append(',').\n-                    append(new Column(null, dataType, precision,\n-                        scale, displaySize).getCreateSQL());\n+                buff.append(args[0].getSQL()).append(',').append(new Column(null, dataType, precision, scale, displaySize).getCreateSQL());\n             }\n             break;\n         }\n@@ -2687,6 +2496,7 @@ public class Function extends Expression implements FunctionCall {\n         }\n     }\n \n+\n     public int getFunctionType() {\n         return info.type;\n     }\n@@ -2697,32 +2507,25 @@ public class Function extends Expression implements FunctionCall {\n     }\n \n     @Override\n-    public ValueResultSet getValueForColumnList(Session session,\n-            Expression[] argList) {\n+    public ValueResultSet getValueForColumnList(Session session, Expression[] argList) {\n         switch (info.type) {\n         case CSVREAD: {\n             String fileName = argList[0].getValue(session).getString();\n             if (fileName == null) {\n                 throw DbException.get(ErrorCode.PARAMETER_NOT_SET_1, \"fileName\");\n             }\n-            String columnList = argList.length < 2 ?\n-                    null : argList[1].getValue(session).getString();\n+            String columnList = argList.length < 2 ? null : argList[1].getValue(session).getString();\n             Csv csv = new Csv();\n-            String options = argList.length < 3 ?\n-                    null : argList[2].getValue(session).getString();\n+            String options = argList.length < 3 ? null : argList[2].getValue(session).getString();\n             String charset = null;\n             if (options != null && options.indexOf('=') >= 0) {\n                 charset = csv.setOptions(options);\n             } else {\n                 charset = options;\n-                String fieldSeparatorRead = argList.length < 4 ?\n-                        null : argList[3].getValue(session).getString();\n-                String fieldDelimiter = argList.length < 5 ?\n-                        null : argList[4].getValue(session).getString();\n-                String escapeCharacter = argList.length < 6 ?\n-                        null : argList[5].getValue(session).getString();\n-                setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter,\n-                        escapeCharacter);\n+                String fieldSeparatorRead = argList.length < 4 ? null : argList[3].getValue(session).getString();\n+                String fieldDelimiter = argList.length < 5 ? null : argList[4].getValue(session).getString();\n+                String escapeCharacter = argList.length < 6 ? null : argList[5].getValue(session).getString();\n+                setCsvDelimiterEscape(csv, fieldSeparatorRead, fieldDelimiter, escapeCharacter);\n             }\n             char fieldSeparator = csv.getFieldSeparatorRead();\n             String[] columns = StringUtils.arraySplit(columnList, fieldSeparator, true);\n@@ -2745,8 +2548,7 @@ public class Function extends Expression implements FunctionCall {\n         return (ValueResultSet) getValueWithArgs(session, argList);\n     }\n \n-    private static void setCsvDelimiterEscape(Csv csv, String fieldSeparator,\n-            String fieldDelimiter, String escapeCharacter) {\n+    private static void setCsvDelimiterEscape(Csv csv, String fieldSeparator, String fieldDelimiter, String escapeCharacter) {\n         if (fieldSeparator != null) {\n             csv.setFieldSeparatorWrite(fieldSeparator);\n             if (fieldSeparator.length() > 0) {\n@@ -2755,13 +2557,11 @@ public class Function extends Expression implements FunctionCall {\n             }\n         }\n         if (fieldDelimiter != null) {\n-            char fd = fieldDelimiter.length() == 0 ?\n-                    0 : fieldDelimiter.charAt(0);\n+            char fd = fieldDelimiter.length() == 0 ? 0 : fieldDelimiter.charAt(0);\n             csv.setFieldDelimiter(fd);\n         }\n         if (escapeCharacter != null) {\n-            char ec = escapeCharacter.length() == 0 ?\n-                    0 : escapeCharacter.charAt(0);\n+            char ec = escapeCharacter.length() == 0 ? 0 : escapeCharacter.charAt(0);\n             csv.setEscapeCharacter(ec);\n         }\n     }\n@@ -2817,4 +2617,4 @@ public class Function extends Expression implements FunctionCall {\n         return info.bufferResultSetToLocalTemp;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 553
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/240/Function.java\nindex ff01f50943..f9fc85c9ba 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_random/240/Function.java\n@@ -279,7 +279,7 @@ public class Function extends Expression implements FunctionCall {\n         addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n         addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n         addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n-        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n+        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true, true);\n         addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n         addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n         addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/240/Function.java\nindex ff01f50943..f9fc85c9ba 100644\n--- a/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/errored/1/240/Function.java\n+++ b/home/thomas/mnt/fernanda/styler-test2/python/./experiments/projects/../results/h2database-h2database/styler_three_grams/240/Function.java\n@@ -279,7 +279,7 @@ public class Function extends Expression implements FunctionCall {\n         addFunction(\"OCTET_LENGTH\", OCTET_LENGTH, 1, Value.LONG);\n         addFunction(\"RAWTOHEX\", RAWTOHEX, 1, Value.STRING);\n         addFunction(\"REPEAT\", REPEAT, 2, Value.STRING);\n-        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true,true);\n+        addFunction(\"REPLACE\", REPLACE, VAR_ARGS, Value.STRING, false, true, true);\n         addFunction(\"RIGHT\", RIGHT, 2, Value.STRING);\n         addFunction(\"RTRIM\", RTRIM, VAR_ARGS, Value.STRING);\n         addFunction(\"SOUNDEX\", SOUNDEX, 1, Value.STRING);\n",
            "diff_size": 1
        }
    ]
}